<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): pcl::MinCutSegmentation&lt; PointT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.11.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_min_cut_segmentation.html">MinCutSegmentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1_min_cut_segmentation-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">pcl::MinCutSegmentation&lt; PointT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements the segmentation algorithm based on minimal cut of the graph.  
 <a href="classpcl_1_1_min_cut_segmentation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="min__cut__segmentation_8h_source.html">pcl/segmentation/min_cut_segmentation.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for pcl::MinCutSegmentation&lt; PointT &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classpcl_1_1_min_cut_segmentation.png" usemap="#pcl::MinCutSegmentation_3C_20PointT_20_3E_map" alt=""/>
  <map id="pcl::MinCutSegmentation_3C_20PointT_20_3E_map" name="pcl::MinCutSegmentation_3C_20PointT_20_3E_map">
<area href="classpcl_1_1_p_c_l_base.html" title="PCL base class." alt="pcl::PCLBase&lt; PointT &gt;" shape="rect" coords="0,0,209,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a92e34825e956e983b45e7356303e47ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a92e34825e956e983b45e7356303e47ce">KdTree</a> = <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;</td></tr>
<tr class="separator:a92e34825e956e983b45e7356303e47ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f14c39a1c99ad8b9be3e0365a47790"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad1f14c39a1c99ad8b9be3e0365a47790">KdTreePtr</a> = typename <a class="el" href="classpcl_1_1search_1_1_search.html#ab4688e4899ce5aa6937dba334dc75763">KdTree::Ptr</a></td></tr>
<tr class="separator:ad1f14c39a1c99ad8b9be3e0365a47790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6a99735e4d7e7ebff5af85d458bd10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a2e6a99735e4d7e7ebff5af85d458bd10">PointCloud</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;</td></tr>
<tr class="separator:a2e6a99735e4d7e7ebff5af85d458bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9476b45e44c2474a558a3950e0e10ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ac9476b45e44c2474a558a3950e0e10ec">PointCloudConstPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloud::ConstPtr</a></td></tr>
<tr class="separator:ac9476b45e44c2474a558a3950e0e10ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb4e8e6e92609fc947d71c2ebc7aa29"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#aedb4e8e6e92609fc947d71c2ebc7aa29">Traits</a> = boost::adjacency_list_traits&lt; boost::vecS, boost::vecS, boost::directedS &gt;</td></tr>
<tr class="separator:aedb4e8e6e92609fc947d71c2ebc7aa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55ac69e3d8625a14133c9267d6e1dc2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a> = boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::directedS, boost::property&lt; boost::vertex_name_t, std::string, boost::property&lt; boost::vertex_index_t, long, boost::property&lt; boost::vertex_color_t, boost::default_color_type, boost::property&lt; boost::vertex_distance_t, long, boost::property&lt; boost::vertex_predecessor_t, Traits::edge_descriptor &gt; &gt; &gt; &gt; &gt;, boost::property&lt; boost::edge_capacity_t, double, boost::property&lt; boost::edge_residual_capacity_t, double, boost::property&lt; boost::edge_reverse_t, Traits::edge_descriptor &gt; &gt; &gt; &gt;</td></tr>
<tr class="separator:ad55ac69e3d8625a14133c9267d6e1dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f62c52cf2fb863ee22c80d508f2796"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a75f62c52cf2fb863ee22c80d508f2796">CapacityMap</a> = boost::property_map&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>, boost::edge_capacity_t &gt;::type</td></tr>
<tr class="separator:a75f62c52cf2fb863ee22c80d508f2796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976f48b91b9d342ee2c7ead6f33d81aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a976f48b91b9d342ee2c7ead6f33d81aa">ReverseEdgeMap</a> = boost::property_map&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>, boost::edge_reverse_t &gt;::type</td></tr>
<tr class="separator:a976f48b91b9d342ee2c7ead6f33d81aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9700966b14d27c60a49da043be9b60f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab9700966b14d27c60a49da043be9b60f">VertexDescriptor</a> = Traits::vertex_descriptor</td></tr>
<tr class="separator:ab9700966b14d27c60a49da043be9b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade44e94e686bf615a6ce3b69386b9786"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ade44e94e686bf615a6ce3b69386b9786">EdgeDescriptor</a> = boost::graph_traits&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a> &gt;::edge_descriptor</td></tr>
<tr class="separator:ade44e94e686bf615a6ce3b69386b9786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615b27cf9548375c7bba0c3dbf9736f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a615b27cf9548375c7bba0c3dbf9736f5">OutEdgeIterator</a> = boost::graph_traits&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a> &gt;::out_edge_iterator</td></tr>
<tr class="separator:a615b27cf9548375c7bba0c3dbf9736f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98471982f0571255aa487b7a1b2eb91"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ac98471982f0571255aa487b7a1b2eb91">VertexIterator</a> = boost::graph_traits&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a> &gt;::vertex_iterator</td></tr>
<tr class="separator:ac98471982f0571255aa487b7a1b2eb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5782a12370a262979981c945ed85c01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ae5782a12370a262979981c945ed85c01">ResidualCapacityMap</a> = boost::property_map&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>, boost::edge_residual_capacity_t &gt;::type</td></tr>
<tr class="separator:ae5782a12370a262979981c945ed85c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2585b3f2bea21d9122d6f2d7377e9243"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a2585b3f2bea21d9122d6f2d7377e9243">IndexMap</a> = boost::property_map&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>, boost::vertex_index_t &gt;::type</td></tr>
<tr class="separator:a2585b3f2bea21d9122d6f2d7377e9243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cdf3aa667c962aee202c588dd85e3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ae3cdf3aa667c962aee202c588dd85e3a">InEdgeIterator</a> = boost::graph_traits&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a> &gt;::in_edge_iterator</td></tr>
<tr class="separator:ae3cdf3aa667c962aee202c588dd85e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb8c5c3309d5bbc53500ad73d9f2244"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a9fb8c5c3309d5bbc53500ad73d9f2244">mGraphPtr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a> &gt;</td></tr>
<tr class="separator:a9fb8c5c3309d5bbc53500ad73d9f2244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointT &gt;</a></td></tr>
<tr class="memitem:a69de4001826d45c280087187322d779d inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a69de4001826d45c280087187322d779d">PointCloud</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;</td></tr>
<tr class="separator:a69de4001826d45c280087187322d779d inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4399c6b93663d4762fc3389c1b594eb8 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a4399c6b93663d4762fc3389c1b594eb8">PointCloudPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloud::Ptr</a></td></tr>
<tr class="separator:a4399c6b93663d4762fc3389c1b594eb8 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575135fb579dc86f7845ed9dba1ea276 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloud::ConstPtr</a></td></tr>
<tr class="separator:a575135fb579dc86f7845ed9dba1ea276 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe906230f3e673dc2ff10b9d579f4ccb inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afe906230f3e673dc2ff10b9d579f4ccb">PointIndicesPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a3c574b78dfbe67c93d09acdbc8ecc499">PointIndices::Ptr</a></td></tr>
<tr class="separator:afe906230f3e673dc2ff10b9d579f4ccb inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b0d9b8a0867631ef2b9114116f9618 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae4b0d9b8a0867631ef2b9114116f9618">PointIndicesConstPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a6880da079270712d46b0bb348cf124bc">PointIndices::ConstPtr</a></td></tr>
<tr class="separator:ae4b0d9b8a0867631ef2b9114116f9618 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3358e32d052b3d259940c0894ef5ef56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a3358e32d052b3d259940c0894ef5ef56">MinCutSegmentation</a> ()</td></tr>
<tr class="memdesc:a3358e32d052b3d259940c0894ef5ef56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that sets default values for member variables.  <a href="classpcl_1_1_min_cut_segmentation.html#a3358e32d052b3d259940c0894ef5ef56">More...</a><br /></td></tr>
<tr class="separator:a3358e32d052b3d259940c0894ef5ef56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059cbc57189cac4e679ccb565f825946"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a059cbc57189cac4e679ccb565f825946">~MinCutSegmentation</a> ()</td></tr>
<tr class="memdesc:a059cbc57189cac4e679ccb565f825946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor that frees memory.  <a href="classpcl_1_1_min_cut_segmentation.html#a059cbc57189cac4e679ccb565f825946">More...</a><br /></td></tr>
<tr class="separator:a059cbc57189cac4e679ccb565f825946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514261617ab81a0565573287eb295459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a514261617ab81a0565573287eb295459">setInputCloud</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> &amp;cloud) override</td></tr>
<tr class="memdesc:a514261617ab81a0565573287eb295459"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method simply sets the input point cloud.  <a href="classpcl_1_1_min_cut_segmentation.html#a514261617ab81a0565573287eb295459">More...</a><br /></td></tr>
<tr class="separator:a514261617ab81a0565573287eb295459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf966684ce9f2e7a1c5d96d96786020"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a2cf966684ce9f2e7a1c5d96d96786020">getSigma</a> () const</td></tr>
<tr class="memdesc:a2cf966684ce9f2e7a1c5d96d96786020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns normalization value for binary potentials.  <a href="classpcl_1_1_min_cut_segmentation.html#a2cf966684ce9f2e7a1c5d96d96786020">More...</a><br /></td></tr>
<tr class="separator:a2cf966684ce9f2e7a1c5d96d96786020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26efd4b2a858c81e4512ccf690085ff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a26efd4b2a858c81e4512ccf690085ff1">setSigma</a> (double sigma)</td></tr>
<tr class="memdesc:a26efd4b2a858c81e4512ccf690085ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to set the normalization value for the binary potentials as described in the article.  <a href="classpcl_1_1_min_cut_segmentation.html#a26efd4b2a858c81e4512ccf690085ff1">More...</a><br /></td></tr>
<tr class="separator:a26efd4b2a858c81e4512ccf690085ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2fb3661dfd5f39fc5a42b9b104d390"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#aac2fb3661dfd5f39fc5a42b9b104d390">getRadius</a> () const</td></tr>
<tr class="memdesc:aac2fb3661dfd5f39fc5a42b9b104d390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns radius to the background.  <a href="classpcl_1_1_min_cut_segmentation.html#aac2fb3661dfd5f39fc5a42b9b104d390">More...</a><br /></td></tr>
<tr class="separator:aac2fb3661dfd5f39fc5a42b9b104d390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aa0dbb62461ceab61a740049ad4a08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a34aa0dbb62461ceab61a740049ad4a08">setRadius</a> (double radius)</td></tr>
<tr class="memdesc:a34aa0dbb62461ceab61a740049ad4a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to set the radius to the background.  <a href="classpcl_1_1_min_cut_segmentation.html#a34aa0dbb62461ceab61a740049ad4a08">More...</a><br /></td></tr>
<tr class="separator:a34aa0dbb62461ceab61a740049ad4a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4383ecee7232537f04b1479da2943bb1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a4383ecee7232537f04b1479da2943bb1">getSourceWeight</a> () const</td></tr>
<tr class="memdesc:a4383ecee7232537f04b1479da2943bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns weight that every edge from the source point has.  <a href="classpcl_1_1_min_cut_segmentation.html#a4383ecee7232537f04b1479da2943bb1">More...</a><br /></td></tr>
<tr class="separator:a4383ecee7232537f04b1479da2943bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b32dd2aedd67923ae756c2e61428bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a5b32dd2aedd67923ae756c2e61428bb6">setSourceWeight</a> (double weight)</td></tr>
<tr class="memdesc:a5b32dd2aedd67923ae756c2e61428bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to set weight for source edges.  <a href="classpcl_1_1_min_cut_segmentation.html#a5b32dd2aedd67923ae756c2e61428bb6">More...</a><br /></td></tr>
<tr class="separator:a5b32dd2aedd67923ae756c2e61428bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e419aac4bbf35fe1d4cfa97610711a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad1f14c39a1c99ad8b9be3e0365a47790">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a00e419aac4bbf35fe1d4cfa97610711a">getSearchMethod</a> () const</td></tr>
<tr class="memdesc:a00e419aac4bbf35fe1d4cfa97610711a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns search method that is used for finding KNN.  <a href="classpcl_1_1_min_cut_segmentation.html#a00e419aac4bbf35fe1d4cfa97610711a">More...</a><br /></td></tr>
<tr class="separator:a00e419aac4bbf35fe1d4cfa97610711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa504b20035dfe255e74dab541804743a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#aa504b20035dfe255e74dab541804743a">setSearchMethod</a> (const <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad1f14c39a1c99ad8b9be3e0365a47790">KdTreePtr</a> &amp;tree)</td></tr>
<tr class="memdesc:aa504b20035dfe255e74dab541804743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to set search method for finding KNN.  <a href="classpcl_1_1_min_cut_segmentation.html#aa504b20035dfe255e74dab541804743a">More...</a><br /></td></tr>
<tr class="separator:aa504b20035dfe255e74dab541804743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bd3fe4a5e258a1af47833b73e43846"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a70bd3fe4a5e258a1af47833b73e43846">getNumberOfNeighbours</a> () const</td></tr>
<tr class="memdesc:a70bd3fe4a5e258a1af47833b73e43846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of neighbours to find.  <a href="classpcl_1_1_min_cut_segmentation.html#a70bd3fe4a5e258a1af47833b73e43846">More...</a><br /></td></tr>
<tr class="separator:a70bd3fe4a5e258a1af47833b73e43846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd719f299ce28585bc9438205fe0ba5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#abd719f299ce28585bc9438205fe0ba5a">setNumberOfNeighbours</a> (unsigned int neighbour_number)</td></tr>
<tr class="memdesc:abd719f299ce28585bc9438205fe0ba5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to set the number of neighbours to find.  <a href="classpcl_1_1_min_cut_segmentation.html#abd719f299ce28585bc9438205fe0ba5a">More...</a><br /></td></tr>
<tr class="separator:abd719f299ce28585bc9438205fe0ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2677ea7d911964bc6269cc6663cb095"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad2677ea7d911964bc6269cc6663cb095">getForegroundPoints</a> () const</td></tr>
<tr class="memdesc:ad2677ea7d911964bc6269cc6663cb095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the points that must belong to foreground.  <a href="classpcl_1_1_min_cut_segmentation.html#ad2677ea7d911964bc6269cc6663cb095">More...</a><br /></td></tr>
<tr class="separator:ad2677ea7d911964bc6269cc6663cb095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8913ee5fe048ab82c24bc9492a12be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ae8913ee5fe048ab82c24bc9492a12be9">setForegroundPoints</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr foreground_points)</td></tr>
<tr class="memdesc:ae8913ee5fe048ab82c24bc9492a12be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to specify points which are known to be the points of the object.  <a href="classpcl_1_1_min_cut_segmentation.html#ae8913ee5fe048ab82c24bc9492a12be9">More...</a><br /></td></tr>
<tr class="separator:ae8913ee5fe048ab82c24bc9492a12be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31a4bfba3fc92a0d073fa15c9eef640"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab31a4bfba3fc92a0d073fa15c9eef640">getBackgroundPoints</a> () const</td></tr>
<tr class="memdesc:ab31a4bfba3fc92a0d073fa15c9eef640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the points that must belong to background.  <a href="classpcl_1_1_min_cut_segmentation.html#ab31a4bfba3fc92a0d073fa15c9eef640">More...</a><br /></td></tr>
<tr class="separator:ab31a4bfba3fc92a0d073fa15c9eef640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb2142a48bbe017b758efcdb24f9e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a5eb2142a48bbe017b758efcdb24f9e49">setBackgroundPoints</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr background_points)</td></tr>
<tr class="memdesc:a5eb2142a48bbe017b758efcdb24f9e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to specify points which are known to be the points of the background.  <a href="classpcl_1_1_min_cut_segmentation.html#a5eb2142a48bbe017b758efcdb24f9e49">More...</a><br /></td></tr>
<tr class="separator:a5eb2142a48bbe017b758efcdb24f9e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e9b08800c71f287e78864356be288b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a35e9b08800c71f287e78864356be288b">extract</a> (std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &amp;clusters)</td></tr>
<tr class="memdesc:a35e9b08800c71f287e78864356be288b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method launches the segmentation algorithm and returns the clusters that were obtained during the segmentation.  <a href="classpcl_1_1_min_cut_segmentation.html#a35e9b08800c71f287e78864356be288b">More...</a><br /></td></tr>
<tr class="separator:a35e9b08800c71f287e78864356be288b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7618043c7d9bbdb0eb603359f9fb9d68"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a7618043c7d9bbdb0eb603359f9fb9d68">getMaxFlow</a> () const</td></tr>
<tr class="memdesc:a7618043c7d9bbdb0eb603359f9fb9d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns that flow value that was calculated during the segmentation.  <a href="classpcl_1_1_min_cut_segmentation.html#a7618043c7d9bbdb0eb603359f9fb9d68">More...</a><br /></td></tr>
<tr class="separator:a7618043c7d9bbdb0eb603359f9fb9d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48af14d98401cf71a291ba6919a4a0b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a9fb8c5c3309d5bbc53500ad73d9f2244">mGraphPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a48af14d98401cf71a291ba6919a4a0b9">getGraph</a> () const</td></tr>
<tr class="memdesc:a48af14d98401cf71a291ba6919a4a0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the graph that was build for finding the minimum cut.  <a href="classpcl_1_1_min_cut_segmentation.html#a48af14d98401cf71a291ba6919a4a0b9">More...</a><br /></td></tr>
<tr class="separator:a48af14d98401cf71a291ba6919a4a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4784e5b04612cf2a802017ab1b7908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">pcl::PointXYZRGB</a> &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#aeb4784e5b04612cf2a802017ab1b7908">getColoredCloud</a> ()</td></tr>
<tr class="memdesc:aeb4784e5b04612cf2a802017ab1b7908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the colored cloud.  <a href="classpcl_1_1_min_cut_segmentation.html#aeb4784e5b04612cf2a802017ab1b7908">More...</a><br /></td></tr>
<tr class="separator:aeb4784e5b04612cf2a802017ab1b7908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointT &gt;</a></td></tr>
<tr class="memitem:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">PCLBase</a> ()</td></tr>
<tr class="memdesc:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">More...</a><br /></td></tr>
<tr class="separator:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">PCLBase</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html">PCLBase</a> &amp;base)</td></tr>
<tr class="memdesc:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">More...</a><br /></td></tr>
<tr class="separator:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ace0baa9034497232920bbe6e5a9f393b">~PCLBase</a> ()=default</td></tr>
<tr class="memdesc:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classpcl_1_1_p_c_l_base.html#ace0baa9034497232920bbe6e5a9f393b">More...</a><br /></td></tr>
<tr class="separator:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f23a3529c4d192d323844ff6ecdb0ef inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a1f23a3529c4d192d323844ff6ecdb0ef">getInputCloud</a> () const</td></tr>
<tr class="memdesc:a1f23a3529c4d192d323844ff6ecdb0ef inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset.  <a href="classpcl_1_1_p_c_l_base.html#a1f23a3529c4d192d323844ff6ecdb0ef">More...</a><br /></td></tr>
<tr class="separator:a1f23a3529c4d192d323844ff6ecdb0ef inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">setIndices</a> (const <a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">More...</a><br /></td></tr>
<tr class="separator:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">setIndices</a> (const <a class="el" href="namespacepcl.html#a011f84e43d80cb736d9ec9abd0930024">IndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">More...</a><br /></td></tr>
<tr class="separator:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">setIndices</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#ae4b0d9b8a0867631ef2b9114116f9618">PointIndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">More...</a><br /></td></tr>
<tr class="separator:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a554d92d5605748c0573f6d1c7428f5a7">setIndices</a> (std::size_t row_start, std::size_t col_start, std::size_t nb_rows, std::size_t nb_cols)</td></tr>
<tr class="memdesc:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indices for the points laying within an interest region of the point cloud.  <a href="classpcl_1_1_p_c_l_base.html#a554d92d5605748c0573f6d1c7428f5a7">More...</a><br /></td></tr>
<tr class="separator:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af46c8513100321ca44df399abb494ad1">getIndices</a> ()</td></tr>
<tr class="memdesc:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="classpcl_1_1_p_c_l_base.html#af46c8513100321ca44df399abb494ad1">More...</a><br /></td></tr>
<tr class="separator:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ade38248f3b9009767b671f20795fa inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepcl.html#a011f84e43d80cb736d9ec9abd0930024">IndicesConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a47ade38248f3b9009767b671f20795fa">getIndices</a> () const</td></tr>
<tr class="memdesc:a47ade38248f3b9009767b671f20795fa inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="classpcl_1_1_p_c_l_base.html#a47ade38248f3b9009767b671f20795fa">More...</a><br /></td></tr>
<tr class="separator:a47ade38248f3b9009767b671f20795fa inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae97525f1375a8eec6d3119bf3de16ef0">operator[]</a> (std::size_t pos) const</td></tr>
<tr class="memdesc:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> operator[] to shorten code.  <a href="classpcl_1_1_p_c_l_base.html#ae97525f1375a8eec6d3119bf3de16ef0">More...</a><br /></td></tr>
<tr class="separator:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a71f7ad8214722aaa8545477203f67707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a71f7ad8214722aaa8545477203f67707">buildGraph</a> ()</td></tr>
<tr class="memdesc:a71f7ad8214722aaa8545477203f67707"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method simply builds the graph that will be used during the segmentation.  <a href="classpcl_1_1_min_cut_segmentation.html#a71f7ad8214722aaa8545477203f67707">More...</a><br /></td></tr>
<tr class="separator:a71f7ad8214722aaa8545477203f67707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f781e16f6cd6a06616f9a670c82743f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a1f781e16f6cd6a06616f9a670c82743f">calculateUnaryPotential</a> (int point, double &amp;source_weight, double &amp;sink_weight) const</td></tr>
<tr class="memdesc:a1f781e16f6cd6a06616f9a670c82743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns unary potential(data cost) for the given point index.  <a href="classpcl_1_1_min_cut_segmentation.html#a1f781e16f6cd6a06616f9a670c82743f">More...</a><br /></td></tr>
<tr class="separator:a1f781e16f6cd6a06616f9a670c82743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab396eeeedc207e63fcaf949f279e2392"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab396eeeedc207e63fcaf949f279e2392">addEdge</a> (int source, int target, double weight)</td></tr>
<tr class="memdesc:ab396eeeedc207e63fcaf949f279e2392"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method simply adds the edge from the source point to the target point with a given weight.  <a href="classpcl_1_1_min_cut_segmentation.html#ab396eeeedc207e63fcaf949f279e2392">More...</a><br /></td></tr>
<tr class="separator:ab396eeeedc207e63fcaf949f279e2392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf267587c36efe7de6b9bfdf377bce81"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#aaf267587c36efe7de6b9bfdf377bce81">calculateBinaryPotential</a> (int source, int target) const</td></tr>
<tr class="memdesc:aaf267587c36efe7de6b9bfdf377bce81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the binary potential(smooth cost) for the given indices of points.  <a href="classpcl_1_1_min_cut_segmentation.html#aaf267587c36efe7de6b9bfdf377bce81">More...</a><br /></td></tr>
<tr class="separator:aaf267587c36efe7de6b9bfdf377bce81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901198878dc0418e5e46317a177a71a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a901198878dc0418e5e46317a177a71a8">recalculateUnaryPotentials</a> ()</td></tr>
<tr class="memdesc:a901198878dc0418e5e46317a177a71a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method recalculates unary potentials(data cost) if some changes were made, instead of creating new graph.  <a href="classpcl_1_1_min_cut_segmentation.html#a901198878dc0418e5e46317a177a71a8">More...</a><br /></td></tr>
<tr class="separator:a901198878dc0418e5e46317a177a71a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26ac12e2ef703f09d725889bd0b91d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab26ac12e2ef703f09d725889bd0b91d4">recalculateBinaryPotentials</a> ()</td></tr>
<tr class="memdesc:ab26ac12e2ef703f09d725889bd0b91d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method recalculates binary potentials(smooth cost) if some changes were made, instead of creating new graph.  <a href="classpcl_1_1_min_cut_segmentation.html#ab26ac12e2ef703f09d725889bd0b91d4">More...</a><br /></td></tr>
<tr class="separator:ab26ac12e2ef703f09d725889bd0b91d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43dc5077b719fdbcc86efbe626e3e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#af43dc5077b719fdbcc86efbe626e3e70">assembleLabels</a> (<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ae5782a12370a262979981c945ed85c01">ResidualCapacityMap</a> &amp;residual_capacity)</td></tr>
<tr class="memdesc:af43dc5077b719fdbcc86efbe626e3e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method analyzes the residual network and assigns a label to every point in the cloud.  <a href="classpcl_1_1_min_cut_segmentation.html#af43dc5077b719fdbcc86efbe626e3e70">More...</a><br /></td></tr>
<tr class="separator:af43dc5077b719fdbcc86efbe626e3e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointT &gt;</a></td></tr>
<tr class="memitem:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">initCompute</a> ()</td></tr>
<tr class="memdesc:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called before starting the actual computation.  <a href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">More...</a><br /></td></tr>
<tr class="separator:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">deinitCompute</a> ()</td></tr>
<tr class="memdesc:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called after finishing the actual computation.  <a href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">More...</a><br /></td></tr>
<tr class="separator:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a04e46f7ecd322ebdfa22324d483d963f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a04e46f7ecd322ebdfa22324d483d963f">inverse_sigma_</a></td></tr>
<tr class="memdesc:a04e46f7ecd322ebdfa22324d483d963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the sigma coefficient.  <a href="classpcl_1_1_min_cut_segmentation.html#a04e46f7ecd322ebdfa22324d483d963f">More...</a><br /></td></tr>
<tr class="separator:a04e46f7ecd322ebdfa22324d483d963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3439f5a0b4f842a21907860de594a57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad3439f5a0b4f842a21907860de594a57">binary_potentials_are_valid_</a></td></tr>
<tr class="memdesc:ad3439f5a0b4f842a21907860de594a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes if the binary potentials are valid.  <a href="classpcl_1_1_min_cut_segmentation.html#ad3439f5a0b4f842a21907860de594a57">More...</a><br /></td></tr>
<tr class="separator:ad3439f5a0b4f842a21907860de594a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac465316ff95b03c37bee47cca9d69b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a3ac465316ff95b03c37bee47cca9d69b">epsilon_</a></td></tr>
<tr class="memdesc:a3ac465316ff95b03c37bee47cca9d69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for comparison of the floating point numbers.  <a href="classpcl_1_1_min_cut_segmentation.html#a3ac465316ff95b03c37bee47cca9d69b">More...</a><br /></td></tr>
<tr class="separator:a3ac465316ff95b03c37bee47cca9d69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a1105703e87b4b5d2e849a7c2f0a1c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#af7a1105703e87b4b5d2e849a7c2f0a1c">radius_</a></td></tr>
<tr class="memdesc:af7a1105703e87b4b5d2e849a7c2f0a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the distance to the background.  <a href="classpcl_1_1_min_cut_segmentation.html#af7a1105703e87b4b5d2e849a7c2f0a1c">More...</a><br /></td></tr>
<tr class="separator:af7a1105703e87b4b5d2e849a7c2f0a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647a6895b703b08f8ff4ebc38ee06e48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a647a6895b703b08f8ff4ebc38ee06e48">unary_potentials_are_valid_</a></td></tr>
<tr class="memdesc:a647a6895b703b08f8ff4ebc38ee06e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes if the unary potentials are valid.  <a href="classpcl_1_1_min_cut_segmentation.html#a647a6895b703b08f8ff4ebc38ee06e48">More...</a><br /></td></tr>
<tr class="separator:a647a6895b703b08f8ff4ebc38ee06e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d636907e2069fb39755d032a490fc76"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a1d636907e2069fb39755d032a490fc76">source_weight_</a></td></tr>
<tr class="memdesc:a1d636907e2069fb39755d032a490fc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the weight for every edge that comes from source point.  <a href="classpcl_1_1_min_cut_segmentation.html#a1d636907e2069fb39755d032a490fc76">More...</a><br /></td></tr>
<tr class="separator:a1d636907e2069fb39755d032a490fc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8935d88f9846f502900c5fe6ebaa67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad1f14c39a1c99ad8b9be3e0365a47790">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a6d8935d88f9846f502900c5fe6ebaa67">search_</a></td></tr>
<tr class="memdesc:a6d8935d88f9846f502900c5fe6ebaa67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the search method that will be used for finding K nearest neighbors.  <a href="classpcl_1_1_min_cut_segmentation.html#a6d8935d88f9846f502900c5fe6ebaa67">More...</a><br /></td></tr>
<tr class="separator:a6d8935d88f9846f502900c5fe6ebaa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d82b2ccc52f3e0a9e44c43c4531c560"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a0d82b2ccc52f3e0a9e44c43c4531c560">number_of_neighbours_</a></td></tr>
<tr class="memdesc:a0d82b2ccc52f3e0a9e44c43c4531c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of neighbors to find.  <a href="classpcl_1_1_min_cut_segmentation.html#a0d82b2ccc52f3e0a9e44c43c4531c560">More...</a><br /></td></tr>
<tr class="separator:a0d82b2ccc52f3e0a9e44c43c4531c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88802f7cbb134bf7855d1bd752f1f5c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a88802f7cbb134bf7855d1bd752f1f5c8">graph_is_valid_</a></td></tr>
<tr class="memdesc:a88802f7cbb134bf7855d1bd752f1f5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes if the graph is valid.  <a href="classpcl_1_1_min_cut_segmentation.html#a88802f7cbb134bf7855d1bd752f1f5c8">More...</a><br /></td></tr>
<tr class="separator:a88802f7cbb134bf7855d1bd752f1f5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5287935fbec11266ac94c8aa6b95bfad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a5287935fbec11266ac94c8aa6b95bfad">foreground_points_</a></td></tr>
<tr class="memdesc:a5287935fbec11266ac94c8aa6b95bfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the points that are known to be in the foreground.  <a href="classpcl_1_1_min_cut_segmentation.html#a5287935fbec11266ac94c8aa6b95bfad">More...</a><br /></td></tr>
<tr class="separator:a5287935fbec11266ac94c8aa6b95bfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac987734d5a94c3530b843d3614ad514b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ac987734d5a94c3530b843d3614ad514b">background_points_</a></td></tr>
<tr class="memdesc:ac987734d5a94c3530b843d3614ad514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the points that are known to be in the background.  <a href="classpcl_1_1_min_cut_segmentation.html#ac987734d5a94c3530b843d3614ad514b">More...</a><br /></td></tr>
<tr class="separator:ac987734d5a94c3530b843d3614ad514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298d8827832655f2dfe6feb675126df3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a298d8827832655f2dfe6feb675126df3">clusters_</a></td></tr>
<tr class="memdesc:a298d8827832655f2dfe6feb675126df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">After the segmentation it will contain the segments.  <a href="classpcl_1_1_min_cut_segmentation.html#a298d8827832655f2dfe6feb675126df3">More...</a><br /></td></tr>
<tr class="separator:a298d8827832655f2dfe6feb675126df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c62ceb19b60c39c01fb9ba34ab32cc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a9fb8c5c3309d5bbc53500ad73d9f2244">mGraphPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a2c62ceb19b60c39c01fb9ba34ab32cc9">graph_</a></td></tr>
<tr class="memdesc:a2c62ceb19b60c39c01fb9ba34ab32cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the graph for finding the maximum flow.  <a href="classpcl_1_1_min_cut_segmentation.html#a2c62ceb19b60c39c01fb9ba34ab32cc9">More...</a><br /></td></tr>
<tr class="separator:a2c62ceb19b60c39c01fb9ba34ab32cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b4e69d75bbb8ed7c3fb7253e25171e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#a75f62c52cf2fb863ee22c80d508f2796">CapacityMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a73b4e69d75bbb8ed7c3fb7253e25171e">capacity_</a></td></tr>
<tr class="memdesc:a73b4e69d75bbb8ed7c3fb7253e25171e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the capacity of every edge in the graph.  <a href="classpcl_1_1_min_cut_segmentation.html#a73b4e69d75bbb8ed7c3fb7253e25171e">More...</a><br /></td></tr>
<tr class="separator:a73b4e69d75bbb8ed7c3fb7253e25171e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01573a6beb9a6edcd91efd50e9205103"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#a976f48b91b9d342ee2c7ead6f33d81aa">ReverseEdgeMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a01573a6beb9a6edcd91efd50e9205103">reverse_edges_</a></td></tr>
<tr class="memdesc:a01573a6beb9a6edcd91efd50e9205103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores reverse edges for every edge in the graph.  <a href="classpcl_1_1_min_cut_segmentation.html#a01573a6beb9a6edcd91efd50e9205103">More...</a><br /></td></tr>
<tr class="separator:a01573a6beb9a6edcd91efd50e9205103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfddf7d3ecbd4fb522797eb0ab7cd42"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab9700966b14d27c60a49da043be9b60f">VertexDescriptor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#abdfddf7d3ecbd4fb522797eb0ab7cd42">vertices_</a></td></tr>
<tr class="memdesc:abdfddf7d3ecbd4fb522797eb0ab7cd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the vertices of the graph.  <a href="classpcl_1_1_min_cut_segmentation.html#abdfddf7d3ecbd4fb522797eb0ab7cd42">More...</a><br /></td></tr>
<tr class="separator:abdfddf7d3ecbd4fb522797eb0ab7cd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a963e3527427de8a2ef04999b73fe6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ac9a963e3527427de8a2ef04999b73fe6">edge_marker_</a></td></tr>
<tr class="memdesc:ac9a963e3527427de8a2ef04999b73fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the information about the edges that were added to the graph.  <a href="classpcl_1_1_min_cut_segmentation.html#ac9a963e3527427de8a2ef04999b73fe6">More...</a><br /></td></tr>
<tr class="separator:ac9a963e3527427de8a2ef04999b73fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e1b55a05d339a82c37f0dfd2b8b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab9700966b14d27c60a49da043be9b60f">VertexDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a774e1b55a05d339a82c37f0dfd2b8b12">source_</a></td></tr>
<tr class="memdesc:a774e1b55a05d339a82c37f0dfd2b8b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the vertex that serves as source.  <a href="classpcl_1_1_min_cut_segmentation.html#a774e1b55a05d339a82c37f0dfd2b8b12">More...</a><br /></td></tr>
<tr class="separator:a774e1b55a05d339a82c37f0dfd2b8b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a7947942d068f57850fea4215c1819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab9700966b14d27c60a49da043be9b60f">VertexDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a63a7947942d068f57850fea4215c1819">sink_</a></td></tr>
<tr class="memdesc:a63a7947942d068f57850fea4215c1819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the vertex that serves as sink.  <a href="classpcl_1_1_min_cut_segmentation.html#a63a7947942d068f57850fea4215c1819">More...</a><br /></td></tr>
<tr class="separator:a63a7947942d068f57850fea4215c1819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c2ee83963e0bbeb5673f9c371fa0f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a02c2ee83963e0bbeb5673f9c371fa0f7">max_flow_</a></td></tr>
<tr class="memdesc:a02c2ee83963e0bbeb5673f9c371fa0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the maximum flow value that was calculated during the segmentation.  <a href="classpcl_1_1_min_cut_segmentation.html#a02c2ee83963e0bbeb5673f9c371fa0f7">More...</a><br /></td></tr>
<tr class="separator:a02c2ee83963e0bbeb5673f9c371fa0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointT &gt;</a></td></tr>
<tr class="memitem:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">input_</a></td></tr>
<tr class="memdesc:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input point cloud dataset.  <a href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">More...</a><br /></td></tr>
<tr class="separator:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">indices_</a></td></tr>
<tr class="memdesc:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the vector of point indices to use.  <a href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">More...</a><br /></td></tr>
<tr class="separator:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">use_indices_</a></td></tr>
<tr class="memdesc:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if point indices are used.  <a href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">More...</a><br /></td></tr>
<tr class="separator:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">fake_indices_</a></td></tr>
<tr class="memdesc:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">If no set of indices are given, we construct a set of fake indices that mimic the input <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a>.  <a href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">More...</a><br /></td></tr>
<tr class="separator:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointT&gt;<br />
class pcl::MinCutSegmentation&lt; PointT &gt;</h3>

<p>This class implements the segmentation algorithm based on minimal cut of the graph. </p>
<p>The description can be found in the article: "Min-Cut Based Segmentation of Point Clouds" </p><dl class="section author"><dt>Author</dt><dd>: Aleksey Golovinskiy and Thomas Funkhouser. </dd></dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00059">59</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a75f62c52cf2fb863ee22c80d508f2796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f62c52cf2fb863ee22c80d508f2796">&#9670;&nbsp;</a></span>CapacityMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a75f62c52cf2fb863ee22c80d508f2796">CapacityMap</a> =  boost::property_map&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>, boost::edge_capacity_t &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00087">87</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ade44e94e686bf615a6ce3b69386b9786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade44e94e686bf615a6ce3b69386b9786">&#9670;&nbsp;</a></span>EdgeDescriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ade44e94e686bf615a6ce3b69386b9786">EdgeDescriptor</a> =  boost::graph_traits&lt;<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>&gt;::edge_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00093">93</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a2585b3f2bea21d9122d6f2d7377e9243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2585b3f2bea21d9122d6f2d7377e9243">&#9670;&nbsp;</a></span>IndexMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a2585b3f2bea21d9122d6f2d7377e9243">IndexMap</a> =  boost::property_map&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>, boost::vertex_index_t &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00101">101</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ae3cdf3aa667c962aee202c588dd85e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cdf3aa667c962aee202c588dd85e3a">&#9670;&nbsp;</a></span>InEdgeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ae3cdf3aa667c962aee202c588dd85e3a">InEdgeIterator</a> =  boost::graph_traits&lt;<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>&gt;::in_edge_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00103">103</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a92e34825e956e983b45e7356303e47ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e34825e956e983b45e7356303e47ce">&#9670;&nbsp;</a></span>KdTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a92e34825e956e983b45e7356303e47ce">KdTree</a> =  <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt;<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00063">63</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ad1f14c39a1c99ad8b9be3e0365a47790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f14c39a1c99ad8b9be3e0365a47790">&#9670;&nbsp;</a></span>KdTreePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad1f14c39a1c99ad8b9be3e0365a47790">KdTreePtr</a> =  typename <a class="el" href="classpcl_1_1search_1_1_search.html#ab4688e4899ce5aa6937dba334dc75763">KdTree::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00064">64</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ad55ac69e3d8625a14133c9267d6e1dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55ac69e3d8625a14133c9267d6e1dc2">&#9670;&nbsp;</a></span>mGraph</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a> =  boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::directedS, boost::property&lt; boost::vertex_name_t, std::string, boost::property&lt; boost::vertex_index_t, long, boost::property&lt; boost::vertex_color_t, boost::default_color_type, boost::property&lt; boost::vertex_distance_t, long, boost::property&lt; boost::vertex_predecessor_t, Traits::edge_descriptor &gt; &gt; &gt; &gt; &gt;, boost::property&lt; boost::edge_capacity_t, double, boost::property&lt; boost::edge_residual_capacity_t, double, boost::property&lt; boost::edge_reverse_t, Traits::edge_descriptor &gt; &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00085">85</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a9fb8c5c3309d5bbc53500ad73d9f2244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb8c5c3309d5bbc53500ad73d9f2244">&#9670;&nbsp;</a></span>mGraphPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a9fb8c5c3309d5bbc53500ad73d9f2244">mGraphPtr</a> =  shared_ptr&lt;<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00105">105</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a615b27cf9548375c7bba0c3dbf9736f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615b27cf9548375c7bba0c3dbf9736f5">&#9670;&nbsp;</a></span>OutEdgeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a615b27cf9548375c7bba0c3dbf9736f5">OutEdgeIterator</a> =  boost::graph_traits&lt;<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>&gt;::out_edge_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00095">95</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a2e6a99735e4d7e7ebff5af85d458bd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6a99735e4d7e7ebff5af85d458bd10">&#9670;&nbsp;</a></span>PointCloud</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_p_c_l_base.html#a69de4001826d45c280087187322d779d">PointCloud</a> =  <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00065">65</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ac9476b45e44c2474a558a3950e0e10ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9476b45e44c2474a558a3950e0e10ec">&#9670;&nbsp;</a></span>PointCloudConstPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> =  typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloud::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00066">66</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ae5782a12370a262979981c945ed85c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5782a12370a262979981c945ed85c01">&#9670;&nbsp;</a></span>ResidualCapacityMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ae5782a12370a262979981c945ed85c01">ResidualCapacityMap</a> =  boost::property_map&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>, boost::edge_residual_capacity_t &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00099">99</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a976f48b91b9d342ee2c7ead6f33d81aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976f48b91b9d342ee2c7ead6f33d81aa">&#9670;&nbsp;</a></span>ReverseEdgeMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a976f48b91b9d342ee2c7ead6f33d81aa">ReverseEdgeMap</a> =  boost::property_map&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>, boost::edge_reverse_t&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00089">89</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="aedb4e8e6e92609fc947d71c2ebc7aa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb4e8e6e92609fc947d71c2ebc7aa29">&#9670;&nbsp;</a></span>Traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#aedb4e8e6e92609fc947d71c2ebc7aa29">Traits</a> =  boost::adjacency_list_traits&lt; boost::vecS, boost::vecS, boost::directedS &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00075">75</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ab9700966b14d27c60a49da043be9b60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9700966b14d27c60a49da043be9b60f">&#9670;&nbsp;</a></span>VertexDescriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab9700966b14d27c60a49da043be9b60f">VertexDescriptor</a> =  Traits::vertex_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00091">91</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ac98471982f0571255aa487b7a1b2eb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98471982f0571255aa487b7a1b2eb91">&#9670;&nbsp;</a></span>VertexIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ac98471982f0571255aa487b7a1b2eb91">VertexIterator</a> =  boost::graph_traits&lt;<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad55ac69e3d8625a14133c9267d6e1dc2">mGraph</a>&gt;::vertex_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00097">97</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3358e32d052b3d259940c0894ef5ef56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3358e32d052b3d259940c0894ef5ef56">&#9670;&nbsp;</a></span>MinCutSegmentation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html">MinCutSegmentation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that sets default values for member variables. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00051">51</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a059cbc57189cac4e679ccb565f825946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059cbc57189cac4e679ccb565f825946">&#9670;&nbsp;</a></span>~MinCutSegmentation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::~<a class="el" href="classpcl_1_1_min_cut_segmentation.html">MinCutSegmentation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor that frees memory. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00074">74</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab396eeeedc207e63fcaf949f279e2392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab396eeeedc207e63fcaf949f279e2392">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method simply adds the edge from the source point to the target point with a given weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>index of the source point of the edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>index of the target point of the edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>weight that will be assigned to the (source, target) edge </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00427">427</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="af43dc5077b719fdbcc86efbe626e3e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43dc5077b719fdbcc86efbe626e3e70">&#9670;&nbsp;</a></span>assembleLabels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::assembleLabels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ae5782a12370a262979981c945ed85c01">ResidualCapacityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>residual_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method analyzes the residual network and assigns a label to every point in the cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">residual_capacity</td><td>residual network that was obtained during the segmentation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00540">540</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

<p class="reference">References <a class="el" href="_point_indices_8h_source.html#l00023">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="a71f7ad8214722aaa8545477203f67707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f7ad8214722aaa8545477203f67707">&#9670;&nbsp;</a></span>buildGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::buildGraph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method simply builds the graph that will be used during the segmentation. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00306">306</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="aaf267587c36efe7de6b9bfdf377bce81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf267587c36efe7de6b9bfdf377bce81">&#9670;&nbsp;</a></span>calculateBinaryPotential()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::calculateBinaryPotential </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the binary potential(smooth cost) for the given indices of points. </p>
<p>In other words it returns weight that must be assigned to the edge from source to target point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>index of the source point of the edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>index of the target point of the edge </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00453">453</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>.</p>

</div>
</div>
<a id="a1f781e16f6cd6a06616f9a670c82743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f781e16f6cd6a06616f9a670c82743f">&#9670;&nbsp;</a></span>calculateUnaryPotential()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::calculateUnaryPotential </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>source_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sink_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns unary potential(data cost) for the given point index. </p>
<p>In other words it calculates weights for (source, point) and (point, sink) edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>index of the point for which weights will be calculated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">source_weight</td><td>calculated weight for the (source, point) edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sink_weight</td><td>calculated weight for the (point, sink) edge </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00371">371</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a35e9b08800c71f287e78864356be288b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e9b08800c71f287e78864356be288b">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method launches the segmentation algorithm and returns the clusters that were obtained during the segmentation. </p>
<p>The indices of points that belong to the object will be stored in the cluster with index 1, other indices will be stored in the cluster with index 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">clusters</td><td>clusters that were obtained. Each cluster is an array of point indices. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00221">221</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="ab31a4bfba3fc92a0d073fa15c9eef640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31a4bfba3fc92a0d073fa15c9eef640">&#9670;&nbsp;</a></span>getBackgroundPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getBackgroundPoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the points that must belong to background. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00202">202</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="aeb4784e5b04612cf2a802017ab1b7908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4784e5b04612cf2a802017ab1b7908">&#9670;&nbsp;</a></span>getColoredCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">pcl::PointXYZRGB</a> &gt;::Ptr <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getColoredCloud</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the colored cloud. </p>
<p>Points that belong to the object have the same color. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00568">568</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ad2677ea7d911964bc6269cc6663cb095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2677ea7d911964bc6269cc6663cb095">&#9670;&nbsp;</a></span>getForegroundPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getForegroundPoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the points that must belong to foreground. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00183">183</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a48af14d98401cf71a291ba6919a4a0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48af14d98401cf71a291ba6919a4a0b9">&#9670;&nbsp;</a></span>getGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a9fb8c5c3309d5bbc53500ad73d9f2244">mGraphPtr</a> <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getGraph</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the graph that was build for finding the minimum cut. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00299">299</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a7618043c7d9bbdb0eb603359f9fb9d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7618043c7d9bbdb0eb603359f9fb9d68">&#9670;&nbsp;</a></span>getMaxFlow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getMaxFlow</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns that flow value that was calculated during the segmentation. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00292">292</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a70bd3fe4a5e258a1af47833b73e43846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bd3fe4a5e258a1af47833b73e43846">&#9670;&nbsp;</a></span>getNumberOfNeighbours()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getNumberOfNeighbours</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of neighbours to find. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00163">163</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="aac2fb3661dfd5f39fc5a42b9b104d390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2fb3661dfd5f39fc5a42b9b104d390">&#9670;&nbsp;</a></span>getRadius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getRadius</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns radius to the background. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00113">113</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a00e419aac4bbf35fe1d4cfa97610711a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e419aac4bbf35fe1d4cfa97610711a">&#9670;&nbsp;</a></span>getSearchMethod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad1f14c39a1c99ad8b9be3e0365a47790">KdTreePtr</a> <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getSearchMethod</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns search method that is used for finding KNN. </p>
<p>The graph is build such way that it contains the edges that connect point and its KNN. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00149">149</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a2cf966684ce9f2e7a1c5d96d96786020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf966684ce9f2e7a1c5d96d96786020">&#9670;&nbsp;</a></span>getSigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getSigma</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns normalization value for binary potentials. </p>
<p>For more information see the article. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00095">95</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a4383ecee7232537f04b1479da2943bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4383ecee7232537f04b1479da2943bb1">&#9670;&nbsp;</a></span>getSourceWeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::getSourceWeight</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns weight that every edge from the source point has. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00131">131</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="ab26ac12e2ef703f09d725889bd0b91d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26ac12e2ef703f09d725889bd0b91d4">&#9670;&nbsp;</a></span>recalculateBinaryPotentials()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::recalculateBinaryPotentials</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method recalculates binary potentials(smooth cost) if some changes were made, instead of creating new graph. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00493">493</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a901198878dc0418e5e46317a177a71a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901198878dc0418e5e46317a177a71a8">&#9670;&nbsp;</a></span>recalculateUnaryPotentials()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::recalculateUnaryPotentials</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method recalculates unary potentials(data cost) if some changes were made, instead of creating new graph. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00468">468</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a5eb2142a48bbe017b758efcdb24f9e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb2142a48bbe017b758efcdb24f9e49">&#9670;&nbsp;</a></span>setBackgroundPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setBackgroundPoints </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>background_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to specify points which are known to be the points of the background. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">background_points</td><td>point cloud that contains background points. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00209">209</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>.</p>

</div>
</div>
<a id="ae8913ee5fe048ab82c24bc9492a12be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8913ee5fe048ab82c24bc9492a12be9">&#9670;&nbsp;</a></span>setForegroundPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setForegroundPoints </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr&#160;</td>
          <td class="paramname"><em>foreground_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to specify points which are known to be the points of the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">foreground_points</td><td>point cloud that contains foreground points. At least one point must be specified. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00190">190</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>.</p>

</div>
</div>
<a id="a514261617ab81a0565573287eb295459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514261617ab81a0565573287eb295459">&#9670;&nbsp;</a></span>setInputCloud()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setInputCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method simply sets the input point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the const boost shared pointer to a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">pcl::PCLBase&lt; PointT &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00085">85</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="abd719f299ce28585bc9438205fe0ba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd719f299ce28585bc9438205fe0ba5a">&#9670;&nbsp;</a></span>setNumberOfNeighbours()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setNumberOfNeighbours </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>neighbour_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to set the number of neighbours to find. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbour_number</td><td>new number of neighbours </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00170">170</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a34aa0dbb62461ceab61a740049ad4a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34aa0dbb62461ceab61a740049ad4a08">&#9670;&nbsp;</a></span>setRadius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setRadius </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to set the radius to the background. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>new radius to the background </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00120">120</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="aa504b20035dfe255e74dab541804743a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa504b20035dfe255e74dab541804743a">&#9670;&nbsp;</a></span>setSearchMethod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setSearchMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad1f14c39a1c99ad8b9be3e0365a47790">KdTreePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to set search method for finding KNN. </p>
<p>The graph is build such way that it contains the edges that connect point and its KNN. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>search method that will be used for finding KNN. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00156">156</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a26efd4b2a858c81e4512ccf690085ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26efd4b2a858c81e4512ccf690085ff1">&#9670;&nbsp;</a></span>setSigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setSigma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to set the normalization value for the binary potentials as described in the article. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sigma</td><td>new normalization value </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00102">102</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<a id="a5b32dd2aedd67923ae756c2e61428bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b32dd2aedd67923ae756c2e61428bb6">&#9670;&nbsp;</a></span>setSourceWeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::setSourceWeight </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to set weight for source edges. </p>
<p>Every edge that comes from the source point will have that weight. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>new weight </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8hpp_source.html#l00138">138</a> of file <a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac987734d5a94c3530b843d3614ad514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac987734d5a94c3530b843d3614ad514b">&#9670;&nbsp;</a></span>background_points_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, Eigen::aligned_allocator&lt;<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&gt; &gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::background_points_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the points that are known to be in the background. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00293">293</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ad3439f5a0b4f842a21907860de594a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3439f5a0b4f842a21907860de594a57">&#9670;&nbsp;</a></span>binary_potentials_are_valid_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::binary_potentials_are_valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signalizes if the binary potentials are valid. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00266">266</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a73b4e69d75bbb8ed7c3fb7253e25171e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b4e69d75bbb8ed7c3fb7253e25171e">&#9670;&nbsp;</a></span>capacity_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a75f62c52cf2fb863ee22c80d508f2796">CapacityMap</a>&gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::capacity_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the capacity of every edge in the graph. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00302">302</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a298d8827832655f2dfe6feb675126df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298d8827832655f2dfe6feb675126df3">&#9670;&nbsp;</a></span>clusters_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a>&gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::clusters_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After the segmentation it will contain the segments. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00296">296</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="ac9a963e3527427de8a2ef04999b73fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a963e3527427de8a2ef04999b73fe6">&#9670;&nbsp;</a></span>edge_marker_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::set&lt;int&gt; &gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::edge_marker_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the information about the edges that were added to the graph. </p>
<p>It is used to avoid the duplicate edges. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00311">311</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a3ac465316ff95b03c37bee47cca9d69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac465316ff95b03c37bee47cca9d69b">&#9670;&nbsp;</a></span>epsilon_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::epsilon_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for comparison of the floating point numbers. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00269">269</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a5287935fbec11266ac94c8aa6b95bfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5287935fbec11266ac94c8aa6b95bfad">&#9670;&nbsp;</a></span>foreground_points_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>, Eigen::aligned_allocator&lt;<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&gt; &gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::foreground_points_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the points that are known to be in the foreground. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00290">290</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a2c62ceb19b60c39c01fb9ba34ab32cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c62ceb19b60c39c01fb9ba34ab32cc9">&#9670;&nbsp;</a></span>graph_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#a9fb8c5c3309d5bbc53500ad73d9f2244">mGraphPtr</a> <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::graph_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the graph for finding the maximum flow. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00299">299</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a88802f7cbb134bf7855d1bd752f1f5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88802f7cbb134bf7855d1bd752f1f5c8">&#9670;&nbsp;</a></span>graph_is_valid_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::graph_is_valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signalizes if the graph is valid. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00287">287</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a04e46f7ecd322ebdfa22324d483d963f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e46f7ecd322ebdfa22324d483d963f">&#9670;&nbsp;</a></span>inverse_sigma_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::inverse_sigma_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the sigma coefficient. </p>
<p>It is used for finding smooth costs. More information can be found in the article. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00263">263</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a02c2ee83963e0bbeb5673f9c371fa0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c2ee83963e0bbeb5673f9c371fa0f7">&#9670;&nbsp;</a></span>max_flow_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::max_flow_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the maximum flow value that was calculated during the segmentation. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00320">320</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a0d82b2ccc52f3e0a9e44c43c4531c560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d82b2ccc52f3e0a9e44c43c4531c560">&#9670;&nbsp;</a></span>number_of_neighbours_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::number_of_neighbours_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the number of neighbors to find. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00284">284</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="af7a1105703e87b4b5d2e849a7c2f0a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a1105703e87b4b5d2e849a7c2f0a1c">&#9670;&nbsp;</a></span>radius_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::radius_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the distance to the background. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00272">272</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a01573a6beb9a6edcd91efd50e9205103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01573a6beb9a6edcd91efd50e9205103">&#9670;&nbsp;</a></span>reverse_edges_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classpcl_1_1_min_cut_segmentation.html#a976f48b91b9d342ee2c7ead6f33d81aa">ReverseEdgeMap</a>&gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::reverse_edges_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores reverse edges for every edge in the graph. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00305">305</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a6d8935d88f9846f502900c5fe6ebaa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8935d88f9846f502900c5fe6ebaa67">&#9670;&nbsp;</a></span>search_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ad1f14c39a1c99ad8b9be3e0365a47790">KdTreePtr</a> <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::search_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the search method that will be used for finding K nearest neighbors. </p>
<p>Neighbours are used for building the graph. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00281">281</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a63a7947942d068f57850fea4215c1819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a7947942d068f57850fea4215c1819">&#9670;&nbsp;</a></span>sink_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab9700966b14d27c60a49da043be9b60f">VertexDescriptor</a> <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::sink_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the vertex that serves as sink. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00317">317</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a774e1b55a05d339a82c37f0dfd2b8b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774e1b55a05d339a82c37f0dfd2b8b12">&#9670;&nbsp;</a></span>source_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab9700966b14d27c60a49da043be9b60f">VertexDescriptor</a> <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::source_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the vertex that serves as source. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00314">314</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a1d636907e2069fb39755d032a490fc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d636907e2069fb39755d032a490fc76">&#9670;&nbsp;</a></span>source_weight_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::source_weight_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the weight for every edge that comes from source point. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00278">278</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="a647a6895b703b08f8ff4ebc38ee06e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647a6895b703b08f8ff4ebc38ee06e48">&#9670;&nbsp;</a></span>unary_potentials_are_valid_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::unary_potentials_are_valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signalizes if the unary potentials are valid. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00275">275</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<a id="abdfddf7d3ecbd4fb522797eb0ab7cd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfddf7d3ecbd4fb522797eb0ab7cd42">&#9670;&nbsp;</a></span>vertices_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html#ab9700966b14d27c60a49da043be9b60f">VertexDescriptor</a> &gt; <a class="el" href="classpcl_1_1_min_cut_segmentation.html">pcl::MinCutSegmentation</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::vertices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the vertices of the graph. </p>

<p class="definition">Definition at line <a class="el" href="min__cut__segmentation_8h_source.html#l00308">308</a> of file <a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>pcl/segmentation/<a class="el" href="min__cut__segmentation_8h_source.html">min_cut_segmentation.h</a></li>
<li>pcl/segmentation/impl/<a class="el" href="min__cut__segmentation_8hpp_source.html">min_cut_segmentation.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Tue Jun 2 2020 14:12:15</p>
</div> <!-- #footer -->
</body>
</html>
