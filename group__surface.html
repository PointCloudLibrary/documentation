<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): Module surface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.11.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Module surface</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="secSurfacePresentation"></a>
Overview</h1>
<p>The <b>pcl_surface</b> library deals with reconstructing the original surfaces from 3D scans. Depending on the task at hand, this can be for example the hull, a mesh representation or a smoothed/resampled surface with normals.</p>
<p>Smoothing and resampling can be important if the cloud is noisy, or if it is composed of multiple scans that are not aligned perfectly. The complexity of the surface estimation can be adjusted, and normals can be estimated in the same step if needed.</p>
<div class="image">
<img src="http://www.pointclouds.org/documentation/tutorials/_images/resampling_1.jpg" alt=""/>
</div>
<p>Meshing is a general way to create a surface out of points, and currently there are two algorithms provided: a very fast triangulation of the original points, and a slower meshing that does smoothing and hole filling as well.</p>
<div class="image">
<img src="http://www.pointclouds.org/assets/images/contents/documentation/surface_meshing.png" alt=""/>
</div>
<p>Creating a convex or concave hull is useful for example when there is a need for a simplified surface representation or when boundaries need to be extracted.</p>
<div class="image">
<img src="http://www.pointclouds.org/assets/images/contents/documentation/surface_hull.png" alt=""/>
</div>
<p>Please visit the tutorials on <a href="http://www.pointclouds.org">http://www.pointclouds.org</a> for more information.</p>
<h1><a class="anchor" id="secSurfaceRequirements"></a>
Requirements</h1>
<ul>
<li><a class="el" href="group__common.html">common</a></li>
<li><a class="el" href="group__search.html">search</a></li>
<li><a class="el" href="group__kdtree.html">kdtree</a></li>
<li><a class="el" href="group__octree.html">octree</a> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_concave_hull.html">pcl::ConcaveHull&lt; PointInT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_concave_hull.html" title="ConcaveHull (alpha shapes) using libqhull library.">ConcaveHull</a></b> (alpha shapes) using libqhull library.  <a href="classpcl_1_1_concave_hull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_convex_hull.html">pcl::ConvexHull&lt; PointInT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_convex_hull.html" title="ConvexHull using libqhull library.">ConvexHull</a></b> using libqhull library.  <a href="classpcl_1_1_convex_hull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ear_clipping.html">pcl::EarClipping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ear clipping triangulation algorithm.  <a href="classpcl_1_1_ear_clipping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_greedy_projection_triangulation.html">pcl::GreedyProjectionTriangulation&lt; PointInT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_greedy_projection_triangulation.html" title="GreedyProjectionTriangulation is an implementation of a greedy triangulation algorithm for 3D points ...">GreedyProjectionTriangulation</a> is an implementation of a greedy triangulation algorithm for 3D points based on local 2D projections.  <a href="classpcl_1_1_greedy_projection_triangulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection&lt; PointNT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_grid.html">Grid</a> projection surface reconstruction method.  <a href="classpcl_1_1_grid_projection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_marching_cubes.html">pcl::MarchingCubes&lt; PointNT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The marching cubes surface reconstruction algorithm.  <a href="classpcl_1_1_marching_cubes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_marching_cubes_hoppe.html">pcl::MarchingCubesHoppe&lt; PointNT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The marching cubes surface reconstruction algorithm, using a signed distance function based on the distance from tangent planes, proposed by Hoppe et.  <a href="classpcl_1_1_marching_cubes_hoppe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_marching_cubes_r_b_f.html">pcl::MarchingCubesRBF&lt; PointNT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The marching cubes surface reconstruction algorithm, using a signed distance function based on radial basis functions.  <a href="classpcl_1_1_marching_cubes_r_b_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_moving_least_squares.html" title="MovingLeastSquares represent an implementation of the MLS (Moving Least Squares) algorithm for data s...">MovingLeastSquares</a> represent an implementation of the MLS (Moving Least Squares) algorithm for data smoothing and improved normal estimation.  <a href="classpcl_1_1_moving_least_squares.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_fast_mesh.html">pcl::OrganizedFastMesh&lt; PointInT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple triangulation/surface reconstruction for organized point clouds.  <a href="classpcl_1_1_organized_fast_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_poisson.html">pcl::Poisson&lt; PointNT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpcl_1_1_poisson.html" title="The Poisson surface reconstruction algorithm.">Poisson</a> surface reconstruction algorithm.  <a href="classpcl_1_1_poisson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_cloud_surface_processing.html">pcl::CloudSurfaceProcessing&lt; PointInT, PointOutT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_cloud_surface_processing.html" title="CloudSurfaceProcessing represents the base class for algorithms that takes a point cloud as input and...">CloudSurfaceProcessing</a></b> represents the base class for algorithms that takes a point cloud as input and produces a new output cloud that has been modified towards a better surface representation.  <a href="classpcl_1_1_cloud_surface_processing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mesh_processing.html">pcl::MeshProcessing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_mesh_processing.html" title="MeshProcessing represents the base class for mesh processing algorithms.">MeshProcessing</a></b> represents the base class for mesh processing algorithms.  <a href="classpcl_1_1_mesh_processing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html">pcl::SurfaceReconstruction&lt; PointInT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_surface_reconstruction.html" title="SurfaceReconstruction represents a base surface reconstruction class.">SurfaceReconstruction</a> represents a base surface reconstruction class.  <a href="classpcl_1_1_surface_reconstruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mesh_construction.html">pcl::MeshConstruction&lt; PointInT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_mesh_construction.html" title="MeshConstruction represents a base surface reconstruction class.">MeshConstruction</a> represents a base surface reconstruction class.  <a href="classpcl_1_1_mesh_construction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_texture_mapping.html">pcl::TextureMapping&lt; PointInT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The texture mapping algorithm.  <a href="classpcl_1_1_texture_mapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga29068d47bc7d9776344c7a7947cead1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surface.html#ga29068d47bc7d9776344c7a7947cead1d">pcl::comparePoints2D</a> (const std::pair&lt; int, Eigen::Vector4f &gt; &amp;p1, const std::pair&lt; int, Eigen::Vector4f &gt; &amp;p2)</td></tr>
<tr class="memdesc:ga29068d47bc7d9776344c7a7947cead1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort 2D points in a vector structure.  <a href="group__surface.html#ga29068d47bc7d9776344c7a7947cead1d">More...</a><br /></td></tr>
<tr class="separator:ga29068d47bc7d9776344c7a7947cead1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dde43ef7735e68f5c69f25501557611"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surface.html#ga9dde43ef7735e68f5c69f25501557611">pcl::isVisible</a> (const Eigen::Vector2f &amp;X, const Eigen::Vector2f &amp;S1, const Eigen::Vector2f &amp;S2, const Eigen::Vector2f &amp;R=Eigen::Vector2f::Zero())</td></tr>
<tr class="memdesc:ga9dde43ef7735e68f5c69f25501557611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a point X is visible from point R (or the origin) when taking into account the segment between the points S1 and S2.  <a href="group__surface.html#ga9dde43ef7735e68f5c69f25501557611">More...</a><br /></td></tr>
<tr class="separator:ga9dde43ef7735e68f5c69f25501557611"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga29068d47bc7d9776344c7a7947cead1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29068d47bc7d9776344c7a7947cead1d">&#9670;&nbsp;</a></span>comparePoints2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::comparePoints2D </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int, Eigen::Vector4f &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; int, Eigen::Vector4f &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/surface/convex_hull.h&gt;</code></p>

<p>Sort 2D points in a vector structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramname">p2</td><td>the second point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface_2include_2pcl_2surface_2convex__hull_8h_source.html#l00060">60</a> of file <a class="el" href="surface_2include_2pcl_2surface_2convex__hull_8h_source.html">convex_hull.h</a>.</p>

<p class="reference">References <a class="el" href="pcl__macros_8h_source.html#l00195">M_PI</a>.</p>

<p class="reference">Referenced by <a class="el" href="convex__hull_8hpp_source.html#l00076">pcl::ConvexHull&lt; PointInT &gt;::performReconstruction2D()</a>.</p>

</div>
</div>
<a id="ga9dde43ef7735e68f5c69f25501557611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dde43ef7735e68f5c69f25501557611">&#9670;&nbsp;</a></span>isVisible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isVisible </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>R</em> = <code>Eigen::Vector2f::Zero&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/surface/gp3.h&gt;</code></p>

<p>Returns if a point X is visible from point R (or the origin) when taking into account the segment between the points S1 and S2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>2D coordinate of the point </td></tr>
    <tr><td class="paramname">S1</td><td>2D coordinate of the segment's first point </td></tr>
    <tr><td class="paramname">S2</td><td>2D coordinate of the segment's second point </td></tr>
    <tr><td class="paramname">R</td><td>2D coordinate of the reference point (defaults to 0,0) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gp3_8h_source.html#l00066">66</a> of file <a class="el" href="gp3_8h_source.html">gp3.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Tue Jun 2 2020 14:11:04</p>
</div> <!-- #footer -->
</body>
</html>
