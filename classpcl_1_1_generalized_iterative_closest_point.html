<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.14.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">GeneralizedIterativeClosestPoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1_generalized_iterative_closest_point-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__registration.html">Module registration</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html" title="GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ...">GeneralizedIterativeClosestPoint</a> is an ICP variant that implements the generalized iterative closest point algorithm as described by Alex Segal et al.  
 <a href="classpcl_1_1_generalized_iterative_closest_point.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gicp_8h_source.html">pcl/registration/gicp.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classpcl_1_1_generalized_iterative_closest_point__inherit__graph.png" border="0" usemap="#apcl_1_1_generalized_iterative_closest_point_3_01_point_source_00_01_point_target_00_01_scalar_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="apcl_1_1_generalized_iterative_closest_point_3_01_point_source_00_01_point_target_00_01_scalar_01_4_inherit__map" id="apcl_1_1_generalized_iterative_closest_point_3_01_point_source_00_01_point_target_00_01_scalar_01_4_inherit__map">
<area shape="rect" title="GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ..." alt="" coords="1933,5,2132,61"/>
<area shape="rect" href="classpcl_1_1_generalized_iterative_closest_point.html" title=" " alt="" coords="2415,5,2633,61"/>
<area shape="rect" href="classpcl_1_1_iterative_closest_point.html" title=" " alt="" coords="1685,5,1884,61"/>
<area shape="rect" href="classpcl_1_1_registration.html" title=" " alt="" coords="1020,5,1208,61"/>
<area shape="rect" href="classpcl_1_1_iterative_closest_point.html" title="IterativeClosestPoint provides a base implementation of the Iterative Closest Point algorithm." alt="" coords="1257,37,1456,93"/>
<area shape="rect" href="classpcl_1_1_p_c_l_base.html" title=" " alt="" coords="341,20,553,47"/>
<area shape="rect" href="classpcl_1_1_registration.html" title="Registration represents the base registration class for general purpose, ICP&#45;like methods." alt="" coords="603,37,791,93"/>
<area shape="rect" href="classpcl_1_1_p_c_l_base.html" title="PCL base class." alt="" coords="5,20,181,47"/>
<area shape="rect" href="classpcl_1_1_generalized_iterative_closest_point6_d.html" title="GeneralizedIterativeClosestPoint6D integrates L*a*b* color space information into the Generalized Ite..." alt="" coords="2683,13,2865,54"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classpcl_1_1_generalized_iterative_closest_point__coll__graph.png" border="0" usemap="#apcl_1_1_generalized_iterative_closest_point_3_01_point_source_00_01_point_target_00_01_scalar_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="apcl_1_1_generalized_iterative_closest_point_3_01_point_source_00_01_point_target_00_01_scalar_01_4_coll__map" id="apcl_1_1_generalized_iterative_closest_point_3_01_point_source_00_01_point_target_00_01_scalar_01_4_coll__map">
<area shape="rect" title="GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ..." alt="" coords="3104,262,3303,318"/>
<area shape="rect" href="classpcl_1_1_iterative_closest_point.html" title=" " alt="" coords="2711,205,2909,261"/>
<area shape="rect" href="classpcl_1_1_registration.html" title=" " alt="" coords="1891,154,2079,210"/>
<area shape="rect" href="classpcl_1_1_iterative_closest_point.html" title="IterativeClosestPoint provides a base implementation of the Iterative Closest Point algorithm." alt="" coords="2283,139,2481,195"/>
<area shape="rect" href="classpcl_1_1_p_c_l_base.html" title=" " alt="" coords="1191,119,1403,146"/>
<area shape="rect" href="classpcl_1_1_registration.html" title="Registration represents the base registration class for general purpose, ICP&#45;like methods." alt="" coords="1459,170,1647,226"/>
<area shape="rect" href="classpcl_1_1_p_c_l_base.html" title="PCL base class." alt="" coords="743,75,919,102"/>
<area shape="rect" title=" " alt="" coords="5,186,96,213"/>
<area shape="rect" title=" " alt="" coords="291,135,457,162"/>
<area shape="rect" title=" " alt="" coords="481,243,715,270"/>
<area shape="rect" title=" " alt="" coords="948,298,1167,325"/>
<area shape="rect" href="classpcl_1_1registration_1_1_default_convergence_criteria.html" title=" " alt="" coords="1884,39,2087,95"/>
<area shape="rect" href="classpcl_1_1registration_1_1_convergence_criteria.html" title="ConvergenceCriteria represents an abstract base class for different convergence criteria used in regi..." alt="" coords="1219,5,1374,47"/>
<area shape="rect" href="classpcl_1_1registration_1_1_default_convergence_criteria.html" title="DefaultConvergenceCriteria represents an instantiation of ConvergenceCriteria, and implements the fol..." alt="" coords="1452,39,1655,95"/>
<area shape="rect" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points." alt="" coords="2715,365,2905,391"/>
<area shape="rect" title=" " alt="" coords="1948,379,2023,406"/>
<area shape="rect" href="structpcl_1_1_p_c_l_header.html" title=" " alt="" coords="2322,426,2442,453"/>
<area shape="rect" title=" " alt="" coords="1948,445,2023,471"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_generalized_iterative_closest_point_1_1_optimization_functor_with_indices.html">OptimizationFunctorWithIndices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimization functor structure  <a href="structpcl_1_1_generalized_iterative_closest_point_1_1_optimization_functor_with_indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a382e93a477bf6134d3f5b58a9c045fe4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointSource &gt;</td></tr>
<tr class="separator:a382e93a477bf6134d3f5b58a9c045fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985118fdd8677d1fcd13cad33013edf2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a985118fdd8677d1fcd13cad33013edf2">PointCloudSourcePtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloudSource::Ptr</a></td></tr>
<tr class="separator:a985118fdd8677d1fcd13cad33013edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96ac4bc6a3d361d388bf58692f2ade"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a4e96ac4bc6a3d361d388bf58692f2ade">PointCloudSourceConstPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloudSource::ConstPtr</a></td></tr>
<tr class="separator:a4e96ac4bc6a3d361d388bf58692f2ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36aa9d54eacdf78c6fd903000fb3f021"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36aa9d54eacdf78c6fd903000fb3f021">PointCloudTarget</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointTarget &gt;</td></tr>
<tr class="separator:a36aa9d54eacdf78c6fd903000fb3f021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2c8d83e0e37cde919b1f2ef0bdfdea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a9a2c8d83e0e37cde919b1f2ef0bdfdea">PointCloudTargetPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloudTarget::Ptr</a></td></tr>
<tr class="separator:a9a2c8d83e0e37cde919b1f2ef0bdfdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeef6118852653929d4c40b364f40245"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#abeef6118852653929d4c40b364f40245">PointCloudTargetConstPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloudTarget::ConstPtr</a></td></tr>
<tr class="separator:abeef6118852653929d4c40b364f40245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c890f441ef8abaf4176061b3956f3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ab5c890f441ef8abaf4176061b3956f3a">PointIndicesPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a3c574b78dfbe67c93d09acdbc8ecc499">PointIndices::Ptr</a></td></tr>
<tr class="separator:ab5c890f441ef8abaf4176061b3956f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9a6b5feb8bfe34a20fd5da4289ba96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a3a9a6b5feb8bfe34a20fd5da4289ba96">PointIndicesConstPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a6880da079270712d46b0bb348cf124bc">PointIndices::ConstPtr</a></td></tr>
<tr class="separator:a3a9a6b5feb8bfe34a20fd5da4289ba96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4aade9bdceb33244fc21d7f8609b01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d4aade9bdceb33244fc21d7f8609b01">MatricesVector</a> = std::vector&lt; Eigen::Matrix3d, Eigen::aligned_allocator&lt; Eigen::Matrix3d &gt; &gt;</td></tr>
<tr class="separator:a7d4aade9bdceb33244fc21d7f8609b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae981b1bdcb17f8aea09317a1d3228b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d4aade9bdceb33244fc21d7f8609b01">MatricesVector</a> &gt;</td></tr>
<tr class="separator:adae981b1bdcb17f8aea09317a1d3228b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e020cfd1d6406a6b5875c3992da4d18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7e020cfd1d6406a6b5875c3992da4d18">MatricesVectorConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d4aade9bdceb33244fc21d7f8609b01">MatricesVector</a> &gt;</td></tr>
<tr class="separator:a7e020cfd1d6406a6b5875c3992da4d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f1ba1069e9afa23827ad55099f59a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a21f1ba1069e9afa23827ad55099f59a7">InputKdTree</a> = typename <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_registration.html#a840969f28198cea50cba0870c5a917ae">KdTree</a></td></tr>
<tr class="separator:a21f1ba1069e9afa23827ad55099f59a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8426ceaa6f83d3695bbc0a33aa59f069"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a8426ceaa6f83d3695bbc0a33aa59f069">InputKdTreePtr</a> = typename <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_registration.html#a421b6b1a94a03d86437895306b12f20e">KdTreePtr</a></td></tr>
<tr class="separator:a8426ceaa6f83d3695bbc0a33aa59f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad0245aa95f46cb145c28f8ba928b3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a3ad0245aa95f46cb145c28f8ba928b3b">Ptr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt; &gt;</td></tr>
<tr class="separator:a3ad0245aa95f46cb145c28f8ba928b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91ed24fe381c135f631145772b9cf10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa91ed24fe381c135f631145772b9cf10">ConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt; &gt;</td></tr>
<tr class="separator:aa91ed24fe381c135f631145772b9cf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f24ec38847c3524a063b59277f58827"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a5f24ec38847c3524a063b59277f58827">Vector3</a> = typename Eigen::Matrix&lt; Scalar, 3, 1 &gt;</td></tr>
<tr class="separator:a5f24ec38847c3524a063b59277f58827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d20cb9ff26c92bcd8bd2fd5ac0b9aca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a5d20cb9ff26c92bcd8bd2fd5ac0b9aca">Vector4</a> = typename Eigen::Matrix&lt; Scalar, 4, 1 &gt;</td></tr>
<tr class="separator:a5d20cb9ff26c92bcd8bd2fd5ac0b9aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97fbb9fbace05b86992dc2a045c34aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af97fbb9fbace05b86992dc2a045c34aa">Vector6d</a> = Eigen::Matrix&lt; double, 6, 1 &gt;</td></tr>
<tr class="separator:af97fbb9fbace05b86992dc2a045c34aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c051540a777aa44808e9333bae3d67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ad5c051540a777aa44808e9333bae3d67">Matrix3</a> = typename Eigen::Matrix&lt; Scalar, 3, 3 &gt;</td></tr>
<tr class="separator:ad5c051540a777aa44808e9333bae3d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dd8bfa4175ce8821c74faacb28014c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> = typename <a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a></td></tr>
<tr class="separator:a29dd8bfa4175ce8821c74faacb28014c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b30cd8f4cc68cce21becdea9b6ad88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a41b30cd8f4cc68cce21becdea9b6ad88">Matrix6d</a> = Eigen::Matrix&lt; double, 6, 6 &gt;</td></tr>
<tr class="separator:a41b30cd8f4cc68cce21becdea9b6ad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2958a780e98203dcd7b16eb01d930f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ace2958a780e98203dcd7b16eb01d930f">AngleAxis</a> = typename Eigen::AngleAxis&lt; Scalar &gt;</td></tr>
<tr class="separator:ace2958a780e98203dcd7b16eb01d930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_iterative_closest_point"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_iterative_closest_point')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_iterative_closest_point.html">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:a5cbf8d0ec3afd1e42c20ad3bf9d9f70e inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a5cbf8d0ec3afd1e42c20ad3bf9d9f70e">PointCloudSource</a> = typename <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt; PointSource, PointTarget, float &gt;::<a class="el" href="classpcl_1_1_iterative_closest_point.html#a5cbf8d0ec3afd1e42c20ad3bf9d9f70e">PointCloudSource</a></td></tr>
<tr class="separator:a5cbf8d0ec3afd1e42c20ad3bf9d9f70e inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4ee82551012e18d33fad7069415fae inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#aee4ee82551012e18d33fad7069415fae">PointCloudSourcePtr</a> = typename PointCloudSource::Ptr</td></tr>
<tr class="separator:aee4ee82551012e18d33fad7069415fae inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01498c91c6d713e25242ea2a9b96d0ce inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a01498c91c6d713e25242ea2a9b96d0ce">PointCloudSourceConstPtr</a> = typename PointCloudSource::ConstPtr</td></tr>
<tr class="separator:a01498c91c6d713e25242ea2a9b96d0ce inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb34ad5c12202e6d2ac9913920a2010 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a2fb34ad5c12202e6d2ac9913920a2010">PointCloudTarget</a> = typename <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt; PointSource, PointTarget, float &gt;::<a class="el" href="classpcl_1_1_iterative_closest_point.html#a2fb34ad5c12202e6d2ac9913920a2010">PointCloudTarget</a></td></tr>
<tr class="separator:a2fb34ad5c12202e6d2ac9913920a2010 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e59238eedd5c2dbfb73ed1a105bfe0 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a53e59238eedd5c2dbfb73ed1a105bfe0">PointCloudTargetPtr</a> = typename PointCloudTarget::Ptr</td></tr>
<tr class="separator:a53e59238eedd5c2dbfb73ed1a105bfe0 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aff5e5da2d38135f72f007830a1da92 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a2aff5e5da2d38135f72f007830a1da92">PointCloudTargetConstPtr</a> = typename PointCloudTarget::ConstPtr</td></tr>
<tr class="separator:a2aff5e5da2d38135f72f007830a1da92 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8048f6adc263e4e4816359a54e8e1f inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#abb8048f6adc263e4e4816359a54e8e1f">PointIndicesPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a3c574b78dfbe67c93d09acdbc8ecc499">PointIndices::Ptr</a></td></tr>
<tr class="separator:abb8048f6adc263e4e4816359a54e8e1f inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9073a1f9208f71c32b3fa7e4413ccaa6 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a9073a1f9208f71c32b3fa7e4413ccaa6">PointIndicesConstPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a6880da079270712d46b0bb348cf124bc">PointIndices::ConstPtr</a></td></tr>
<tr class="separator:a9073a1f9208f71c32b3fa7e4413ccaa6 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccfd87123598f4650ffb20ea3f4774d inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a3ccfd87123598f4650ffb20ea3f4774d">Ptr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a>&lt; PointSource, PointTarget, float &gt; &gt;</td></tr>
<tr class="separator:a3ccfd87123598f4650ffb20ea3f4774d inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ccad31d5b7cc07941899436d7d5313 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#af1ccad31d5b7cc07941899436d7d5313">ConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a>&lt; PointSource, PointTarget, float &gt; &gt;</td></tr>
<tr class="separator:af1ccad31d5b7cc07941899436d7d5313 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b1f9d82bea112069392930dc7adca8 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a08b1f9d82bea112069392930dc7adca8">Matrix4</a> = typename <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt; PointSource, PointTarget, float &gt;::<a class="el" href="classpcl_1_1_iterative_closest_point.html#a08b1f9d82bea112069392930dc7adca8">Matrix4</a></td></tr>
<tr class="separator:a08b1f9d82bea112069392930dc7adca8 inherit pub_types_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_registration"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_registration')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:a9182ad0a61f178483dcb977973936262 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a9182ad0a61f178483dcb977973936262">Matrix4</a> = Eigen::Matrix&lt; float, 4, 4 &gt;</td></tr>
<tr class="separator:a9182ad0a61f178483dcb977973936262 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4d999fbd5a2c2bd2817baac7f4b288 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a6a4d999fbd5a2c2bd2817baac7f4b288">Ptr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt; PointSource, PointTarget, float &gt; &gt;</td></tr>
<tr class="separator:a6a4d999fbd5a2c2bd2817baac7f4b288 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d4da46f90d40e0f68ccfc0e84a4b9c inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a28d4da46f90d40e0f68ccfc0e84a4b9c">ConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt; PointSource, PointTarget, float &gt; &gt;</td></tr>
<tr class="separator:a28d4da46f90d40e0f68ccfc0e84a4b9c inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8dda4286ffaba094bc697419449760 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#abe8dda4286ffaba094bc697419449760">CorrespondenceRejectorPtr</a> = <a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector.html#aa78bf1ce04d44d8411f6c2816568c5a9">pcl::registration::CorrespondenceRejector::Ptr</a></td></tr>
<tr class="separator:abe8dda4286ffaba094bc697419449760 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840969f28198cea50cba0870c5a917ae inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a840969f28198cea50cba0870c5a917ae">KdTree</a> = <a class="el" href="classpcl_1_1search_1_1_kd_tree.html">pcl::search::KdTree</a>&lt; PointTarget &gt;</td></tr>
<tr class="separator:a840969f28198cea50cba0870c5a917ae inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b6b1a94a03d86437895306b12f20e inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a421b6b1a94a03d86437895306b12f20e">KdTreePtr</a> = typename <a class="el" href="classpcl_1_1search_1_1_kd_tree.html#a2f8aaac1133159c3daa45d3bacd3441e">KdTree::Ptr</a></td></tr>
<tr class="separator:a421b6b1a94a03d86437895306b12f20e inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0d1bee9b3fc9ba6801ecc0ebb26106 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#acc0d1bee9b3fc9ba6801ecc0ebb26106">KdTreeReciprocal</a> = <a class="el" href="classpcl_1_1search_1_1_kd_tree.html">pcl::search::KdTree</a>&lt; PointSource &gt;</td></tr>
<tr class="separator:acc0d1bee9b3fc9ba6801ecc0ebb26106 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d752af19dd9841c6b169e56aca7f36 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a02d752af19dd9841c6b169e56aca7f36">KdTreeReciprocalPtr</a> = typename <a class="el" href="classpcl_1_1search_1_1_kd_tree.html#a2f8aaac1133159c3daa45d3bacd3441e">KdTreeReciprocal::Ptr</a></td></tr>
<tr class="separator:a02d752af19dd9841c6b169e56aca7f36 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3fc583011a672b1bd3524bf0501d2d inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a2e3fc583011a672b1bd3524bf0501d2d">PointCloudSource</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointSource &gt;</td></tr>
<tr class="separator:a2e3fc583011a672b1bd3524bf0501d2d inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c91f0c89c96e36afb33642ff77a4a1 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a52c91f0c89c96e36afb33642ff77a4a1">PointCloudSourcePtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloudSource::Ptr</a></td></tr>
<tr class="separator:a52c91f0c89c96e36afb33642ff77a4a1 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cbc215c62f4a8f5541b67638e70b61 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a41cbc215c62f4a8f5541b67638e70b61">PointCloudSourceConstPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloudSource::ConstPtr</a></td></tr>
<tr class="separator:a41cbc215c62f4a8f5541b67638e70b61 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa8713874e113575da5f9966cc2e515 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3aa8713874e113575da5f9966cc2e515">PointCloudTarget</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointTarget &gt;</td></tr>
<tr class="separator:a3aa8713874e113575da5f9966cc2e515 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8782c45f79051e52a4e45ec1bfb668c3 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a8782c45f79051e52a4e45ec1bfb668c3">PointCloudTargetPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloudTarget::Ptr</a></td></tr>
<tr class="separator:a8782c45f79051e52a4e45ec1bfb668c3 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa6a6606115f71dee8724740b18e2c0 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a5fa6a6606115f71dee8724740b18e2c0">PointCloudTargetConstPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloudTarget::ConstPtr</a></td></tr>
<tr class="separator:a5fa6a6606115f71dee8724740b18e2c0 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea37015177856ba9b85ba75187d71e5 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#acea37015177856ba9b85ba75187d71e5">PointRepresentationConstPtr</a> = typename <a class="el" href="classpcl_1_1search_1_1_kd_tree.html#a8aa2c2f9dc65966d8098d786c361cf85">KdTree::PointRepresentationConstPtr</a></td></tr>
<tr class="separator:acea37015177856ba9b85ba75187d71e5 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce984dc7fbca793a87501c4beb6027f inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#acce984dc7fbca793a87501c4beb6027f">TransformationEstimation</a> = typename <a class="el" href="classpcl_1_1registration_1_1_transformation_estimation.html">pcl::registration::TransformationEstimation</a>&lt; PointSource, PointTarget, float &gt;</td></tr>
<tr class="separator:acce984dc7fbca793a87501c4beb6027f inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51abf545364b8e7da1a84d35c9a4045d inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a51abf545364b8e7da1a84d35c9a4045d">TransformationEstimationPtr</a> = typename TransformationEstimation::Ptr</td></tr>
<tr class="separator:a51abf545364b8e7da1a84d35c9a4045d inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc436eae12627777bdcd3a26ed26c0bc inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#acc436eae12627777bdcd3a26ed26c0bc">TransformationEstimationConstPtr</a> = typename TransformationEstimation::ConstPtr</td></tr>
<tr class="separator:acc436eae12627777bdcd3a26ed26c0bc inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b676f6914020e907136156176eb252 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab4b676f6914020e907136156176eb252">CorrespondenceEstimation</a> = <a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_base.html">pcl::registration::CorrespondenceEstimationBase</a>&lt; PointSource, PointTarget, float &gt;</td></tr>
<tr class="separator:ab4b676f6914020e907136156176eb252 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae6ff7053ea37bb830de913f7708b79 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aeae6ff7053ea37bb830de913f7708b79">CorrespondenceEstimationPtr</a> = typename <a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_base.html#aefbfbaee8b889b201b5e2d5445af5194">CorrespondenceEstimation::Ptr</a></td></tr>
<tr class="separator:aeae6ff7053ea37bb830de913f7708b79 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3823dd4da3ca84a5f44d1d69f526b7d8 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3823dd4da3ca84a5f44d1d69f526b7d8">CorrespondenceEstimationConstPtr</a> = typename <a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_base.html#a343bd20baa02d367e7cb83c274d9fead">CorrespondenceEstimation::ConstPtr</a></td></tr>
<tr class="separator:a3823dd4da3ca84a5f44d1d69f526b7d8 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19da1953bb9e5844a26f173a0d723a06 inherit pub_types_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a19da1953bb9e5844a26f173a0d723a06">UpdateVisualizerCallbackSignature</a> = void(const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointSource &gt; &amp;, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointTarget &gt; &amp;, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;)</td></tr>
<tr class="memdesc:a19da1953bb9e5844a26f173a0d723a06 inherit pub_types_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback signature to the function updating intermediate source point cloud position during it's registration to the target point cloud.  <a href="classpcl_1_1_registration.html#a19da1953bb9e5844a26f173a0d723a06">More...</a><br /></td></tr>
<tr class="separator:a19da1953bb9e5844a26f173a0d723a06 inherit pub_types_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointSource &gt;</a></td></tr>
<tr class="memitem:a69de4001826d45c280087187322d779d inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a69de4001826d45c280087187322d779d">PointCloud</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointSource &gt;</td></tr>
<tr class="separator:a69de4001826d45c280087187322d779d inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4399c6b93663d4762fc3389c1b594eb8 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a4399c6b93663d4762fc3389c1b594eb8">PointCloudPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloud::Ptr</a></td></tr>
<tr class="separator:a4399c6b93663d4762fc3389c1b594eb8 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575135fb579dc86f7845ed9dba1ea276 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloud::ConstPtr</a></td></tr>
<tr class="separator:a575135fb579dc86f7845ed9dba1ea276 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe906230f3e673dc2ff10b9d579f4ccb inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afe906230f3e673dc2ff10b9d579f4ccb">PointIndicesPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a3c574b78dfbe67c93d09acdbc8ecc499">PointIndices::Ptr</a></td></tr>
<tr class="separator:afe906230f3e673dc2ff10b9d579f4ccb inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b0d9b8a0867631ef2b9114116f9618 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae4b0d9b8a0867631ef2b9114116f9618">PointIndicesConstPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a6880da079270712d46b0bb348cf124bc">PointIndices::ConstPtr</a></td></tr>
<tr class="separator:ae4b0d9b8a0867631ef2b9114116f9618 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3c183cbfcfbd7c7cb6ab245d1c64717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga35846236568f16ca7fa07d958966e12c">PCL_MAKE_ALIGNED_OPERATOR_NEW</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ab3c183cbfcfbd7c7cb6ab245d1c64717">GeneralizedIterativeClosestPoint</a> ()</td></tr>
<tr class="memdesc:ab3c183cbfcfbd7c7cb6ab245d1c64717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#ab3c183cbfcfbd7c7cb6ab245d1c64717">More...</a><br /></td></tr>
<tr class="separator:ab3c183cbfcfbd7c7cb6ab245d1c64717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b5b16fda7890e3db3b3ec1a9de549e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a66b5b16fda7890e3db3b3ec1a9de549e">setInputSource</a> (const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a4e96ac4bc6a3d361d388bf58692f2ade">PointCloudSourceConstPtr</a> &amp;cloud) override</td></tr>
<tr class="memdesc:a66b5b16fda7890e3db3b3ec1a9de549e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input dataset.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a66b5b16fda7890e3db3b3ec1a9de549e">More...</a><br /></td></tr>
<tr class="separator:a66b5b16fda7890e3db3b3ec1a9de549e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d63a05331246ebe49cae693ae5c3c91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d63a05331246ebe49cae693ae5c3c91">setSourceCovariances</a> (const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a> &amp;covariances)</td></tr>
<tr class="memdesc:a7d63a05331246ebe49cae693ae5c3c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the covariances of the input source (if computed externally!).  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a7d63a05331246ebe49cae693ae5c3c91">More...</a><br /></td></tr>
<tr class="separator:a7d63a05331246ebe49cae693ae5c3c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5401d81e34329703ea0cea21feeeea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ad5401d81e34329703ea0cea21feeeea0">setInputTarget</a> (const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#abeef6118852653929d4c40b364f40245">PointCloudTargetConstPtr</a> &amp;target) override</td></tr>
<tr class="memdesc:ad5401d81e34329703ea0cea21feeeea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input target (e.g., the point cloud that we want to align the input source to)  <a href="classpcl_1_1_generalized_iterative_closest_point.html#ad5401d81e34329703ea0cea21feeeea0">More...</a><br /></td></tr>
<tr class="separator:ad5401d81e34329703ea0cea21feeeea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b92dc15e9f973a145e93707e1d81e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a6b92dc15e9f973a145e93707e1d81e49">setTargetCovariances</a> (const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a> &amp;covariances)</td></tr>
<tr class="memdesc:a6b92dc15e9f973a145e93707e1d81e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the covariances of the input target (if computed externally!).  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a6b92dc15e9f973a145e93707e1d81e49">More...</a><br /></td></tr>
<tr class="separator:a6b92dc15e9f973a145e93707e1d81e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1090f4d956cb6435ab8efde135f7abe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a1090f4d956cb6435ab8efde135f7abe1">estimateRigidTransformationBFGS</a> (const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> &amp;cloud_src, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;indices_src, const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36aa9d54eacdf78c6fd903000fb3f021">PointCloudTarget</a> &amp;cloud_tgt, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;indices_tgt, <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;transformation_matrix)</td></tr>
<tr class="memdesc:a1090f4d956cb6435ab8efde135f7abe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate a rigid rotation transformation between a source and a target point cloud using an iterative non-linear <a class="el" href="class_b_f_g_s.html" title="BFGS stands for BroydenFletcherGoldfarbShanno (BFGS) method for solving unconstrained nonlinear op...">BFGS</a> approach.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a1090f4d956cb6435ab8efde135f7abe1">More...</a><br /></td></tr>
<tr class="separator:a1090f4d956cb6435ab8efde135f7abe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcade7eb021c48c52744ac8b5c86601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a8fcade7eb021c48c52744ac8b5c86601">estimateRigidTransformationNewton</a> (const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> &amp;cloud_src, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;indices_src, const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36aa9d54eacdf78c6fd903000fb3f021">PointCloudTarget</a> &amp;cloud_tgt, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;indices_tgt, <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;transformation_matrix)</td></tr>
<tr class="memdesc:a8fcade7eb021c48c52744ac8b5c86601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate a rigid rotation transformation between a source and a target point cloud using an iterative non-linear Newton approach.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a8fcade7eb021c48c52744ac8b5c86601">More...</a><br /></td></tr>
<tr class="separator:a8fcade7eb021c48c52744ac8b5c86601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3c58acd527064baf9dededd0715933"><td class="memItemLeft" align="right" valign="top">const Eigen::Matrix3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#acd3c58acd527064baf9dededd0715933">mahalanobis</a> (std::size_t index) const</td></tr>
<tr class="separator:acd3c58acd527064baf9dededd0715933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd84f1612f02b9899b215527709a84a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#acd84f1612f02b9899b215527709a84a6">computeRDerivative</a> (const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af97fbb9fbace05b86992dc2a045c34aa">Vector6d</a> &amp;x, const Eigen::Matrix3d &amp;dCost_dR_T, <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af97fbb9fbace05b86992dc2a045c34aa">Vector6d</a> &amp;g) const</td></tr>
<tr class="memdesc:acd84f1612f02b9899b215527709a84a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of the cost function w.r.t rotation angles.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#acd84f1612f02b9899b215527709a84a6">More...</a><br /></td></tr>
<tr class="separator:acd84f1612f02b9899b215527709a84a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9edeeb9005cfbf29c4a3a800654c445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa9edeeb9005cfbf29c4a3a800654c445">setRotationEpsilon</a> (double epsilon)</td></tr>
<tr class="memdesc:aa9edeeb9005cfbf29c4a3a800654c445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rotation epsilon (maximum allowable difference between two consecutive rotations) in order for an optimization to be considered as having converged to the final solution.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#aa9edeeb9005cfbf29c4a3a800654c445">More...</a><br /></td></tr>
<tr class="separator:aa9edeeb9005cfbf29c4a3a800654c445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa843ff8a7317a624905887efee6d83b1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa843ff8a7317a624905887efee6d83b1">getRotationEpsilon</a> () const</td></tr>
<tr class="memdesc:aa843ff8a7317a624905887efee6d83b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rotation epsilon (maximum allowable difference between two consecutive rotations) as set by the user.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#aa843ff8a7317a624905887efee6d83b1">More...</a><br /></td></tr>
<tr class="separator:aa843ff8a7317a624905887efee6d83b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21457deb8ef3afabccdf96255a3da8b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a21457deb8ef3afabccdf96255a3da8b3">setCorrespondenceRandomness</a> (int k)</td></tr>
<tr class="memdesc:a21457deb8ef3afabccdf96255a3da8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of neighbors used when selecting a point neighbourhood to compute covariances.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a21457deb8ef3afabccdf96255a3da8b3">More...</a><br /></td></tr>
<tr class="separator:a21457deb8ef3afabccdf96255a3da8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ca08cd0bf4eefbe9b27453d410ddc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a18ca08cd0bf4eefbe9b27453d410ddc3">getCorrespondenceRandomness</a> () const</td></tr>
<tr class="memdesc:a18ca08cd0bf4eefbe9b27453d410ddc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of neighbors used when computing covariances as set by the user.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a18ca08cd0bf4eefbe9b27453d410ddc3">More...</a><br /></td></tr>
<tr class="separator:a18ca08cd0bf4eefbe9b27453d410ddc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967836b6189c341c0a02f75e8557395a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a967836b6189c341c0a02f75e8557395a">useBFGS</a> ()</td></tr>
<tr class="memdesc:a967836b6189c341c0a02f75e8557395a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="class_b_f_g_s.html" title="BFGS stands for BroydenFletcherGoldfarbShanno (BFGS) method for solving unconstrained nonlinear op...">BFGS</a> optimizer instead of default Newton optimizer.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a967836b6189c341c0a02f75e8557395a">More...</a><br /></td></tr>
<tr class="separator:a967836b6189c341c0a02f75e8557395a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76704be34336bb0fe7b140159e2436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#abd76704be34336bb0fe7b140159e2436">setMaximumOptimizerIterations</a> (int max)</td></tr>
<tr class="memdesc:abd76704be34336bb0fe7b140159e2436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of iterations at the optimization step.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#abd76704be34336bb0fe7b140159e2436">More...</a><br /></td></tr>
<tr class="separator:abd76704be34336bb0fe7b140159e2436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49132c9ea0621db884acc1b608bc7cb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a49132c9ea0621db884acc1b608bc7cb0">getMaximumOptimizerIterations</a> () const</td></tr>
<tr class="memdesc:a49132c9ea0621db884acc1b608bc7cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum number of iterations at the optimization step.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a49132c9ea0621db884acc1b608bc7cb0">More...</a><br /></td></tr>
<tr class="separator:a49132c9ea0621db884acc1b608bc7cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13eeb2e2d3ec9167a6d16ed1b71ef9cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a13eeb2e2d3ec9167a6d16ed1b71ef9cd">setTranslationGradientTolerance</a> (double tolerance)</td></tr>
<tr class="memdesc:a13eeb2e2d3ec9167a6d16ed1b71ef9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimal translation gradient threshold for early optimization stop.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a13eeb2e2d3ec9167a6d16ed1b71ef9cd">More...</a><br /></td></tr>
<tr class="separator:a13eeb2e2d3ec9167a6d16ed1b71ef9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a5ebd31d9c74e35dabed495633a68c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ad3a5ebd31d9c74e35dabed495633a68c">getTranslationGradientTolerance</a> () const</td></tr>
<tr class="memdesc:ad3a5ebd31d9c74e35dabed495633a68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimal translation gradient threshold for early optimization stop.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#ad3a5ebd31d9c74e35dabed495633a68c">More...</a><br /></td></tr>
<tr class="separator:ad3a5ebd31d9c74e35dabed495633a68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6c9c89ca7ec16b6af71935a236de11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aeb6c9c89ca7ec16b6af71935a236de11">setRotationGradientTolerance</a> (double tolerance)</td></tr>
<tr class="memdesc:aeb6c9c89ca7ec16b6af71935a236de11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimal rotation gradient threshold for early optimization stop.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#aeb6c9c89ca7ec16b6af71935a236de11">More...</a><br /></td></tr>
<tr class="separator:aeb6c9c89ca7ec16b6af71935a236de11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c758620f357e1898b80ac5af103329"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ab6c758620f357e1898b80ac5af103329">getRotationGradientTolerance</a> () const</td></tr>
<tr class="memdesc:ab6c758620f357e1898b80ac5af103329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimal rotation gradient threshold for early optimization stop.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#ab6c758620f357e1898b80ac5af103329">More...</a><br /></td></tr>
<tr class="separator:ab6c758620f357e1898b80ac5af103329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba43122aab57ea7b4980d0c7e607346e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aba43122aab57ea7b4980d0c7e607346e">setNumberOfThreads</a> (unsigned int nr_threads=0)</td></tr>
<tr class="memdesc:aba43122aab57ea7b4980d0c7e607346e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the scheduler and set the number of threads to use.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#aba43122aab57ea7b4980d0c7e607346e">More...</a><br /></td></tr>
<tr class="separator:aba43122aab57ea7b4980d0c7e607346e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_iterative_closest_point"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_iterative_closest_point')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_iterative_closest_point.html">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:a8a45affbd2ef281d58e0741adc9d07ae inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a8a45affbd2ef281d58e0741adc9d07ae">IterativeClosestPoint</a> ()</td></tr>
<tr class="memdesc:a8a45affbd2ef281d58e0741adc9d07ae inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classpcl_1_1_iterative_closest_point.html#a8a45affbd2ef281d58e0741adc9d07ae">More...</a><br /></td></tr>
<tr class="separator:a8a45affbd2ef281d58e0741adc9d07ae inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfae0f7386b8b1425f994ce42179405 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#acdfae0f7386b8b1425f994ce42179405">IterativeClosestPoint</a> (const <a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a> &amp;)=delete</td></tr>
<tr class="memdesc:acdfae0f7386b8b1425f994ce42179405 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Due to <code>convergence_criteria_</code> holding references to the class members, it is tricky to correctly implement its copy and move operations correctly.  <a href="classpcl_1_1_iterative_closest_point.html#acdfae0f7386b8b1425f994ce42179405">More...</a><br /></td></tr>
<tr class="separator:acdfae0f7386b8b1425f994ce42179405 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb358bcf989a6b269d7c770be8378a8 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#aafb358bcf989a6b269d7c770be8378a8">IterativeClosestPoint</a> (<a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aafb358bcf989a6b269d7c770be8378a8 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290991e6bf3a042bc48b22313bb7a6c6 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a290991e6bf3a042bc48b22313bb7a6c6">operator=</a> (const <a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a> &amp;)=delete</td></tr>
<tr class="separator:a290991e6bf3a042bc48b22313bb7a6c6 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b1b715e9bbb078bf65d3e7ab9fdbce inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a68b1b715e9bbb078bf65d3e7ab9fdbce">operator=</a> (<a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a68b1b715e9bbb078bf65d3e7ab9fdbce inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5c19315d2877a76c7c0dd489ec27ea inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#aea5c19315d2877a76c7c0dd489ec27ea">~IterativeClosestPoint</a> () override=default</td></tr>
<tr class="memdesc:aea5c19315d2877a76c7c0dd489ec27ea inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="classpcl_1_1_iterative_closest_point.html#aea5c19315d2877a76c7c0dd489ec27ea">More...</a><br /></td></tr>
<tr class="separator:aea5c19315d2877a76c7c0dd489ec27ea inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78bef717f7a6270194511c66fe16b36 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1registration_1_1_default_convergence_criteria.html">pcl::registration::DefaultConvergenceCriteria</a>&lt; float &gt;::<a class="el" href="classpcl_1_1_iterative_closest_point.html#a3ccfd87123598f4650ffb20ea3f4774d">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#ac78bef717f7a6270194511c66fe16b36">getConvergeCriteria</a> ()</td></tr>
<tr class="memdesc:ac78bef717f7a6270194511c66fe16b36 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the DefaultConvergenceCriteria used by the IterativeClosestPoint class.  <a href="classpcl_1_1_iterative_closest_point.html#ac78bef717f7a6270194511c66fe16b36">More...</a><br /></td></tr>
<tr class="separator:ac78bef717f7a6270194511c66fe16b36 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5856385eef2e0326eb33a29be37dd53 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#ad5856385eef2e0326eb33a29be37dd53">setInputSource</a> (const <a class="el" href="classpcl_1_1_iterative_closest_point.html#a01498c91c6d713e25242ea2a9b96d0ce">PointCloudSourceConstPtr</a> &amp;cloud) override</td></tr>
<tr class="memdesc:ad5856385eef2e0326eb33a29be37dd53 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input source (e.g., the point cloud that we want to align to the target)  <a href="classpcl_1_1_iterative_closest_point.html#ad5856385eef2e0326eb33a29be37dd53">More...</a><br /></td></tr>
<tr class="separator:ad5856385eef2e0326eb33a29be37dd53 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5843b9a8cb4bf2894715913b20e34f inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a8c5843b9a8cb4bf2894715913b20e34f">setInputTarget</a> (const <a class="el" href="classpcl_1_1_iterative_closest_point.html#a2aff5e5da2d38135f72f007830a1da92">PointCloudTargetConstPtr</a> &amp;cloud) override</td></tr>
<tr class="memdesc:a8c5843b9a8cb4bf2894715913b20e34f inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input target (e.g., the point cloud that we want to align the input source to)  <a href="classpcl_1_1_iterative_closest_point.html#a8c5843b9a8cb4bf2894715913b20e34f">More...</a><br /></td></tr>
<tr class="separator:a8c5843b9a8cb4bf2894715913b20e34f inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c5480a073da9c53fcb0d387e1c997b inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a22c5480a073da9c53fcb0d387e1c997b">setUseReciprocalCorrespondences</a> (bool use_reciprocal_correspondence)</td></tr>
<tr class="memdesc:a22c5480a073da9c53fcb0d387e1c997b inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether to use reciprocal correspondence or not.  <a href="classpcl_1_1_iterative_closest_point.html#a22c5480a073da9c53fcb0d387e1c997b">More...</a><br /></td></tr>
<tr class="separator:a22c5480a073da9c53fcb0d387e1c997b inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767cf980c6f268fb030fe12754ca32e3 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a767cf980c6f268fb030fe12754ca32e3">getUseReciprocalCorrespondences</a> () const</td></tr>
<tr class="memdesc:a767cf980c6f268fb030fe12754ca32e3 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain whether reciprocal correspondence are used or not.  <a href="classpcl_1_1_iterative_closest_point.html#a767cf980c6f268fb030fe12754ca32e3">More...</a><br /></td></tr>
<tr class="separator:a767cf980c6f268fb030fe12754ca32e3 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77ca4a75f057faace23c02dbc3c4fa1 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#ac77ca4a75f057faace23c02dbc3c4fa1">setNumberOfThreads</a> (unsigned int nr_threads)</td></tr>
<tr class="memdesc:ac77ca4a75f057faace23c02dbc3c4fa1 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads to use.  <a href="classpcl_1_1_iterative_closest_point.html#ac77ca4a75f057faace23c02dbc3c4fa1">More...</a><br /></td></tr>
<tr class="separator:ac77ca4a75f057faace23c02dbc3c4fa1 inherit pub_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_registration"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_registration')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:a83a7a76a4c9d467c3a7bacdc4062f810 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a83a7a76a4c9d467c3a7bacdc4062f810">Registration</a> ()</td></tr>
<tr class="memdesc:a83a7a76a4c9d467c3a7bacdc4062f810 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classpcl_1_1_registration.html#a83a7a76a4c9d467c3a7bacdc4062f810">More...</a><br /></td></tr>
<tr class="separator:a83a7a76a4c9d467c3a7bacdc4062f810 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd5ce807d193daee11ac12513bc1647 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#addd5ce807d193daee11ac12513bc1647">~Registration</a> () override=default</td></tr>
<tr class="memdesc:addd5ce807d193daee11ac12513bc1647 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor.  <a href="classpcl_1_1_registration.html#addd5ce807d193daee11ac12513bc1647">More...</a><br /></td></tr>
<tr class="separator:addd5ce807d193daee11ac12513bc1647 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16bd1099eb60c9ac26fdc6c56058029 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ad16bd1099eb60c9ac26fdc6c56058029">setTransformationEstimation</a> (const <a class="el" href="classpcl_1_1_registration.html#a51abf545364b8e7da1a84d35c9a4045d">TransformationEstimationPtr</a> &amp;te)</td></tr>
<tr class="memdesc:ad16bd1099eb60c9ac26fdc6c56058029 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the transformation estimation object.  <a href="classpcl_1_1_registration.html#ad16bd1099eb60c9ac26fdc6c56058029">More...</a><br /></td></tr>
<tr class="separator:ad16bd1099eb60c9ac26fdc6c56058029 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8e20116d171898515ed94997c3c7d inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a34f8e20116d171898515ed94997c3c7d">setCorrespondenceEstimation</a> (const <a class="el" href="classpcl_1_1_registration.html#aeae6ff7053ea37bb830de913f7708b79">CorrespondenceEstimationPtr</a> &amp;ce)</td></tr>
<tr class="memdesc:a34f8e20116d171898515ed94997c3c7d inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the correspondence estimation object.  <a href="classpcl_1_1_registration.html#a34f8e20116d171898515ed94997c3c7d">More...</a><br /></td></tr>
<tr class="separator:a34f8e20116d171898515ed94997c3c7d inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d56239d2f0d7c567f9402a177d3a0e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a41cbc215c62f4a8f5541b67638e70b61">PointCloudSourceConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ac0d56239d2f0d7c567f9402a177d3a0e">getInputSource</a> ()</td></tr>
<tr class="memdesc:ac0d56239d2f0d7c567f9402a177d3a0e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset target.  <a href="classpcl_1_1_registration.html#ac0d56239d2f0d7c567f9402a177d3a0e">More...</a><br /></td></tr>
<tr class="separator:ac0d56239d2f0d7c567f9402a177d3a0e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97259be9f630f5f21ef60e3e62f8fa47 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a5fa6a6606115f71dee8724740b18e2c0">PointCloudTargetConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a97259be9f630f5f21ef60e3e62f8fa47">getInputTarget</a> ()</td></tr>
<tr class="memdesc:a97259be9f630f5f21ef60e3e62f8fa47 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset target.  <a href="classpcl_1_1_registration.html#a97259be9f630f5f21ef60e3e62f8fa47">More...</a><br /></td></tr>
<tr class="separator:a97259be9f630f5f21ef60e3e62f8fa47 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409442a0f43b73e1227335307b1d9ccc inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a409442a0f43b73e1227335307b1d9ccc">setSearchMethodTarget</a> (const <a class="el" href="classpcl_1_1_registration.html#a421b6b1a94a03d86437895306b12f20e">KdTreePtr</a> &amp;tree, bool force_no_recompute=false)</td></tr>
<tr class="memdesc:a409442a0f43b73e1227335307b1d9ccc inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the search object used to find correspondences in the target cloud.  <a href="classpcl_1_1_registration.html#a409442a0f43b73e1227335307b1d9ccc">More...</a><br /></td></tr>
<tr class="separator:a409442a0f43b73e1227335307b1d9ccc inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600327adbe8c11394c52f13364133cd inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a421b6b1a94a03d86437895306b12f20e">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a7600327adbe8c11394c52f13364133cd">getSearchMethodTarget</a> () const</td></tr>
<tr class="memdesc:a7600327adbe8c11394c52f13364133cd inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the search method used to find correspondences in the target cloud.  <a href="classpcl_1_1_registration.html#a7600327adbe8c11394c52f13364133cd">More...</a><br /></td></tr>
<tr class="separator:a7600327adbe8c11394c52f13364133cd inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfafcf5966b90f513f52ff0a7a42f37 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3bfafcf5966b90f513f52ff0a7a42f37">setSearchMethodSource</a> (const <a class="el" href="classpcl_1_1_registration.html#a02d752af19dd9841c6b169e56aca7f36">KdTreeReciprocalPtr</a> &amp;tree, bool force_no_recompute=false)</td></tr>
<tr class="memdesc:a3bfafcf5966b90f513f52ff0a7a42f37 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the search object used to find correspondences in the source cloud (usually used by reciprocal correspondence finding).  <a href="classpcl_1_1_registration.html#a3bfafcf5966b90f513f52ff0a7a42f37">More...</a><br /></td></tr>
<tr class="separator:a3bfafcf5966b90f513f52ff0a7a42f37 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add717357d14e16c3d71eefe8cd658343 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a02d752af19dd9841c6b169e56aca7f36">KdTreeReciprocalPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#add717357d14e16c3d71eefe8cd658343">getSearchMethodSource</a> () const</td></tr>
<tr class="memdesc:add717357d14e16c3d71eefe8cd658343 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the search method used to find correspondences in the source cloud.  <a href="classpcl_1_1_registration.html#add717357d14e16c3d71eefe8cd658343">More...</a><br /></td></tr>
<tr class="separator:add717357d14e16c3d71eefe8cd658343 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e68bd39ac943131dcbf1431f9afe3f3 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a9182ad0a61f178483dcb977973936262">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a1e68bd39ac943131dcbf1431f9afe3f3">getFinalTransformation</a> ()</td></tr>
<tr class="memdesc:a1e68bd39ac943131dcbf1431f9afe3f3 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final transformation matrix estimated by the registration method.  <a href="classpcl_1_1_registration.html#a1e68bd39ac943131dcbf1431f9afe3f3">More...</a><br /></td></tr>
<tr class="separator:a1e68bd39ac943131dcbf1431f9afe3f3 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b11948c03bee5474b2224bf988f701 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a9182ad0a61f178483dcb977973936262">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a86b11948c03bee5474b2224bf988f701">getLastIncrementalTransformation</a> ()</td></tr>
<tr class="memdesc:a86b11948c03bee5474b2224bf988f701 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last incremental transformation matrix estimated by the registration method.  <a href="classpcl_1_1_registration.html#a86b11948c03bee5474b2224bf988f701">More...</a><br /></td></tr>
<tr class="separator:a86b11948c03bee5474b2224bf988f701 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3844d186f7a99d15464368e0f25635ed inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3844d186f7a99d15464368e0f25635ed">setMaximumIterations</a> (int nr_iterations)</td></tr>
<tr class="memdesc:a3844d186f7a99d15464368e0f25635ed inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations the internal optimization should run for.  <a href="classpcl_1_1_registration.html#a3844d186f7a99d15464368e0f25635ed">More...</a><br /></td></tr>
<tr class="separator:a3844d186f7a99d15464368e0f25635ed inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1c20667e8bc292a687c9664fd30735 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#adf1c20667e8bc292a687c9664fd30735">getMaximumIterations</a> ()</td></tr>
<tr class="memdesc:adf1c20667e8bc292a687c9664fd30735 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of iterations the internal optimization should run for, as set by the user.  <a href="classpcl_1_1_registration.html#adf1c20667e8bc292a687c9664fd30735">More...</a><br /></td></tr>
<tr class="separator:adf1c20667e8bc292a687c9664fd30735 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbe7e76761563c44cb2460376ed5e53 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a1fbe7e76761563c44cb2460376ed5e53">setRANSACIterations</a> (int ransac_iterations)</td></tr>
<tr class="memdesc:a1fbe7e76761563c44cb2460376ed5e53 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of iterations RANSAC should run for.  <a href="classpcl_1_1_registration.html#a1fbe7e76761563c44cb2460376ed5e53">More...</a><br /></td></tr>
<tr class="separator:a1fbe7e76761563c44cb2460376ed5e53 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcce068a7d132be1eb299d509390ca1 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#affcce068a7d132be1eb299d509390ca1">getRANSACIterations</a> ()</td></tr>
<tr class="memdesc:affcce068a7d132be1eb299d509390ca1 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of iterations RANSAC should run for, as set by the user.  <a href="classpcl_1_1_registration.html#affcce068a7d132be1eb299d509390ca1">More...</a><br /></td></tr>
<tr class="separator:affcce068a7d132be1eb299d509390ca1 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64db6d25e2707a174dbad28f2484bffe inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a64db6d25e2707a174dbad28f2484bffe">setRANSACOutlierRejectionThreshold</a> (double inlier_threshold)</td></tr>
<tr class="memdesc:a64db6d25e2707a174dbad28f2484bffe inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the inlier distance threshold for the internal RANSAC outlier rejection loop.  <a href="classpcl_1_1_registration.html#a64db6d25e2707a174dbad28f2484bffe">More...</a><br /></td></tr>
<tr class="separator:a64db6d25e2707a174dbad28f2484bffe inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4ae8d2e7b280de376b1e8a3956157e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a6b4ae8d2e7b280de376b1e8a3956157e">getRANSACOutlierRejectionThreshold</a> ()</td></tr>
<tr class="memdesc:a6b4ae8d2e7b280de376b1e8a3956157e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inlier distance threshold for the internal outlier rejection loop as set by the user.  <a href="classpcl_1_1_registration.html#a6b4ae8d2e7b280de376b1e8a3956157e">More...</a><br /></td></tr>
<tr class="separator:a6b4ae8d2e7b280de376b1e8a3956157e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65596dcc3cb5d2647857226fb3d999a5 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a65596dcc3cb5d2647857226fb3d999a5">setMaxCorrespondenceDistance</a> (double distance_threshold)</td></tr>
<tr class="memdesc:a65596dcc3cb5d2647857226fb3d999a5 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum distance threshold between two correspondent points in source &lt;-&gt; target.  <a href="classpcl_1_1_registration.html#a65596dcc3cb5d2647857226fb3d999a5">More...</a><br /></td></tr>
<tr class="separator:a65596dcc3cb5d2647857226fb3d999a5 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fec358f22d434de9a654b6ffd5949f inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a71fec358f22d434de9a654b6ffd5949f">getMaxCorrespondenceDistance</a> ()</td></tr>
<tr class="memdesc:a71fec358f22d434de9a654b6ffd5949f inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum distance threshold between two correspondent points in source &lt;-&gt; target.  <a href="classpcl_1_1_registration.html#a71fec358f22d434de9a654b6ffd5949f">More...</a><br /></td></tr>
<tr class="separator:a71fec358f22d434de9a654b6ffd5949f inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec74ab878cca8d62fd1be9942685a8c1 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aec74ab878cca8d62fd1be9942685a8c1">setTransformationEpsilon</a> (double epsilon)</td></tr>
<tr class="memdesc:aec74ab878cca8d62fd1be9942685a8c1 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transformation epsilon (maximum allowable translation squared difference between two consecutive transformations) in order for an optimization to be considered as having converged to the final solution.  <a href="classpcl_1_1_registration.html#aec74ab878cca8d62fd1be9942685a8c1">More...</a><br /></td></tr>
<tr class="separator:aec74ab878cca8d62fd1be9942685a8c1 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19024853d8480a0e4bc3193f6f75f7c8 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a19024853d8480a0e4bc3193f6f75f7c8">getTransformationEpsilon</a> ()</td></tr>
<tr class="memdesc:a19024853d8480a0e4bc3193f6f75f7c8 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation epsilon (maximum allowable translation squared difference between two consecutive transformations) as set by the user.  <a href="classpcl_1_1_registration.html#a19024853d8480a0e4bc3193f6f75f7c8">More...</a><br /></td></tr>
<tr class="separator:a19024853d8480a0e4bc3193f6f75f7c8 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f9a8fcddba2f0cf545f36f5debe095 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ae0f9a8fcddba2f0cf545f36f5debe095">setTransformationRotationEpsilon</a> (double epsilon)</td></tr>
<tr class="memdesc:ae0f9a8fcddba2f0cf545f36f5debe095 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transformation rotation epsilon (maximum allowable rotation difference between two consecutive transformations) in order for an optimization to be considered as having converged to the final solution.  <a href="classpcl_1_1_registration.html#ae0f9a8fcddba2f0cf545f36f5debe095">More...</a><br /></td></tr>
<tr class="separator:ae0f9a8fcddba2f0cf545f36f5debe095 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdfdf0839a3badff3d44113762cca2c inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a5fdfdf0839a3badff3d44113762cca2c">getTransformationRotationEpsilon</a> ()</td></tr>
<tr class="memdesc:a5fdfdf0839a3badff3d44113762cca2c inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation rotation epsilon (maximum allowable difference between two consecutive transformations) as set by the user (epsilon is the cos(angle) in a axis-angle representation).  <a href="classpcl_1_1_registration.html#a5fdfdf0839a3badff3d44113762cca2c">More...</a><br /></td></tr>
<tr class="separator:a5fdfdf0839a3badff3d44113762cca2c inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0bb4577dbe144bd467d4a9632b84d8 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aeb0bb4577dbe144bd467d4a9632b84d8">setEuclideanFitnessEpsilon</a> (double epsilon)</td></tr>
<tr class="memdesc:aeb0bb4577dbe144bd467d4a9632b84d8 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum allowed Euclidean error between two consecutive steps in the ICP loop, before the algorithm is considered to have converged.  <a href="classpcl_1_1_registration.html#aeb0bb4577dbe144bd467d4a9632b84d8">More...</a><br /></td></tr>
<tr class="separator:aeb0bb4577dbe144bd467d4a9632b84d8 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b9fa3e4d1285d16361efe4d0634bde inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a71b9fa3e4d1285d16361efe4d0634bde">getEuclideanFitnessEpsilon</a> ()</td></tr>
<tr class="memdesc:a71b9fa3e4d1285d16361efe4d0634bde inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum allowed distance error before the algorithm will be considered to have converged, as set by the user.  <a href="classpcl_1_1_registration.html#a71b9fa3e4d1285d16361efe4d0634bde">More...</a><br /></td></tr>
<tr class="separator:a71b9fa3e4d1285d16361efe4d0634bde inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da970b4fbd4d1dfbaa4ab76d3d7d22e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a5da970b4fbd4d1dfbaa4ab76d3d7d22e">setPointRepresentation</a> (const <a class="el" href="classpcl_1_1_registration.html#acea37015177856ba9b85ba75187d71e5">PointRepresentationConstPtr</a> &amp;point_representation)</td></tr>
<tr class="memdesc:a5da970b4fbd4d1dfbaa4ab76d3d7d22e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a boost shared pointer to the PointRepresentation to be used when comparing points.  <a href="classpcl_1_1_registration.html#a5da970b4fbd4d1dfbaa4ab76d3d7d22e">More...</a><br /></td></tr>
<tr class="separator:a5da970b4fbd4d1dfbaa4ab76d3d7d22e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d243a085c3b4957cb559fc1b8666517 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a4d243a085c3b4957cb559fc1b8666517">registerVisualizationCallback</a> (std::function&lt; <a class="el" href="classpcl_1_1_registration.html#a19da1953bb9e5844a26f173a0d723a06">UpdateVisualizerCallbackSignature</a> &gt; &amp;visualizerCallback)</td></tr>
<tr class="memdesc:a4d243a085c3b4957cb559fc1b8666517 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the user callback function which will be called from registration thread in order to update point cloud obtained after each iteration.  <a href="classpcl_1_1_registration.html#a4d243a085c3b4957cb559fc1b8666517">More...</a><br /></td></tr>
<tr class="separator:a4d243a085c3b4957cb559fc1b8666517 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26742c383b6f5e86fb96a236fb08728 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab26742c383b6f5e86fb96a236fb08728">getFitnessScore</a> (double max_range=std::numeric_limits&lt; double &gt;::max())</td></tr>
<tr class="memdesc:ab26742c383b6f5e86fb96a236fb08728 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the Euclidean fitness score (e.g., mean of squared distances from the source to the target)  <a href="classpcl_1_1_registration.html#ab26742c383b6f5e86fb96a236fb08728">More...</a><br /></td></tr>
<tr class="separator:ab26742c383b6f5e86fb96a236fb08728 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9c05b613e698af21f3cb048e611adc inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a4b9c05b613e698af21f3cb048e611adc">getFitnessScore</a> (const std::vector&lt; float &gt; &amp;distances_a, const std::vector&lt; float &gt; &amp;distances_b)</td></tr>
<tr class="memdesc:a4b9c05b613e698af21f3cb048e611adc inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the Euclidean fitness score (e.g., mean of squared distances from the source to the target) from two sets of correspondence distances (distances between source and target points)  <a href="classpcl_1_1_registration.html#a4b9c05b613e698af21f3cb048e611adc">More...</a><br /></td></tr>
<tr class="separator:a4b9c05b613e698af21f3cb048e611adc inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace75587f47d87c305ff80aa7d1198b3e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ace75587f47d87c305ff80aa7d1198b3e">hasConverged</a> () const</td></tr>
<tr class="memdesc:ace75587f47d87c305ff80aa7d1198b3e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of convergence after the last align run.  <a href="classpcl_1_1_registration.html#ace75587f47d87c305ff80aa7d1198b3e">More...</a><br /></td></tr>
<tr class="separator:ace75587f47d87c305ff80aa7d1198b3e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96212303ca16b6d60020824086887c4f inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a96212303ca16b6d60020824086887c4f">align</a> (<a class="el" href="classpcl_1_1_registration.html#a2e3fc583011a672b1bd3524bf0501d2d">PointCloudSource</a> &amp;output)</td></tr>
<tr class="memdesc:a96212303ca16b6d60020824086887c4f inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the registration algorithm which estimates the transformation and returns the transformed source (input) as <em>output</em>.  <a href="classpcl_1_1_registration.html#a96212303ca16b6d60020824086887c4f">More...</a><br /></td></tr>
<tr class="separator:a96212303ca16b6d60020824086887c4f inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d64f86162b2df716ead8d978579c11 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab1d64f86162b2df716ead8d978579c11">align</a> (<a class="el" href="classpcl_1_1_registration.html#a2e3fc583011a672b1bd3524bf0501d2d">PointCloudSource</a> &amp;output, const <a class="el" href="classpcl_1_1_registration.html#a9182ad0a61f178483dcb977973936262">Matrix4</a> &amp;guess)</td></tr>
<tr class="memdesc:ab1d64f86162b2df716ead8d978579c11 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the registration algorithm which estimates the transformation and returns the transformed source (input) as <em>output</em>.  <a href="classpcl_1_1_registration.html#ab1d64f86162b2df716ead8d978579c11">More...</a><br /></td></tr>
<tr class="separator:ab1d64f86162b2df716ead8d978579c11 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eae6a42450893ca1c2ed81560159f2 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a26eae6a42450893ca1c2ed81560159f2">getClassName</a> () const</td></tr>
<tr class="memdesc:a26eae6a42450893ca1c2ed81560159f2 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class get name method.  <a href="classpcl_1_1_registration.html#a26eae6a42450893ca1c2ed81560159f2">More...</a><br /></td></tr>
<tr class="separator:a26eae6a42450893ca1c2ed81560159f2 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b42c13696bef68c50d5c3135bc573cf inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a0b42c13696bef68c50d5c3135bc573cf">initCompute</a> ()</td></tr>
<tr class="memdesc:a0b42c13696bef68c50d5c3135bc573cf inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal computation initialization.  <a href="classpcl_1_1_registration.html#a0b42c13696bef68c50d5c3135bc573cf">More...</a><br /></td></tr>
<tr class="separator:a0b42c13696bef68c50d5c3135bc573cf inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae210269f0404556b8dd7f4306084a91d inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ae210269f0404556b8dd7f4306084a91d">initComputeReciprocal</a> ()</td></tr>
<tr class="memdesc:ae210269f0404556b8dd7f4306084a91d inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal computation when reciprocal lookup is needed.  <a href="classpcl_1_1_registration.html#ae210269f0404556b8dd7f4306084a91d">More...</a><br /></td></tr>
<tr class="separator:ae210269f0404556b8dd7f4306084a91d inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663e64d6d5103eb937addd3e33104cf6 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a663e64d6d5103eb937addd3e33104cf6">addCorrespondenceRejector</a> (const <a class="el" href="classpcl_1_1_registration.html#abe8dda4286ffaba094bc697419449760">CorrespondenceRejectorPtr</a> &amp;rejector)</td></tr>
<tr class="memdesc:a663e64d6d5103eb937addd3e33104cf6 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new correspondence rejector to the list.  <a href="classpcl_1_1_registration.html#a663e64d6d5103eb937addd3e33104cf6">More...</a><br /></td></tr>
<tr class="separator:a663e64d6d5103eb937addd3e33104cf6 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c221d8f1151096721db3817610c9d9 inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcl_1_1_registration.html#abe8dda4286ffaba094bc697419449760">CorrespondenceRejectorPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ac0c221d8f1151096721db3817610c9d9">getCorrespondenceRejectors</a> ()</td></tr>
<tr class="memdesc:ac0c221d8f1151096721db3817610c9d9 inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of correspondence rejectors.  <a href="classpcl_1_1_registration.html#ac0c221d8f1151096721db3817610c9d9">More...</a><br /></td></tr>
<tr class="separator:ac0c221d8f1151096721db3817610c9d9 inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d49f38bcb804bb893a14e3cd4ed31e inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a33d49f38bcb804bb893a14e3cd4ed31e">removeCorrespondenceRejector</a> (unsigned int i)</td></tr>
<tr class="memdesc:a33d49f38bcb804bb893a14e3cd4ed31e inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the i-th correspondence rejector in the list.  <a href="classpcl_1_1_registration.html#a33d49f38bcb804bb893a14e3cd4ed31e">More...</a><br /></td></tr>
<tr class="separator:a33d49f38bcb804bb893a14e3cd4ed31e inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169aeb5141fc6e1cec83582ae284aeaa inherit pub_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a169aeb5141fc6e1cec83582ae284aeaa">clearCorrespondenceRejectors</a> ()</td></tr>
<tr class="memdesc:a169aeb5141fc6e1cec83582ae284aeaa inherit pub_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list of correspondence rejectors.  <a href="classpcl_1_1_registration.html#a169aeb5141fc6e1cec83582ae284aeaa">More...</a><br /></td></tr>
<tr class="separator:a169aeb5141fc6e1cec83582ae284aeaa inherit pub_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointSource &gt;</a></td></tr>
<tr class="memitem:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">PCLBase</a> ()</td></tr>
<tr class="memdesc:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">More...</a><br /></td></tr>
<tr class="separator:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">PCLBase</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html">PCLBase</a> &amp;base)</td></tr>
<tr class="memdesc:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">More...</a><br /></td></tr>
<tr class="separator:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ace0baa9034497232920bbe6e5a9f393b">~PCLBase</a> ()=default</td></tr>
<tr class="memdesc:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classpcl_1_1_p_c_l_base.html#ace0baa9034497232920bbe6e5a9f393b">More...</a><br /></td></tr>
<tr class="separator:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">setInputCloud</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> &amp;cloud)</td></tr>
<tr class="memdesc:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input dataset.  <a href="classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">More...</a><br /></td></tr>
<tr class="separator:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd745c4f7a792212f4fc3720b9d46ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a8cd745c4f7a792212f4fc3720b9d46ea">getInputCloud</a> () const</td></tr>
<tr class="memdesc:a8cd745c4f7a792212f4fc3720b9d46ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset.  <a href="classpcl_1_1_p_c_l_base.html#a8cd745c4f7a792212f4fc3720b9d46ea">More...</a><br /></td></tr>
<tr class="separator:a8cd745c4f7a792212f4fc3720b9d46ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">setIndices</a> (const <a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">More...</a><br /></td></tr>
<tr class="separator:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">setIndices</a> (const <a class="el" href="namespacepcl.html#a011f84e43d80cb736d9ec9abd0930024">IndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">More...</a><br /></td></tr>
<tr class="separator:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">setIndices</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#ae4b0d9b8a0867631ef2b9114116f9618">PointIndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">More...</a><br /></td></tr>
<tr class="separator:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a554d92d5605748c0573f6d1c7428f5a7">setIndices</a> (std::size_t row_start, std::size_t col_start, std::size_t nb_rows, std::size_t nb_cols)</td></tr>
<tr class="memdesc:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indices for the points laying within an interest region of the point cloud.  <a href="classpcl_1_1_p_c_l_base.html#a554d92d5605748c0573f6d1c7428f5a7">More...</a><br /></td></tr>
<tr class="separator:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af46c8513100321ca44df399abb494ad1">getIndices</a> ()</td></tr>
<tr class="memdesc:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="classpcl_1_1_p_c_l_base.html#af46c8513100321ca44df399abb494ad1">More...</a><br /></td></tr>
<tr class="separator:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae187b37230758959572ceb1e6e2045 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a011f84e43d80cb736d9ec9abd0930024">IndicesConstPtr</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#acae187b37230758959572ceb1e6e2045">getIndices</a> () const</td></tr>
<tr class="memdesc:acae187b37230758959572ceb1e6e2045 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="classpcl_1_1_p_c_l_base.html#acae187b37230758959572ceb1e6e2045">More...</a><br /></td></tr>
<tr class="separator:acae187b37230758959572ceb1e6e2045 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const PointSource &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae97525f1375a8eec6d3119bf3de16ef0">operator[]</a> (std::size_t pos) const</td></tr>
<tr class="memdesc:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override PointCloud operator[] to shorten code.  <a href="classpcl_1_1_p_c_l_base.html#ae97525f1375a8eec6d3119bf3de16ef0">More...</a><br /></td></tr>
<tr class="separator:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8671ae8cccdb4f89ef3035caf18d7e86"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a8671ae8cccdb4f89ef3035caf18d7e86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a8671ae8cccdb4f89ef3035caf18d7e86">computeCovariances</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa91ed24fe381c135f631145772b9cf10">ConstPtr</a> cloud, const typename <a class="el" href="classpcl_1_1search_1_1_kd_tree.html">pcl::search::KdTree</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a3ad0245aa95f46cb145c28f8ba928b3b">Ptr</a> tree, <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d4aade9bdceb33244fc21d7f8609b01">MatricesVector</a> &amp;cloud_covariances)</td></tr>
<tr class="memdesc:a8671ae8cccdb4f89ef3035caf18d7e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute points covariances matrices according to the K nearest neighbors.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a8671ae8cccdb4f89ef3035caf18d7e86">More...</a><br /></td></tr>
<tr class="separator:a8671ae8cccdb4f89ef3035caf18d7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3451bfc8b681792fee760c79efad33c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ab3451bfc8b681792fee760c79efad33c">matricesInnerProd</a> (const Eigen::MatrixXd &amp;mat1, const Eigen::MatrixXd &amp;mat2) const</td></tr>
<tr class="separator:ab3451bfc8b681792fee760c79efad33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8753620e8d943d463221ab2cdd6644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ace8753620e8d943d463221ab2cdd6644">computeTransformation</a> (<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> &amp;output, const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;guess) override</td></tr>
<tr class="memdesc:ace8753620e8d943d463221ab2cdd6644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rigid transformation computation method with initial guess.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#ace8753620e8d943d463221ab2cdd6644">More...</a><br /></td></tr>
<tr class="separator:ace8753620e8d943d463221ab2cdd6644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51688925efb0e23519654e70761e663"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af51688925efb0e23519654e70761e663">searchForNeighbors</a> (const PointSource &amp;query, <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;index, std::vector&lt; float &gt; &amp;distance)</td></tr>
<tr class="memdesc:af51688925efb0e23519654e70761e663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the closest nearest neighbor of a given point.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#af51688925efb0e23519654e70761e663">More...</a><br /></td></tr>
<tr class="separator:af51688925efb0e23519654e70761e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd0d0ef06f9db8ba2593675f7288354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a2bd0d0ef06f9db8ba2593675f7288354">applyState</a> (<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;t, const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af97fbb9fbace05b86992dc2a045c34aa">Vector6d</a> &amp;x) const</td></tr>
<tr class="memdesc:a2bd0d0ef06f9db8ba2593675f7288354"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute transformation matrix from transformation matrix  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a2bd0d0ef06f9db8ba2593675f7288354">More...</a><br /></td></tr>
<tr class="separator:a2bd0d0ef06f9db8ba2593675f7288354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_iterative_closest_point"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_iterative_closest_point')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_iterative_closest_point.html">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:a9e5609b6e348a9592b12871d175dabbf inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a9e5609b6e348a9592b12871d175dabbf">transformCloud</a> (const <a class="el" href="classpcl_1_1_iterative_closest_point.html#a5cbf8d0ec3afd1e42c20ad3bf9d9f70e">PointCloudSource</a> &amp;input, <a class="el" href="classpcl_1_1_iterative_closest_point.html#a5cbf8d0ec3afd1e42c20ad3bf9d9f70e">PointCloudSource</a> &amp;output, const <a class="el" href="classpcl_1_1_iterative_closest_point.html#a08b1f9d82bea112069392930dc7adca8">Matrix4</a> &amp;transform)</td></tr>
<tr class="memdesc:a9e5609b6e348a9592b12871d175dabbf inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform to a given dataset.  <a href="classpcl_1_1_iterative_closest_point.html#a9e5609b6e348a9592b12871d175dabbf">More...</a><br /></td></tr>
<tr class="separator:a9e5609b6e348a9592b12871d175dabbf inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab544d15c8d9ecead444290f0872a41c6 inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#ab544d15c8d9ecead444290f0872a41c6">computeTransformation</a> (<a class="el" href="classpcl_1_1_iterative_closest_point.html#a5cbf8d0ec3afd1e42c20ad3bf9d9f70e">PointCloudSource</a> &amp;output, const <a class="el" href="classpcl_1_1_iterative_closest_point.html#a08b1f9d82bea112069392930dc7adca8">Matrix4</a> &amp;guess) override</td></tr>
<tr class="memdesc:ab544d15c8d9ecead444290f0872a41c6 inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rigid transformation computation method with initial guess.  <a href="classpcl_1_1_iterative_closest_point.html#ab544d15c8d9ecead444290f0872a41c6">More...</a><br /></td></tr>
<tr class="separator:ab544d15c8d9ecead444290f0872a41c6 inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51eb8b9d92dbb56ae7a74958aac54b6 inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#aa51eb8b9d92dbb56ae7a74958aac54b6">determineRequiredBlobData</a> ()</td></tr>
<tr class="memdesc:aa51eb8b9d92dbb56ae7a74958aac54b6 inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks at the Estimators and Rejectors and determines whether their blob-setter methods need to be called.  <a href="classpcl_1_1_iterative_closest_point.html#aa51eb8b9d92dbb56ae7a74958aac54b6">More...</a><br /></td></tr>
<tr class="separator:aa51eb8b9d92dbb56ae7a74958aac54b6 inherit pro_methods_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_registration"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_registration')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:a9abd71cc105c84d6c74ed18562d8ec00 inherit pro_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a9abd71cc105c84d6c74ed18562d8ec00">searchForNeighbors</a> (const <a class="el" href="classpcl_1_1_registration.html#a2e3fc583011a672b1bd3524bf0501d2d">PointCloudSource</a> &amp;cloud, int index, <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;indices, std::vector&lt; float &gt; &amp;distances)</td></tr>
<tr class="memdesc:a9abd71cc105c84d6c74ed18562d8ec00 inherit pro_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the closest nearest neighbor of a given point.  <a href="classpcl_1_1_registration.html#a9abd71cc105c84d6c74ed18562d8ec00">More...</a><br /></td></tr>
<tr class="separator:a9abd71cc105c84d6c74ed18562d8ec00 inherit pro_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eb5d425e7cc8a998f0e4b1b253a6f5 inherit pro_methods_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ae5eb5d425e7cc8a998f0e4b1b253a6f5">computeTransformation</a> (<a class="el" href="classpcl_1_1_registration.html#a2e3fc583011a672b1bd3524bf0501d2d">PointCloudSource</a> &amp;output, const <a class="el" href="classpcl_1_1_registration.html#a9182ad0a61f178483dcb977973936262">Matrix4</a> &amp;guess)=0</td></tr>
<tr class="memdesc:ae5eb5d425e7cc8a998f0e4b1b253a6f5 inherit pro_methods_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract transformation computation method with initial guess.  <a href="classpcl_1_1_registration.html#ae5eb5d425e7cc8a998f0e4b1b253a6f5">More...</a><br /></td></tr>
<tr class="separator:ae5eb5d425e7cc8a998f0e4b1b253a6f5 inherit pro_methods_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointSource &gt;</a></td></tr>
<tr class="memitem:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">initCompute</a> ()</td></tr>
<tr class="memdesc:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called before starting the actual computation.  <a href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">More...</a><br /></td></tr>
<tr class="separator:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">deinitCompute</a> ()</td></tr>
<tr class="memdesc:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called after finishing the actual computation.  <a href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">More...</a><br /></td></tr>
<tr class="separator:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aba36233f6a4f311bd42eabcf2a2142ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aba36233f6a4f311bd42eabcf2a2142ec">k_correspondences_</a> {20}</td></tr>
<tr class="memdesc:aba36233f6a4f311bd42eabcf2a2142ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of neighbors used for covariances computation.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#aba36233f6a4f311bd42eabcf2a2142ec">More...</a><br /></td></tr>
<tr class="separator:aba36233f6a4f311bd42eabcf2a2142ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61f1a99e5eff02f8c34e802ba741cb4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa61f1a99e5eff02f8c34e802ba741cb4">gicp_epsilon_</a> {0.001}</td></tr>
<tr class="memdesc:aa61f1a99e5eff02f8c34e802ba741cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The epsilon constant for gicp paper; this is NOT the convergence tolerance default: 0.001.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#aa61f1a99e5eff02f8c34e802ba741cb4">More...</a><br /></td></tr>
<tr class="separator:aa61f1a99e5eff02f8c34e802ba741cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bea59ebf516fe6d85137444f6d21906"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a0bea59ebf516fe6d85137444f6d21906">rotation_epsilon_</a> {2e-3}</td></tr>
<tr class="memdesc:a0bea59ebf516fe6d85137444f6d21906"><td class="mdescLeft">&#160;</td><td class="mdescRight">The epsilon constant for rotation error.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a0bea59ebf516fe6d85137444f6d21906">More...</a><br /></td></tr>
<tr class="separator:a0bea59ebf516fe6d85137444f6d21906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399028e82ddfe0e5da5c35c68f386aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a399028e82ddfe0e5da5c35c68f386aeb">base_transformation_</a></td></tr>
<tr class="memdesc:a399028e82ddfe0e5da5c35c68f386aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">base transformation  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a399028e82ddfe0e5da5c35c68f386aeb">More...</a><br /></td></tr>
<tr class="separator:a399028e82ddfe0e5da5c35c68f386aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02315b62d78549b2a92e06268acf351"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa02315b62d78549b2a92e06268acf351">tmp_src_</a></td></tr>
<tr class="memdesc:aa02315b62d78549b2a92e06268acf351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary pointer to the source dataset.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#aa02315b62d78549b2a92e06268acf351">More...</a><br /></td></tr>
<tr class="separator:aa02315b62d78549b2a92e06268acf351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444644d3974bc5fb9c0897ec1b6ea9ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36aa9d54eacdf78c6fd903000fb3f021">PointCloudTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a444644d3974bc5fb9c0897ec1b6ea9ea">tmp_tgt_</a></td></tr>
<tr class="memdesc:a444644d3974bc5fb9c0897ec1b6ea9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary pointer to the target dataset.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a444644d3974bc5fb9c0897ec1b6ea9ea">More...</a><br /></td></tr>
<tr class="separator:a444644d3974bc5fb9c0897ec1b6ea9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbac149567cf4f69db548b7387a98c0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#afbac149567cf4f69db548b7387a98c0e">tmp_idx_src_</a></td></tr>
<tr class="memdesc:afbac149567cf4f69db548b7387a98c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary pointer to the source dataset indices.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#afbac149567cf4f69db548b7387a98c0e">More...</a><br /></td></tr>
<tr class="separator:afbac149567cf4f69db548b7387a98c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e07dc0b2c7840ef4503fe19784646d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36e07dc0b2c7840ef4503fe19784646d">tmp_idx_tgt_</a></td></tr>
<tr class="memdesc:a36e07dc0b2c7840ef4503fe19784646d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary pointer to the target dataset indices.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a36e07dc0b2c7840ef4503fe19784646d">More...</a><br /></td></tr>
<tr class="separator:a36e07dc0b2c7840ef4503fe19784646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4960f89966c67be6b9043234c836b234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a4960f89966c67be6b9043234c836b234">input_covariances_</a></td></tr>
<tr class="memdesc:a4960f89966c67be6b9043234c836b234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input cloud points covariances.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a4960f89966c67be6b9043234c836b234">More...</a><br /></td></tr>
<tr class="separator:a4960f89966c67be6b9043234c836b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75fb2f9a00f1f4323496322c751e100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ac75fb2f9a00f1f4323496322c751e100">target_covariances_</a></td></tr>
<tr class="memdesc:ac75fb2f9a00f1f4323496322c751e100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target cloud points covariances.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#ac75fb2f9a00f1f4323496322c751e100">More...</a><br /></td></tr>
<tr class="separator:ac75fb2f9a00f1f4323496322c751e100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf7b4f438b2c6680d90423a06ecdada"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#abcf7b4f438b2c6680d90423a06ecdada">mahalanobis_</a></td></tr>
<tr class="memdesc:abcf7b4f438b2c6680d90423a06ecdada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mahalanobis matrices holder.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#abcf7b4f438b2c6680d90423a06ecdada">More...</a><br /></td></tr>
<tr class="separator:abcf7b4f438b2c6680d90423a06ecdada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c0ea4932019a741cd8d051503f7fc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa5c0ea4932019a741cd8d051503f7fc3">max_inner_iterations_</a> {20}</td></tr>
<tr class="memdesc:aa5c0ea4932019a741cd8d051503f7fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of optimizations  <a href="classpcl_1_1_generalized_iterative_closest_point.html#aa5c0ea4932019a741cd8d051503f7fc3">More...</a><br /></td></tr>
<tr class="separator:aa5c0ea4932019a741cd8d051503f7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb91bc51609e471178b0995b68af25a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a3cb91bc51609e471178b0995b68af25a">translation_gradient_tolerance_</a> {1e-2}</td></tr>
<tr class="memdesc:a3cb91bc51609e471178b0995b68af25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimal translation gradient for early optimization stop  <a href="classpcl_1_1_generalized_iterative_closest_point.html#a3cb91bc51609e471178b0995b68af25a">More...</a><br /></td></tr>
<tr class="separator:a3cb91bc51609e471178b0995b68af25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0fc47ad1a34503b1fad9f3549cc206"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ade0fc47ad1a34503b1fad9f3549cc206">rotation_gradient_tolerance_</a> {1e-2}</td></tr>
<tr class="memdesc:ade0fc47ad1a34503b1fad9f3549cc206"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimal rotation gradient for early optimization stop  <a href="classpcl_1_1_generalized_iterative_closest_point.html#ade0fc47ad1a34503b1fad9f3549cc206">More...</a><br /></td></tr>
<tr class="separator:ade0fc47ad1a34503b1fad9f3549cc206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ca1f40422565aba86684f8be454852"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointSource &gt; &amp;cloud_src, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;src_indices, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointTarget &gt; &amp;cloud_tgt, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;tgt_indices, <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;transformation_matrix)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ae8ca1f40422565aba86684f8be454852">rigid_transformation_estimation_</a></td></tr>
<tr class="separator:ae8ca1f40422565aba86684f8be454852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_iterative_closest_point"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_iterative_closest_point')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_iterative_closest_point.html">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:af995b618d9a817c64a66d663fb84954d inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#af995b618d9a817c64a66d663fb84954d">x_idx_offset_</a></td></tr>
<tr class="memdesc:af995b618d9a817c64a66d663fb84954d inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">XYZ fields offset.  <a href="classpcl_1_1_iterative_closest_point.html#af995b618d9a817c64a66d663fb84954d">More...</a><br /></td></tr>
<tr class="separator:af995b618d9a817c64a66d663fb84954d inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca74fa5419419bb6d44ea54e611f11d inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a0ca74fa5419419bb6d44ea54e611f11d">y_idx_offset_</a></td></tr>
<tr class="separator:a0ca74fa5419419bb6d44ea54e611f11d inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91c1b40d8d950efe536f2a68b3e58f6 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#af91c1b40d8d950efe536f2a68b3e58f6">z_idx_offset_</a></td></tr>
<tr class="separator:af91c1b40d8d950efe536f2a68b3e58f6 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73a6b697fddb837bafc1652895b9473 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#aa73a6b697fddb837bafc1652895b9473">nx_idx_offset_</a></td></tr>
<tr class="memdesc:aa73a6b697fddb837bafc1652895b9473 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal fields offset.  <a href="classpcl_1_1_iterative_closest_point.html#aa73a6b697fddb837bafc1652895b9473">More...</a><br /></td></tr>
<tr class="separator:aa73a6b697fddb837bafc1652895b9473 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330f48788719e333b2449610529513b3 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a330f48788719e333b2449610529513b3">ny_idx_offset_</a></td></tr>
<tr class="separator:a330f48788719e333b2449610529513b3 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1015908db1af1c5f9e0c25b860c3b652 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a1015908db1af1c5f9e0c25b860c3b652">nz_idx_offset_</a></td></tr>
<tr class="separator:a1015908db1af1c5f9e0c25b860c3b652 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4cebbb2d9789f5f55e6831e335b15d inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a1c4cebbb2d9789f5f55e6831e335b15d">use_reciprocal_correspondence_</a></td></tr>
<tr class="memdesc:a1c4cebbb2d9789f5f55e6831e335b15d inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">The correspondence type used for correspondence estimation.  <a href="classpcl_1_1_iterative_closest_point.html#a1c4cebbb2d9789f5f55e6831e335b15d">More...</a><br /></td></tr>
<tr class="separator:a1c4cebbb2d9789f5f55e6831e335b15d inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c473bc941c384d52d8af7cc34e4d703 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a9c473bc941c384d52d8af7cc34e4d703">source_has_normals_</a></td></tr>
<tr class="memdesc:a9c473bc941c384d52d8af7cc34e4d703 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal check whether source dataset has normals or not.  <a href="classpcl_1_1_iterative_closest_point.html#a9c473bc941c384d52d8af7cc34e4d703">More...</a><br /></td></tr>
<tr class="separator:a9c473bc941c384d52d8af7cc34e4d703 inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed96da82ec7cdef9e3bad46c28dfc9be inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#aed96da82ec7cdef9e3bad46c28dfc9be">target_has_normals_</a></td></tr>
<tr class="memdesc:aed96da82ec7cdef9e3bad46c28dfc9be inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal check whether target dataset has normals or not.  <a href="classpcl_1_1_iterative_closest_point.html#aed96da82ec7cdef9e3bad46c28dfc9be">More...</a><br /></td></tr>
<tr class="separator:aed96da82ec7cdef9e3bad46c28dfc9be inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed9b4b47ccd4dc2da120a021d73122c inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a4ed9b4b47ccd4dc2da120a021d73122c">need_source_blob_</a></td></tr>
<tr class="memdesc:a4ed9b4b47ccd4dc2da120a021d73122c inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for whether estimators and rejectors need various data.  <a href="classpcl_1_1_iterative_closest_point.html#a4ed9b4b47ccd4dc2da120a021d73122c">More...</a><br /></td></tr>
<tr class="separator:a4ed9b4b47ccd4dc2da120a021d73122c inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5280d4564584ec9b1483210db067ad inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a2b5280d4564584ec9b1483210db067ad">need_target_blob_</a></td></tr>
<tr class="separator:a2b5280d4564584ec9b1483210db067ad inherit pro_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_registration"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_registration')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:a1e493af70763e05bcaf5ecd0ed7be63d inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a1e493af70763e05bcaf5ecd0ed7be63d">reg_name_</a></td></tr>
<tr class="memdesc:a1e493af70763e05bcaf5ecd0ed7be63d inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The registration method name.  <a href="classpcl_1_1_registration.html#a1e493af70763e05bcaf5ecd0ed7be63d">More...</a><br /></td></tr>
<tr class="separator:a1e493af70763e05bcaf5ecd0ed7be63d inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b6170328705f29854aba00c4feb66d inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a421b6b1a94a03d86437895306b12f20e">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a79b6170328705f29854aba00c4feb66d">tree_</a></td></tr>
<tr class="memdesc:a79b6170328705f29854aba00c4feb66d inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the spatial search object.  <a href="classpcl_1_1_registration.html#a79b6170328705f29854aba00c4feb66d">More...</a><br /></td></tr>
<tr class="separator:a79b6170328705f29854aba00c4feb66d inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3362d946f4b60e2628dc02e2af1f24fd inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a02d752af19dd9841c6b169e56aca7f36">KdTreeReciprocalPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a3362d946f4b60e2628dc02e2af1f24fd">tree_reciprocal_</a></td></tr>
<tr class="memdesc:a3362d946f4b60e2628dc02e2af1f24fd inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the spatial search object of the source.  <a href="classpcl_1_1_registration.html#a3362d946f4b60e2628dc02e2af1f24fd">More...</a><br /></td></tr>
<tr class="separator:a3362d946f4b60e2628dc02e2af1f24fd inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6957c3193d73098cb0535d6625d591d4 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a6957c3193d73098cb0535d6625d591d4">nr_iterations_</a></td></tr>
<tr class="memdesc:a6957c3193d73098cb0535d6625d591d4 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of iterations the internal optimization ran for (used internally).  <a href="classpcl_1_1_registration.html#a6957c3193d73098cb0535d6625d591d4">More...</a><br /></td></tr>
<tr class="separator:a6957c3193d73098cb0535d6625d591d4 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa776d097d20137f2702a275d931989d2 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aa776d097d20137f2702a275d931989d2">max_iterations_</a></td></tr>
<tr class="memdesc:aa776d097d20137f2702a275d931989d2 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of iterations the internal optimization should run for.  <a href="classpcl_1_1_registration.html#aa776d097d20137f2702a275d931989d2">More...</a><br /></td></tr>
<tr class="separator:aa776d097d20137f2702a275d931989d2 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9099e6970624c4ee91817f3f97f82f7f inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a9099e6970624c4ee91817f3f97f82f7f">ransac_iterations_</a></td></tr>
<tr class="memdesc:a9099e6970624c4ee91817f3f97f82f7f inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of iterations RANSAC should run for.  <a href="classpcl_1_1_registration.html#a9099e6970624c4ee91817f3f97f82f7f">More...</a><br /></td></tr>
<tr class="separator:a9099e6970624c4ee91817f3f97f82f7f inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ac08a379a3b5db44c5c502cf6a882e inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a5fa6a6606115f71dee8724740b18e2c0">PointCloudTargetConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#af9ac08a379a3b5db44c5c502cf6a882e">target_</a></td></tr>
<tr class="memdesc:af9ac08a379a3b5db44c5c502cf6a882e inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input point cloud dataset target.  <a href="classpcl_1_1_registration.html#af9ac08a379a3b5db44c5c502cf6a882e">More...</a><br /></td></tr>
<tr class="separator:af9ac08a379a3b5db44c5c502cf6a882e inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023e79a041ee70e8383654432cf5a71e inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a9182ad0a61f178483dcb977973936262">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a023e79a041ee70e8383654432cf5a71e">final_transformation_</a></td></tr>
<tr class="memdesc:a023e79a041ee70e8383654432cf5a71e inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final transformation matrix estimated by the registration method after N iterations.  <a href="classpcl_1_1_registration.html#a023e79a041ee70e8383654432cf5a71e">More...</a><br /></td></tr>
<tr class="separator:a023e79a041ee70e8383654432cf5a71e inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdeaab1c7d5e156a7bd35ee71c1f0db inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a9182ad0a61f178483dcb977973936262">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a2cdeaab1c7d5e156a7bd35ee71c1f0db">transformation_</a></td></tr>
<tr class="memdesc:a2cdeaab1c7d5e156a7bd35ee71c1f0db inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transformation matrix estimated by the registration method.  <a href="classpcl_1_1_registration.html#a2cdeaab1c7d5e156a7bd35ee71c1f0db">More...</a><br /></td></tr>
<tr class="separator:a2cdeaab1c7d5e156a7bd35ee71c1f0db inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0064ba2f733ef07476f42de09a656f inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a9182ad0a61f178483dcb977973936262">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a8d0064ba2f733ef07476f42de09a656f">previous_transformation_</a></td></tr>
<tr class="memdesc:a8d0064ba2f733ef07476f42de09a656f inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The previous transformation matrix estimated by the registration method (used internally).  <a href="classpcl_1_1_registration.html#a8d0064ba2f733ef07476f42de09a656f">More...</a><br /></td></tr>
<tr class="separator:a8d0064ba2f733ef07476f42de09a656f inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd6519634f433c0be2fd640c0c75108 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#adbd6519634f433c0be2fd640c0c75108">transformation_epsilon_</a></td></tr>
<tr class="memdesc:adbd6519634f433c0be2fd640c0c75108 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum difference between two consecutive transformations in order to consider convergence (user defined).  <a href="classpcl_1_1_registration.html#adbd6519634f433c0be2fd640c0c75108">More...</a><br /></td></tr>
<tr class="separator:adbd6519634f433c0be2fd640c0c75108 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eed9e69dd00183e69337f920beccdb inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aa9eed9e69dd00183e69337f920beccdb">transformation_rotation_epsilon_</a></td></tr>
<tr class="memdesc:aa9eed9e69dd00183e69337f920beccdb inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum rotation difference between two consecutive transformations in order to consider convergence (user defined).  <a href="classpcl_1_1_registration.html#aa9eed9e69dd00183e69337f920beccdb">More...</a><br /></td></tr>
<tr class="separator:aa9eed9e69dd00183e69337f920beccdb inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bf2297e961c3012bffe79fdd2d495d inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab5bf2297e961c3012bffe79fdd2d495d">euclidean_fitness_epsilon_</a></td></tr>
<tr class="memdesc:ab5bf2297e961c3012bffe79fdd2d495d inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum allowed Euclidean error between two consecutive steps in the ICP loop, before the algorithm is considered to have converged.  <a href="classpcl_1_1_registration.html#ab5bf2297e961c3012bffe79fdd2d495d">More...</a><br /></td></tr>
<tr class="separator:ab5bf2297e961c3012bffe79fdd2d495d inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aa975f33a8f22573bad118ddda10dd inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a15aa975f33a8f22573bad118ddda10dd">corr_dist_threshold_</a></td></tr>
<tr class="memdesc:a15aa975f33a8f22573bad118ddda10dd inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum distance threshold between two correspondent points in source &lt;-&gt; target.  <a href="classpcl_1_1_registration.html#a15aa975f33a8f22573bad118ddda10dd">More...</a><br /></td></tr>
<tr class="separator:a15aa975f33a8f22573bad118ddda10dd inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d7a9089d15932a78775dbb0b30d42f inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab5d7a9089d15932a78775dbb0b30d42f">inlier_threshold_</a></td></tr>
<tr class="memdesc:ab5d7a9089d15932a78775dbb0b30d42f inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inlier distance threshold for the internal RANSAC outlier rejection loop.  <a href="classpcl_1_1_registration.html#ab5d7a9089d15932a78775dbb0b30d42f">More...</a><br /></td></tr>
<tr class="separator:ab5d7a9089d15932a78775dbb0b30d42f inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e94793b677e107410ebb29ea2f931e9 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a8e94793b677e107410ebb29ea2f931e9">converged_</a></td></tr>
<tr class="memdesc:a8e94793b677e107410ebb29ea2f931e9 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds internal convergence state, given user parameters.  <a href="classpcl_1_1_registration.html#a8e94793b677e107410ebb29ea2f931e9">More...</a><br /></td></tr>
<tr class="separator:a8e94793b677e107410ebb29ea2f931e9 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24a16c695a87b1f6c597384d926ad24 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ab24a16c695a87b1f6c597384d926ad24">min_number_correspondences_</a></td></tr>
<tr class="memdesc:ab24a16c695a87b1f6c597384d926ad24 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum number of correspondences that the algorithm needs before attempting to estimate the transformation.  <a href="classpcl_1_1_registration.html#ab24a16c695a87b1f6c597384d926ad24">More...</a><br /></td></tr>
<tr class="separator:ab24a16c695a87b1f6c597384d926ad24 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f1c160391fff07f34339b63286e228 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a12f6f222e9a2be3c0fa8cdf49903c1aa">CorrespondencesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a98f1c160391fff07f34339b63286e228">correspondences_</a></td></tr>
<tr class="memdesc:a98f1c160391fff07f34339b63286e228 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of correspondences determined at this ICP step.  <a href="classpcl_1_1_registration.html#a98f1c160391fff07f34339b63286e228">More...</a><br /></td></tr>
<tr class="separator:a98f1c160391fff07f34339b63286e228 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99baaa7e513bda9103c58fd1471557ed inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#a51abf545364b8e7da1a84d35c9a4045d">TransformationEstimationPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a99baaa7e513bda9103c58fd1471557ed">transformation_estimation_</a></td></tr>
<tr class="memdesc:a99baaa7e513bda9103c58fd1471557ed inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A TransformationEstimation object, used to calculate the 4x4 rigid transformation.  <a href="classpcl_1_1_registration.html#a99baaa7e513bda9103c58fd1471557ed">More...</a><br /></td></tr>
<tr class="separator:a99baaa7e513bda9103c58fd1471557ed inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e6122a988e5114f4caa1212920444 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_registration.html#aeae6ff7053ea37bb830de913f7708b79">CorrespondenceEstimationPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a5f5e6122a988e5114f4caa1212920444">correspondence_estimation_</a></td></tr>
<tr class="memdesc:a5f5e6122a988e5114f4caa1212920444 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CorrespondenceEstimation object, used to estimate correspondences between the source and the target cloud.  <a href="classpcl_1_1_registration.html#a5f5e6122a988e5114f4caa1212920444">More...</a><br /></td></tr>
<tr class="separator:a5f5e6122a988e5114f4caa1212920444 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc73c4731a1e01ac100ebf4659578e1c inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcl_1_1_registration.html#abe8dda4286ffaba094bc697419449760">CorrespondenceRejectorPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#adc73c4731a1e01ac100ebf4659578e1c">correspondence_rejectors_</a></td></tr>
<tr class="memdesc:adc73c4731a1e01ac100ebf4659578e1c inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of correspondence rejectors to use.  <a href="classpcl_1_1_registration.html#adc73c4731a1e01ac100ebf4659578e1c">More...</a><br /></td></tr>
<tr class="separator:adc73c4731a1e01ac100ebf4659578e1c inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0167493576dabedd7678aa6811dee363 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a0167493576dabedd7678aa6811dee363">target_cloud_updated_</a></td></tr>
<tr class="memdesc:a0167493576dabedd7678aa6811dee363 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable that stores whether we have a new target cloud, meaning we need to pre-process it again.  <a href="classpcl_1_1_registration.html#a0167493576dabedd7678aa6811dee363">More...</a><br /></td></tr>
<tr class="separator:a0167493576dabedd7678aa6811dee363 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd89f31379081d9cc75e3ce9ab1a947 inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#aefd89f31379081d9cc75e3ce9ab1a947">source_cloud_updated_</a></td></tr>
<tr class="memdesc:aefd89f31379081d9cc75e3ce9ab1a947 inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable that stores whether we have a new source cloud, meaning we need to pre-process it again.  <a href="classpcl_1_1_registration.html#aefd89f31379081d9cc75e3ce9ab1a947">More...</a><br /></td></tr>
<tr class="separator:aefd89f31379081d9cc75e3ce9ab1a947 inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6335de3036d6e0fe9a3942cd6f30c87f inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a6335de3036d6e0fe9a3942cd6f30c87f">force_no_recompute_</a></td></tr>
<tr class="memdesc:a6335de3036d6e0fe9a3942cd6f30c87f inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag which, if set, means the tree operating on the target cloud will never be recomputed.  <a href="classpcl_1_1_registration.html#a6335de3036d6e0fe9a3942cd6f30c87f">More...</a><br /></td></tr>
<tr class="separator:a6335de3036d6e0fe9a3942cd6f30c87f inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fc63c91641a5e160aa19108a7811ec inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#ad1fc63c91641a5e160aa19108a7811ec">force_no_recompute_reciprocal_</a></td></tr>
<tr class="memdesc:ad1fc63c91641a5e160aa19108a7811ec inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag which, if set, means the tree operating on the source cloud will never be recomputed.  <a href="classpcl_1_1_registration.html#ad1fc63c91641a5e160aa19108a7811ec">More...</a><br /></td></tr>
<tr class="separator:ad1fc63c91641a5e160aa19108a7811ec inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12331085b51ec5c3e05448b701bf0f8b inherit pro_attribs_classpcl_1_1_registration"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classpcl_1_1_registration.html#a19da1953bb9e5844a26f173a0d723a06">UpdateVisualizerCallbackSignature</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html#a12331085b51ec5c3e05448b701bf0f8b">update_visualizer_</a></td></tr>
<tr class="memdesc:a12331085b51ec5c3e05448b701bf0f8b inherit pro_attribs_classpcl_1_1_registration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to update intermediate source point cloud position during it's registration to the target point cloud.  <a href="classpcl_1_1_registration.html#a12331085b51ec5c3e05448b701bf0f8b">More...</a><br /></td></tr>
<tr class="separator:a12331085b51ec5c3e05448b701bf0f8b inherit pro_attribs_classpcl_1_1_registration"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointSource &gt;</a></td></tr>
<tr class="memitem:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">input_</a></td></tr>
<tr class="memdesc:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input point cloud dataset.  <a href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">More...</a><br /></td></tr>
<tr class="separator:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">indices_</a></td></tr>
<tr class="memdesc:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the vector of point indices to use.  <a href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">More...</a><br /></td></tr>
<tr class="separator:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">use_indices_</a></td></tr>
<tr class="memdesc:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if point indices are used.  <a href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">More...</a><br /></td></tr>
<tr class="separator:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">fake_indices_</a></td></tr>
<tr class="memdesc:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">If no set of indices are given, we construct a set of fake indices that mimic the input PointCloud.  <a href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">More...</a><br /></td></tr>
<tr class="separator:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classpcl_1_1_iterative_closest_point"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classpcl_1_1_iterative_closest_point')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpcl_1_1_iterative_closest_point.html">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, float &gt;</a></td></tr>
<tr class="memitem:a6271a9c8a9e4d4c532408007630973a8 inherit pub_attribs_classpcl_1_1_iterative_closest_point"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1registration_1_1_default_convergence_criteria.html">pcl::registration::DefaultConvergenceCriteria</a>&lt; float &gt;::<a class="el" href="classpcl_1_1_iterative_closest_point.html#a3ccfd87123598f4650ffb20ea3f4774d">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html#a6271a9c8a9e4d4c532408007630973a8">convergence_criteria_</a></td></tr>
<tr class="separator:a6271a9c8a9e4d4c532408007630973a8 inherit pub_attribs_classpcl_1_1_iterative_closest_point"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointSource, typename PointTarget, typename Scalar = float&gt;<br />
class pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;</h3>

<p><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html" title="GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ...">GeneralizedIterativeClosestPoint</a> is an ICP variant that implements the generalized iterative closest point algorithm as described by Alex Segal et al. </p>
<p>in <a href="http://www.robots.ox.ac.uk/~avsegal/resources/papers/Generalized_ICP.pdf">http://www.robots.ox.ac.uk/~avsegal/resources/papers/Generalized_ICP.pdf</a> The approach is based on using anisotropic cost functions to optimize the alignment after closest point assignments have been made. The original code uses GSL and ANN while in ours we use FLANN and Newton's method for optimization (call <code>useBFGS</code> to switch to <a class="el" href="class_b_f_g_s.html" title="BFGS stands for BroydenFletcherGoldfarbShanno (BFGS) method for solving unconstrained nonlinear op...">BFGS</a> optimizer, however Newton is usually faster and more accurate). Basic usage example: </p><div class="fragment"><div class="line"><a class="code" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt;</a> reg;</div>
<div class="line">reg.<a class="code" href="classpcl_1_1_generalized_iterative_closest_point.html#a66b5b16fda7890e3db3b3ec1a9de549e">setInputSource</a>(src);</div>
<div class="line">reg.<a class="code" href="classpcl_1_1_generalized_iterative_closest_point.html#ad5401d81e34329703ea0cea21feeeea0">setInputTarget</a>(tgt);</div>
<div class="line"><span class="comment">// use default parameters or set them yourself, for example:</span></div>
<div class="line"><span class="comment">// reg.setMaximumIterations(...);</span></div>
<div class="line"><span class="comment">// reg.setTransformationEpsilon(...);</span></div>
<div class="line"><span class="comment">// reg.setRotationEpsilon(...);</span></div>
<div class="line"><span class="comment">// reg.setCorrespondenceRandomness(...);</span></div>
<div class="line"><a class="code" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr</a> output(<span class="keyword">new</span> <a class="code" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt;pcl::PointXYZ&gt;</a>);</div>
<div class="line"><span class="comment">// supply a better guess, if possible:</span></div>
<div class="line">Eigen::Matrix4f guess = Eigen::Matrix4f::Identity();</div>
<div class="line">reg.<a class="code" href="classpcl_1_1_registration.html#a96212303ca16b6d60020824086887c4f">align</a>(*output, guess);</div>
<div class="line">std::cout &lt;&lt; reg.<a class="code" href="classpcl_1_1_registration.html#a1e68bd39ac943131dcbf1431f9afe3f3">getFinalTransformation</a>() &lt;&lt; std::endl;</div>
<div class="ttc" id="aclasspcl_1_1_generalized_iterative_closest_point_html"><div class="ttname"><a href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a></div><div class="ttdoc">GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ...</div><div class="ttdef"><b>Definition:</b> <a href="gicp_8h_source.html#l00075">gicp.h:76</a></div></div>
<div class="ttc" id="aclasspcl_1_1_generalized_iterative_closest_point_html_a66b5b16fda7890e3db3b3ec1a9de549e"><div class="ttname"><a href="classpcl_1_1_generalized_iterative_closest_point.html#a66b5b16fda7890e3db3b3ec1a9de549e">pcl::GeneralizedIterativeClosestPoint::setInputSource</a></div><div class="ttdeci">void setInputSource(const PointCloudSourceConstPtr &amp;cloud) override</div><div class="ttdoc">Provide a pointer to the input dataset.</div><div class="ttdef"><b>Definition:</b> <a href="gicp_8h_source.html#l00159">gicp.h:159</a></div></div>
<div class="ttc" id="aclasspcl_1_1_generalized_iterative_closest_point_html_ad5401d81e34329703ea0cea21feeeea0"><div class="ttname"><a href="classpcl_1_1_generalized_iterative_closest_point.html#ad5401d81e34329703ea0cea21feeeea0">pcl::GeneralizedIterativeClosestPoint::setInputTarget</a></div><div class="ttdeci">void setInputTarget(const PointCloudTargetConstPtr &amp;target) override</div><div class="ttdoc">Provide a pointer to the input target (e.g., the point cloud that we want to align the input source t...</div><div class="ttdef"><b>Definition:</b> <a href="gicp_8h_source.html#l00193">gicp.h:193</a></div></div>
<div class="ttc" id="aclasspcl_1_1_point_cloud_html"><div class="ttname"><a href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; pcl::PointXYZ &gt;</a></div></div>
<div class="ttc" id="aclasspcl_1_1_point_cloud_html_ab805ba3b19e952ad19d084a9caa3dc60"><div class="ttname"><a href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">pcl::PointCloud::Ptr</a></div><div class="ttdeci">shared_ptr&lt; PointCloud&lt; PointT &gt; &gt; Ptr</div><div class="ttdef"><b>Definition:</b> <a href="common_2include_2pcl_2point__cloud_8h_source.html#l00413">point_cloud.h:413</a></div></div>
<div class="ttc" id="aclasspcl_1_1_registration_html_a1e68bd39ac943131dcbf1431f9afe3f3"><div class="ttname"><a href="classpcl_1_1_registration.html#a1e68bd39ac943131dcbf1431f9afe3f3">pcl::Registration::getFinalTransformation</a></div><div class="ttdeci">Matrix4 getFinalTransformation()</div><div class="ttdoc">Get the final transformation matrix estimated by the registration method.</div><div class="ttdef"><b>Definition:</b> <a href="registration_2include_2pcl_2registration_2registration_8h_source.html#l00259">registration.h:259</a></div></div>
<div class="ttc" id="aclasspcl_1_1_registration_html_a96212303ca16b6d60020824086887c4f"><div class="ttname"><a href="classpcl_1_1_registration.html#a96212303ca16b6d60020824086887c4f">pcl::Registration::align</a></div><div class="ttdeci">void align(PointCloudSource &amp;output)</div><div class="ttdoc">Call the registration algorithm which estimates the transformation and returns the transformed source...</div><div class="ttdef"><b>Definition:</b> <a href="registration_8hpp_source.html#l00168">registration.hpp:168</a></div></div>
</div><!-- fragment --> <dl class="section author"><dt>Author</dt><dd>Nizar Sallem </dd></dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00075">75</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ace2958a780e98203dcd7b16eb01d930f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2958a780e98203dcd7b16eb01d930f">&#9670;&nbsp;</a></span>AngleAxis</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ace2958a780e98203dcd7b16eb01d930f">AngleAxis</a> =  typename Eigen::AngleAxis&lt;Scalar&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00132">132</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="aa91ed24fe381c135f631145772b9cf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91ed24fe381c135f631145772b9cf10">&#9670;&nbsp;</a></span>ConstPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa91ed24fe381c135f631145772b9cf10">ConstPtr</a> =  shared_ptr&lt; const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">GeneralizedIterativeClosestPoint</a>&lt;PointSource, PointTarget, Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00122">122</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a21f1ba1069e9afa23827ad55099f59a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f1ba1069e9afa23827ad55099f59a7">&#9670;&nbsp;</a></span>InputKdTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a21f1ba1069e9afa23827ad55099f59a7">InputKdTree</a> =  typename <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt;PointSource, PointTarget, Scalar&gt;::<a class="el" href="classpcl_1_1_registration.html#a840969f28198cea50cba0870c5a917ae">KdTree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00116">116</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a8426ceaa6f83d3695bbc0a33aa59f069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8426ceaa6f83d3695bbc0a33aa59f069">&#9670;&nbsp;</a></span>InputKdTreePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a8426ceaa6f83d3695bbc0a33aa59f069">InputKdTreePtr</a> =  typename <a class="el" href="classpcl_1_1_registration.html">Registration</a>&lt;PointSource, PointTarget, Scalar&gt;::<a class="el" href="classpcl_1_1_registration.html#a421b6b1a94a03d86437895306b12f20e">KdTreePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00117">117</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a7d4aade9bdceb33244fc21d7f8609b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4aade9bdceb33244fc21d7f8609b01">&#9670;&nbsp;</a></span>MatricesVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d4aade9bdceb33244fc21d7f8609b01">MatricesVector</a> =  std::vector&lt;Eigen::Matrix3d, Eigen::aligned_allocator&lt;Eigen::Matrix3d&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00111">111</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a7e020cfd1d6406a6b5875c3992da4d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e020cfd1d6406a6b5875c3992da4d18">&#9670;&nbsp;</a></span>MatricesVectorConstPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7e020cfd1d6406a6b5875c3992da4d18">MatricesVectorConstPtr</a> =  shared_ptr&lt;const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d4aade9bdceb33244fc21d7f8609b01">MatricesVector</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00114">114</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="adae981b1bdcb17f8aea09317a1d3228b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae981b1bdcb17f8aea09317a1d3228b">&#9670;&nbsp;</a></span>MatricesVectorPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a> =  shared_ptr&lt;<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d4aade9bdceb33244fc21d7f8609b01">MatricesVector</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00113">113</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="ad5c051540a777aa44808e9333bae3d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c051540a777aa44808e9333bae3d67">&#9670;&nbsp;</a></span>Matrix3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ad5c051540a777aa44808e9333bae3d67">Matrix3</a> =  typename Eigen::Matrix&lt;Scalar, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00128">128</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a29dd8bfa4175ce8821c74faacb28014c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29dd8bfa4175ce8821c74faacb28014c">&#9670;&nbsp;</a></span>Matrix4</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> =  typename <a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a>&lt;PointSource, PointTarget, Scalar&gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00129">129</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a41b30cd8f4cc68cce21becdea9b6ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b30cd8f4cc68cce21becdea9b6ad88">&#9670;&nbsp;</a></span>Matrix6d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a41b30cd8f4cc68cce21becdea9b6ad88">Matrix6d</a> =  Eigen::Matrix&lt;double, 6, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00131">131</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a382e93a477bf6134d3f5b58a9c045fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382e93a477bf6134d3f5b58a9c045fe4">&#9670;&nbsp;</a></span>PointCloudSource</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> =  <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;PointSource&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00100">100</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a4e96ac4bc6a3d361d388bf58692f2ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e96ac4bc6a3d361d388bf58692f2ade">&#9670;&nbsp;</a></span>PointCloudSourceConstPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a4e96ac4bc6a3d361d388bf58692f2ade">PointCloudSourceConstPtr</a> =  typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloudSource::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00102">102</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a985118fdd8677d1fcd13cad33013edf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985118fdd8677d1fcd13cad33013edf2">&#9670;&nbsp;</a></span>PointCloudSourcePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a985118fdd8677d1fcd13cad33013edf2">PointCloudSourcePtr</a> =  typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloudSource::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00101">101</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a36aa9d54eacdf78c6fd903000fb3f021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36aa9d54eacdf78c6fd903000fb3f021">&#9670;&nbsp;</a></span>PointCloudTarget</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36aa9d54eacdf78c6fd903000fb3f021">PointCloudTarget</a> =  <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;PointTarget&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00104">104</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="abeef6118852653929d4c40b364f40245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeef6118852653929d4c40b364f40245">&#9670;&nbsp;</a></span>PointCloudTargetConstPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#abeef6118852653929d4c40b364f40245">PointCloudTargetConstPtr</a> =  typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloudTarget::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00106">106</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a9a2c8d83e0e37cde919b1f2ef0bdfdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2c8d83e0e37cde919b1f2ef0bdfdea">&#9670;&nbsp;</a></span>PointCloudTargetPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a9a2c8d83e0e37cde919b1f2ef0bdfdea">PointCloudTargetPtr</a> =  typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloudTarget::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00105">105</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a3a9a6b5feb8bfe34a20fd5da4289ba96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9a6b5feb8bfe34a20fd5da4289ba96">&#9670;&nbsp;</a></span>PointIndicesConstPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a3a9a6b5feb8bfe34a20fd5da4289ba96">PointIndicesConstPtr</a> =  <a class="el" href="structpcl_1_1_point_indices.html#a6880da079270712d46b0bb348cf124bc">PointIndices::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00109">109</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="ab5c890f441ef8abaf4176061b3956f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c890f441ef8abaf4176061b3956f3a">&#9670;&nbsp;</a></span>PointIndicesPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#ab5c890f441ef8abaf4176061b3956f3a">PointIndicesPtr</a> =  <a class="el" href="structpcl_1_1_point_indices.html#a3c574b78dfbe67c93d09acdbc8ecc499">PointIndices::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00108">108</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a3ad0245aa95f46cb145c28f8ba928b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad0245aa95f46cb145c28f8ba928b3b">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a3ad0245aa95f46cb145c28f8ba928b3b">Ptr</a> =  shared_ptr&lt;<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">GeneralizedIterativeClosestPoint</a>&lt;PointSource, PointTarget, Scalar&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00120">120</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a5f24ec38847c3524a063b59277f58827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f24ec38847c3524a063b59277f58827">&#9670;&nbsp;</a></span>Vector3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a5f24ec38847c3524a063b59277f58827">Vector3</a> =  typename Eigen::Matrix&lt;Scalar, 3, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00125">125</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a5d20cb9ff26c92bcd8bd2fd5ac0b9aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d20cb9ff26c92bcd8bd2fd5ac0b9aca">&#9670;&nbsp;</a></span>Vector4</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a5d20cb9ff26c92bcd8bd2fd5ac0b9aca">Vector4</a> =  typename Eigen::Matrix&lt;Scalar, 4, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00126">126</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="af97fbb9fbace05b86992dc2a045c34aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97fbb9fbace05b86992dc2a045c34aa">&#9670;&nbsp;</a></span>Vector6d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af97fbb9fbace05b86992dc2a045c34aa">Vector6d</a> =  Eigen::Matrix&lt;double, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00127">127</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3c183cbfcfbd7c7cb6ab245d1c64717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c183cbfcfbd7c7cb6ab245d1c64717">&#9670;&nbsp;</a></span>GeneralizedIterativeClosestPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga35846236568f16ca7fa07d958966e12c">PCL_MAKE_ALIGNED_OPERATOR_NEW</a> <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">GeneralizedIterativeClosestPoint</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty constructor. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00137">137</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="registration_2include_2pcl_2registration_2registration_8h_source.html#l00603">pcl::Registration&lt; PointSource, PointTarget, float &gt;::corr_dist_threshold_</a>, <a class="el" href="gicp_8hpp_source.html#l00373">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::estimateRigidTransformationNewton()</a>, <a class="el" href="registration_2include_2pcl_2registration_2registration_8h_source.html#l00563">pcl::Registration&lt; PointSource, PointTarget, float &gt;::max_iterations_</a>, <a class="el" href="registration_2include_2pcl_2registration_2registration_8h_source.html#l00618">pcl::Registration&lt; PointSource, PointTarget, float &gt;::min_number_correspondences_</a>, <a class="el" href="registration_2include_2pcl_2registration_2registration_8h_source.html#l00548">pcl::Registration&lt; PointSource, PointTarget, float &gt;::reg_name_</a>, <a class="el" href="gicp_8h_source.html#l00514">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::rigid_transformation_estimation_</a>, <a class="el" href="gicp_8hpp_source.html#l00050">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setNumberOfThreads()</a>, and <a class="el" href="registration_2include_2pcl_2registration_2registration_8h_source.html#l00585">pcl::Registration&lt; PointSource, PointTarget, float &gt;::transformation_epsilon_</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2bd0d0ef06f9db8ba2593675f7288354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd0d0ef06f9db8ba2593675f7288354">&#9670;&nbsp;</a></span>applyState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::applyState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af97fbb9fbace05b86992dc2a045c34aa">Vector6d</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute transformation matrix from transformation matrix </p>

<p class="definition">Definition at line <a class="el" href="gicp_8hpp_source.html#l00926">926</a> of file <a class="el" href="gicp_8hpp_source.html">gicp.hpp</a>.</p>

</div>
</div>
<a id="a8671ae8cccdb4f89ef3035caf18d7e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8671ae8cccdb4f89ef3035caf18d7e86">&#9670;&nbsp;</a></span>computeCovariances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar &gt; </div>
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::computeCovariances </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#aa91ed24fe381c135f631145772b9cf10">ConstPtr</a>&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classpcl_1_1search_1_1_kd_tree.html">pcl::search::KdTree</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::<a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a3ad0245aa95f46cb145c28f8ba928b3b">Ptr</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a7d4aade9bdceb33244fc21d7f8609b01">MatricesVector</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_covariances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute points covariances matrices according to the K nearest neighbors. </p>
<p>K is set via <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a21457deb8ef3afabccdf96255a3da8b3" title="Set the number of neighbors used when selecting a point neighbourhood to compute covariances.">setCorrespondenceRandomness()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>pointer to point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>KD tree performer for nearest neighbors search </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_covariances</td><td>covariances matrices for each point in the cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8hpp_source.html#l00073">73</a> of file <a class="el" href="gicp_8hpp_source.html">gicp.hpp</a>.</p>

<p class="reference">References <a class="el" href="kdtree_8hpp_source.html#l00088">pcl::search::KdTree&lt; PointT, Tree &gt;::nearestKSearch()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="acd84f1612f02b9899b215527709a84a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd84f1612f02b9899b215527709a84a6">&#9670;&nbsp;</a></span>computeRDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::computeRDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af97fbb9fbace05b86992dc2a045c34aa">Vector6d</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>dCost_dR_T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#af97fbb9fbace05b86992dc2a045c34aa">Vector6d</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of the cost function w.r.t rotation angles. </p>
<p>rotation matrix is obtainded from rotation angles x[3], x[4] and x[5] </p><dl class="section return"><dt>Returns</dt><dd>d/d_Phi, d/d_Theta, d/d_Psi respectively in g[3], g[4] and g[5] </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>array representing 3D transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dCost_dR_T</td><td>the transpose of the derivative of the cost function w.r.t rotation matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>gradient vector </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8hpp_source.html#l00205">205</a> of file <a class="el" href="gicp_8hpp_source.html">gicp.hpp</a>.</p>

</div>
</div>
<a id="ace8753620e8d943d463221ab2cdd6644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8753620e8d943d463221ab2cdd6644">&#9670;&nbsp;</a></span>computeTransformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::computeTransformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rigid transformation computation method with initial guess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the transformed input point cloud dataset using the rigid transformation found</td></tr>
    <tr><td class="paramname">guess</td><td>the initial guess of the transformation to compute </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8hpp_source.html#l00769">769</a> of file <a class="el" href="gicp_8hpp_source.html">gicp.hpp</a>.</p>

<p class="reference">References <a class="el" href="registration_8hpp_source.html#l00105">pcl::Registration&lt; PointSource, PointTarget, float &gt;::initComputeReciprocal()</a>, and <a class="el" href="transforms_8hpp_source.html#l00221">pcl::transformPointCloud()</a>.</p>

</div>
</div>
<a id="a1090f4d956cb6435ab8efde135f7abe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1090f4d956cb6435ab8efde135f7abe1">&#9670;&nbsp;</a></span>estimateRigidTransformationBFGS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::estimateRigidTransformationBFGS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36aa9d54eacdf78c6fd903000fb3f021">PointCloudTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate a rigid rotation transformation between a source and a target point cloud using an iterative non-linear <a class="el" href="class_b_f_g_s.html" title="BFGS stands for BroydenFletcherGoldfarbShanno (BFGS) method for solving unconstrained nonlinear op...">BFGS</a> approach. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_src</td><td>the source point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_src</td><td>the vector of indices describing the points of interest in <em>cloud_src</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_tgt</td><td>the target point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_tgt</td><td>the vector of indices describing the correspondences of the interest points from <em>indices_src</em> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">transformation_matrix</td><td>the resultant transformation matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8hpp_source.html#l00296">296</a> of file <a class="el" href="gicp_8hpp_source.html">gicp.hpp</a>.</p>

<p class="reference">References <a class="el" href="bfgs_8h_source.html#l00361">BFGS&lt; FunctorType &gt;::minimizeInit()</a>, <a class="el" href="bfgs_8h_source.html#l00393">BFGS&lt; FunctorType &gt;::minimizeOneStep()</a>, <a class="el" href="bfgs_8h_source.html#l00075">BFGSSpace::NoProgress</a>, <a class="el" href="bfgs_8h_source.html#l00152">BFGS&lt; FunctorType &gt;::Parameters::order</a>, <a class="el" href="bfgs_8h_source.html#l00169">BFGS&lt; FunctorType &gt;::parameters</a>, <a class="el" href="bfgs_8h_source.html#l00146">BFGS&lt; FunctorType &gt;::Parameters::rho</a>, <a class="el" href="bfgs_8h_source.html#l00073">BFGSSpace::Running</a>, <a class="el" href="bfgs_8h_source.html#l00147">BFGS&lt; FunctorType &gt;::Parameters::sigma</a>, <a class="el" href="bfgs_8h_source.html#l00074">BFGSSpace::Success</a>, <a class="el" href="bfgs_8h_source.html#l00148">BFGS&lt; FunctorType &gt;::Parameters::tau1</a>, <a class="el" href="bfgs_8h_source.html#l00149">BFGS&lt; FunctorType &gt;::Parameters::tau2</a>, <a class="el" href="bfgs_8h_source.html#l00150">BFGS&lt; FunctorType &gt;::Parameters::tau3</a>, and <a class="el" href="bfgs_8h_source.html#l00476">BFGS&lt; FunctorType &gt;::testGradient()</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00311">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::useBFGS()</a>.</p>

</div>
</div>
<a id="a8fcade7eb021c48c52744ac8b5c86601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcade7eb021c48c52744ac8b5c86601">&#9670;&nbsp;</a></span>estimateRigidTransformationNewton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::estimateRigidTransformationNewton </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36aa9d54eacdf78c6fd903000fb3f021">PointCloudTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate a rigid rotation transformation between a source and a target point cloud using an iterative non-linear Newton approach. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_src</td><td>the source point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_src</td><td>the vector of indices describing the points of interest in <em>cloud_src</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_tgt</td><td>the target point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_tgt</td><td>the vector of indices describing the correspondences of the interest points from <em>indices_src</em> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">transformation_matrix</td><td>the resultant transformation matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8hpp_source.html#l00372">372</a> of file <a class="el" href="gicp_8hpp_source.html">gicp.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00137">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::GeneralizedIterativeClosestPoint()</a>.</p>

</div>
</div>
<a id="a18ca08cd0bf4eefbe9b27453d410ddc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ca08cd0bf4eefbe9b27453d410ddc3">&#9670;&nbsp;</a></span>getCorrespondenceRandomness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::getCorrespondenceRandomness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of neighbors used when computing covariances as set by the user. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00303">303</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00386">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::k_correspondences_</a>.</p>

</div>
</div>
<a id="a49132c9ea0621db884acc1b608bc7cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49132c9ea0621db884acc1b608bc7cb0">&#9670;&nbsp;</a></span>getMaximumOptimizerIterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::getMaximumOptimizerIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximum number of iterations at the optimization step. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00335">335</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00425">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::max_inner_iterations_</a>.</p>

</div>
</div>
<a id="aa843ff8a7317a624905887efee6d83b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa843ff8a7317a624905887efee6d83b1">&#9670;&nbsp;</a></span>getRotationEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::getRotationEpsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rotation epsilon (maximum allowable difference between two consecutive rotations) as set by the user. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00282">282</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00398">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::rotation_epsilon_</a>.</p>

</div>
</div>
<a id="ab6c758620f357e1898b80ac5af103329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c758620f357e1898b80ac5af103329">&#9670;&nbsp;</a></span>getRotationGradientTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::getRotationGradientTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimal rotation gradient threshold for early optimization stop. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00370">370</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00431">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::rotation_gradient_tolerance_</a>.</p>

</div>
</div>
<a id="ad3a5ebd31d9c74e35dabed495633a68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a5ebd31d9c74e35dabed495633a68c">&#9670;&nbsp;</a></span>getTranslationGradientTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::getTranslationGradientTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimal translation gradient threshold for early optimization stop. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00353">353</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00428">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::translation_gradient_tolerance_</a>.</p>

</div>
</div>
<a id="acd3c58acd527064baf9dededd0715933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3c58acd527064baf9dededd0715933">&#9670;&nbsp;</a></span>mahalanobis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Matrix3d&amp; <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::mahalanobis </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Mahalanobis distance matrix for the given point index </dd></dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00248">248</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00422">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::mahalanobis_</a>.</p>

</div>
</div>
<a id="ab3451bfc8b681792fee760c79efad33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3451bfc8b681792fee760c79efad33c">&#9670;&nbsp;</a></span>matricesInnerProd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::matricesInnerProd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>trace of mat1 . mat2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>matrix of dimension nxm </td></tr>
    <tr><td class="paramname">mat2</td><td>matrix of dimension mxp </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00450">450</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="af51688925efb0e23519654e70761e663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51688925efb0e23519654e70761e663">&#9670;&nbsp;</a></span>searchForNeighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::searchForNeighbors </td>
          <td>(</td>
          <td class="paramtype">const PointSource &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the closest nearest neighbor of a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the point to search a nearest neighbour for </td></tr>
    <tr><td class="paramname">index</td><td>vector of size 1 to store the index of the nearest neighbour found </td></tr>
    <tr><td class="paramname">distance</td><td>vector of size 1 to store the distance to nearest neighbour found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00476">476</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>, and <a class="el" href="registration_2include_2pcl_2registration_2registration_8h_source.html#l00551">pcl::Registration&lt; PointSource, PointTarget, float &gt;::tree_</a>.</p>

</div>
</div>
<a id="a21457deb8ef3afabccdf96255a3da8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21457deb8ef3afabccdf96255a3da8b3">&#9670;&nbsp;</a></span>setCorrespondenceRandomness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setCorrespondenceRandomness </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of neighbors used when selecting a point neighbourhood to compute covariances. </p>
<p>A higher value will bring more accurate covariance matrix but will make covariances computation slower. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number of neighbors to use when computing covariances </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00294">294</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00386">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::k_correspondences_</a>.</p>

</div>
</div>
<a id="a66b5b16fda7890e3db3b3ec1a9de549e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b5b16fda7890e3db3b3ec1a9de549e">&#9670;&nbsp;</a></span>setInputSource()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setInputSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a4e96ac4bc6a3d361d388bf58692f2ade">PointCloudSourceConstPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the input dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the const boost shared pointer to a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00159">159</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="registration_2include_2pcl_2registration_2registration_8h_source.html#l00485">pcl::Registration&lt; PointSource, PointTarget, float &gt;::getClassName()</a>, <a class="el" href="gicp_8h_source.html#l00416">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::input_covariances_</a>, <a class="el" href="icp_8h_source.html#l00199">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setInputSource()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="ad5401d81e34329703ea0cea21feeeea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5401d81e34329703ea0cea21feeeea0">&#9670;&nbsp;</a></span>setInputTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setInputTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#abeef6118852653929d4c40b364f40245">PointCloudTargetConstPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the input target (e.g., the point cloud that we want to align the input source to) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the input point cloud target </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00193">193</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="icp_8h_source.html#l00232">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setInputTarget()</a>, and <a class="el" href="gicp_8h_source.html#l00419">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::target_covariances_</a>.</p>

</div>
</div>
<a id="abd76704be34336bb0fe7b140159e2436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd76704be34336bb0fe7b140159e2436">&#9670;&nbsp;</a></span>setMaximumOptimizerIterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setMaximumOptimizerIterations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum number of iterations at the optimization step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>maximum number of iterations for the optimizer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00327">327</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00425">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::max_inner_iterations_</a>.</p>

</div>
</div>
<a id="aba43122aab57ea7b4980d0c7e607346e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba43122aab57ea7b4980d0c7e607346e">&#9670;&nbsp;</a></span>setNumberOfThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setNumberOfThreads </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nr_threads</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the scheduler and set the number of threads to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr_threads</td><td>the number of hardware threads to use (0 sets the value back to automatic) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8hpp_source.html#l00050">50</a> of file <a class="el" href="gicp_8hpp_source.html">gicp.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00137">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::GeneralizedIterativeClosestPoint()</a>.</p>

</div>
</div>
<a id="aa9edeeb9005cfbf29c4a3a800654c445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9edeeb9005cfbf29c4a3a800654c445">&#9670;&nbsp;</a></span>setRotationEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setRotationEpsilon </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the rotation epsilon (maximum allowable difference between two consecutive rotations) in order for an optimization to be considered as having converged to the final solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>the rotation epsilon </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00273">273</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00398">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::rotation_epsilon_</a>.</p>

</div>
</div>
<a id="aeb6c9c89ca7ec16b6af71935a236de11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6c9c89ca7ec16b6af71935a236de11">&#9670;&nbsp;</a></span>setRotationGradientTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setRotationGradientTolerance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the minimal rotation gradient threshold for early optimization stop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>rotation gradient threshold in radians </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00362">362</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00431">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::rotation_gradient_tolerance_</a>.</p>

</div>
</div>
<a id="a7d63a05331246ebe49cae693ae5c3c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d63a05331246ebe49cae693ae5c3c91">&#9670;&nbsp;</a></span>setSourceCovariances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setSourceCovariances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>covariances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the covariances of the input source (if computed externally!). </p>
<p>If not set, <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html" title="GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ...">GeneralizedIterativeClosestPoint</a> will compute the covariances itself. Make sure to set the covariances AFTER setting the input source point cloud (setting the input source point cloud will reset the covariances). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">covariances</td><td>the input source covariances </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00184">184</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00416">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::input_covariances_</a>.</p>

</div>
</div>
<a id="a6b92dc15e9f973a145e93707e1d81e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b92dc15e9f973a145e93707e1d81e49">&#9670;&nbsp;</a></span>setTargetCovariances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setTargetCovariances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>covariances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the covariances of the input target (if computed externally!). </p>
<p>If not set, <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html" title="GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ...">GeneralizedIterativeClosestPoint</a> will compute the covariances itself. Make sure to set the covariances AFTER setting the input source point cloud (setting the input source point cloud will reset the covariances). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">covariances</td><td>the input target covariances </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00207">207</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00419">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::target_covariances_</a>.</p>

</div>
</div>
<a id="a13eeb2e2d3ec9167a6d16ed1b71ef9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13eeb2e2d3ec9167a6d16ed1b71ef9cd">&#9670;&nbsp;</a></span>setTranslationGradientTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::setTranslationGradientTolerance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the minimal translation gradient threshold for early optimization stop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>translation gradient threshold in meters </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00344">344</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8h_source.html#l00428">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::translation_gradient_tolerance_</a>.</p>

</div>
</div>
<a id="a967836b6189c341c0a02f75e8557395a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967836b6189c341c0a02f75e8557395a">&#9670;&nbsp;</a></span>useBFGS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::useBFGS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <a class="el" href="class_b_f_g_s.html" title="BFGS stands for BroydenFletcherGoldfarbShanno (BFGS) method for solving unconstrained nonlinear op...">BFGS</a> optimizer instead of default Newton optimizer. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00311">311</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">References <a class="el" href="gicp_8hpp_source.html#l00297">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::estimateRigidTransformationBFGS()</a>, and <a class="el" href="gicp_8h_source.html#l00514">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::rigid_transformation_estimation_</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a399028e82ddfe0e5da5c35c68f386aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399028e82ddfe0e5da5c35c68f386aeb">&#9670;&nbsp;</a></span>base_transformation_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a> <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::base_transformation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>base transformation </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00401">401</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="aa61f1a99e5eff02f8c34e802ba741cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61f1a99e5eff02f8c34e802ba741cb4">&#9670;&nbsp;</a></span>gicp_epsilon_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::gicp_epsilon_ {0.001}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The epsilon constant for gicp paper; this is NOT the convergence tolerance default: 0.001. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00392">392</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a4960f89966c67be6b9043234c836b234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4960f89966c67be6b9043234c836b234">&#9670;&nbsp;</a></span>input_covariances_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a> <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::input_covariances_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input cloud points covariances. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00416">416</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00159">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setInputSource()</a>, and <a class="el" href="gicp_8h_source.html#l00184">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setSourceCovariances()</a>.</p>

</div>
</div>
<a id="aba36233f6a4f311bd42eabcf2a2142ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba36233f6a4f311bd42eabcf2a2142ec">&#9670;&nbsp;</a></span>k_correspondences_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::k_correspondences_ {20}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of neighbors used for covariances computation. </p>
<p>default: 20 </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00386">386</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00303">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::getCorrespondenceRandomness()</a>, and <a class="el" href="gicp_8h_source.html#l00294">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setCorrespondenceRandomness()</a>.</p>

</div>
</div>
<a id="abcf7b4f438b2c6680d90423a06ecdada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf7b4f438b2c6680d90423a06ecdada">&#9670;&nbsp;</a></span>mahalanobis_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Matrix3d&gt; <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::mahalanobis_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mahalanobis matrices holder. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00422">422</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00248">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::mahalanobis()</a>.</p>

</div>
</div>
<a id="aa5c0ea4932019a741cd8d051503f7fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c0ea4932019a741cd8d051503f7fc3">&#9670;&nbsp;</a></span>max_inner_iterations_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::max_inner_iterations_ {20}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maximum number of optimizations </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00425">425</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00335">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::getMaximumOptimizerIterations()</a>, and <a class="el" href="gicp_8h_source.html#l00327">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setMaximumOptimizerIterations()</a>.</p>

</div>
</div>
<a id="ae8ca1f40422565aba86684f8be454852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ca1f40422565aba86684f8be454852">&#9670;&nbsp;</a></span>rigid_transformation_estimation_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;PointSource&gt;&amp; cloud_src, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a>&amp; src_indices, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;PointTarget&gt;&amp; cloud_tgt, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a>&amp; tgt_indices, <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a29dd8bfa4175ce8821c74faacb28014c">Matrix4</a>&amp; transformation_matrix)&gt; <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::rigid_transformation_estimation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00514">514</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00137">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::GeneralizedIterativeClosestPoint()</a>, and <a class="el" href="gicp_8h_source.html#l00311">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::useBFGS()</a>.</p>

</div>
</div>
<a id="a0bea59ebf516fe6d85137444f6d21906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bea59ebf516fe6d85137444f6d21906">&#9670;&nbsp;</a></span>rotation_epsilon_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::rotation_epsilon_ {2e-3}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The epsilon constant for rotation error. </p>
<p>(In GICP the transformation epsilon is split in rotation part and translation part). default: 2e-3 </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00398">398</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00282">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::getRotationEpsilon()</a>, and <a class="el" href="gicp_8h_source.html#l00273">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setRotationEpsilon()</a>.</p>

</div>
</div>
<a id="ade0fc47ad1a34503b1fad9f3549cc206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0fc47ad1a34503b1fad9f3549cc206">&#9670;&nbsp;</a></span>rotation_gradient_tolerance_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::rotation_gradient_tolerance_ {1e-2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>minimal rotation gradient for early optimization stop </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00431">431</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00370">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::getRotationGradientTolerance()</a>, and <a class="el" href="gicp_8h_source.html#l00362">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setRotationGradientTolerance()</a>.</p>

</div>
</div>
<a id="ac75fb2f9a00f1f4323496322c751e100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75fb2f9a00f1f4323496322c751e100">&#9670;&nbsp;</a></span>target_covariances_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#adae981b1bdcb17f8aea09317a1d3228b">MatricesVectorPtr</a> <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::target_covariances_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target cloud points covariances. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00419">419</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00193">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setInputTarget()</a>, and <a class="el" href="gicp_8h_source.html#l00207">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setTargetCovariances()</a>.</p>

</div>
</div>
<a id="afbac149567cf4f69db548b7387a98c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbac149567cf4f69db548b7387a98c0e">&#9670;&nbsp;</a></span>tmp_idx_src_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a>* <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::tmp_idx_src_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary pointer to the source dataset indices. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00410">410</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a36e07dc0b2c7840ef4503fe19784646d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e07dc0b2c7840ef4503fe19784646d">&#9670;&nbsp;</a></span>tmp_idx_tgt_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a>* <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::tmp_idx_tgt_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary pointer to the target dataset indices. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00413">413</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="aa02315b62d78549b2a92e06268acf351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02315b62d78549b2a92e06268acf351">&#9670;&nbsp;</a></span>tmp_src_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a382e93a477bf6134d3f5b58a9c045fe4">PointCloudSource</a>* <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::tmp_src_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary pointer to the source dataset. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00404">404</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a444644d3974bc5fb9c0897ec1b6ea9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444644d3974bc5fb9c0897ec1b6ea9ea">&#9670;&nbsp;</a></span>tmp_tgt_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html#a36aa9d54eacdf78c6fd903000fb3f021">PointCloudTarget</a>* <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::tmp_tgt_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary pointer to the target dataset. </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00407">407</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

</div>
</div>
<a id="a3cb91bc51609e471178b0995b68af25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb91bc51609e471178b0995b68af25a">&#9670;&nbsp;</a></span>translation_gradient_tolerance_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointSource , typename PointTarget , typename Scalar  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint</a>&lt; PointSource, PointTarget, Scalar &gt;::translation_gradient_tolerance_ {1e-2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>minimal translation gradient for early optimization stop </p>

<p class="definition">Definition at line <a class="el" href="gicp_8h_source.html#l00428">428</a> of file <a class="el" href="gicp_8h_source.html">gicp.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="gicp_8h_source.html#l00353">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::getTranslationGradientTolerance()</a>, and <a class="el" href="gicp_8h_source.html#l00344">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::setTranslationGradientTolerance()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>pcl/registration/<a class="el" href="gicp_8h_source.html">gicp.h</a></li>
<li>pcl/registration/impl/<a class="el" href="gicp_8hpp_source.html">gicp.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Wed Oct 23 2024 10:17:19</p>
</div> <!-- #footer -->
</body>
</html>
