<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.14.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>File <a class="el" href="common_2include_2pcl_2common_2file__io_8h.html">file_io.h</a>  </dt>
<dd><a class="anchor" id="_todo000001"></a>move this to <a class="el" href="namespacepcl_1_1console.html">pcl::console</a>  </dd>
<dt>Namespace <a class="el" href="namespaceopenni__wrapper.html">openni_wrapper</a>  </dt>
<dd><a class="anchor" id="_todo000030"></a>Get rid of all exception-specifications, these are useless and soon to be deprecated  </dd>
<dt>Member <a class="el" href="group__filters.html#ga2fa1a673ddb4fce5d408141a0f7f10ec">pcl::assignNormalWeights</a>  (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud&lt; NormalT &gt;</a> &amp;cloud, index_t index, const Indices &amp;k_indices, const std::vector&lt; float &gt; &amp;k_sqr_distances)</dt>
<dd><a class="anchor" id="_todo000010"></a>Currently, this function equalizes all weights to 1  </dd>
<dt>Member <a class="el" href="namespacepcl.html#a8b1e6bf082a51cc2d633495a03a18a6a">pcl::createMapping</a>  (const std::vector&lt; pcl::PCLPointField &gt; &amp;msg_fields, MsgFieldMap &amp;field_map)</dt>
<dd><a class="anchor" id="_todo000002"></a>One could construct a pathological case where the struct has a field where the serialized data has padding  </dd>
<dt>Member <a class="el" href="classpcl_1_1cuda_1_1_sample_consensus_model.html#a5ac9119f5acff9ee8506df784a11f952">pcl::cuda::SampleConsensusModel&lt; Storage &gt;::setRadiusLimits</a>  (float min_radius, float max_radius)</dt>
<dd><a class="anchor" id="_todo000008"></a>change this to set limits on the entire model  </dd>
<dt>Member <a class="el" href="classpcl_1_1_euclidean_cluster_extraction.html#ad91d5929e06b257969c4747a65f98b7d">pcl::EuclideanClusterExtraction&lt; PointT &gt;::getSearchMethod</a>  () const</dt>
<dd><a class="anchor" id="_todo000038"></a>fix this for a generic search tree  </dd>
<dt>Class <a class="el" href="classpcl_1_1_farthest_point_sampling.html">pcl::FarthestPointSampling&lt; PointT &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000009"></a>add support to export/import distance metric  </dd>
<dt>Class <a class="el" href="classpcl_1_1geometry_1_1_mesh_base.html">pcl::geometry::MeshBase&lt; DerivedT, MeshTraitsT, MeshTagT &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000011"></a>Add documentation  </dd>
<dt>Class <a class="el" href="classpcl_1_1geometry_1_1_mesh_i_o.html">pcl::geometry::MeshIO&lt; MeshT &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000012"></a><ul>
<li>Only writes the topology (not the mesh data).</li>
<li>Supports only ascii.</li>
<li>Does not consider the mesh traits (e.g. manifold or not)  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classpcl_1_1gpu_1_1_euclidean_cluster_extraction.html#afac2bb37ade429a250919154da7c5258">pcl::gpu::EuclideanClusterExtraction&lt; PointT &gt;::getSearchMethod</a>  ()</dt>
<dd><a class="anchor" id="_todo000024"></a>fix this for a generic search tree  </dd>
<dt>Member <a class="el" href="classpcl_1_1gpu_1_1_euclidean_labeled_cluster_extraction.html#a55f5da27101dc036466ad8479a719524">pcl::gpu::EuclideanLabeledClusterExtraction&lt; PointT &gt;::extract</a>  (std::vector&lt; PointIndices &gt; &amp;clusters)</dt>
<dd><a class="anchor" id="_todo000028"></a>what do we do if input isn't a <a class="el" href="structpcl_1_1_point_x_y_z.html" title="A point structure representing Euclidean xyz coordinates.">PointXYZ</a> cloud?  </dd>
<dt>Member <a class="el" href="classpcl_1_1gpu_1_1_euclidean_labeled_cluster_extraction.html#a4639debabce4242c7dd0c9884ab1ac7a">pcl::gpu::EuclideanLabeledClusterExtraction&lt; PointT &gt;::getSearchMethod</a>  ()</dt>
<dd><a class="anchor" id="_todo000025"></a>fix this for a generic search tree  </dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu.html#aeba99c55253d47f8704805fe14cefa5c">pcl::gpu::extractEuclideanClusters</a>  (const typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">pcl::PointCloud&lt; PointT &gt;::Ptr</a> &amp;host_cloud_, const <a class="el" href="classpcl_1_1gpu_1_1_octree.html#a3b7148e7aae9577d3eceae143ecc55c9" title="Types.">pcl::gpu::Octree::Ptr</a> &amp;tree, float tolerance, std::vector&lt; PointIndices &gt; &amp;clusters, unsigned int min_pts_per_cluster, unsigned int max_pts_per_cluster)</dt>
<dd><a class="anchor" id="_todo000027"></a>: adjust this to a variable number settable with method  </dd>
<dt>Class <a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html">pcl::gpu::people::Blob2</a>  </dt>
<dd><a class="anchor" id="_todo000013"></a>: clean this out in the end, perhaps place the children in a separate struct  </dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people.html#ac834202c072b6dcbaaa3e25f884b17b9">pcl::gpu::people::buildRelations</a>  (std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a>, Eigen::aligned_allocator&lt; pcl::gpu::people::Blob2 &gt; &gt; &gt; &amp;sorted, <a class="el" href="classpcl_1_1gpu_1_1people_1_1_person_attribs.html#ab628b68403d958656aacd13f3bc476e1">PersonAttribs::Ptr</a> person_attribs)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000023"></a>This function also fixes the kinematic chain, we should implement this in a xml or LUT </p>
<p class="enddd">look if we can't get a more efficient implementation (iterator together with sortBlobs perhaps?)  </p>
</dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people.html#ac86f91ab867f99c80ed0c78fd79e64e3">pcl::gpu::people::buildRelations</a>  (std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a>, Eigen::aligned_allocator&lt; pcl::gpu::people::Blob2 &gt; &gt; &gt; &amp;sorted)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000022"></a>This function also fixes the kinematic chain, we should implement this in a xml or LUT </p>
<p class="enddd">look if we can't get a more efficient implementation (iterator together with sortBlobs perhaps?)  </p>
</dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people.html#a21553e59b91043b83a27f5eebf712468">pcl::gpu::people::evaluateBlobs</a>  (<a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a> &amp;parent, <a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a> &amp;child, int child_nr)</dt>
<dd><a class="anchor" id="_todo000018"></a>what if child is second link in stead of first link (ea forearm in stead of elbow for arm)  </dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people.html#a14bbfa2bc48db9afc008c8699ce5f791">pcl::gpu::people::evaluateBlobs</a>  (<a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a> &amp;parent, <a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a> &amp;child, int child_nr, <a class="el" href="classpcl_1_1gpu_1_1people_1_1_person_attribs.html#ab628b68403d958656aacd13f3bc476e1">PersonAttribs::Ptr</a> person_attribs)</dt>
<dd><a class="anchor" id="_todo000019"></a>what if child is second link in stead of first link (ea forearm in stead of elbow for arm)  </dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people.html#acbb1f800958fba47cb0788f6fe2accde">pcl::gpu::people::evaluateBlobVector</a>  (std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a>, Eigen::aligned_allocator&lt; Blob2 &gt; &gt; &gt; &amp;sorted, unsigned int parent_label, int child_label, int child_number, <a class="el" href="classpcl_1_1gpu_1_1people_1_1_person_attribs.html#ab628b68403d958656aacd13f3bc476e1">PersonAttribs::Ptr</a> person_attribs)</dt>
<dd><a class="anchor" id="_todo000021"></a>once we have good evaluation function reconsider best_value  </dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people.html#a43069436f611ff397727fe4f017fda88">pcl::gpu::people::evaluateBlobVector</a>  (std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a>, Eigen::aligned_allocator&lt; Blob2 &gt; &gt; &gt; &amp;sorted, unsigned int parent_label, int child_label, int child_number)</dt>
<dd><a class="anchor" id="_todo000020"></a>once we have good evaluation function reconsider best_value  </dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people_1_1label__skeleton.html#a9ecf799021d5b70538d7bf32019ade7d">pcl::gpu::people::label_skeleton::smoothLabelImage</a>  (cv::Mat &amp;lmap_in, cv::Mat &amp;dmap, cv::Mat &amp;lmap_out)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000016"></a>make the patch size a parameter </p>
<p class="interdd">make the z-distance a parameter </p>
<p class="enddd">add a Gaussian contribution function to depth and vote  </p>
</dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people_1_1label__skeleton.html#ae4842345989dd82a973890299b3defed">pcl::gpu::people::label_skeleton::sortIndicesToBlob2</a>  (const pcl::PointCloud&lt; pcl::PointXYZ &gt; &amp;cloud_in, unsigned int sizeThres, std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1gpu_1_1people_1_1_blob2.html" title="This structure contains all parameters to describe blobs and their parent/child relations.">Blob2</a>, Eigen::aligned_allocator&lt; Blob2 &gt; &gt; &gt; &amp;sorted, std::vector&lt; std::vector&lt; pcl::PointIndices &gt; &gt; &amp;indices)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000017"></a>implement the eigenvalue evaluation again </p>
<p class="enddd">do we still need sizeThres?  </p>
</dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people.html#a723741ae00a4d63617adf8a9645490c6">pcl::gpu::people::LUT_max_part_size</a>  []</dt>
<dd><a class="anchor" id="_todo000015"></a>read this from XML file  </dd>
<dt>Member <a class="el" href="namespacepcl_1_1gpu_1_1people.html#ab9fa744e63931f8f79d76a0b0bf2cba0">pcl::gpu::people::part_t</a>  </dt>
<dd><a class="anchor" id="_todo000014"></a>implement label 25 to 29  </dd>
<dt>Member <a class="el" href="classpcl_1_1gpu_1_1_seeded_hue_segmentation.html#a467d979d97a9a7423d9ba2b9bb2f0359">pcl::gpu::SeededHueSegmentation::getSearchMethod</a>  ()</dt>
<dd><a class="anchor" id="_todo000026"></a>fix this for a generic search tree  </dd>
<dt>Member <a class="el" href="classpcl_1_1gpu_1_1_seeded_hue_segmentation.html#ac0b560196fb4b7596f6a4753daace175">pcl::gpu::SeededHueSegmentation::segment</a>  (<a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_in, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_out)</dt>
<dd><a class="anchor" id="_todo000029"></a>what do we do if input isn't a <a class="el" href="structpcl_1_1_point_x_y_z.html" title="A point structure representing Euclidean xyz coordinates.">PointXYZ</a> cloud?  </dd>
<dt>Member <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">pcl::IndicesAllocator</a>  </dt>
<dd><a class="anchor" id="_todo000007"></a>Remove with C++20  </dd>
<dt>Member <a class="el" href="namespacepcl.html#a342daa7d979543dc66fb56be2b1e53fb">pcl::is_invocable_v</a>  </dt>
<dd><a class="anchor" id="_todo000005"></a>: Remove in C++17  </dd>
<dt>Member <a class="el" href="classpcl_1_1_iterative_closest_point.html#acdfae0f7386b8b1425f994ce42179405">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::IterativeClosestPoint</a>  (const <a class="el" href="classpcl_1_1_iterative_closest_point.html" title="IterativeClosestPoint provides a base implementation of the Iterative Closest Point algorithm.">IterativeClosestPoint</a> &amp;)=delete</dt>
<dd><a class="anchor" id="_todo000034"></a>: remove deleted ctors and assignments operations after resolving the issue  </dd>
<dt>Member <a class="el" href="namespacepcl.html#a73954cca0b970cb4aae7db33a568998a">pcl::PointXYZRGBAtoXYZHSV</a>  (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html" title="A point structure representing Euclidean xyz coordinates, and the RGBA color.">PointXYZRGBA</a> &amp;in, <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;out)</dt>
<dd><a class="anchor" id="_todo000004"></a>include the A parameter but how?  </dd>
<dt>Class <a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_features.html">pcl::registration::CorrespondenceRejectorFeatures</a>  </dt>
<dd><a class="anchor" id="_todo000033"></a>explain this better. </dd>
<dt>Member <a class="el" href="namespacepcl.html#a8b884eb9b34dae7fb0ffe8f85ea9fb18">pcl::remove_cvref_t</a>  </dt>
<dd><a class="anchor" id="_todo000006"></a>: Remove in C++17  </dd>
<dt>Member <a class="el" href="classpcl_1_1_sample_consensus_model.html#a3ed94271a12d7903c0bee9091e9a8f95">pcl::SampleConsensusModel&lt; PointT &gt;::setRadiusLimits</a>  (const double &amp;min_radius, const double &amp;max_radius)</dt>
<dd><a class="anchor" id="_todo000035"></a>change this to set limits on the entire model  </dd>
<dt>Member <a class="el" href="classpcl_1_1_sample_consensus_model_sphere.html#abb0a6e433fc874b6cba94964cdd91891">pcl::SampleConsensusModelSphere&lt; PointT &gt;::projectPoints</a>  (const Indices &amp;inliers, const Eigen::VectorXf &amp;model_coefficients, <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> &amp;projected_points, bool copy_data_fields=true) const override</dt>
<dd><a class="anchor" id="_todo000036"></a>implement this.  </dd>
<dt>Member <a class="el" href="classpcl_1_1search_1_1_organized_neighbor.html#a477438d0d657faa6b8162d26078e4d5f">pcl::search::OrganizedNeighbor&lt; PointT &gt;::nearestKSearch</a>  (const PointT &amp;p_q, int k, Indices &amp;k_indices, std::vector&lt; float &gt; &amp;k_sqr_distances) const override</dt>
<dd><a class="anchor" id="_todo000037"></a>still need to implements this functionality  </dd>
<dt>Member <a class="el" href="group__segmentation.html#gaf25653016cc78d6cf7adad3651b0d7ed">pcl::seededHueSegmentation</a>  (const PointCloud&lt; PointXYZRGB &gt; &amp;cloud, const <a class="el" href="classpcl_1_1search_1_1_search.html#ab4688e4899ce5aa6937dba334dc75763">search::Search&lt; PointXYZRGBL &gt;::Ptr</a> &amp;tree, float tolerance, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_in, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_out, float delta_hue=0.0)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000040"></a>look how to make this templated!</p>
<p class="enddd"></p>
</dd>
<dt>Member <a class="el" href="group__segmentation.html#ga5891c20fc0abc04063e117afaa8554d6">pcl::seededHueSegmentation</a>  (const PointCloud&lt; PointXYZRGB &gt; &amp;cloud, const <a class="el" href="classpcl_1_1search_1_1_search.html#ab4688e4899ce5aa6937dba334dc75763">search::Search&lt; PointXYZRGB &gt;::Ptr</a> &amp;tree, float tolerance, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_in, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_out, float delta_hue=0.0)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000039"></a>look how to make this templated!</p>
<p class="enddd"></p>
</dd>
<dt>Member <a class="el" href="classpcl_1_1_surface_normal_modality.html#a47eba682876ce6fae24aa4020f4649c7">pcl::SurfaceNormalModality&lt; PointInT &gt;::computeAndQuantizeSurfaceNormals2</a>  ()</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000031"></a>Should also need camera model, or at least focal lengths? Replace distance_threshold with mask? </p>
<p class="enddd"><a class="anchor" id="_todo000032"></a>Magic number 1150 is focal length? This is something like f in SXGA mode, but in VGA is more like 530.  </p>
</dd>
<dt>Member <a class="el" href="namespacepcl.html#a62c828dd99044427e7962d6c1b3df632">pcl::toPCLPointCloud2</a>  (const pcl::PointCloud&lt; PointT &gt; &amp;cloud, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;msg, bool padding)</dt>
<dd><a class="anchor" id="_todo000003"></a>msg.is_bigendian = ?;  </dd>
<dt>Member <a class="el" href="classpcl_1_1visualization_1_1_point_cloud_color_handler_h_s_v_field.html#a978fd8d90b9f7099c637822b81544420">pcl::visualization::PointCloudColorHandlerHSVField&lt; PointT &gt;::getColor</a>  () const override</dt>
<dd><a class="anchor" id="_todo000041"></a>do this with the point_types_conversion in common, first template it! </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Wed Oct 23 2024 10:17:06</p>
</div> <!-- #footer -->
</body>
</html>
