<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): Module registration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.11.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Module registration</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="secRegistrationPresentation"></a>
Overview</h1>
<p>Combining several datasets into a global consistent model is usually performed using a technique called registration. The key idea is to identify corresponding points between the data sets and find a transformation that minimizes the distance (alignment error) between corresponding points. This process is repeated, since correspondence search is affected by the relative position and orientation of the data sets. Once the alignment errors fall below a given threshold, the registration is said to be complete.</p>
<p>The <b>pcl_registration</b> library implements a plethora of point cloud registration algorithms for both organized an unorganized (general purpose) datasets.</p>
<div class="image">
<img src="http://www.pointclouds.org/assets/images/contents/documentation/registration_outdoor.png" alt=""/>
</div>
 <div class="image">
<img src="http://www.pointclouds.org/assets/images/contents/documentation/registration_closeup.png" alt=""/>
</div>
<h1><a class="anchor" id="secRegistrationRequirements"></a>
Requirements</h1>
<ul>
<li><a class="el" href="group__common.html">common</a></li>
<li><a class="el" href="group__kdtree.html">kdtree</a></li>
<li><a class="el" href="group__sample__consensus.html">sample_consensus</a></li>
<li><a class="el" href="group__features.html">features</a> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_convergence_criteria.html">pcl::registration::ConvergenceCriteria</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_convergence_criteria.html" title="ConvergenceCriteria represents an abstract base class for different convergence criteria used in regi...">ConvergenceCriteria</a></b> represents an abstract base class for different convergence criteria used in registration loops.  <a href="classpcl_1_1registration_1_1_convergence_criteria.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_base.html">pcl::registration::CorrespondenceEstimationBase&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract <b><a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_base.html" title="Abstract CorrespondenceEstimationBase class.">CorrespondenceEstimationBase</a></b> class.  <a href="classpcl_1_1registration_1_1_correspondence_estimation_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation.html">pcl::registration::CorrespondenceEstimation&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation.html" title="CorrespondenceEstimation represents the base class for determining correspondences between target and...">CorrespondenceEstimation</a></b> represents the base class for determining correspondences between target and query point sets/features.  <a href="classpcl_1_1registration_1_1_correspondence_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_back_projection.html">pcl::registration::CorrespondenceEstimationBackProjection&lt; PointSource, PointTarget, NormalT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CorrespondenceEstimationBackprojection</b> computes correspondences as points in the target cloud which have minimum  <a href="classpcl_1_1registration_1_1_correspondence_estimation_back_projection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_normal_shooting.html">pcl::registration::CorrespondenceEstimationNormalShooting&lt; PointSource, PointTarget, NormalT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_correspondence_estimation_normal_shooting.html" title="CorrespondenceEstimationNormalShooting computes correspondences as points in the target cloud which h...">CorrespondenceEstimationNormalShooting</a></b> computes correspondences as points in the target cloud which have minimum distance to normals computed on the input cloud  <a href="classpcl_1_1registration_1_1_correspondence_estimation_normal_shooting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector.html">pcl::registration::CorrespondenceRejector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector.html" title="CorrespondenceRejector represents the base class for correspondence rejection methods">CorrespondenceRejector</a></b> represents the base class for correspondence rejection methods  <a href="classpcl_1_1registration_1_1_correspondence_rejector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_data_container_interface.html">pcl::registration::DataContainerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_data_container_interface.html" title="DataContainerInterface provides a generic interface for computing correspondence scores between corre...">DataContainerInterface</a></b> provides a generic interface for computing correspondence scores between correspondent points in the input and target clouds  <a href="classpcl_1_1registration_1_1_data_container_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_data_container.html">pcl::registration::DataContainer&lt; PointT, NormalT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_data_container.html" title="DataContainer is a container for the input and target point clouds and implements the interface to co...">DataContainer</a></b> is a container for the input and target point clouds and implements the interface to compute correspondence scores between correspondent points in the input and target clouds  <a href="classpcl_1_1registration_1_1_data_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_distance.html">pcl::registration::CorrespondenceRejectorDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_distance.html" title="CorrespondenceRejectorDistance implements a simple correspondence rejection method based on threshold...">CorrespondenceRejectorDistance</a></b> implements a simple correspondence rejection method based on thresholding the distances between the correspondences.  <a href="classpcl_1_1registration_1_1_correspondence_rejector_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_features.html">pcl::registration::CorrespondenceRejectorFeatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_features.html" title="CorrespondenceRejectorFeatures implements a correspondence rejection method based on a set of feature...">CorrespondenceRejectorFeatures</a> implements a correspondence rejection method based on a set of feature descriptors.  <a href="classpcl_1_1registration_1_1_correspondence_rejector_features.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_median_distance.html">pcl::registration::CorrespondenceRejectorMedianDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_median_distance.html" title="CorrespondenceRejectorMedianDistance implements a simple correspondence rejection method based on thr...">CorrespondenceRejectorMedianDistance</a> implements a simple correspondence rejection method based on thresholding based on the median distance between the correspondences.  <a href="classpcl_1_1registration_1_1_correspondence_rejector_median_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_one_to_one.html">pcl::registration::CorrespondenceRejectorOneToOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_one_to_one.html" title="CorrespondenceRejectorOneToOne implements a correspondence rejection method based on eliminating dupl...">CorrespondenceRejectorOneToOne</a> implements a correspondence rejection method based on eliminating duplicate match indices in the correspondences.  <a href="classpcl_1_1registration_1_1_correspondence_rejector_one_to_one.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejection_organized_boundary.html">pcl::registration::CorrespondenceRejectionOrganizedBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpcl_1_1registration_1_1_correspondence_rejection_organized_boundary.html" title="The CorrespondenceRejectionOrganizedBoundary class implements a simple correspondence rejection measu...">CorrespondenceRejectionOrganizedBoundary</a> class implements a simple correspondence rejection measure.  <a href="classpcl_1_1registration_1_1_correspondence_rejection_organized_boundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_poly.html">pcl::registration::CorrespondenceRejectorPoly&lt; SourceT, TargetT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_poly.html" title="CorrespondenceRejectorPoly implements a correspondence rejection method that exploits low-level and p...">CorrespondenceRejectorPoly</a> implements a correspondence rejection method that exploits low-level and pose-invariant geometric constraints between two point sets by forming virtual polygons of a user-specifiable cardinality on each model using the input correspondences.  <a href="classpcl_1_1registration_1_1_correspondence_rejector_poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_sample_consensus.html">pcl::registration::CorrespondenceRejectorSampleConsensus&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_sample_consensus.html" title="CorrespondenceRejectorSampleConsensus implements a correspondence rejection using Random Sample Conse...">CorrespondenceRejectorSampleConsensus</a> implements a correspondence rejection using Random Sample Consensus to identify inliers (and reject outliers)  <a href="classpcl_1_1registration_1_1_correspondence_rejector_sample_consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_sample_consensus2_d.html">pcl::registration::CorrespondenceRejectorSampleConsensus2D&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_sample_consensus2_d.html" title="CorrespondenceRejectorSampleConsensus2D implements a pixel-based correspondence rejection using Rando...">CorrespondenceRejectorSampleConsensus2D</a> implements a pixel-based correspondence rejection using Random Sample Consensus to identify inliers (and reject outliers)  <a href="classpcl_1_1registration_1_1_correspondence_rejector_sample_consensus2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_surface_normal.html">pcl::registration::CorrespondenceRejectorSurfaceNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_surface_normal.html" title="CorrespondenceRejectorSurfaceNormal implements a simple correspondence rejection method based on the ...">CorrespondenceRejectorSurfaceNormal</a></b> implements a simple correspondence rejection method based on the angle between the normals at correspondent points.  <a href="classpcl_1_1registration_1_1_correspondence_rejector_surface_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_trimmed.html">pcl::registration::CorrespondenceRejectorTrimmed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_trimmed.html" title="CorrespondenceRejectorTrimmed implements a correspondence rejection for ICP-like registration algorit...">CorrespondenceRejectorTrimmed</a> implements a correspondence rejection for ICP-like registration algorithms that uses only the best 'k' correspondences where 'k' is some estimate of the overlap between the two point clouds being registered.  <a href="classpcl_1_1registration_1_1_correspondence_rejector_trimmed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_correspondence_rejector_var_trimmed.html">pcl::registration::CorrespondenceRejectorVarTrimmed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CorrespondenceRejectoVarTrimmed</b> implements a simple correspondence rejection method by considering as inliers a certain percentage of correspondences with the least distances.  <a href="classpcl_1_1registration_1_1_correspondence_rejector_var_trimmed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_query_index.html">pcl::registration::sortCorrespondencesByQueryIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_query_index.html" title="sortCorrespondencesByQueryIndex : a functor for sorting correspondences by query index">sortCorrespondencesByQueryIndex</a></b> : a functor for sorting correspondences by query index  <a href="structpcl_1_1registration_1_1sort_correspondences_by_query_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_match_index.html">pcl::registration::sortCorrespondencesByMatchIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_match_index.html" title="sortCorrespondencesByMatchIndex : a functor for sorting correspondences by match index">sortCorrespondencesByMatchIndex</a></b> : a functor for sorting correspondences by match index  <a href="structpcl_1_1registration_1_1sort_correspondences_by_match_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_distance.html">pcl::registration::sortCorrespondencesByDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_distance.html" title="sortCorrespondencesByDistance : a functor for sorting correspondences by distance">sortCorrespondencesByDistance</a></b> : a functor for sorting correspondences by distance  <a href="structpcl_1_1registration_1_1sort_correspondences_by_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_query_index_and_distance.html">pcl::registration::sortCorrespondencesByQueryIndexAndDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_query_index_and_distance.html" title="sortCorrespondencesByQueryIndexAndDistance : a functor for sorting correspondences by query index and...">sortCorrespondencesByQueryIndexAndDistance</a></b> : a functor for sorting correspondences by query index <em>and</em> distance  <a href="structpcl_1_1registration_1_1sort_correspondences_by_query_index_and_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_match_index_and_distance.html">pcl::registration::sortCorrespondencesByMatchIndexAndDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1sort_correspondences_by_match_index_and_distance.html" title="sortCorrespondencesByMatchIndexAndDistance : a functor for sorting correspondences by match index and...">sortCorrespondencesByMatchIndexAndDistance</a></b> : a functor for sorting correspondences by match index <em>and</em> distance  <a href="structpcl_1_1registration_1_1sort_correspondences_by_match_index_and_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_default_convergence_criteria.html">pcl::registration::DefaultConvergenceCriteria&lt; Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_default_convergence_criteria.html" title="DefaultConvergenceCriteria represents an instantiation of ConvergenceCriteria, and implements the fol...">DefaultConvergenceCriteria</a></b> represents an instantiation of <a class="el" href="classpcl_1_1registration_1_1_convergence_criteria.html" title="ConvergenceCriteria represents an abstract base class for different convergence criteria used in regi...">ConvergenceCriteria</a>, and implements the following criteria for registration loop evaluation:  <a href="classpcl_1_1registration_1_1_default_convergence_criteria.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1_null_measurement.html">pcl::registration::NullMeasurement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1_null_measurement.html" title="NullMeasurement struct">NullMeasurement</a></b> struct  <a href="structpcl_1_1registration_1_1_null_measurement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1_pose_measurement.html">pcl::registration::PoseMeasurement&lt; VertexT, InformationT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1_pose_measurement.html" title="PoseMeasurement struct">PoseMeasurement</a></b> struct  <a href="structpcl_1_1registration_1_1_pose_measurement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_e_l_c_h.html">pcl::registration::ELCH&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_e_l_c_h.html" title="ELCH (Explicit Loop Closing Heuristic) class">ELCH</a></b> (Explicit Loop Closing Heuristic) class  <a href="classpcl_1_1registration_1_1_e_l_c_h.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html" title="GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ...">GeneralizedIterativeClosestPoint</a> is an ICP variant that implements the generalized iterative closest point algorithm as described by Alex Segal et al.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_graph_handler.html">pcl::registration::GraphHandler&lt; GraphT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_graph_handler.html" title="GraphHandler class is a wrapper for a general SLAM graph The actual graph class must fulfill the foll...">GraphHandler</a></b> class is a wrapper for a general SLAM graph The actual graph class must fulfill the following boost::graph concepts:  <a href="classpcl_1_1registration_1_1_graph_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_graph_optimizer.html">pcl::registration::GraphOptimizer&lt; GraphT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_graph_optimizer.html" title="GraphOptimizer class; derive and specialize for each graph type">GraphOptimizer</a></b> class; derive and specialize for each graph type  <a href="classpcl_1_1registration_1_1_graph_optimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_graph_registration.html">pcl::GraphRegistration&lt; GraphT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_graph_registration.html" title="GraphRegistration class is the base class for graph-based registration methods">GraphRegistration</a></b> class is the base class for graph-based registration methods  <a href="classpcl_1_1_graph_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html" title="FPCSInitialAlignment computes corresponding four point congruent sets as described in: &quot;4-points cong...">FPCSInitialAlignment</a> computes corresponding four point congruent sets as described in: "4-points congruent sets for robust pairwise surface registration", Dror Aiger, Niloy Mitra, Daniel Cohen-Or.  <a href="classpcl_1_1registration_1_1_f_p_c_s_initial_alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_k_f_p_c_s_initial_alignment.html">pcl::registration::KFPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_k_f_p_c_s_initial_alignment.html" title="KFPCSInitialAlignment computes corresponding four point congruent sets based on keypoints as describe...">KFPCSInitialAlignment</a> computes corresponding four point congruent sets based on keypoints as described in: "Markerless point cloud registration with keypoint-based 4-points congruent sets", Pascal Theiler, Jan Dirk Wegner, Konrad Schindler.  <a href="classpcl_1_1registration_1_1_k_f_p_c_s_initial_alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_initial_alignment.html">pcl::SampleConsensusInitialAlignment&lt; PointSource, PointTarget, FeatureT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sample_consensus_initial_alignment.html" title="SampleConsensusInitialAlignment is an implementation of the initial alignment algorithm described in ...">SampleConsensusInitialAlignment</a></b> is an implementation of the initial alignment algorithm described in section IV of "Fast Point Feature Histograms (FPFH) for 3D Registration," Rusu et al.  <a href="classpcl_1_1_sample_consensus_initial_alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html">pcl::IterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_iterative_closest_point.html" title="IterativeClosestPoint provides a base implementation of the Iterative Closest Point algorithm.">IterativeClosestPoint</a></b> provides a base implementation of the Iterative Closest Point algorithm.  <a href="classpcl_1_1_iterative_closest_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point_with_normals.html">pcl::IterativeClosestPointWithNormals&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_iterative_closest_point_with_normals.html" title="IterativeClosestPointWithNormals is a special case of IterativeClosestPoint, that uses a transformati...">IterativeClosestPointWithNormals</a></b> is a special case of <a class="el" href="classpcl_1_1_iterative_closest_point.html" title="IterativeClosestPoint provides a base implementation of the Iterative Closest Point algorithm.">IterativeClosestPoint</a>, that uses a transformation estimated based on Point to Plane distances by default.  <a href="classpcl_1_1_iterative_closest_point_with_normals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point_non_linear.html">pcl::IterativeClosestPointNonLinear&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_iterative_closest_point_non_linear.html" title="IterativeClosestPointNonLinear is an ICP variant that uses Levenberg-Marquardt optimization backend.">IterativeClosestPointNonLinear</a></b> is an ICP variant that uses Levenberg-Marquardt optimization backend.  <a href="classpcl_1_1_iterative_closest_point_non_linear.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_incremental_registration.html">pcl::registration::IncrementalRegistration&lt; PointT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incremental <a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a> class.  <a href="classpcl_1_1registration_1_1_incremental_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_joint_iterative_closest_point.html">pcl::JointIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_joint_iterative_closest_point.html" title="JointIterativeClosestPoint extends ICP to multiple frames which share the same transform.">JointIterativeClosestPoint</a></b> extends ICP to multiple frames which share the same transform.  <a href="classpcl_1_1_joint_iterative_closest_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_l_u_m.html">pcl::registration::LUM&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally Consistent Scan Matching based on an algorithm by Lu and Milios.  <a href="classpcl_1_1registration_1_1_l_u_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_meta_registration.html">pcl::registration::MetaRegistration&lt; PointT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta <a class="el" href="classpcl_1_1_registration.html">Registration</a> class.  <a href="classpcl_1_1registration_1_1_meta_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_pairwise_graph_registration.html">pcl::PairwiseGraphRegistration&lt; GraphT, PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_pairwise_graph_registration.html" title="PairwiseGraphRegistration class aligns the clouds two by two">PairwiseGraphRegistration</a></b> class aligns the clouds two by two  <a href="classpcl_1_1_pairwise_graph_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html">pcl::Registration&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_registration.html" title="Registration represents the base registration class for general purpose, ICP-like methods.">Registration</a></b> represents the base registration class for general purpose, ICP-like methods.  <a href="classpcl_1_1_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_prerejective.html">pcl::SampleConsensusPrerejective&lt; PointSource, PointTarget, FeatureT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose estimation and alignment class using a prerejective RANSAC routine.  <a href="classpcl_1_1_sample_consensus_prerejective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation.html">pcl::registration::TransformationEstimation&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation.html" title="TransformationEstimation represents the base class for methods for transformation estimation based on...">TransformationEstimation</a> represents the base class for methods for transformation estimation based on:  <a href="classpcl_1_1registration_1_1_transformation_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation2_d.html">pcl::registration::TransformationEstimation2D&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation2_d.html" title="TransformationEstimation2D implements a simple 2D rigid transformation estimation (x,...">TransformationEstimation2D</a></b> implements a simple 2D rigid transformation estimation (x, y, theta) for a given pair of datasets.  <a href="classpcl_1_1registration_1_1_transformation_estimation2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation3_point.html">pcl::registration::TransformationEstimation3Point&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TransformationEstimation3Points represents the class for transformation estimation based on:  <a href="classpcl_1_1registration_1_1_transformation_estimation3_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_d_q.html">pcl::registration::TransformationEstimationDQ&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_d_q.html" title="TransformationEstimationDQ implements dual quaternion based estimation of the transformation aligning...">TransformationEstimationDQ</a></b> implements dual quaternion based estimation of the transformation aligning the given correspondences.  <a href="classpcl_1_1registration_1_1_transformation_estimation_d_q.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_dual_quaternion.html">pcl::registration::TransformationEstimationDualQuaternion&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_dual_quaternion.html" title="TransformationEstimationDualQuaternion implements dual quaternion based estimation of the transformat...">TransformationEstimationDualQuaternion</a></b> implements dual quaternion based estimation of the transformation aligning the given correspondences.  <a href="classpcl_1_1registration_1_1_transformation_estimation_dual_quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_l_m.html">pcl::registration::TransformationEstimationLM&lt; PointSource, PointTarget, MatScalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_l_m.html" title="TransformationEstimationLM implements Levenberg Marquardt-based estimation of the transformation alig...">TransformationEstimationLM</a></b> implements Levenberg Marquardt-based estimation of the transformation aligning the given correspondences.  <a href="classpcl_1_1registration_1_1_transformation_estimation_l_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane.html">pcl::registration::TransformationEstimationPointToPlane&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane.html" title="TransformationEstimationPointToPlane uses Levenberg Marquardt optimization to find the transformation...">TransformationEstimationPointToPlane</a></b> uses Levenberg Marquardt optimization to find the transformation that minimizes the point-to-plane distance between the given correspondences.  <a href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_l_l_s.html">pcl::registration::TransformationEstimationPointToPlaneLLS&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_l_l_s.html" title="TransformationEstimationPointToPlaneLLS implements a Linear Least Squares (LLS) approximation for min...">TransformationEstimationPointToPlaneLLS</a></b> implements a Linear Least Squares (LLS) approximation for minimizing the point-to-plane distance between two clouds of corresponding points with normals.  <a href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_l_l_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_l_l_s_weighted.html">pcl::registration::TransformationEstimationPointToPlaneLLSWeighted&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_l_l_s_weighted.html" title="TransformationEstimationPointToPlaneLLSWeighted implements a Linear Least Squares (LLS) approximation...">TransformationEstimationPointToPlaneLLSWeighted</a></b> implements a Linear Least Squares (LLS) approximation for minimizing the point-to-plane distance between two clouds of corresponding points with normals, with the possibility of assigning weights to the correspondences.  <a href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_l_l_s_weighted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_weighted.html">pcl::registration::TransformationEstimationPointToPlaneWeighted&lt; PointSource, PointTarget, MatScalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_weighted.html" title="TransformationEstimationPointToPlaneWeighted uses Levenberg Marquardt optimization to find the transf...">TransformationEstimationPointToPlaneWeighted</a></b> uses Levenberg Marquardt optimization to find the transformation that minimizes the point-to-plane distance between the given correspondences.  <a href="classpcl_1_1registration_1_1_transformation_estimation_point_to_plane_weighted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_s_v_d.html">pcl::registration::TransformationEstimationSVD&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_s_v_d.html" title="TransformationEstimationSVD implements SVD-based estimation of the transformation aligning the given ...">TransformationEstimationSVD</a></b> implements SVD-based estimation of the transformation aligning the given correspondences.  <a href="classpcl_1_1registration_1_1_transformation_estimation_s_v_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_s_v_d_scale.html">pcl::registration::TransformationEstimationSVDScale&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_s_v_d.html" title="TransformationEstimationSVD implements SVD-based estimation of the transformation aligning the given ...">TransformationEstimationSVD</a></b> implements SVD-based estimation of the transformation aligning the given correspondences.  <a href="classpcl_1_1registration_1_1_transformation_estimation_s_v_d_scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_symmetric_point_to_plane_l_l_s.html">pcl::registration::TransformationEstimationSymmetricPointToPlaneLLS&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_transformation_estimation_symmetric_point_to_plane_l_l_s.html" title="TransformationEstimationSymmetricPointToPlaneLLS implements a Linear Least Squares (LLS) approximatio...">TransformationEstimationSymmetricPointToPlaneLLS</a></b> implements a Linear Least Squares (LLS) approximation for minimizing the symmetric point-to-plane distance between two clouds of corresponding points with normals.  <a href="classpcl_1_1registration_1_1_transformation_estimation_symmetric_point_to_plane_l_l_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_validation.html">pcl::registration::TransformationValidation&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_transformation_validation.html" title="TransformationValidation represents the base class for methods that validate the correctness of a tra...">TransformationValidation</a> represents the base class for methods that validate the correctness of a transformation found through <a class="el" href="classpcl_1_1registration_1_1_transformation_estimation.html">TransformationEstimation</a>.  <a href="classpcl_1_1registration_1_1_transformation_validation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_transformation_validation_euclidean.html">pcl::registration::TransformationValidationEuclidean&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1registration_1_1_transformation_validation_euclidean.html" title="TransformationValidationEuclidean computes an L2SQR norm between a source and target dataset.">TransformationValidationEuclidean</a> computes an L2SQR norm between a source and target dataset.  <a href="classpcl_1_1registration_1_1_transformation_validation_euclidean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1_null_estimate.html">pcl::registration::NullEstimate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1_null_estimate.html" title="NullEstimate struct">NullEstimate</a></b> struct  <a href="structpcl_1_1registration_1_1_null_estimate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1registration_1_1_pose_estimate.html">pcl::registration::PoseEstimate&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="structpcl_1_1registration_1_1_pose_estimate.html" title="PoseEstimate struct">PoseEstimate</a></b> struct  <a href="structpcl_1_1registration_1_1_pose_estimate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_warp_point_rigid.html">pcl::registration::WarpPointRigid&lt; PointSourceT, PointTargetT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base warp point class.  <a href="classpcl_1_1registration_1_1_warp_point_rigid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_warp_point_rigid3_d.html">pcl::registration::WarpPointRigid3D&lt; PointSourceT, PointTargetT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_warp_point_rigid3_d.html" title="WarpPointRigid3D enables 3D (1D rotation + 2D translation) transformations for points.">WarpPointRigid3D</a></b> enables 3D (1D rotation + 2D translation) transformations for points.  <a href="classpcl_1_1registration_1_1_warp_point_rigid3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1registration_1_1_warp_point_rigid6_d.html">pcl::registration::WarpPointRigid6D&lt; PointSourceT, PointTargetT, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1registration_1_1_warp_point_rigid3_d.html" title="WarpPointRigid3D enables 3D (1D rotation + 2D translation) transformations for points.">WarpPointRigid3D</a></b> enables 6D (3D rotation + 3D translation) transformations for points.  <a href="classpcl_1_1registration_1_1_warp_point_rigid6_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga846fa69df3418046ae2ea54887ea092e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__registration.html#ga846fa69df3418046ae2ea54887ea092e">POINT_CLOUD_REGISTER_POINT_STRUCT</a> (<a class="el" href="structpcl_1_1___point_x_y_z_l_a_b.html">pcl::_PointXYZLAB</a>,(float, x, x)(float, y, y)(float, z, z)(float, L, L)(float, a, a)(float, b, b)) namespace pcl</td></tr>
<tr class="separator:ga846fa69df3418046ae2ea54887ea092e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga846fa69df3418046ae2ea54887ea092e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga846fa69df3418046ae2ea54887ea092e">&#9670;&nbsp;</a></span>POINT_CLOUD_REGISTER_POINT_STRUCT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POINT_CLOUD_REGISTER_POINT_STRUCT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcl_1_1___point_x_y_z_l_a_b.html">pcl::_PointXYZLAB</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(float, x, x)(float, y, y)(float, z, z)(float, L, L)(float, a, a)(float, b, b)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/registration/gicp6d.h&gt;</code></p>
<p>GeneralizedIterativeClosestPoint6D integrates L*a*b* color space information into the Generalized Iterative Closest Point (GICP) algorithm.</p>
<p>The suggested input is PointXYZRGBA.</p>
<dl class="section note"><dt>Note</dt><dd>If you use this code in any academic work, please cite:</dd></dl>
<ul>
<li>M. Korn, M. Holzkothen, J. Pauli Color Supported Generalized-ICP. In Proceedings of VISAPP 2014 - International Conference on Computer Vision Theory and Applications, Lisbon, Portugal, January 2014.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Martin Holzkothen, Michael Korn</dd></dl>
<p>constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lab_weight</td><td>the color weight</td></tr>
  </table>
  </dd>
</dl>
<p>Provide a pointer to the input source (e.g., the point cloud that we want to align to the target)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud source</td></tr>
  </table>
  </dd>
</dl>
<p>Provide a pointer to the input target (e.g., the point cloud that we want to align the input source to)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud target</td></tr>
  </table>
  </dd>
</dl>
<p>Rigid transformation computation method with initial guess. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the transformed input point cloud dataset using the rigid transformation found </td></tr>
    <tr><td class="paramname">guess</td><td>the initial guess of the transformation to compute</td></tr>
  </table>
  </dd>
</dl>
<p>Search for the closest nearest neighbor of a given point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the point to search a nearest neighbour for </td></tr>
    <tr><td class="paramname">index</td><td>vector of size 1 to store the index of the nearest neighbour found </td></tr>
    <tr><td class="paramname">distance</td><td>vector of size 1 to store the distance to nearest neighbour found</td></tr>
  </table>
  </dd>
</dl>
<p>Holds the converted (LAB) data cloud.</p>
<p>Holds the converted (LAB) model cloud.</p>
<p>6d-tree to search in model cloud.</p>
<p>The color weight.</p>
<p>Custom point representation to perform kdtree searches in more than 3 (i.e. in all 6) dimensions.</p>
<p>Enables 6d searches with kd-tree class using the color weight.</p>

<p class="definition">Definition at line <a class="el" href="gicp6d_8h_source.html#l00079">79</a> of file <a class="el" href="gicp6d_8h_source.html">gicp6d.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>, <a class="el" href="point__representation_8h_source.html#l00063">pcl::PointRepresentation&lt; PointT &gt;::nr_dimensions_</a>, <a class="el" href="pcl__macros_8h_source.html#l00331">PCL_EXPORTS</a>, and <a class="el" href="point__representation_8h_source.html#l00075">pcl::PointRepresentation&lt; PointT &gt;::trivial_</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Tue Jun 2 2020 14:11:04</p>
</div> <!-- #footer -->
</body>
</html>
