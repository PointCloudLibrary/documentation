<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): pcl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.11.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pcl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepcl_1_1common"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1common.html">common</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1_comparison_ops"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1_comparison_ops.html">ComparisonOps</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1console"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1console.html">console</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1deprecated"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1deprecated.html">deprecated</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1device"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1distances"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1distances.html">distances</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1face__detection"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1face__detection.html">face_detection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1features"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1features.html">features</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1fields"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1fields.html">fields</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1filters"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1filters.html">filters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1geometry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1geometry.html">geometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1gpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1gpu.html">gpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1io.html">io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1ism"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1ism.html">ism</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1keypoints"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1keypoints.html">keypoints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1kinfu_l_s"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1kinfu_l_s.html">kinfuLS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1ndt2d"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1ndt2d.html">ndt2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1occlusion__reasoning"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1occlusion__reasoning.html">occlusion_reasoning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1octree"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1octree.html">octree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1outofcore"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1outofcore.html">outofcore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1people"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1people.html">people</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1poisson"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1poisson.html">poisson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1recognition"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1recognition.html">recognition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1registration"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1registration.html">registration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1search"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1search.html">search</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1segmentation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1segmentation.html">segmentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1surface"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1surface.html">surface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1test.html">test</a></td></tr>
<tr class="memdesc:namespacepcl_1_1test"><td class="mdescLeft">&#160;</td><td class="mdescRight">test_macros.h provide helper macros for testing vectors, matrices etc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1texture__mapping"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1texture__mapping.html">texture_mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1tracking"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1tracking.html">tracking</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1traits.html">traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1utils.html">utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepcl_1_1visualization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl_1_1visualization.html">visualization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___axis.html">_Axis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___intensity.html">_Intensity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___intensity32u.html">_Intensity32u</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___intensity8u.html">_Intensity8u</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___normal.html">_Normal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_d_e_m.html">_PointDEM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_normal.html">_PointNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_surfel.html">_PointSurfel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_with_range.html">_PointWithRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_with_scale.html">_PointWithScale</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_with_viewpoint.html">_PointWithViewpoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z.html">_PointXYZ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_h_s_v.html">_PointXYZHSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_i.html">_PointXYZI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the intensity value.  <a href="structpcl_1_1___point_x_y_z_i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_i_normal.html">_PointXYZINormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_l.html">_PointXYZL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_l_a_b.html">_PointXYZLAB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_l_normal.html">_PointXYZLNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_r_g_b.html">_PointXYZRGB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_r_g_b_a.html">_PointXYZRGBA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_r_g_b_l.html">_PointXYZRGBL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_r_g_b_normal.html">_PointXYZRGBNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___reference_frame.html">_ReferenceFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing the Local Reference Frame of a point.  <a href="structpcl_1_1___reference_frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___r_g_b.html">_RGB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_adaptive_cost_s_o_stereo_matching.html">AdaptiveCostSOStereoMatching</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Cost 2-pass Scanline Optimization Stereo Matching class.  <a href="classpcl_1_1_adaptive_cost_s_o_stereo_matching.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_adaptive_range_coder.html">AdaptiveRangeCoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_adaptive_range_coder.html" title="AdaptiveRangeCoder compression class">AdaptiveRangeCoder</a></b> compression class  <a href="classpcl_1_1_adaptive_range_coder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_agast_keypoint2_d.html">AgastKeypoint2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects 2D AGAST corner points.  <a href="classpcl_1_1_agast_keypoint2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_agast_keypoint2_d_3_01pcl_1_1_point_x_y_z_00_01pcl_1_1_point_u_v_01_4.html">AgastKeypoint2D&lt; pcl::PointXYZ, pcl::PointUV &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects 2D AGAST corner points.  <a href="classpcl_1_1_agast_keypoint2_d_3_01pcl_1_1_point_x_y_z_00_01pcl_1_1_point_u_v_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_agast_keypoint2_d_base.html">AgastKeypoint2DBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects 2D AGAST corner points.  <a href="classpcl_1_1_agast_keypoint2_d_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_approximate_progressive_morphological_filter.html">ApproximateProgressiveMorphologicalFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Progressive Morphological <a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class.">Filter</a> for segmentation of ground points.  <a href="classpcl_1_1_approximate_progressive_morphological_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_approximate_voxel_grid.html">ApproximateVoxelGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_approximate_voxel_grid.html" title="ApproximateVoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the...">ApproximateVoxelGrid</a> assembles a local 3D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a>, and downsamples + filters the data.  <a href="classpcl_1_1_approximate_voxel_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_a_s_c_i_i_reader.html">ASCIIReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ascii Point Cloud Reader.  <a href="classpcl_1_1_a_s_c_i_i_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_axis.html">Axis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing an <a class="el" href="structpcl_1_1_axis.html" title="A point structure representing an Axis using its normal coordinates.">Axis</a> using its normal coordinates.  <a href="structpcl_1_1_axis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_bad_argument_exception.html">BadArgumentException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown when the arguments number or type is wrong/unhandled.  <a href="classpcl_1_1_bad_argument_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_bearing_angle_image.html">BearingAngleImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class <a class="el" href="classpcl_1_1_bearing_angle_image.html" title="class BearingAngleImage is used as an interface to generate Bearing Angle(BA) image.">BearingAngleImage</a> is used as an interface to generate Bearing Angle(BA) image.  <a href="classpcl_1_1_bearing_angle_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_bilateral_filter.html">BilateralFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bilateral filter implementation for point cloud data.  <a href="classpcl_1_1_bilateral_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_bilateral_upsampling.html">BilateralUpsampling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bilateral filtering implementation, based on the following paper:  <a href="classpcl_1_1_bilateral_upsampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_binary_tree_threshold_based_branch_estimator.html">BinaryTreeThresholdBasedBranchEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branch estimator for binary trees where the branch is computed only from the threshold.  <a href="classpcl_1_1_binary_tree_threshold_based_branch_estimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_bivariate_polynomial_t.html">BivariatePolynomialT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a bivariate polynomial and provides some functionality for it.  <a href="classpcl_1_1_bivariate_polynomial_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_block_based_stereo_matching.html">BlockBasedStereoMatching</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block based (or fixed window) Stereo Matching class.  <a href="classpcl_1_1_block_based_stereo_matching.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_b_o_a_r_d_local_reference_frame_estimation.html">BOARDLocalReferenceFrameEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_b_o_a_r_d_local_reference_frame_estimation.html" title="BOARDLocalReferenceFrameEstimation implements the BOrder Aware Repeatable Directions algorithm for lo...">BOARDLocalReferenceFrameEstimation</a> implements the BOrder Aware Repeatable Directions algorithm for local reference frame estimation as described here:  <a href="classpcl_1_1_b_o_a_r_d_local_reference_frame_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_border_description.html">BorderDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to store if a point in a range image lies on a border between an obstacle and the background.  <a href="structpcl_1_1_border_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_boundary.html">Boundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing a description of whether a point is lying on a surface boundary or not.  <a href="structpcl_1_1_boundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_boundary_estimation.html">BoundaryEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_boundary_estimation.html" title="BoundaryEstimation estimates whether a set of points is lying on surface boundaries using an angle cr...">BoundaryEstimation</a> estimates whether a set of points is lying on surface boundaries using an angle criterion.  <a href="classpcl_1_1_boundary_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_bounding_box_x_y_z.html">BoundingBoxXYZ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_box_clipper3_d.html">BoxClipper3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a box clipper in 3D. Actually it allows affine transformations, thus any parallelepiped in general pose. The affine transformation is used to transform the point before clipping it using the unit cube centered at origin and with an extend of -1 to +1 in each dimension.  <a href="classpcl_1_1_box_clipper3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_branch_estimator.html">BranchEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for branch estimators.  <a href="classpcl_1_1_branch_estimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_b_r_i_s_k2_d_estimation.html">BRISK2DEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the BRISK-descriptor, based on the original code and paper reference by.  <a href="classpcl_1_1_b_r_i_s_k2_d_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_brisk_keypoint2_d.html">BriskKeypoint2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects BRISK interest points based on the original code and paper reference by.  <a href="classpcl_1_1_brisk_keypoint2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_b_r_i_s_k_signature512.html">BRISKSignature512</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Binary Robust Invariant Scalable Keypoints (BRISK).  <a href="structpcl_1_1_b_r_i_s_k_signature512.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_centroid_point.html">CentroidPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic class that computes the centroid of points fed to it.  <a href="classpcl_1_1_centroid_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_clipper3_d.html">Clipper3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for 3D clipper objects.  <a href="classpcl_1_1_clipper3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_cloud_iterator.html">CloudIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for point clouds with or without given indices.  <a href="classpcl_1_1_cloud_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_cloud_surface_processing.html">CloudSurfaceProcessing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_cloud_surface_processing.html" title="CloudSurfaceProcessing represents the base class for algorithms that takes a point cloud as input and...">CloudSurfaceProcessing</a></b> represents the base class for algorithms that takes a point cloud as input and produces a new output cloud that has been modified towards a better surface representation.  <a href="classpcl_1_1_cloud_surface_processing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_color_gradient_d_o_t_modality.html">ColorGradientDOTModality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_color_gradient_modality.html">ColorGradientModality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modality based on max-RGB gradients.  <a href="classpcl_1_1_color_gradient_modality.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_color_l_u_t.html">ColorLUT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_color_modality.html">ColorModality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_comparator.html">Comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> is the base class for comparators that compare two points given some function.  <a href="classpcl_1_1_comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_comparison_base.html">ComparisonBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (abstract) base class for the comparison object.  <a href="classpcl_1_1_comparison_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_compute_failed_exception.html">ComputeFailedException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_concave_hull.html">ConcaveHull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_concave_hull.html" title="ConcaveHull (alpha shapes) using libqhull library.">ConcaveHull</a></b> (alpha shapes) using libqhull library.  <a href="classpcl_1_1_concave_hull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_conditional_euclidean_clustering.html">ConditionalEuclideanClustering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_conditional_euclidean_clustering.html" title="ConditionalEuclideanClustering performs segmentation based on Euclidean distance and a user-defined c...">ConditionalEuclideanClustering</a></b> performs segmentation based on Euclidean distance and a user-defined clustering condition.  <a href="classpcl_1_1_conditional_euclidean_clustering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_conditional_removal.html">ConditionalRemoval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_conditional_removal.html" title="ConditionalRemoval filters data that satisfies certain conditions.">ConditionalRemoval</a></b> filters data that satisfies certain conditions.  <a href="classpcl_1_1_conditional_removal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_condition_and.html">ConditionAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND condition.  <a href="classpcl_1_1_condition_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_condition_base.html">ConditionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base condition class.  <a href="classpcl_1_1_condition_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_condition_or.html">ConditionOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR condition.  <a href="classpcl_1_1_condition_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for point clouds with or without given indices.  <a href="classpcl_1_1_const_cloud_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_convex_hull.html">ConvexHull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_convex_hull.html" title="ConvexHull using libqhull library.">ConvexHull</a></b> using libqhull library.  <a href="classpcl_1_1_convex_hull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_convolution.html">Convolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D convolution class.  <a href="classpcl_1_1_convolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_copy_if_field_exists.html">CopyIfFieldExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper functor that can copy a specific value if the given field exists.  <a href="structpcl_1_1_copy_if_field_exists.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpcl_1_1_correspondence.html" title="Correspondence represents a match between two entities (e.g., points, descriptors,...">Correspondence</a> represents a match between two entities (e.g., points, descriptors, etc).  <a href="structpcl_1_1_correspondence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_correspondence_grouping.html">CorrespondenceGrouping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for <a class="el" href="structpcl_1_1_correspondence.html" title="Correspondence represents a match between two entities (e.g., points, descriptors,...">Correspondence</a> Grouping algorithms.  <a href="classpcl_1_1_correspondence_grouping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_covariance_sampling.html">CovarianceSampling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud sampling based on the 6D covariances.  <a href="classpcl_1_1_covariance_sampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_p_c_segmentation.html">CPCSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A segmentation algorithm partitioning a supervoxel graph.  <a href="classpcl_1_1_c_p_c_segmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_p_p_f_estimation.html">CPPFEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that calculates the "surflet" features for each pair in the given pointcloud.  <a href="classpcl_1_1_c_p_p_f_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_c_p_p_f_signature.html">CPPFSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure for storing the Point Pair <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> (CPPF) values.  <a href="structpcl_1_1_c_p_p_f_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_crf_normal_segmentation.html">CrfNormalSegmentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_crf_segmentation.html">CrfSegmentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_r_h_alignment.html">CRHAlignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_c_r_h_alignment.html" title="CRHAlignment uses two Camera Roll Histograms (CRH) to find the roll rotation that aligns both views.">CRHAlignment</a> uses two <a class="el" href="class_camera.html">Camera</a> Roll Histograms (CRH) to find the roll rotation that aligns both views.  <a href="classpcl_1_1_c_r_h_alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_r_h_estimation.html">CRHEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_c_r_h_estimation.html" title="CRHEstimation estimates the Camera Roll Histogram (CRH) descriptor for a given point cloud dataset co...">CRHEstimation</a> estimates the <a class="el" href="class_camera.html">Camera</a> Roll <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (CRH) descriptor for a given point cloud dataset containing XYZ data and normals, as presented in:  <a href="classpcl_1_1_c_r_h_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_crop_box.html">CropBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_crop_box.html" title="CropBox is a filter that allows the user to filter all the data inside of a given box.">CropBox</a> is a filter that allows the user to filter all the data inside of a given box.  <a href="classpcl_1_1_crop_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_crop_box_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">CropBox&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_crop_box.html" title="CropBox is a filter that allows the user to filter all the data inside of a given box.">CropBox</a> is a filter that allows the user to filter all the data inside of a given box.  <a href="classpcl_1_1_crop_box_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_crop_hull.html">CropHull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class.">Filter</a> points that lie inside or outside a 3D closed surface or 2D closed polygon, as generated by the <a class="el" href="classpcl_1_1_convex_hull.html" title="ConvexHull using libqhull library.">ConvexHull</a> or <a class="el" href="classpcl_1_1_concave_hull.html" title="ConcaveHull (alpha shapes) using libqhull library.">ConcaveHull</a> classes.  <a href="classpcl_1_1_crop_hull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_custom_point_representation.html">CustomPointRepresentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_custom_point_representation.html" title="CustomPointRepresentation extends PointRepresentation to allow for sub-part selection on the point.">CustomPointRepresentation</a></b> extends <a class="el" href="classpcl_1_1_point_representation.html" title="PointRepresentation provides a set of methods for converting a point structs/object into an n-dimensi...">PointRepresentation</a> to allow for sub-part selection on the point.  <a href="classpcl_1_1_custom_point_representation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_v_f_h_estimation.html">CVFHEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_c_v_f_h_estimation.html" title="CVFHEstimation estimates the Clustered Viewpoint Feature Histogram (CVFH) descriptor for a given poin...">CVFHEstimation</a> estimates the Clustered Viewpoint <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (CVFH) descriptor for a given point cloud dataset containing XYZ data and normals, as presented in:  <a href="classpcl_1_1_c_v_f_h_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_david_s_d_k_grabber.html">DavidSDKGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for davidSDK structured light compliant devices.  <a href="classpcl_1_1_david_s_d_k_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_decision_forest.html">DecisionForest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a decision forest.  <a href="classpcl_1_1_decision_forest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_decision_forest_evaluator.html">DecisionForestEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for evaluating a decision forests.  <a href="classpcl_1_1_decision_forest_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_decision_forest_trainer.html">DecisionForestTrainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trainer for decision trees.  <a href="classpcl_1_1_decision_forest_trainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_decision_tree.html">DecisionTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a decision tree.  <a href="classpcl_1_1_decision_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_decision_tree_evaluator.html">DecisionTreeEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for evaluating a decision tree.  <a href="classpcl_1_1_decision_tree_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_decision_tree_trainer.html">DecisionTreeTrainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trainer for decision trees.  <a href="classpcl_1_1_decision_tree_trainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_decision_tree_trainer_data_provider.html">DecisionTreeTrainerDataProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_feature_representation.html">DefaultFeatureRepresentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DefaulFeatureRepresentation</b> extends <a class="el" href="classpcl_1_1_point_representation.html" title="PointRepresentation provides a set of methods for converting a point structs/object into an n-dimensi...">PointRepresentation</a> and is intended to be used when defining the default behavior for feature descriptor types (i.e., copy each element of each field into a float array).  <a href="classpcl_1_1_default_feature_representation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_iterator.html">DefaultIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation.html">DefaultPointRepresentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_default_point_representation.html" title="DefaultPointRepresentation extends PointRepresentation to define default behavior for common point ty...">DefaultPointRepresentation</a></b> extends <a class="el" href="classpcl_1_1_point_representation.html" title="PointRepresentation provides a set of methods for converting a point structs/object into an n-dimensi...">PointRepresentation</a> to define default behavior for common point types.  <a href="classpcl_1_1_default_point_representation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_f_p_f_h_signature33_01_4.html">DefaultPointRepresentation&lt; FPFHSignature33 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_g_a_s_d_signature512_01_4.html">DefaultPointRepresentation&lt; GASDSignature512 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_g_a_s_d_signature7992_01_4.html">DefaultPointRepresentation&lt; GASDSignature7992 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_g_a_s_d_signature984_01_4.html">DefaultPointRepresentation&lt; GASDSignature984 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_narf36_01_4.html">DefaultPointRepresentation&lt; Narf36 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_normal_based_signature12_01_4.html">DefaultPointRepresentation&lt; NormalBasedSignature12 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_p_f_h_r_g_b_signature250_01_4.html">DefaultPointRepresentation&lt; PFHRGBSignature250 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_p_f_h_signature125_01_4.html">DefaultPointRepresentation&lt; PFHSignature125 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_point_normal_01_4.html">DefaultPointRepresentation&lt; PointNormal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_point_x_y_z_01_4.html">DefaultPointRepresentation&lt; PointXYZ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_point_x_y_z_i_01_4.html">DefaultPointRepresentation&lt; PointXYZI &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_p_p_f_signature_01_4.html">DefaultPointRepresentation&lt; PPFSignature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_shape_context1980_01_4.html">DefaultPointRepresentation&lt; ShapeContext1980 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_s_h_o_t1344_01_4.html">DefaultPointRepresentation&lt; SHOT1344 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_s_h_o_t352_01_4.html">DefaultPointRepresentation&lt; SHOT352 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_unique_shape_context1960_01_4.html">DefaultPointRepresentation&lt; UniqueShapeContext1960 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_default_point_representation_3_01_v_f_h_signature308_01_4.html">DefaultPointRepresentation&lt; VFHSignature308 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_dense_crf.html">DenseCrf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_dense_quantized_multi_mod_template.html">DenseQuantizedMultiModTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_dense_quantized_single_mod_template.html">DenseQuantizedSingleModTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_depth_sense_grabber.html">DepthSenseGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for DepthSense devices (e.g.  <a href="classpcl_1_1_depth_sense_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_difference_of_normals_estimation.html">DifferenceOfNormalsEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Difference of Normals (DoN) scale filter implementation for point cloud data.  <a href="classpcl_1_1_difference_of_normals_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_digital_elevation_map_builder.html">DigitalElevationMapBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a Digital Elevation Map in the column-disparity space from a disparity map and a color image of the scene.  <a href="classpcl_1_1_digital_elevation_map_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_dinast_grabber.html">DinastGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for DINAST devices (i.e., IPA-1002, IPA-1110, IPA-2001)  <a href="classpcl_1_1_dinast_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_disparity_map_converter.html">DisparityMapConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute point cloud from the disparity map.  <a href="classpcl_1_1_disparity_map_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_distance_map.html">DistanceMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a distance map obtained from a distance transformation.  <a href="classpcl_1_1_distance_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_d_o_t_m_o_d.html">DOTMOD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching using the <a class="el" href="classpcl_1_1_d_o_t_m_o_d.html" title="Template matching using the DOTMOD approach.">DOTMOD</a> approach.  <a href="classpcl_1_1_d_o_t_m_o_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_d_o_t_modality.html">DOTModality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_d_o_t_m_o_d_detection.html">DOTMODDetection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ear_clipping.html">EarClipping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ear clipping triangulation algorithm.  <a href="classpcl_1_1_ear_clipping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_edge_aware_plane_comparator.html">EdgeAwarePlaneComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_edge_aware_plane_comparator.html" title="EdgeAwarePlaneComparator is a Comparator that operates on plane coefficients, for use in planar segme...">EdgeAwarePlaneComparator</a> is a <a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> that operates on plane coefficients, for use in planar segmentation.  <a href="classpcl_1_1_edge_aware_plane_comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_energy_maps.html">EnergyMaps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a set of energy maps.  <a href="classpcl_1_1_energy_maps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ensenso_grabber.html">EnsensoGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for IDS-Imaging Ensenso's devices.  <a href="classpcl_1_1_ensenso_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_e_s_f_estimation.html">ESFEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_e_s_f_estimation.html" title="ESFEstimation estimates the ensemble of shape functions descriptors for a given point cloud dataset c...">ESFEstimation</a></b> estimates the ensemble of shape functions descriptors for a given point cloud dataset containing points.  <a href="classpcl_1_1_e_s_f_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_e_s_f_signature640.html">ESFSignature640</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Ensemble of Shape Functions (ESF).  <a href="structpcl_1_1_e_s_f_signature640.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_euclidean_cluster_comparator.html">EuclideanClusterComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_euclidean_cluster_comparator.html" title="EuclideanClusterComparator is a comparator used for finding clusters based on euclidian distance.">EuclideanClusterComparator</a> is a comparator used for finding clusters based on euclidian distance.  <a href="classpcl_1_1_euclidean_cluster_comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_euclidean_cluster_comparator_3_01_point_t_00_01_point_l_t_00_01deprecated_1_1_t_01_4.html">EuclideanClusterComparator&lt; PointT, PointLT, deprecated::T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_euclidean_cluster_extraction.html">EuclideanClusterExtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_euclidean_cluster_extraction.html" title="EuclideanClusterExtraction represents a segmentation class for cluster extraction in an Euclidean sen...">EuclideanClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense.  <a href="classpcl_1_1_euclidean_cluster_extraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_euclidean_plane_coefficient_comparator.html">EuclideanPlaneCoefficientComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_euclidean_plane_coefficient_comparator.html" title="EuclideanPlaneCoefficientComparator is a Comparator that operates on plane coefficients,...">EuclideanPlaneCoefficientComparator</a> is a <a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> that operates on plane coefficients, for use in planar segmentation.  <a href="classpcl_1_1_euclidean_plane_coefficient_comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_event_frequency.html">EventFrequency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to measure frequency of a certain event.  <a href="classpcl_1_1_event_frequency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_extract_indices.html">ExtractIndices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_extract_indices.html" title="ExtractIndices extracts a set of indices from a point cloud.">ExtractIndices</a></b> extracts a set of indices from a point cloud.  <a href="classpcl_1_1_extract_indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_extract_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">ExtractIndices&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_extract_indices.html" title="ExtractIndices extracts a set of indices from a point cloud.">ExtractIndices</a></b> extracts a set of indices from a point cloud.  <a href="classpcl_1_1_extract_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_extract_polygonal_prism_data.html">ExtractPolygonalPrismData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_extract_polygonal_prism_data.html" title="ExtractPolygonalPrismData uses a set of point indices that represent a planar model,...">ExtractPolygonalPrismData</a></b> uses a set of point indices that represent a planar model, and together with a given height, generates a 3D polygonal prism.  <a href="classpcl_1_1_extract_polygonal_prism_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_fast_bilateral_filter.html">FastBilateralFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a fast bilateral filter for smoothing depth information in organized point clouds Based on the following paper:  <a href="classpcl_1_1_fast_bilateral_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_fast_bilateral_filter_o_m_p.html">FastBilateralFilterOMP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a fast bilateral filter for smoothing depth information in organized point clouds Based on the following paper:  <a href="classpcl_1_1_fast_bilateral_filter_o_m_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature.html">Feature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> represents the base feature class.  <a href="classpcl_1_1_feature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature_from_labels.html">FeatureFromLabels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature_from_normals.html">FeatureFromNormals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature_handler.html">FeatureHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class interface which is used for creating and evaluating features.  <a href="classpcl_1_1_feature_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature_histogram.html">FeatureHistogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for histograms for computing mean and variance of some floats.  <a href="classpcl_1_1_feature_histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature_with_local_reference_frames.html">FeatureWithLocalReferenceFrames</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_feature_with_local_reference_frames.html" title="FeatureWithLocalReferenceFrames provides a public interface for descriptor extractor classes which ne...">FeatureWithLocalReferenceFrames</a> provides a public interface for descriptor extractor classes which need a local reference frame at each input keypoint.  <a href="classpcl_1_1_feature_with_local_reference_frames.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_fern.html">Fern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a <a class="el" href="classpcl_1_1_fern.html" title="Class representing a Fern.">Fern</a>.  <a href="classpcl_1_1_fern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_fern_evaluator.html">FernEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for evaluating a fern.  <a href="classpcl_1_1_fern_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_fern_trainer.html">FernTrainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trainer for a <a class="el" href="classpcl_1_1_fern.html" title="Class representing a Fern.">Fern</a>.  <a href="classpcl_1_1_fern_trainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_field_comparison.html">FieldComparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The field-based specialization of the comparison object.  <a href="classpcl_1_1_field_comparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_field_matches.html">FieldMatches</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_file_grabber.html">FileGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_file_grabber.html" title="FileGrabber provides a container-style interface for grabbers which operate on fixed-size input.">FileGrabber</a> provides a container-style interface for grabbers which operate on fixed-size input.  <a href="classpcl_1_1_file_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_file_reader.html">FileReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud Data (FILE) file format reader interface.  <a href="classpcl_1_1_file_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_file_writer.html">FileWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud Data (FILE) file format writer.  <a href="classpcl_1_1_file_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class.">Filter</a> represents the base filter class.  <a href="classpcl_1_1_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_filter_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">Filter&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class.">Filter</a> represents the base filter class.  <a href="classpcl_1_1_filter_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_filter_indices.html">FilterIndices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_filter_indices.html" title="FilterIndices represents the base class for filters that are about binary point removal.">FilterIndices</a></b> represents the base class for filters that are about binary point removal.  <a href="classpcl_1_1_filter_indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_filter_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">FilterIndices&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_filter_indices.html" title="FilterIndices represents the base class for filters that are about binary point removal.">FilterIndices</a></b> represents the base class for filters that are about binary point removal.  <a href="classpcl_1_1_filter_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_f_l_a_r_e_local_reference_frame_estimation.html">FLARELocalReferenceFrameEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_f_l_a_r_e_local_reference_frame_estimation.html" title="FLARELocalReferenceFrameEstimation implements the Fast LocAl Reference framE algorithm for local refe...">FLARELocalReferenceFrameEstimation</a> implements the Fast LocAl Reference framE algorithm for local reference frame estimation as described here:  <a href="classpcl_1_1_f_l_a_r_e_local_reference_frame_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1for__each__type__impl.html">for_each_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1for__each__type__impl_3_01false_01_4.html">for_each_type_impl&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_f_p_f_h_estimation.html">FPFHEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_f_p_f_h_estimation.html" title="FPFHEstimation estimates the Fast Point Feature Histogram (FPFH) descriptor for a given point cloud d...">FPFHEstimation</a> estimates the <b>Fast Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (FPFH)</b> descriptor for a given point cloud dataset containing points and normals.  <a href="classpcl_1_1_f_p_f_h_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_f_p_f_h_estimation_o_m_p.html">FPFHEstimationOMP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_f_p_f_h_estimation_o_m_p.html" title="FPFHEstimationOMP estimates the Fast Point Feature Histogram (FPFH) descriptor for a given point clou...">FPFHEstimationOMP</a> estimates the Fast Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (FPFH) descriptor for a given point cloud dataset containing points and normals, in parallel, using the OpenMP standard.  <a href="classpcl_1_1_f_p_f_h_estimation_o_m_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_f_p_f_h_signature33.html">FPFHSignature33</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Fast Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (FPFH).  <a href="structpcl_1_1_f_p_f_h_signature33.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_frustum_culling.html">FrustumCulling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_frustum_culling.html" title="FrustumCulling filters points inside a frustum given by pose and field of view of the camera.">FrustumCulling</a> filters points inside a frustum given by pose and field of view of the camera.  <a href="classpcl_1_1_frustum_culling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_functor.html">Functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base functor all the models that need non linear optimization must define their own one and implement operator() (const Eigen::VectorXd&amp; x, Eigen::VectorXd&amp; fvec) or operator() (const Eigen::VectorXf&amp; x, Eigen::VectorXf&amp; fvec) depending on the chosen _Scalar.  <a href="structpcl_1_1_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_g_a_s_d_color_estimation.html">GASDColorEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_g_a_s_d_color_estimation.html" title="GASDColorEstimation estimates the Globally Aligned Spatial Distribution (GASD) descriptor for a given...">GASDColorEstimation</a> estimates the Globally Aligned Spatial Distribution (GASD) descriptor for a given point cloud dataset given XYZ and <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> data.  <a href="classpcl_1_1_g_a_s_d_color_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_g_a_s_d_estimation.html">GASDEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_g_a_s_d_estimation.html" title="GASDEstimation estimates the Globally Aligned Spatial Distribution (GASD) descriptor for a given poin...">GASDEstimation</a> estimates the Globally Aligned Spatial Distribution (GASD) descriptor for a given point cloud dataset given XYZ data.  <a href="classpcl_1_1_g_a_s_d_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_a_s_d_signature512.html">GASDSignature512</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Globally Aligned Spatial Distribution (GASD) shape descriptor.  <a href="structpcl_1_1_g_a_s_d_signature512.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_a_s_d_signature7992.html">GASDSignature7992</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Globally Aligned Spatial Distribution (GASD) shape and color descriptor.  <a href="structpcl_1_1_g_a_s_d_signature7992.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_a_s_d_signature984.html">GASDSignature984</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Globally Aligned Spatial Distribution (GASD) shape and color descriptor.  <a href="structpcl_1_1_g_a_s_d_signature984.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_gaussian_kernel.html">GaussianKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classpcl_1_1_gaussian_kernel.html" title="Class GaussianKernel assembles all the method for computing, convolving, smoothing,...">GaussianKernel</a> assembles all the method for computing, convolving, smoothing, gradients computing an image using a gaussian kernel.  <a href="classpcl_1_1_gaussian_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html">GeneralizedIterativeClosestPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_generalized_iterative_closest_point.html" title="GeneralizedIterativeClosestPoint is an ICP variant that implements the generalized iterative closest ...">GeneralizedIterativeClosestPoint</a> is an ICP variant that implements the generalized iterative closest point algorithm as described by Alex Segal et al.  <a href="classpcl_1_1_generalized_iterative_closest_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_geometric_consistency_grouping.html">GeometricConsistencyGrouping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a 3D correspondence grouping enforcing geometric consistency among feature correspondences.  <a href="classpcl_1_1_geometric_consistency_grouping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_g_f_p_f_h_estimation.html">GFPFHEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_g_f_p_f_h_estimation.html" title="GFPFHEstimation estimates the Global Fast Point Feature Histogram (GFPFH) descriptor for a given poin...">GFPFHEstimation</a></b> estimates the Global Fast Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (GFPFH) descriptor for a given point cloud dataset containing points and labels.  <a href="classpcl_1_1_g_f_p_f_h_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_f_p_f_h_signature16.html">GFPFHSignature16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the GFPFH descriptor with 16 bins.  <a href="structpcl_1_1_g_f_p_f_h_signature16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_global_hypotheses_verification.html">GlobalHypothesesVerification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hypothesis verification method proposed in "A Global Hypotheses Verification Method for 3D Object Recognition", A.  <a href="classpcl_1_1_global_hypotheses_verification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grabber.html">Grabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> interface for PCL 1.x device drivers.  <a href="classpcl_1_1_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grab_cut.html">GrabCut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="classpcl_1_1_grab_cut.html" title="Implementation of the GrabCut segmentation in &quot;GrabCut — Interactive Foreground Extraction using Iter...">GrabCut</a> segmentation in "GrabCut — Interactive Foreground Extraction using Iterated Graph Cuts" by Carsten Rother, Vladimir Kolmogorov and Andrew Blake.  <a href="classpcl_1_1_grab_cut.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_gradient_x_y.html">GradientXY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the intensity value.  <a href="structpcl_1_1_gradient_x_y.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_graph_registration.html">GraphRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_graph_registration.html" title="GraphRegistration class is the base class for graph-based registration methods">GraphRegistration</a></b> class is the base class for graph-based registration methods  <a href="classpcl_1_1_graph_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_gray_stereo_matching.html">GrayStereoMatching</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stereo Matching abstract class for Grayscale images.  <a href="classpcl_1_1_gray_stereo_matching.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_greedy_projection_triangulation.html">GreedyProjectionTriangulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_greedy_projection_triangulation.html" title="GreedyProjectionTriangulation is an implementation of a greedy triangulation algorithm for 3D points ...">GreedyProjectionTriangulation</a> is an implementation of a greedy triangulation algorithm for 3D points based on local 2D projections.  <a href="classpcl_1_1_greedy_projection_triangulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_greedy_verification.html">GreedyVerification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A greedy hypothesis verification method.  <a href="classpcl_1_1_greedy_verification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_minimum.html">GridMinimum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grid_minimum.html" title="GridMinimum assembles a local 2D grid over a given PointCloud, and downsamples the data.">GridMinimum</a> assembles a local 2D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a>, and downsamples the data.  <a href="classpcl_1_1_grid_minimum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_grid.html">Grid</a> projection surface reconstruction method.  <a href="classpcl_1_1_grid_projection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ground_plane_comparator.html">GroundPlaneComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_ground_plane_comparator.html" title="GroundPlaneComparator is a Comparator for detecting smooth surfaces suitable for driving.">GroundPlaneComparator</a> is a <a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> for detecting smooth surfaces suitable for driving.  <a href="classpcl_1_1_ground_plane_comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_g_r_s_d_estimation.html">GRSDEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_g_r_s_d_estimation.html" title="GRSDEstimation estimates the Global Radius-based Surface Descriptor (GRSD) for a given point cloud da...">GRSDEstimation</a></b> estimates the Global Radius-based Surface Descriptor (GRSD) for a given point cloud dataset containing points and normals.  <a href="classpcl_1_1_g_r_s_d_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_r_s_d_signature21.html">GRSDSignature21</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Global Radius-based Surface Descriptor (GRSD).  <a href="structpcl_1_1_g_r_s_d_signature21.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_harris_keypoint2_d.html">HarrisKeypoint2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_harris_keypoint2_d.html" title="HarrisKeypoint2D detects Harris corners family points.">HarrisKeypoint2D</a> detects Harris corners family points.  <a href="classpcl_1_1_harris_keypoint2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_harris_keypoint3_d.html">HarrisKeypoint3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_harris_keypoint3_d.html" title="HarrisKeypoint3D uses the idea of 2D Harris keypoints, but instead of using image gradients,...">HarrisKeypoint3D</a> uses the idea of 2D Harris keypoints, but instead of using image gradients, it uses surface normals.  <a href="classpcl_1_1_harris_keypoint3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_harris_keypoint6_d.html">HarrisKeypoint6D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_keypoint.html" title="Keypoint represents the base class for key points.">Keypoint</a> detector for detecting corners in 3D (XYZ), 2D (intensity) AND mixed versions of these.  <a href="classpcl_1_1_harris_keypoint6_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1has__custom__allocator.html">has_custom_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests at compile time if type T has a custom allocator.  <a href="structpcl_1_1has__custom__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_hash_table_o_l_d.html">HashTableOLD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_h_d_l_grabber.html">HDLGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for the Velodyne High-Definition-Laser (HDL)  <a href="classpcl_1_1_h_d_l_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_histogram.html">Histogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing an N-D histogram.  <a href="structpcl_1_1_histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_hough3_d_grouping.html">Hough3DGrouping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a 3D correspondence grouping algorithm that can deal with multiple instances of a model template found into a given scene.  <a href="classpcl_1_1_hough3_d_grouping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_hypothesis_verification.html">HypothesisVerification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for hypotheses verification methods.  <a href="classpcl_1_1_hypothesis_verification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_i_f_s_reader.html">IFSReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed Face set (IFS) file format reader.  <a href="classpcl_1_1_i_f_s_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_i_f_s_writer.html">IFSWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud Data (IFS) file format writer.  <a href="classpcl_1_1_i_f_s_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_image_grabber.html">ImageGrabber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_image_grabber_base.html">ImageGrabberBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Image file grabber.  <a href="classpcl_1_1_image_grabber_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_init_failed_exception.html">InitFailedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when init can not be performed should be used in all the <a class="el" href="classpcl_1_1_p_c_l_base.html" title="PCL base class.">PCLBase</a> class inheritants.  <a href="classpcl_1_1_init_failed_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_integral_image2_d.html">IntegralImage2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines an integral image representation for a given organized data array.  <a href="classpcl_1_1_integral_image2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_integral_image2_d_3_01_data_type_00_011_01_4.html">IntegralImage2D&lt; DataType, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial template specialization for integral images with just one channel.  <a href="classpcl_1_1_integral_image2_d_3_01_data_type_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_integral_image_normal_estimation.html">IntegralImageNormalEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface normal estimation on organized data using integral images.  <a href="classpcl_1_1_integral_image_normal_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_integral_image_type_traits.html">IntegralImageTypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_integral_image_type_traits_3_01char_01_4.html">IntegralImageTypeTraits&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_integral_image_type_traits_3_01float_01_4.html">IntegralImageTypeTraits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_integral_image_type_traits_3_01int_01_4.html">IntegralImageTypeTraits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_integral_image_type_traits_3_01short_01_4.html">IntegralImageTypeTraits&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_integral_image_type_traits_3_01unsigned_01char_01_4.html">IntegralImageTypeTraits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_integral_image_type_traits_3_01unsigned_01int_01_4.html">IntegralImageTypeTraits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_integral_image_type_traits_3_01unsigned_01short_01_4.html">IntegralImageTypeTraits&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_intensity.html">Intensity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the grayscale intensity in single-channel images.  <a href="structpcl_1_1_intensity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_intensity32u.html">Intensity32u</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the grayscale intensity in single-channel images.  <a href="structpcl_1_1_intensity32u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_intensity8u.html">Intensity8u</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the grayscale intensity in single-channel images.  <a href="structpcl_1_1_intensity8u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_intensity_gradient.html">IntensityGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the intensity gradient of an XYZI point cloud.  <a href="structpcl_1_1_intensity_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_intensity_gradient_estimation.html">IntensityGradientEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_intensity_gradient_estimation.html" title="IntensityGradientEstimation estimates the intensity gradient for a point cloud that contains position...">IntensityGradientEstimation</a> estimates the intensity gradient for a point cloud that contains position and intensity values.  <a href="classpcl_1_1_intensity_gradient_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_intensity_spin_estimation.html">IntensitySpinEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_intensity_spin_estimation.html" title="IntensitySpinEstimation estimates the intensity-domain spin image descriptors for a given point cloud...">IntensitySpinEstimation</a> estimates the intensity-domain spin image descriptors for a given point cloud dataset containing points and intensity.  <a href="classpcl_1_1_intensity_spin_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_interest_point.html">InterestPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing an interest point with Euclidean xyz coordinates, and an interest value.  <a href="structpcl_1_1_interest_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1intersect.html">intersect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_invalid_conversion_exception.html">InvalidConversionException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown when a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> message cannot be converted into a PCL type.  <a href="classpcl_1_1_invalid_conversion_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_invalid_s_a_c_model_type_exception.html">InvalidSACModelTypeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown when a sample consensus model doesn't have the correct number of samples defined in <a class="el" href="model__types_8h_source.html">model_types.h</a>.  <a href="classpcl_1_1_invalid_s_a_c_model_type_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_i_o_exception.html">IOException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown during an IO error (typical read/write errors)  <a href="classpcl_1_1_i_o_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_i_s_m_peak.html">ISMPeak</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used for storing peak.  <a href="structpcl_1_1_i_s_m_peak.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_is_not_dense_exception.html">IsNotDenseException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown when a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> is not dense but is attempted to be used as dense.  <a href="classpcl_1_1_is_not_dense_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_i_s_s_keypoint3_d.html">ISSKeypoint3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_i_s_s_keypoint3_d.html" title="ISSKeypoint3D detects the Intrinsic Shape Signatures keypoints for a given point cloud.">ISSKeypoint3D</a> detects the Intrinsic Shape Signatures keypoints for a given point cloud.  <a href="classpcl_1_1_i_s_s_keypoint3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point.html">IterativeClosestPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_iterative_closest_point.html" title="IterativeClosestPoint provides a base implementation of the Iterative Closest Point algorithm.">IterativeClosestPoint</a></b> provides a base implementation of the Iterative Closest Point algorithm.  <a href="classpcl_1_1_iterative_closest_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point_non_linear.html">IterativeClosestPointNonLinear</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_iterative_closest_point_non_linear.html" title="IterativeClosestPointNonLinear is an ICP variant that uses Levenberg-Marquardt optimization backend.">IterativeClosestPointNonLinear</a></b> is an ICP variant that uses Levenberg-Marquardt optimization backend.  <a href="classpcl_1_1_iterative_closest_point_non_linear.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterative_closest_point_with_normals.html">IterativeClosestPointWithNormals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_iterative_closest_point_with_normals.html" title="IterativeClosestPointWithNormals is a special case of IterativeClosestPoint, that uses a transformati...">IterativeClosestPointWithNormals</a></b> is a special case of <a class="el" href="classpcl_1_1_iterative_closest_point.html" title="IterativeClosestPoint provides a base implementation of the Iterative Closest Point algorithm.">IterativeClosestPoint</a>, that uses a transformation estimated based on Point to Plane distances by default.  <a href="classpcl_1_1_iterative_closest_point_with_normals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_iterator_idx.html">IteratorIdx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_joint_iterative_closest_point.html">JointIterativeClosestPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_joint_iterative_closest_point.html" title="JointIterativeClosestPoint extends ICP to multiple frames which share the same transform.">JointIterativeClosestPoint</a></b> extends ICP to multiple frames which share the same transform.  <a href="classpcl_1_1_joint_iterative_closest_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_kd_tree.html">KdTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_kd_tree.html" title="KdTree represents the base spatial locator class for kd-tree implementations.">KdTree</a> represents the base spatial locator class for kd-tree implementations.  <a href="classpcl_1_1_kd_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_kd_tree_f_l_a_n_n.html">KdTreeFLANN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_kd_tree_f_l_a_n_n.html" title="KdTreeFLANN is a generic type of 3D spatial locator using kD-tree structures.">KdTreeFLANN</a> is a generic type of 3D spatial locator using kD-tree structures.  <a href="classpcl_1_1_kd_tree_f_l_a_n_n.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1kernel.html">kernel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_kernel_width_too_small_exception.html">KernelWidthTooSmallException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown when the kernel size is too small.  <a href="classpcl_1_1_kernel_width_too_small_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_keypoint.html">Keypoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_keypoint.html" title="Keypoint represents the base class for key points.">Keypoint</a></b> represents the base class for key points.  <a href="classpcl_1_1_keypoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_kmeans.html">Kmeans</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">K-means clustering.  <a href="classpcl_1_1_kmeans.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_label.html">Label</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_labeled_euclidean_cluster_extraction.html">LabeledEuclideanClusterExtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_labeled_euclidean_cluster_extraction.html" title="LabeledEuclideanClusterExtraction represents a segmentation class for cluster extraction in an Euclid...">LabeledEuclideanClusterExtraction</a></b> represents a segmentation class for cluster extraction in an Euclidean sense, with label info.  <a href="classpcl_1_1_labeled_euclidean_cluster_extraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_c_c_p_segmentation.html">LCCPSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connected supervoxels separated by concave borders.  <a href="classpcl_1_1_l_c_c_p_segmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_least_median_squares.html">LeastMedianSquares</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_least_median_squares.html" title="LeastMedianSquares represents an implementation of the LMedS (Least Median of Squares) algorithm.">LeastMedianSquares</a></b> represents an implementation of the LMedS (Least Median of Squares) algorithm.  <a href="classpcl_1_1_least_median_squares.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_linearized_maps.html">LinearizedMaps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a set of linearized maps.  <a href="classpcl_1_1_linearized_maps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_linear_least_squares_normal_estimation.html">LinearLeastSquaresNormalEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface normal estimation on dense data using a least-squares estimation based on a first-order Taylor approximation.  <a href="classpcl_1_1_linear_least_squares_normal_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_line_iterator.html">LineIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Organized Index Iterator for iterating over the "pixels" for a given line using the Bresenham algorithm.  <a href="classpcl_1_1_line_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_l_i_n_e_m_o_d.html">LINEMOD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template matching using the <a class="el" href="classpcl_1_1_l_i_n_e_m_o_d.html" title="Template matching using the LINEMOD approach.">LINEMOD</a> approach.  <a href="classpcl_1_1_l_i_n_e_m_o_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_l_i_n_e_m_o_d___orientation_map.html">LINEMOD_OrientationMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map that stores orientations.  <a href="structpcl_1_1_l_i_n_e_m_o_d___orientation_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_l_i_n_e_m_o_d_detection.html">LINEMODDetection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a detection of a template using the <a class="el" href="classpcl_1_1_l_i_n_e_m_o_d.html" title="Template matching using the LINEMOD approach.">LINEMOD</a> approach.  <a href="structpcl_1_1_l_i_n_e_m_o_d_detection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_line_r_g_b_d.html">LineRGBD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level class for template matching using the <a class="el" href="classpcl_1_1_l_i_n_e_m_o_d.html" title="Template matching using the LINEMOD approach.">LINEMOD</a> approach based on <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> and Depth data.  <a href="classpcl_1_1_line_r_g_b_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_local_maximum.html">LocalMaximum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_local_maximum.html" title="LocalMaximum downsamples the cloud, by eliminating points that are locally maximal.">LocalMaximum</a> downsamples the cloud, by eliminating points that are locally maximal.  <a href="classpcl_1_1_local_maximum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_marching_cubes.html">MarchingCubes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The marching cubes surface reconstruction algorithm.  <a href="classpcl_1_1_marching_cubes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_marching_cubes_hoppe.html">MarchingCubesHoppe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The marching cubes surface reconstruction algorithm, using a signed distance function based on the distance from tangent planes, proposed by Hoppe et.  <a href="classpcl_1_1_marching_cubes_hoppe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_marching_cubes_r_b_f.html">MarchingCubesRBF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The marching cubes surface reconstruction algorithm, using a signed distance function based on radial basis functions.  <a href="classpcl_1_1_marching_cubes_r_b_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mask_map.html">MaskMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_maximum_likelihood_sample_consensus.html">MaximumLikelihoodSampleConsensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_maximum_likelihood_sample_consensus.html" title="MaximumLikelihoodSampleConsensus represents an implementation of the MLESAC (Maximum Likelihood Estim...">MaximumLikelihoodSampleConsensus</a></b> represents an implementation of the MLESAC (Maximum Likelihood Estimator SAmple Consensus) algorithm, as described in: "MLESAC: A new robust estimator with application to 
estimating image geometry", P.H.S.  <a href="classpcl_1_1_maximum_likelihood_sample_consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_median_filter.html">MedianFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the median filter.  <a href="classpcl_1_1_median_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mesh_construction.html">MeshConstruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_mesh_construction.html" title="MeshConstruction represents a base surface reconstruction class.">MeshConstruction</a> represents a base surface reconstruction class.  <a href="classpcl_1_1_mesh_construction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mesh_processing.html">MeshProcessing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_mesh_processing.html" title="MeshProcessing represents the base class for mesh processing algorithms.">MeshProcessing</a></b> represents the base class for mesh processing algorithms.  <a href="classpcl_1_1_mesh_processing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mesh_quadric_decimation_v_t_k.html">MeshQuadricDecimationVTK</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCL mesh decimation based on vtkQuadricDecimation from the VTK library.  <a href="classpcl_1_1_mesh_quadric_decimation_v_t_k.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mesh_smoothing_laplacian_v_t_k.html">MeshSmoothingLaplacianVTK</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCL mesh smoothing based on the vtkSmoothPolyDataFilter algorithm from the VTK library.  <a href="classpcl_1_1_mesh_smoothing_laplacian_v_t_k.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mesh_smoothing_windowed_sinc_v_t_k.html">MeshSmoothingWindowedSincVTK</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCL mesh smoothing based on the vtkWindowedSincPolyDataFilter algorithm from the VTK library.  <a href="classpcl_1_1_mesh_smoothing_windowed_sinc_v_t_k.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_mesh_subdivision_v_t_k.html">MeshSubdivisionVTK</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCL mesh smoothing based on the vtkLinearSubdivisionFilter, vtkLoopSubdivisionFilter, vtkButterflySubdivisionFilter depending on the selected MeshSubdivisionVTKFilterType algorithm from the VTK library.  <a href="classpcl_1_1_mesh_subdivision_v_t_k.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_m_estimator_sample_consensus.html">MEstimatorSampleConsensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_m_estimator_sample_consensus.html" title="MEstimatorSampleConsensus represents an implementation of the MSAC (M-estimator SAmple Consensus) alg...">MEstimatorSampleConsensus</a></b> represents an implementation of the MSAC (M-estimator SAmple Consensus) algorithm, as described in: "MLESAC: A new robust estimator with application to estimating image geometry", P.H.S.  <a href="classpcl_1_1_m_estimator_sample_consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_min_cut_segmentation.html">MinCutSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the segmentation algorithm based on minimal cut of the graph.  <a href="classpcl_1_1_min_cut_segmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_m_l_s_result.html">MLSResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure used to store the results of the MLS fitting.  <a href="structpcl_1_1_m_l_s_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_model_coefficients.html">ModelCoefficients</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_model_outlier_removal.html">ModelOutlierRemoval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_model_outlier_removal.html" title="ModelOutlierRemoval filters points in a cloud based on the distance between model and point.">ModelOutlierRemoval</a></b> filters points in a cloud based on the distance between model and point.  <a href="classpcl_1_1_model_outlier_removal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_moment_invariants.html">MomentInvariants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the three moment invariants.  <a href="structpcl_1_1_moment_invariants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moment_invariants_estimation.html">MomentInvariantsEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_moment_invariants_estimation.html" title="MomentInvariantsEstimation estimates the 3 moment invariants (j1, j2, j3) at each 3D point.">MomentInvariantsEstimation</a> estimates the 3 moment invariants (j1, j2, j3) at each 3D point.  <a href="classpcl_1_1_moment_invariants_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moment_of_inertia_estimation.html">MomentOfInertiaEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the method for extracting features based on moment of inertia.  <a href="classpcl_1_1_moment_of_inertia_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_morphology.html">Morphology</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_moving_least_squares.html" title="MovingLeastSquares represent an implementation of the MLS (Moving Least Squares) algorithm for data s...">MovingLeastSquares</a> represent an implementation of the MLS (Moving Least Squares) algorithm for data smoothing and improved normal estimation.  <a href="classpcl_1_1_moving_least_squares.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_m_t_l_reader.html">MTLReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature.html">MultiChannel2DComparisonFeature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> for comparing two sample points in 2D multi-channel data.  <a href="classpcl_1_1_multi_channel2_d_comparison_feature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> utility class that handles the creation and evaluation of RGBD comparison features.  <a href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_multi_channel2_d_data.html">MultiChannel2DData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds two-dimensional multi-channel data.  <a href="classpcl_1_1_multi_channel2_d_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a set of two-dimensional multi-channel data.  <a href="classpcl_1_1_multi_channel2_d_data_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_multiple_data2_d_example_index.html">MultipleData2DExampleIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example index for a set of 2D data blocks.  <a href="structpcl_1_1_multiple_data2_d_example_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_multiscale_feature_persistence.html">MultiscaleFeaturePersistence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class for extracting the persistent features from an input point cloud It can be given any <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> estimator instance and will compute the features of the input over a multiscale representation of the cloud and output the unique ones over those scales.  <a href="classpcl_1_1_multiscale_feature_persistence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_narf.html">Narf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NARF (<a class="el" href="structpcl_1_1_normal.html" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> Aligned Radial Features) is a point feature descriptor type for 3D data.  <a href="classpcl_1_1_narf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_narf36.html">Narf36</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the <a class="el" href="classpcl_1_1_narf.html" title="NARF (Normal Aligned Radial Features) is a point feature descriptor type for 3D data.">Narf</a> descriptor.  <a href="structpcl_1_1_narf36.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_narf_descriptor.html">NarfDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Computes</b> NARF feature descriptors for points in a range image See B.  <a href="classpcl_1_1_narf_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_narf_keypoint.html">NarfKeypoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>NARF</b> (<a class="el" href="structpcl_1_1_normal.html" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> Aligned Radial <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a>) keypoints.  <a href="classpcl_1_1_narf_keypoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_nd_centroid_functor.html">NdCentroidFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor structure for n-D centroid estimation.  <a href="structpcl_1_1_nd_centroid_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_nd_concatenate_functor.html">NdConcatenateFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor structure for concatenate.  <a href="structpcl_1_1_nd_concatenate_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_nd_copy_eigen_point_functor.html">NdCopyEigenPointFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor structure for copying data between an <a class="el" href="namespace_eigen.html">Eigen</a> type and a PointT.  <a href="structpcl_1_1_nd_copy_eigen_point_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_nd_copy_point_eigen_functor.html">NdCopyPointEigenFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor structure for copying data between an <a class="el" href="namespace_eigen.html">Eigen</a> type and a PointT.  <a href="structpcl_1_1_nd_copy_point_eigen_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_normal.html">Normal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_normal_based_signature12.html">NormalBasedSignature12</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the <a class="el" href="structpcl_1_1_normal.html" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> Based Signature for a feature matrix of 4-by-3.  <a href="structpcl_1_1_normal_based_signature12.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_based_signature_estimation.html">NormalBasedSignatureEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal-based feature signature estimation class.  <a href="classpcl_1_1_normal_based_signature_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_distributions_transform.html">NormalDistributionsTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D <a class="el" href="structpcl_1_1_normal.html" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> Distribution Transform registration implementation for point cloud data.  <a href="classpcl_1_1_normal_distributions_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_distributions_transform2_d.html">NormalDistributionsTransform2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_normal_distributions_transform2_d.html" title="NormalDistributionsTransform2D provides an implementation of the Normal Distributions Transform algor...">NormalDistributionsTransform2D</a></b> provides an implementation of the <a class="el" href="structpcl_1_1_normal.html" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> Distributions Transform algorithm for scan matching.  <a href="classpcl_1_1_normal_distributions_transform2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_estimation.html">NormalEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_normal_estimation.html" title="NormalEstimation estimates local surface properties (surface normals and curvatures)at each 3D point.">NormalEstimation</a> estimates local surface properties (surface normals and curvatures)at each 3D point.  <a href="classpcl_1_1_normal_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_estimation_o_m_p.html">NormalEstimationOMP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_normal_estimation_o_m_p.html" title="NormalEstimationOMP estimates local surface properties at each 3D point, such as surface normals and ...">NormalEstimationOMP</a> estimates local surface properties at each 3D point, such as surface normals and curvatures, in parallel, using the OpenMP standard.  <a href="classpcl_1_1_normal_estimation_o_m_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_refinement.html">NormalRefinement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal vector refinement class  <a href="classpcl_1_1_normal_refinement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_space_sampling.html">NormalSpaceSampling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_normal_space_sampling.html" title="NormalSpaceSampling samples the input point cloud in the space of normal directions computed at every...">NormalSpaceSampling</a></b> samples the input point cloud in the space of normal directions computed at every point.  <a href="classpcl_1_1_normal_space_sampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_not_enough_points_exception.html">NotEnoughPointsException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown when the number of correspondents is not equal to the minimum required.  <a href="classpcl_1_1_not_enough_points_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_o_b_j_reader.html">OBJReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_o_n_i_grabber.html">ONIGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple ONI grabber.  <a href="classpcl_1_1_o_n_i_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_open_n_i_grabber.html">OpenNIGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for OpenNI devices (i.e., Primesense PSDK, Microsoft Kinect, Asus XTion Pro/Live)  <a href="classpcl_1_1_open_n_i_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_connected_component_segmentation.html">OrganizedConnectedComponentSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_organized_connected_component_segmentation.html" title="OrganizedConnectedComponentSegmentation allows connected components to be found within organized poin...">OrganizedConnectedComponentSegmentation</a> allows connected components to be found within organized point cloud data, given a comparison function.  <a href="classpcl_1_1_organized_connected_component_segmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_edge_base.html">OrganizedEdgeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_organized_edge_base.html" title="OrganizedEdgeBase, OrganizedEdgeFromRGB, OrganizedEdgeFromNormals, and OrganizedEdgeFromRGBNormals fi...">OrganizedEdgeBase</a>, <a class="el" href="classpcl_1_1_organized_edge_from_r_g_b.html">OrganizedEdgeFromRGB</a>, <a class="el" href="classpcl_1_1_organized_edge_from_normals.html">OrganizedEdgeFromNormals</a>, and <a class="el" href="classpcl_1_1_organized_edge_from_r_g_b_normals.html">OrganizedEdgeFromRGBNormals</a> find 3D edges from an organized point cloud data.  <a href="classpcl_1_1_organized_edge_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_edge_from_normals.html">OrganizedEdgeFromNormals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_edge_from_r_g_b.html">OrganizedEdgeFromRGB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_edge_from_r_g_b_normals.html">OrganizedEdgeFromRGBNormals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_fast_mesh.html">OrganizedFastMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple triangulation/surface reconstruction for organized point clouds.  <a href="classpcl_1_1_organized_fast_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_index_iterator.html">OrganizedIndexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for iterators on 2-dimensional maps like images/organized clouds etc.  <a href="classpcl_1_1_organized_index_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_multi_plane_segmentation.html">OrganizedMultiPlaneSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_organized_multi_plane_segmentation.html" title="OrganizedMultiPlaneSegmentation finds all planes present in the input cloud, and outputs a vector of ...">OrganizedMultiPlaneSegmentation</a> finds all planes present in the input cloud, and outputs a vector of plane equations, as well as a vector of point clouds corresponding to the inliers of each detected plane.  <a href="classpcl_1_1_organized_multi_plane_segmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_organized_neighbor_search.html">OrganizedNeighborSearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_organized_neighbor_search.html" title="OrganizedNeighborSearch class">OrganizedNeighborSearch</a></b> class  <a href="classpcl_1_1_organized_neighbor_search.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_o_u_r_c_v_f_h_estimation.html">OURCVFHEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_o_u_r_c_v_f_h_estimation.html" title="OURCVFHEstimation estimates the Oriented, Unique and Repetable Clustered Viewpoint Feature Histogram ...">OURCVFHEstimation</a> estimates the Oriented, Unique and Repetable Clustered Viewpoint <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (CVFH) descriptor for a given point cloud dataset given XYZ data and normals, as presented in:  <a href="classpcl_1_1_o_u_r_c_v_f_h_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_packed_h_s_i_comparison.html">PackedHSIComparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packed HSI specialization of the comparison object.  <a href="classpcl_1_1_packed_h_s_i_comparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_packed_r_g_b_comparison.html">PackedRGBComparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packed rgb specialization of the comparison object.  <a href="classpcl_1_1_packed_r_g_b_comparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_pairwise_graph_registration.html">PairwiseGraphRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_pairwise_graph_registration.html" title="PairwiseGraphRegistration class aligns the clouds two by two">PairwiseGraphRegistration</a></b> class aligns the clouds two by two  <a href="classpcl_1_1_pairwise_graph_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_pairwise_potential.html">PairwisePotential</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_papazov_h_v.html">PapazovHV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hypothesis verification method proposed in "An Efficient RANSAC for 3D Object Recognition in Noisy and Occluded Scenes", C.  <a href="classpcl_1_1_papazov_h_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_pass_through.html">PassThrough</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_pass_through.html" title="PassThrough passes points in a cloud based on constraints for one particular field of the point type.">PassThrough</a></b> passes points in a cloud based on constraints for one particular field of the point type.  <a href="classpcl_1_1_pass_through.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_pass_through_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">PassThrough&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_pass_through.html" title="PassThrough passes points in a cloud based on constraints for one particular field of the point type.">PassThrough</a> uses the base <a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class.">Filter</a> class methods to pass through all data that satisfies the user given constraints.  <a href="classpcl_1_1_pass_through_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_a.html">PCA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Principal Component analysis (<a class="el" href="classpcl_1_1_p_c_a.html" title="Principal Component analysis (PCA) class.">PCA</a>) class.  <a href="classpcl_1_1_p_c_a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_d_grabber.html">PCDGrabber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_d_grabber_base.html">PCDGrabberBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for PCD file grabber.  <a href="classpcl_1_1_p_c_d_grabber_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_d_reader.html">PCDReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud Data (PCD) file format reader.  <a href="classpcl_1_1_p_c_d_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_d_writer.html">PCDWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud Data (PCD) file format writer.  <a href="classpcl_1_1_p_c_d_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html">PCLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCL base class.  <a href="classpcl_1_1_p_c_l_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">PCLBase&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_exception.html">PCLException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for all pcl exceptions which inherits from std::runtime_error.  <a href="classpcl_1_1_p_c_l_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_c_l_header.html">PCLHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_c_l_image.html">PCLImage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html">PCLSurfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure abstract class.  <a href="classpcl_1_1_p_c_l_surface_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_permutohedral.html">Permutohedral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a high-dimensional gaussian filtering using the permutohedral lattice.  <a href="classpcl_1_1_permutohedral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_f_h_estimation.html">PFHEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_p_f_h_estimation.html" title="PFHEstimation estimates the Point Feature Histogram (PFH) descriptor for a given point cloud dataset ...">PFHEstimation</a> estimates the Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (PFH) descriptor for a given point cloud dataset containing points and normals.  <a href="classpcl_1_1_p_f_h_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_f_h_r_g_b_estimation.html">PFHRGBEstimation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_f_h_r_g_b_signature250.html">PFHRGBSignature250</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> with colors (PFHRGB).  <a href="structpcl_1_1_p_f_h_r_g_b_signature250.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_f_h_signature125.html">PFHSignature125</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (PFH).  <a href="structpcl_1_1_p_f_h_signature125.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_piecewise_linear_function.html">PiecewiseLinearFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides functionalities to efficiently return values for piecewise linear function.  <a href="classpcl_1_1_piecewise_linear_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_planar_polygon.html">PlanarPolygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_planar_polygon.html" title="PlanarPolygon represents a planar (2D) polygon, potentially in a 3D space.">PlanarPolygon</a> represents a planar (2D) polygon, potentially in a 3D space.  <a href="classpcl_1_1_planar_polygon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_planar_polygon_fusion.html">PlanarPolygonFusion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_planar_polygon_fusion.html" title="PlanarPolygonFusion takes a list of 2D planar polygons and attempts to reduce them to a minimum set t...">PlanarPolygonFusion</a> takes a list of 2D planar polygons and attempts to reduce them to a minimum set that best represents the scene, based on various given comparators.  <a href="classpcl_1_1_planar_polygon_fusion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_planar_region.html">PlanarRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_planar_region.html" title="PlanarRegion represents a set of points that lie in a plane.">PlanarRegion</a> represents a set of points that lie in a plane.  <a href="classpcl_1_1_planar_region.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_plane_clipper3_d.html">PlaneClipper3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a plane clipper in 3D.  <a href="classpcl_1_1_plane_clipper3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_plane_coefficient_comparator.html">PlaneCoefficientComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_plane_coefficient_comparator.html" title="PlaneCoefficientComparator is a Comparator that operates on plane coefficients, for use in planar seg...">PlaneCoefficientComparator</a> is a <a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> that operates on plane coefficients, for use in planar segmentation.  <a href="classpcl_1_1_plane_coefficient_comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_plane_refinement_comparator.html">PlaneRefinementComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_plane_refinement_comparator.html" title="PlaneRefinementComparator is a Comparator that operates on plane coefficients, for use in planar segm...">PlaneRefinementComparator</a> is a <a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> that operates on plane coefficients, for use in planar segmentation.  <a href="classpcl_1_1_plane_refinement_comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_l_y_reader.html">PLYReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud Data (PLY) file format reader.  <a href="classpcl_1_1_p_l_y_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_l_y_writer.html">PLYWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Cloud Data (PLY) file format writer.  <a href="classpcl_1_1_p_l_y_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> represents the base class in PCL for storing collections of 3D points.  <a href="classpcl_1_1_point_cloud.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_correspondence3_d.html">PointCorrespondence3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a (possible) correspondence between two 3D points in two different coordinate frames (e.g.  <a href="structpcl_1_1_point_correspondence3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_correspondence6_d.html">PointCorrespondence6D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a (possible) correspondence between two points (e.g.  <a href="structpcl_1_1_point_correspondence6_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_data_at_offset.html">PointDataAtOffset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A datatype that enables type-correct comparisons.  <a href="classpcl_1_1_point_data_at_offset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_d_e_m.html">PointDEM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Digital Elevation Map.  <a href="structpcl_1_1_point_d_e_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_normal.html">PointNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, together with normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_point_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_representation.html">PointRepresentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_point_representation.html" title="PointRepresentation provides a set of methods for converting a point structs/object into an n-dimensi...">PointRepresentation</a></b> provides a set of methods for converting a point structs/object into an n-dimensional vector.  <a href="classpcl_1_1_point_representation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_surfel.html">PointSurfel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A surfel, that is, a point structure representing Euclidean xyz coordinates, together with normal coordinates, a RGBA color, a radius, a confidence value and the surface curvature estimate.  <a href="structpcl_1_1_point_surfel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_u_v.html">PointUV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D point structure representing pixel image coordinates.  <a href="structpcl_1_1_point_u_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, padded with an extra range float.  <a href="structpcl_1_1_point_with_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_with_scale.html">PointWithScale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing a 3-D position and scale.  <a href="structpcl_1_1_point_with_scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_with_viewpoint.html">PointWithViewpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates together with the viewpoint from which it was seen.  <a href="structpcl_1_1_point_with_viewpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y.html">PointXY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D point structure representing Euclidean xy coordinates.  <a href="structpcl_1_1_point_x_y.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_x_y32f.html">PointXY32f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D point with float x- and y-coordinates.  <a href="classpcl_1_1_point_x_y32f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_x_y32i.html">PointXY32i</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D point with integer x- and y-coordinates.  <a href="classpcl_1_1_point_x_y32i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z.html">PointXYZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates.  <a href="structpcl_1_1_point_x_y_z.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_i.html">PointXYZI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_i_edge.html">PointXYZIEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point cloud containing edge information.  <a href="structpcl_1_1_point_x_y_z_i_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_i_normal.html">PointXYZINormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, intensity, together with normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_point_x_y_z_i_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_l.html">PointXYZL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_l_a_b.html">PointXYZLAB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom point type for position and CIELAB color value.  <a href="structpcl_1_1_point_x_y_z_l_a_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_l_normal.html">PointXYZLNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, a label, together with normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_point_x_y_z_l_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> color.  <a href="structpcl_1_1_point_x_y_z_r_g_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the RGBA color.  <a href="structpcl_1_1_point_x_y_z_r_g_b_a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_l.html">PointXYZRGBL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_normal.html">PointXYZRGBNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> color, together with normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_point_x_y_z_r_g_b_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_poisson.html">Poisson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpcl_1_1_poisson.html" title="The Poisson surface reconstruction algorithm.">Poisson</a> surface reconstruction algorithm.  <a href="classpcl_1_1_poisson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_polygon_mesh.html">PolygonMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_polynomial_calculations_t.html">PolynomialCalculationsT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides some functionality for polynomials, like finding roots or approximating bivariate polynomials.  <a href="classpcl_1_1_polynomial_calculations_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_poses_from_matches.html">PosesFromMatches</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate 3D transformation based on point correspondences  <a href="classpcl_1_1_poses_from_matches.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_p_f_estimation.html">PPFEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that calculates the "surflet" features for each pair in the given pointcloud.  <a href="classpcl_1_1_p_p_f_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_p_f_hash_map_search.html">PPFHashMapSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_p_f_registration.html">PPFRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that registers two point clouds based on their sets of PPFSignatures.  <a href="classpcl_1_1_p_p_f_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_p_f_r_g_b_estimation.html">PPFRGBEstimation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_p_f_r_g_b_region_estimation.html">PPFRGBRegionEstimation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_p_f_r_g_b_signature.html">PPFRGBSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure for storing the Point Pair Color <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> (PPFRGB) values.  <a href="structpcl_1_1_p_p_f_r_g_b_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_p_f_signature.html">PPFSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure for storing the Point Pair <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> (PPF) values.  <a href="structpcl_1_1_p_p_f_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_principal_curvatures.html">PrincipalCurvatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the principal curvatures and their magnitudes.  <a href="structpcl_1_1_principal_curvatures.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_principal_curvatures_estimation.html">PrincipalCurvaturesEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_principal_curvatures_estimation.html" title="PrincipalCurvaturesEstimation estimates the directions (eigenvectors) and magnitudes (eigenvalues) of...">PrincipalCurvaturesEstimation</a> estimates the directions (eigenvectors) and magnitudes (eigenvalues) of principal surface curvatures for a given point cloud dataset containing points and normals.  <a href="classpcl_1_1_principal_curvatures_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_principal_radii_r_s_d.html">PrincipalRadiiRSD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the minimum and maximum surface radii (in meters) computed using RSD.  <a href="structpcl_1_1_principal_radii_r_s_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_progressive_morphological_filter.html">ProgressiveMorphologicalFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Progressive Morphological <a class="el" href="classpcl_1_1_filter.html" title="Filter represents the base filter class.">Filter</a> for segmentation of ground points.  <a href="classpcl_1_1_progressive_morphological_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_progressive_sample_consensus.html">ProgressiveSampleConsensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_random_sample_consensus.html" title="RandomSampleConsensus represents an implementation of the RANSAC (RANdom SAmple Consensus) algorithm,...">RandomSampleConsensus</a></b> represents an implementation of the RANSAC (RAndom SAmple Consensus) algorithm, as described in: "Matching with PROSAC – Progressive Sample Consensus", Chum, O.  <a href="classpcl_1_1_progressive_sample_consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_project_inliers.html">ProjectInliers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_project_inliers.html" title="ProjectInliers uses a model and a set of inlier indices from a PointCloud to project them into a sepa...">ProjectInliers</a></b> uses a model and a set of inlier indices from a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> to project them into a separate <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a>.  <a href="classpcl_1_1_project_inliers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_project_inliers_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">ProjectInliers&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_project_inliers.html" title="ProjectInliers uses a model and a set of inlier indices from a PointCloud to project them into a sepa...">ProjectInliers</a></b> uses a model and a set of inlier indices from a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> to project them into a separate <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a>.  <a href="classpcl_1_1_project_inliers_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_pyramid_feature_histogram.html">PyramidFeatureHistogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that compares two sets of features by using a multiscale representation of the features inside a pyramid.  <a href="classpcl_1_1_pyramid_feature_histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_quantizable_modality.html">QuantizableModality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a quantizable modality.  <a href="classpcl_1_1_quantizable_modality.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_quantized_map.html">QuantizedMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_quantized_multi_mod_feature.html">QuantizedMultiModFeature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> that defines a position and quantized value in a specific modality.  <a href="structpcl_1_1_quantized_multi_mod_feature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_quantized_normal_look_up_table.html">QuantizedNormalLookUpTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up-table for fast surface normal quantization.  <a href="structpcl_1_1_quantized_normal_look_up_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_radius_outlier_removal.html">RadiusOutlierRemoval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_radius_outlier_removal.html" title="RadiusOutlierRemoval filters points in a cloud based on the number of neighbors they have.">RadiusOutlierRemoval</a></b> filters points in a cloud based on the number of neighbors they have.  <a href="classpcl_1_1_radius_outlier_removal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_radius_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">RadiusOutlierRemoval&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_radius_outlier_removal.html" title="RadiusOutlierRemoval filters points in a cloud based on the number of neighbors they have.">RadiusOutlierRemoval</a></b> is a simple filter that removes outliers if the number of neighbors in a certain search radius is smaller than a given K.  <a href="classpcl_1_1_radius_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_randomized_m_estimator_sample_consensus.html">RandomizedMEstimatorSampleConsensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_randomized_m_estimator_sample_consensus.html" title="RandomizedMEstimatorSampleConsensus represents an implementation of the RMSAC (Randomized M-estimator...">RandomizedMEstimatorSampleConsensus</a></b> represents an implementation of the RMSAC (Randomized M-estimator SAmple Consensus) algorithm, which basically adds a Td,d test (see <em><a class="el" href="classpcl_1_1_randomized_random_sample_consensus.html" title="RandomizedRandomSampleConsensus represents an implementation of the RRANSAC (Randomized RAndom SAmple...">RandomizedRandomSampleConsensus</a></em>) to an MSAC estimator (see <em><a class="el" href="classpcl_1_1_m_estimator_sample_consensus.html" title="MEstimatorSampleConsensus represents an implementation of the MSAC (M-estimator SAmple Consensus) alg...">MEstimatorSampleConsensus</a></em>).  <a href="classpcl_1_1_randomized_m_estimator_sample_consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_randomized_random_sample_consensus.html">RandomizedRandomSampleConsensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_randomized_random_sample_consensus.html" title="RandomizedRandomSampleConsensus represents an implementation of the RRANSAC (Randomized RAndom SAmple...">RandomizedRandomSampleConsensus</a></b> represents an implementation of the RRANSAC (Randomized RAndom SAmple Consensus), as described in "Randomized RANSAC with Td,d test", O.  <a href="classpcl_1_1_randomized_random_sample_consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_random_sample.html">RandomSample</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_random_sample.html" title="RandomSample applies a random sampling with uniform probability.">RandomSample</a></b> applies a random sampling with uniform probability.  <a href="classpcl_1_1_random_sample.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_random_sample_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">RandomSample&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_random_sample.html" title="RandomSample applies a random sampling with uniform probability.">RandomSample</a></b> applies a random sampling with uniform probability.  <a href="classpcl_1_1_random_sample_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_random_sample_consensus.html">RandomSampleConsensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_random_sample_consensus.html" title="RandomSampleConsensus represents an implementation of the RANSAC (RANdom SAmple Consensus) algorithm,...">RandomSampleConsensus</a></b> represents an implementation of the RANSAC (RANdom SAmple Consensus) algorithm, as described in: "Random Sample Consensus: A Paradigm for Model Fitting with Applications to Image Analysis and 
Automated Cartography", Martin A.  <a href="classpcl_1_1_random_sample_consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_range_image.html" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where...">RangeImage</a> is derived from pcl/PointCloud and provides functionalities with focus on situations where a 3D scene was captured from a specific view point.  <a href="classpcl_1_1_range_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image_border_extractor.html">RangeImageBorderExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Extract</b> obstacle borders from range images, meaning positions where there is a transition from foreground to background.  <a href="classpcl_1_1_range_image_border_extractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image_planar.html">RangeImagePlanar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_range_image_planar.html" title="RangeImagePlanar is derived from the original range image and differs from it because it&#39;s not a sphe...">RangeImagePlanar</a></b> is derived from the original range image and differs from it because it's not a spherical projection, but using a projection plane (as normal cameras do), therefore being better applicable for range sensors that already provide a range image by themselves (stereo cameras, ToF-cameras), so that a conversion to point cloud and then to a spherical range image becomes unnecessary.  <a href="classpcl_1_1_range_image_planar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image_spherical.html">RangeImageSpherical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_range_image_spherical.html" title="RangeImageSpherical is derived from the original range image and uses a slightly different spherical ...">RangeImageSpherical</a></b> is derived from the original range image and uses a slightly different spherical projection.  <a href="classpcl_1_1_range_image_spherical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_real_sense2_grabber.html">RealSense2Grabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for Intel Realsense 2 SDK devices (D400 series)  <a href="classpcl_1_1_real_sense2_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_real_sense_grabber.html">RealSenseGrabber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_reference_frame.html">ReferenceFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_region3_d.html">Region3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_region3_d.html" title="Region3D represents summary statistics of a 3D collection of points.">Region3D</a> represents summary statistics of a 3D collection of points.  <a href="classpcl_1_1_region3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_region_growing.html">RegionGrowing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the well known Region Growing algorithm used for segmentation.  <a href="classpcl_1_1_region_growing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_region_growing_r_g_b.html">RegionGrowingRGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the well known Region Growing algorithm used for segmentation based on color of points.  <a href="classpcl_1_1_region_growing_r_g_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_region_x_y.html">RegionXY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a region in XY-space.  <a href="structpcl_1_1_region_x_y.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration.html">Registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_registration.html" title="Registration represents the base registration class for general purpose, ICP-like methods.">Registration</a></b> represents the base registration class for general purpose, ICP-like methods.  <a href="classpcl_1_1_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_registration_visualizer.html">RegistrationVisualizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_registration_visualizer.html" title="RegistrationVisualizer represents the base class for rendering the intermediate positions occupied by...">RegistrationVisualizer</a></b> represents the base class for rendering the intermediate positions occupied by the source point cloud during it's registration to the target point cloud.  <a href="classpcl_1_1_registration_visualizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_regression_variance_node.html">RegressionVarianceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node for a regression trees which optimizes variance.  <a href="classpcl_1_1_regression_variance_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_regression_variance_stats_estimator.html">RegressionVarianceStatsEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics estimator for regression trees which optimizes variance.  <a href="classpcl_1_1_regression_variance_stats_estimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_r_f_face_detector_trainer.html">RFFaceDetectorTrainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_r_g_b.html">RGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> color information.  <a href="structpcl_1_1_r_g_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_r_g_b_plane_coefficient_comparator.html">RGBPlaneCoefficientComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_r_g_b_plane_coefficient_comparator.html" title="RGBPlaneCoefficientComparator is a Comparator that operates on plane coefficients,...">RGBPlaneCoefficientComparator</a> is a <a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> that operates on plane coefficients, for use in planar segmentation.  <a href="classpcl_1_1_r_g_b_plane_coefficient_comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_r_i_f_t_estimation.html">RIFTEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_r_i_f_t_estimation.html" title="RIFTEstimation estimates the Rotation Invariant Feature Transform descriptors for a given point cloud...">RIFTEstimation</a> estimates the Rotation Invariant <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> Transform descriptors for a given point cloud dataset containing points and intensity.  <a href="classpcl_1_1_r_i_f_t_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_robot_eye_grabber.html">RobotEyeGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for the Ocular Robotics RobotEye sensor.  <a href="classpcl_1_1_robot_eye_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_r_o_p_s_estimation.html">ROPSEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the method for extracting RoPS features presented in the article "Rotational Projection Statistics for 3D Local Surface Description and Object Recognition" by Yulan Guo, Ferdous Sohel, Mohammed Bennamoun, Min Lu and Jianwei Wan.  <a href="classpcl_1_1_r_o_p_s_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_r_s_d_estimation.html">RSDEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_r_s_d_estimation.html" title="RSDEstimation estimates the Radius-based Surface Descriptor (minimal and maximal radius of the local ...">RSDEstimation</a></b> estimates the Radius-based Surface Descriptor (minimal and maximal radius of the local surface's curves) for a given point cloud dataset containing points and normals.  <a href="classpcl_1_1_r_s_d_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_a_c_segmentation.html">SACSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_s_a_c_segmentation.html" title="SACSegmentation represents the Nodelet segmentation class for Sample Consensus methods and models,...">SACSegmentation</a></b> represents the Nodelet segmentation class for Sample Consensus methods and models, in the sense that it just creates a Nodelet wrapper for generic-purpose SAC-based segmentation.  <a href="classpcl_1_1_s_a_c_segmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_a_c_segmentation_from_normals.html">SACSegmentationFromNormals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_s_a_c_segmentation_from_normals.html" title="SACSegmentationFromNormals represents the PCL nodelet segmentation class for Sample Consensus methods...">SACSegmentationFromNormals</a></b> represents the PCL nodelet segmentation class for Sample Consensus methods and models that require the use of surface normals for estimation.  <a href="classpcl_1_1_s_a_c_segmentation_from_normals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus.html">SampleConsensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus.html" title="SampleConsensus represents the base class.">SampleConsensus</a> represents the base class.  <a href="classpcl_1_1_sample_consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_initial_alignment.html">SampleConsensusInitialAlignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sample_consensus_initial_alignment.html" title="SampleConsensusInitialAlignment is an implementation of the initial alignment algorithm described in ...">SampleConsensusInitialAlignment</a></b> is an implementation of the initial alignment algorithm described in section IV of "Fast Point Feature Histograms (FPFH) for 3D Registration," Rusu et al.  <a href="classpcl_1_1_sample_consensus_initial_alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model.html">SampleConsensusModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sample_consensus_model.html" title="SampleConsensusModel represents the base model class.">SampleConsensusModel</a></b> represents the base model class.  <a href="classpcl_1_1_sample_consensus_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_circle2_d.html">SampleConsensusModelCircle2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_circle2_d.html" title="SampleConsensusModelCircle2D defines a model for 2D circle segmentation on the X-Y plane.">SampleConsensusModelCircle2D</a> defines a model for 2D circle segmentation on the X-Y plane.  <a href="classpcl_1_1_sample_consensus_model_circle2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_circle3_d.html">SampleConsensusModelCircle3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_circle3_d.html" title="SampleConsensusModelCircle3D defines a model for 3D circle segmentation.">SampleConsensusModelCircle3D</a> defines a model for 3D circle segmentation.  <a href="classpcl_1_1_sample_consensus_model_circle3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_cone.html">SampleConsensusModelCone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sample_consensus_model_cone.html" title="SampleConsensusModelCone defines a model for 3D cone segmentation.">SampleConsensusModelCone</a></b> defines a model for 3D cone segmentation.  <a href="classpcl_1_1_sample_consensus_model_cone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_cylinder.html">SampleConsensusModelCylinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sample_consensus_model_cylinder.html" title="SampleConsensusModelCylinder defines a model for 3D cylinder segmentation.">SampleConsensusModelCylinder</a></b> defines a model for 3D cylinder segmentation.  <a href="classpcl_1_1_sample_consensus_model_cylinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_from_normals.html">SampleConsensusModelFromNormals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sample_consensus_model_from_normals.html" title="SampleConsensusModelFromNormals represents the base model class for models that require the use of su...">SampleConsensusModelFromNormals</a></b> represents the base model class for models that require the use of surface normals for estimation.  <a href="classpcl_1_1_sample_consensus_model_from_normals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_line.html">SampleConsensusModelLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_line.html" title="SampleConsensusModelLine defines a model for 3D line segmentation.">SampleConsensusModelLine</a> defines a model for 3D line segmentation.  <a href="classpcl_1_1_sample_consensus_model_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_normal_parallel_plane.html">SampleConsensusModelNormalParallelPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_normal_parallel_plane.html" title="SampleConsensusModelNormalParallelPlane defines a model for 3D plane segmentation using additional su...">SampleConsensusModelNormalParallelPlane</a> defines a model for 3D plane segmentation using additional surface normal constraints.  <a href="classpcl_1_1_sample_consensus_model_normal_parallel_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_normal_plane.html">SampleConsensusModelNormalPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_normal_plane.html" title="SampleConsensusModelNormalPlane defines a model for 3D plane segmentation using additional surface no...">SampleConsensusModelNormalPlane</a> defines a model for 3D plane segmentation using additional surface normal constraints.  <a href="classpcl_1_1_sample_consensus_model_normal_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_normal_sphere.html">SampleConsensusModelNormalSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sample_consensus_model_normal_sphere.html" title="SampleConsensusModelNormalSphere defines a model for 3D sphere segmentation using additional surface ...">SampleConsensusModelNormalSphere</a></b> defines a model for 3D sphere segmentation using additional surface normal constraints.  <a href="classpcl_1_1_sample_consensus_model_normal_sphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_parallel_line.html">SampleConsensusModelParallelLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_parallel_line.html" title="SampleConsensusModelParallelLine defines a model for 3D line segmentation using additional angular co...">SampleConsensusModelParallelLine</a> defines a model for 3D line segmentation using additional angular constraints.  <a href="classpcl_1_1_sample_consensus_model_parallel_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_parallel_plane.html">SampleConsensusModelParallelPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sample_consensus_model_parallel_plane.html" title="SampleConsensusModelParallelPlane defines a model for 3D plane segmentation using additional angular ...">SampleConsensusModelParallelPlane</a></b> defines a model for 3D plane segmentation using additional angular constraints.  <a href="classpcl_1_1_sample_consensus_model_parallel_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_perpendicular_plane.html">SampleConsensusModelPerpendicularPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_perpendicular_plane.html" title="SampleConsensusModelPerpendicularPlane defines a model for 3D plane segmentation using additional ang...">SampleConsensusModelPerpendicularPlane</a> defines a model for 3D plane segmentation using additional angular constraints.  <a href="classpcl_1_1_sample_consensus_model_perpendicular_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_plane.html">SampleConsensusModelPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_plane.html" title="SampleConsensusModelPlane defines a model for 3D plane segmentation.">SampleConsensusModelPlane</a> defines a model for 3D plane segmentation.  <a href="classpcl_1_1_sample_consensus_model_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_registration.html">SampleConsensusModelRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_registration.html" title="SampleConsensusModelRegistration defines a model for Point-To-Point registration outlier rejection.">SampleConsensusModelRegistration</a> defines a model for Point-To-Point registration outlier rejection.  <a href="classpcl_1_1_sample_consensus_model_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_registration2_d.html">SampleConsensusModelRegistration2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_registration2_d.html" title="SampleConsensusModelRegistration2D defines a model for Point-To-Point registration outlier rejection ...">SampleConsensusModelRegistration2D</a> defines a model for Point-To-Point registration outlier rejection using distances between 2D pixels.  <a href="classpcl_1_1_sample_consensus_model_registration2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_sphere.html">SampleConsensusModelSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_sphere.html" title="SampleConsensusModelSphere defines a model for 3D sphere segmentation.">SampleConsensusModelSphere</a> defines a model for 3D sphere segmentation.  <a href="classpcl_1_1_sample_consensus_model_sphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_model_stick.html">SampleConsensusModelStick</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_sample_consensus_model_stick.html" title="SampleConsensusModelStick defines a model for 3D stick segmentation.">SampleConsensusModelStick</a> defines a model for 3D stick segmentation.  <a href="classpcl_1_1_sample_consensus_model_stick.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sample_consensus_prerejective.html">SampleConsensusPrerejective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose estimation and alignment class using a prerejective RANSAC routine.  <a href="classpcl_1_1_sample_consensus_prerejective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_sampling_surface_normal.html">SamplingSurfaceNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_sampling_surface_normal.html" title="SamplingSurfaceNormal divides the input space into grids until each grid contains a maximum of N poin...">SamplingSurfaceNormal</a></b> divides the input space into grids until each grid contains a maximum of N points, and samples points randomly within each grid.  <a href="classpcl_1_1_sampling_surface_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler.html">ScaledMultiChannel2DComparisonFeatureHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> utility class that handles the creation and evaluation of RGBD comparison features.  <a href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler_c_code_generator.html">ScaledMultiChannel2DComparisonFeatureHandlerCCodeGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_scope_time.html">ScopeTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to measure the time spent in a scope.  <a href="classpcl_1_1_scope_time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_seeded_hue_segmentation.html">SeededHueSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_seeded_hue_segmentation.html" title="SeededHueSegmentation.">SeededHueSegmentation</a>.  <a href="classpcl_1_1_seeded_hue_segmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_segment_differences.html">SegmentDifferences</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_segment_differences.html" title="SegmentDifferences obtains the difference between two spatially aligned point clouds and returns the ...">SegmentDifferences</a></b> obtains the difference between two spatially aligned point clouds and returns the difference between them for a maximum given distance threshold.  <a href="classpcl_1_1_segment_differences.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_set_if_field_exists.html">SetIfFieldExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper functor that can set a specific value in a field if the field exists.  <a href="structpcl_1_1_set_if_field_exists.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_shadow_points.html">ShadowPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_shadow_points.html" title="ShadowPoints removes the ghost points appearing on edge discontinuties">ShadowPoints</a></b> removes the ghost points appearing on edge discontinuties  <a href="classpcl_1_1_shadow_points.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_shape_context1980.html">ShapeContext1980</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing a Shape Context.  <a href="structpcl_1_1_shape_context1980.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_shape_context3_d_estimation.html">ShapeContext3DEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_shape_context3_d_estimation.html" title="ShapeContext3DEstimation implements the 3D shape context descriptor as described in:">ShapeContext3DEstimation</a> implements the 3D shape context descriptor as described in:  <a href="classpcl_1_1_shape_context3_d_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_h_o_t1344.html">SHOT1344</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the generic Signature of Histograms of OrienTations (SHOT) - shape+color.  <a href="structpcl_1_1_s_h_o_t1344.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_h_o_t352.html">SHOT352</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the generic Signature of Histograms of OrienTations (SHOT) - shape only.  <a href="structpcl_1_1_s_h_o_t352.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_color_estimation.html">SHOTColorEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_h_o_t_color_estimation.html" title="SHOTColorEstimation estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a giv...">SHOTColorEstimation</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points, normals and colors.  <a href="classpcl_1_1_s_h_o_t_color_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_color_estimation_o_m_p.html">SHOTColorEstimationOMP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_h_o_t_color_estimation_o_m_p.html" title="SHOTColorEstimationOMP estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a ...">SHOTColorEstimationOMP</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points, normals and colors, in parallel, using the OpenMP standard.  <a href="classpcl_1_1_s_h_o_t_color_estimation_o_m_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_estimation.html">SHOTEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_h_o_t_estimation.html" title="SHOTEstimation estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given po...">SHOTEstimation</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points and normals.  <a href="classpcl_1_1_s_h_o_t_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_estimation_base.html">SHOTEstimationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_h_o_t_estimation.html" title="SHOTEstimation estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given po...">SHOTEstimation</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points and normals.  <a href="classpcl_1_1_s_h_o_t_estimation_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_estimation_o_m_p.html">SHOTEstimationOMP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_h_o_t_estimation_o_m_p.html" title="SHOTEstimationOMP estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given...">SHOTEstimationOMP</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points and normals, in parallel, using the OpenMP standard.  <a href="classpcl_1_1_s_h_o_t_estimation_o_m_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation.html">SHOTLocalReferenceFrameEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation.html" title="SHOTLocalReferenceFrameEstimation estimates the Local Reference Frame used in the calculation of the ...">SHOTLocalReferenceFrameEstimation</a> estimates the Local Reference Frame used in the calculation of the (SHOT) descriptor.  <a href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation_o_m_p.html">SHOTLocalReferenceFrameEstimationOMP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation.html" title="SHOTLocalReferenceFrameEstimation estimates the Local Reference Frame used in the calculation of the ...">SHOTLocalReferenceFrameEstimation</a> estimates the Local Reference Frame used in the calculation of the (SHOT) descriptor.  <a href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation_o_m_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_i_f_t_keypoint.html">SIFTKeypoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_s_i_f_t_keypoint.html" title="SIFTKeypoint detects the Scale Invariant Feature Transform keypoints for a given point cloud dataset ...">SIFTKeypoint</a></b> detects the Scale Invariant <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> Transform keypoints for a given point cloud dataset containing points and intensity.  <a href="classpcl_1_1_s_i_f_t_keypoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_i_f_t_keypoint_field_selector.html">SIFTKeypointFieldSelector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_i_f_t_keypoint_field_selector_3_01_point_normal_01_4.html">SIFTKeypointFieldSelector&lt; PointNormal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_i_f_t_keypoint_field_selector_3_01_point_x_y_z_r_g_b_01_4.html">SIFTKeypointFieldSelector&lt; PointXYZRGB &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_i_f_t_keypoint_field_selector_3_01_point_x_y_z_r_g_b_a_01_4.html">SIFTKeypointFieldSelector&lt; PointXYZRGBA &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_smoothed_surfaces_keypoint.html">SmoothedSurfacesKeypoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on the paper: Xinju Li and Igor Guskov Multi-scale features for approximate alignment of point-based surfaces Proceedings of the third Eurographics symposium on <a class="el" href="class_geometry.html">Geometry</a> processing July 2005, Vienna, Austria.  <a href="classpcl_1_1_smoothed_surfaces_keypoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_solver_didnt_converge_exception.html">SolverDidntConvergeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown when the non linear solver didn't converge.  <a href="classpcl_1_1_solver_didnt_converge_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_sparse_quantized_multi_mod_template.html">SparseQuantizedMultiModTemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-modality template constructed from a set of quantized multi-modality features.  <a href="structpcl_1_1_sparse_quantized_multi_mod_template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_spin_image_estimation.html">SpinImageEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates spin-image descriptors in the given input points.  <a href="classpcl_1_1_spin_image_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_static_range_coder.html">StaticRangeCoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_static_range_coder.html" title="StaticRangeCoder compression class">StaticRangeCoder</a></b> compression class  <a href="classpcl_1_1_static_range_coder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_statistical_multiscale_interest_region_extraction.html">StatisticalMultiscaleInterestRegionExtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for extracting interest regions from unstructured point clouds, based on a multi scale statistical approach.  <a href="classpcl_1_1_statistical_multiscale_interest_region_extraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_statistical_outlier_removal.html">StatisticalOutlierRemoval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_statistical_outlier_removal.html" title="StatisticalOutlierRemoval uses point neighborhood statistics to filter outlier data.">StatisticalOutlierRemoval</a></b> uses point neighborhood statistics to filter outlier data.  <a href="classpcl_1_1_statistical_outlier_removal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_statistical_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">StatisticalOutlierRemoval&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_statistical_outlier_removal.html" title="StatisticalOutlierRemoval uses point neighborhood statistics to filter outlier data.">StatisticalOutlierRemoval</a></b> uses point neighborhood statistics to filter outlier data.  <a href="classpcl_1_1_statistical_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_stats_estimator.html">StatsEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class interface for gathering statistics for decision tree learning.  <a href="classpcl_1_1_stats_estimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_stereo_grabber.html">StereoGrabber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_stereo_grabber_base.html">StereoGrabberBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Stereo file grabber.  <a href="classpcl_1_1_stereo_grabber_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_stereo_matching.html">StereoMatching</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stereo Matching abstract class.  <a href="classpcl_1_1_stereo_matching.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_stop_watch.html">StopWatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple stopwatch.  <a href="classpcl_1_1_stop_watch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_supervoxel.html">Supervoxel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_supervoxel.html" title="Supervoxel container class - stores a cluster extracted using supervoxel clustering.">Supervoxel</a> container class - stores a cluster extracted using supervoxel clustering.  <a href="classpcl_1_1_supervoxel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_supervoxel_clustering.html">SupervoxelClustering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a supervoxel algorithm based on voxel structure, normals, and rgb values.  <a href="classpcl_1_1_supervoxel_clustering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_normal_modality.html">SurfaceNormalModality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modality based on surface normals.  <a href="classpcl_1_1_surface_normal_modality.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html">SurfaceReconstruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_surface_reconstruction.html" title="SurfaceReconstruction represents a base surface reconstruction class.">SurfaceReconstruction</a> represents a base surface reconstruction class.  <a href="classpcl_1_1_surface_reconstruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surfel_smoothing.html">SurfelSmoothing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_u_s_a_n_keypoint.html">SUSANKeypoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_u_s_a_n_keypoint.html" title="SUSANKeypoint implements a RGB-D extension of the SUSAN detector including normal directions variatio...">SUSANKeypoint</a> implements a RGB-D extension of the SUSAN detector including normal directions variation in top of intensity variation.  <a href="classpcl_1_1_s_u_s_a_n_keypoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_v_m.html">SVM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classpcl_1_1_s_v_m.html" title="Base class for SVM SVM (Support Vector Machines).">SVM</a> <a class="el" href="classpcl_1_1_s_v_m.html" title="Base class for SVM SVM (Support Vector Machines).">SVM</a> (Support Vector Machines).  <a href="classpcl_1_1_s_v_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_v_m_classify.html">SVMClassify</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_v_m.html" title="Base class for SVM SVM (Support Vector Machines).">SVM</a> (Support Vector Machines) classification of a dataset.  <a href="classpcl_1_1_s_v_m_classify.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_v_m_data.html">SVMData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure stores the features and the label of a single sample which has to be used for the training or the classification of the <a class="el" href="classpcl_1_1_s_v_m.html" title="Base class for SVM SVM (Support Vector Machines).">SVM</a> (Support Vector Machines).  <a href="structpcl_1_1_s_v_m_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_v_m_data_point.html">SVMDataPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure initialize a single feature value for the classification using <a class="el" href="classpcl_1_1_s_v_m.html" title="Base class for SVM SVM (Support Vector Machines).">SVM</a> (Support Vector Machines).  <a href="structpcl_1_1_s_v_m_data_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_v_m_model.html">SVMModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure initialize a model created by the <a class="el" href="classpcl_1_1_s_v_m.html" title="Base class for SVM SVM (Support Vector Machines).">SVM</a> (Support Vector Machines) classifier (<a class="el" href="classpcl_1_1_s_v_m_train.html" title="SVM (Support Vector Machines) training class for the SVM machine learning.">pcl::SVMTrain</a>).  <a href="structpcl_1_1_s_v_m_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_v_m_param.html">SVMParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure stores the parameters for the classificationa nd must be initialized and passed to the training method <a class="el" href="classpcl_1_1_s_v_m_train.html" title="SVM (Support Vector Machines) training class for the SVM machine learning.">pcl::SVMTrain</a>.  <a href="structpcl_1_1_s_v_m_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_v_m_train.html">SVMTrain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_s_v_m.html" title="Base class for SVM SVM (Support Vector Machines).">SVM</a> (Support Vector Machines) training class for the <a class="el" href="classpcl_1_1_s_v_m.html" title="Base class for SVM SVM (Support Vector Machines).">SVM</a> machine learning.  <a href="classpcl_1_1_s_v_m_train.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_synchronized_queue.html">SynchronizedQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_synchronizer.html">Synchronizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">/brief This template class synchronizes two data streams of different types.  <a href="classpcl_1_1_synchronizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ternary_tree_missing_data_branch_estimator.html">TernaryTreeMissingDataBranchEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branch estimator for ternary trees where one branch is used for missing data (indicated by flag != 0).  <a href="classpcl_1_1_ternary_tree_missing_data_branch_estimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_tex_material.html">TexMaterial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_texture_mapping.html">TextureMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The texture mapping algorithm.  <a href="classpcl_1_1_texture_mapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_texture_mesh.html">TextureMesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_tf_quadratic_x_y_z_comparison.html">TfQuadraticXYZComparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparison whether the (x,y,z) components of a given point satisfy (p'Ap + 2v'p + c [OP] 0).  <a href="classpcl_1_1_tf_quadratic_x_y_z_comparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_time_trigger.html">TimeTrigger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer class that invokes registered callback methods periodically.  <a href="classpcl_1_1_time_trigger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_trajkovic_keypoint2_d.html">TrajkovicKeypoint2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_trajkovic_keypoint2_d.html" title="TrajkovicKeypoint2D implements Trajkovic and Hedley corner detector on organized pooint cloud using i...">TrajkovicKeypoint2D</a> implements Trajkovic and Hedley corner detector on organized pooint cloud using intensity information.  <a href="classpcl_1_1_trajkovic_keypoint2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_trajkovic_keypoint3_d.html">TrajkovicKeypoint3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_trajkovic_keypoint3_d.html" title="TrajkovicKeypoint3D implements Trajkovic and Hedley corner detector on point cloud using geometric in...">TrajkovicKeypoint3D</a> implements Trajkovic and Hedley corner detector on point cloud using geometric information.  <a href="classpcl_1_1_trajkovic_keypoint3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_transformation_from_correspondences.html">TransformationFromCorrespondences</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a transformation based on corresponding 3D points.  <a href="classpcl_1_1_transformation_from_correspondences.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_t_s_d_f_volume.html">TSDFVolume</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_unary_classifier.html">UnaryClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_unhandled_point_type_exception.html">UnhandledPointTypeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_uniform_sampling.html">UniformSampling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b><a class="el" href="classpcl_1_1_uniform_sampling.html" title="UniformSampling assembles a local 3D grid over a given PointCloud, and downsamples + filters the data...">UniformSampling</a></b> assembles a local 3D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a>, and downsamples + filters the data.  <a href="classpcl_1_1_uniform_sampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_unique_shape_context.html">UniqueShapeContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_unique_shape_context.html" title="UniqueShapeContext implements the Unique Shape Context Descriptor described here:">UniqueShapeContext</a> implements the Unique Shape Context Descriptor described here:  <a href="classpcl_1_1_unique_shape_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_unique_shape_context1960.html">UniqueShapeContext1960</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing a Unique Shape Context.  <a href="structpcl_1_1_unique_shape_context1960.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_unorganized_point_cloud_exception.html">UnorganizedPointCloudException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that is thrown when an organized point cloud is needed but not provided.  <a href="classpcl_1_1_unorganized_point_cloud_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_vector_average.html">VectorAverage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the weighted average and the covariance matrix.  <a href="classpcl_1_1_vector_average.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_vertices.html">Vertices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a set of vertices in a polygon mesh, by basically storing an array of indices.  <a href="structpcl_1_1_vertices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_v_f_h_estimation.html">VFHEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_v_f_h_estimation.html" title="VFHEstimation estimates the Viewpoint Feature Histogram (VFH) descriptor for a given point cloud data...">VFHEstimation</a> estimates the <b>Viewpoint <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (VFH)</b> descriptor for a given point cloud dataset containing points and normals.  <a href="classpcl_1_1_v_f_h_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_v_f_h_signature308.html">VFHSignature308</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Viewpoint <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (VFH).  <a href="structpcl_1_1_v_f_h_signature308.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_v_l_p_grabber.html">VLPGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_grabber.html" title="Grabber interface for PCL 1.x device drivers.">Grabber</a> for the Velodyne LiDAR (VLP), based on the Velodyne High Definition Laser (HDL)  <a href="classpcl_1_1_v_l_p_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_voxel_grid.html">VoxelGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_voxel_grid.html" title="VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data.">VoxelGrid</a> assembles a local 3D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a>, and downsamples + filters the data.  <a href="classpcl_1_1_voxel_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_voxel_grid_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html">VoxelGrid&lt; pcl::PCLPointCloud2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_voxel_grid.html" title="VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data.">VoxelGrid</a> assembles a local 3D grid over a given <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a>, and downsamples + filters the data.  <a href="classpcl_1_1_voxel_grid_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_voxel_grid_covariance.html">VoxelGridCovariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A searchable voxel strucure containing the mean and covariance of the data.  <a href="classpcl_1_1_voxel_grid_covariance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_voxel_grid_label.html">VoxelGridLabel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_voxel_grid_occlusion_estimation.html">VoxelGridOcclusionEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_voxel_grid.html" title="VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data.">VoxelGrid</a> to estimate occluded space in the scene.  <a href="classpcl_1_1_voxel_grid_occlusion_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_v_t_k_utils.html">VTKUtils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1x_nd_copy_eigen_point_functor.html">xNdCopyEigenPointFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor structure for copying data between an Eigen::VectorXf and a PointT.  <a href="structpcl_1_1x_nd_copy_eigen_point_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1x_nd_copy_point_eigen_functor.html">xNdCopyPointEigenFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor structure for copying data between an Eigen::VectorXf and a PointT.  <a href="structpcl_1_1x_nd_copy_point_eigen_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a50f06eaf95ee8d0c6af44271124a3660"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a50f06eaf95ee8d0c6af44271124a3660">BivariatePolynomiald</a> = <a class="el" href="classpcl_1_1_bivariate_polynomial_t.html">BivariatePolynomialT</a>&lt; double &gt;</td></tr>
<tr class="separator:a50f06eaf95ee8d0c6af44271124a3660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f368bb27adce3e34778c4da706d99cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3f368bb27adce3e34778c4da706d99cc">BivariatePolynomial</a> = <a class="el" href="classpcl_1_1_bivariate_polynomial_t.html">BivariatePolynomialT</a>&lt; float &gt;</td></tr>
<tr class="separator:a3f368bb27adce3e34778c4da706d99cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba82385a43e15881364be0c2e3d4296"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7ba82385a43e15881364be0c2e3d4296">GlasbeyLUT</a> = <a class="el" href="classpcl_1_1_color_l_u_t.html">ColorLUT</a>&lt; <a class="el" href="namespacepcl.html#a617dd0c1fbdf854bfbfb9ef2943665aba4583b0f87c691c76ca961b2bcbd99eea">pcl::LUT_GLASBEY</a> &gt;</td></tr>
<tr class="separator:a7ba82385a43e15881364be0c2e3d4296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f5a094c924a88a345aae1da1cb9aba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a25f5a094c924a88a345aae1da1cb9aba">ViridisLUT</a> = <a class="el" href="classpcl_1_1_color_l_u_t.html">ColorLUT</a>&lt; <a class="el" href="namespacepcl.html#a617dd0c1fbdf854bfbfb9ef2943665aba63f4dba9bc10114af8e426b4b878d854">pcl::LUT_VIRIDIS</a> &gt;</td></tr>
<tr class="separator:a25f5a094c924a88a345aae1da1cb9aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e00f23039fed247228ae9ae17325e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a34e00f23039fed247228ae9ae17325e0">PolynomialCalculationsd</a> = <a class="el" href="classpcl_1_1_polynomial_calculations_t.html">PolynomialCalculationsT</a>&lt; double &gt;</td></tr>
<tr class="separator:a34e00f23039fed247228ae9ae17325e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb0aae9ce07363038a232bdf3aea749"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8bb0aae9ce07363038a232bdf3aea749">PolynomialCalculations</a> = <a class="el" href="classpcl_1_1_polynomial_calculations_t.html">PolynomialCalculationsT</a>&lt; float &gt;</td></tr>
<tr class="separator:a8bb0aae9ce07363038a232bdf3aea749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76216d9ffebafc2fd60d2c21885ae86b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a76216d9ffebafc2fd60d2c21885ae86b">VectorAverage2f</a> = <a class="el" href="classpcl_1_1_vector_average.html">VectorAverage</a>&lt; float, 2 &gt;</td></tr>
<tr class="separator:a76216d9ffebafc2fd60d2c21885ae86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0669ff605ec2dcbf01300e309fc658f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0669ff605ec2dcbf01300e309fc658f2">VectorAverage3f</a> = <a class="el" href="classpcl_1_1_vector_average.html">VectorAverage</a>&lt; float, 3 &gt;</td></tr>
<tr class="separator:a0669ff605ec2dcbf01300e309fc658f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66951b4ad71c91a0b49545ac199ba38a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a66951b4ad71c91a0b49545ac199ba38a">VectorAverage4f</a> = <a class="el" href="classpcl_1_1_vector_average.html">VectorAverage</a>&lt; float, 4 &gt;</td></tr>
<tr class="separator:a66951b4ad71c91a0b49545ac199ba38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e904e5c6f763188a410832f96ac00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">Correspondences</a> = std::vector&lt; <a class="el" href="structpcl_1_1_correspondence.html">pcl::Correspondence</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_correspondence.html">pcl::Correspondence</a> &gt; &gt;</td></tr>
<tr class="separator:a5f8e904e5c6f763188a410832f96ac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f6f222e9a2be3c0fa8cdf49903c1aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a12f6f222e9a2be3c0fa8cdf49903c1aa">CorrespondencesPtr</a> = shared_ptr&lt; <a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">Correspondences</a> &gt;</td></tr>
<tr class="separator:a12f6f222e9a2be3c0fa8cdf49903c1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359b3e0a2e6a4f2d71b22cb32004862d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a359b3e0a2e6a4f2d71b22cb32004862d">CorrespondencesConstPtr</a> = shared_ptr&lt; const <a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">Correspondences</a> &gt;</td></tr>
<tr class="separator:a359b3e0a2e6a4f2d71b22cb32004862d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76674024fd731f2ee3974c518576e53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab76674024fd731f2ee3974c518576e53">PointCorrespondences3DVector</a> = std::vector&lt; <a class="el" href="structpcl_1_1_point_correspondence3_d.html">PointCorrespondence3D</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_correspondence3_d.html">PointCorrespondence3D</a> &gt; &gt;</td></tr>
<tr class="separator:ab76674024fd731f2ee3974c518576e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa4bb55445446ac9dad1ccd1d87b861"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#adaa4bb55445446ac9dad1ccd1d87b861">PointCorrespondences6DVector</a> = std::vector&lt; <a class="el" href="structpcl_1_1_point_correspondence6_d.html">PointCorrespondence6D</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_correspondence6_d.html">PointCorrespondence6D</a> &gt; &gt;</td></tr>
<tr class="separator:adaa4bb55445446ac9dad1ccd1d87b861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad407d69b35fab38328de6519fc5971b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad407d69b35fab38328de6519fc5971b5">Array3fMap</a> = Eigen::Map&lt; Eigen::Array3f &gt;</td></tr>
<tr class="separator:ad407d69b35fab38328de6519fc5971b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd080c373c46953232448f70566dbeca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abd080c373c46953232448f70566dbeca">Array3fMapConst</a> = const Eigen::Map&lt; const Eigen::Array3f &gt;</td></tr>
<tr class="separator:abd080c373c46953232448f70566dbeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934d06850ba45c8cc47e5cdc6da0b0ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a934d06850ba45c8cc47e5cdc6da0b0ce">Array4fMap</a> = Eigen::Map&lt; Eigen::Array4f, Eigen::Aligned &gt;</td></tr>
<tr class="separator:a934d06850ba45c8cc47e5cdc6da0b0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbe388fc6305729a2005fb6b30cf1fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8bbe388fc6305729a2005fb6b30cf1fb">Array4fMapConst</a> = const Eigen::Map&lt; const Eigen::Array4f, Eigen::Aligned &gt;</td></tr>
<tr class="separator:a8bbe388fc6305729a2005fb6b30cf1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b40c6dea7a9ea4d94e83519bdbe38a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a76b40c6dea7a9ea4d94e83519bdbe38a">Vector3fMap</a> = Eigen::Map&lt; Eigen::Vector3f &gt;</td></tr>
<tr class="separator:a76b40c6dea7a9ea4d94e83519bdbe38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646587b6e57635d1fa584cd7186ecc9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6646587b6e57635d1fa584cd7186ecc9">Vector3fMapConst</a> = const Eigen::Map&lt; const Eigen::Vector3f &gt;</td></tr>
<tr class="separator:a6646587b6e57635d1fa584cd7186ecc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2577a5ee21a3af86d334a1d8f2824a25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2577a5ee21a3af86d334a1d8f2824a25">Vector4fMap</a> = Eigen::Map&lt; Eigen::Vector4f, Eigen::Aligned &gt;</td></tr>
<tr class="separator:a2577a5ee21a3af86d334a1d8f2824a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868c010207876ae6613dc04f5e9f9e46"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a868c010207876ae6613dc04f5e9f9e46">Vector4fMapConst</a> = const Eigen::Map&lt; const Eigen::Vector4f, Eigen::Aligned &gt;</td></tr>
<tr class="separator:a868c010207876ae6613dc04f5e9f9e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e50f13135d27977665a621922ce6f15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8e50f13135d27977665a621922ce6f15">Vector3c</a> = Eigen::Matrix&lt; std::uint8_t, 3, 1 &gt;</td></tr>
<tr class="separator:a8e50f13135d27977665a621922ce6f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e24d7da943faacfceecdd0d52ef704"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ac0e24d7da943faacfceecdd0d52ef704">Vector3cMap</a> = Eigen::Map&lt; <a class="el" href="namespacepcl.html#a8e50f13135d27977665a621922ce6f15">Vector3c</a> &gt;</td></tr>
<tr class="separator:ac0e24d7da943faacfceecdd0d52ef704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fac8027055b30756aeaa4a2143a4c1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6fac8027055b30756aeaa4a2143a4c1b">Vector3cMapConst</a> = const Eigen::Map&lt; const <a class="el" href="namespacepcl.html#a8e50f13135d27977665a621922ce6f15">Vector3c</a> &gt;</td></tr>
<tr class="separator:a6fac8027055b30756aeaa4a2143a4c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f12fe818900868f62f44cbe3e69070"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a84f12fe818900868f62f44cbe3e69070">Vector4c</a> = Eigen::Matrix&lt; std::uint8_t, 4, 1 &gt;</td></tr>
<tr class="separator:a84f12fe818900868f62f44cbe3e69070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aef7c957446afe2803849e70a77ba97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3aef7c957446afe2803849e70a77ba97">Vector4cMap</a> = Eigen::Map&lt; <a class="el" href="namespacepcl.html#a84f12fe818900868f62f44cbe3e69070">Vector4c</a>, Eigen::Aligned &gt;</td></tr>
<tr class="separator:a3aef7c957446afe2803849e70a77ba97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbed164f7149b4fec73541a52633f33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2dbed164f7149b4fec73541a52633f33">Vector4cMapConst</a> = const Eigen::Map&lt; const <a class="el" href="namespacepcl.html#a84f12fe818900868f62f44cbe3e69070">Vector4c</a>, Eigen::Aligned &gt;</td></tr>
<tr class="separator:a2dbed164f7149b4fec73541a52633f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad856b1db80591d2019b5781993550c83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad856b1db80591d2019b5781993550c83">ModelCoefficientsPtr</a> = <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">ModelCoefficients::Ptr</a></td></tr>
<tr class="separator:ad856b1db80591d2019b5781993550c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8212c54e01f75c163675dd96006e07d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8212c54e01f75c163675dd96006e07d0">ModelCoefficientsConstPtr</a> = <a class="el" href="structpcl_1_1_model_coefficients.html#ae10f3f75a03c6513e1665cd28ea50881">ModelCoefficients::ConstPtr</a></td></tr>
<tr class="separator:a8212c54e01f75c163675dd96006e07d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11731b62628e35f6adc312d1cdaf372"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a> = shared_ptr&lt; <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &gt;</td></tr>
<tr class="separator:ab11731b62628e35f6adc312d1cdaf372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011f84e43d80cb736d9ec9abd0930024"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a011f84e43d80cb736d9ec9abd0930024">IndicesConstPtr</a> = shared_ptr&lt; const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &gt;</td></tr>
<tr class="separator:a011f84e43d80cb736d9ec9abd0930024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022355a03682d73506ff03a07099e238"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a022355a03682d73506ff03a07099e238">HeaderPtr</a> = <a class="el" href="structpcl_1_1_p_c_l_header.html#a55b3c053bb47cda7ff147d98c050543b">PCLHeader::Ptr</a></td></tr>
<tr class="separator:a022355a03682d73506ff03a07099e238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2169862b7553da3717fe1c1df021a2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af2169862b7553da3717fe1c1df021a2f">HeaderConstPtr</a> = <a class="el" href="structpcl_1_1_p_c_l_header.html#a8d3dfee745a5d239e2e7f7d5972621cd">PCLHeader::ConstPtr</a></td></tr>
<tr class="separator:af2169862b7553da3717fe1c1df021a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae135037ab459b4319a895d765758a57a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae135037ab459b4319a895d765758a57a">PCLImagePtr</a> = <a class="el" href="structpcl_1_1_p_c_l_image.html#ac6b9a9cd5f96ca68e8bc15b7db7846cb">PCLImage::Ptr</a></td></tr>
<tr class="separator:ae135037ab459b4319a895d765758a57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09315268fe8cf472847ea6f7e6f786e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab09315268fe8cf472847ea6f7e6f786e">PCLImageConstPtr</a> = <a class="el" href="structpcl_1_1_p_c_l_image.html#aa6866e76de8f68a5b0cf16ffc62dff87">PCLImage::ConstPtr</a></td></tr>
<tr class="separator:ab09315268fe8cf472847ea6f7e6f786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ae712f092fbdb4a77bddd2310cdab5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a73ae712f092fbdb4a77bddd2310cdab5">PCLPointCloud2Ptr</a> = <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html#a5123c3c0386ccc5efd7d7a3b70fdc9bc">PCLPointCloud2::Ptr</a></td></tr>
<tr class="separator:a73ae712f092fbdb4a77bddd2310cdab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64de997fa516c97e85cf8dc9d72146d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad64de997fa516c97e85cf8dc9d72146d">PCLPointCloud2ConstPtr</a> = <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html#ad44a1f084d41d5bac3d41fe247364bb5">PCLPointCloud2::ConstPtr</a></td></tr>
<tr class="separator:ad64de997fa516c97e85cf8dc9d72146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e42abe7fe47c172f71d02855e1136d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab8e42abe7fe47c172f71d02855e1136d">PCLPointFieldPtr</a> = <a class="el" href="structpcl_1_1_p_c_l_point_field.html#afaf15e7f600289cc628874bc9b87de61">PCLPointField::Ptr</a></td></tr>
<tr class="separator:ab8e42abe7fe47c172f71d02855e1136d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0442b7abe91ce5799302859bee6d6f86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0442b7abe91ce5799302859bee6d6f86">PCLPointFieldConstPtr</a> = <a class="el" href="structpcl_1_1_p_c_l_point_field.html#ab719c9f0266eec0d4cd59b76f73b894f">PCLPointField::ConstPtr</a></td></tr>
<tr class="separator:a0442b7abe91ce5799302859bee6d6f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae716f0bdfbc7ae033006733a42fb6b63"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae716f0bdfbc7ae033006733a42fb6b63">MsgFieldMap</a> = std::vector&lt; <a class="el" href="structpcl_1_1detail_1_1_field_mapping.html">detail::FieldMapping</a> &gt;</td></tr>
<tr class="separator:ae716f0bdfbc7ae033006733a42fb6b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2b6757a09f69abeb6795cc0956acbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gafb2b6757a09f69abeb6795cc0956acbf">BorderTraits</a> = std::bitset&lt; 32 &gt;</td></tr>
<tr class="memdesc:gafb2b6757a09f69abeb6795cc0956acbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type to store extended information about a transition from foreground to backgroundSpecification of the fields for <a class="el" href="structpcl_1_1_border_description.html#a48b78318ec7151ebca3d61a47891470c">BorderDescription::traits</a>.  <a href="group__common.html#gafb2b6757a09f69abeb6795cc0956acbf">More...</a><br /></td></tr>
<tr class="separator:gafb2b6757a09f69abeb6795cc0956acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9648b74014e6b52eb855a7f75dad9806"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9648b74014e6b52eb855a7f75dad9806">PointIndicesPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a3c574b78dfbe67c93d09acdbc8ecc499">PointIndices::Ptr</a></td></tr>
<tr class="separator:a9648b74014e6b52eb855a7f75dad9806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf931dfa9573efdfea6ca35cb8a52993"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aaf931dfa9573efdfea6ca35cb8a52993">PointIndicesConstPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a6880da079270712d46b0bb348cf124bc">PointIndices::ConstPtr</a></td></tr>
<tr class="separator:aaf931dfa9573efdfea6ca35cb8a52993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52624ff976b10c9bc0bbec9fec13c5f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a52624ff976b10c9bc0bbec9fec13c5f3">PolygonMeshPtr</a> = <a class="el" href="structpcl_1_1_polygon_mesh.html#a99c6fe1a6692ce2d9cd51363e254e554">PolygonMesh::Ptr</a></td></tr>
<tr class="separator:a52624ff976b10c9bc0bbec9fec13c5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da120eaa8024e3bf1ef6a4c4ec29f32"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0da120eaa8024e3bf1ef6a4c4ec29f32">PolygonMeshConstPtr</a> = <a class="el" href="structpcl_1_1_polygon_mesh.html#ae9324cf4996134d4d1b8034b3fceee90">PolygonMesh::ConstPtr</a></td></tr>
<tr class="separator:a0da120eaa8024e3bf1ef6a4c4ec29f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a4202aed992879df6a4c58fb7ed82e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a35a4202aed992879df6a4c58fb7ed82e">TextureMeshPtr</a> = <a class="el" href="structpcl_1_1_texture_mesh.html#adeefe5363d8f45241db45422f733ab57">TextureMesh::Ptr</a></td></tr>
<tr class="separator:a35a4202aed992879df6a4c58fb7ed82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73edca3e6c28df5ff439bce6a795d635"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a73edca3e6c28df5ff439bce6a795d635">TextureMeshConstPtr</a> = <a class="el" href="structpcl_1_1_texture_mesh.html#ab7696e9d1c3660272032c20b65e88fc7">TextureMesh::ConstPtr</a></td></tr>
<tr class="separator:a73edca3e6c28df5ff439bce6a795d635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a3f6db24e4059a582c45b8650bf9d2"><td class="memTemplParams" colspan="2">template&lt;typename ... &gt; </td></tr>
<tr class="memitem:ac6a3f6db24e4059a582c45b8650bf9d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ac6a3f6db24e4059a582c45b8650bf9d2">void_t</a> = void</td></tr>
<tr class="separator:ac6a3f6db24e4059a582c45b8650bf9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8ace9e1a2351f301fd4b89b2940811"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aea8ace9e1a2351f301fd4b89b2940811">uint8_t</a> = std::uint8_t</td></tr>
<tr class="separator:aea8ace9e1a2351f301fd4b89b2940811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3b61cc55405d1a0c938d0c57cd59fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abf3b61cc55405d1a0c938d0c57cd59fa">int8_t</a> = std::int8_t</td></tr>
<tr class="separator:abf3b61cc55405d1a0c938d0c57cd59fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318eea0dc010eb432540e93fb326903b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a318eea0dc010eb432540e93fb326903b">uint16_t</a> = std::uint16_t</td></tr>
<tr class="separator:a318eea0dc010eb432540e93fb326903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76057dcaa0702a6e8d9e773bf07d5b11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a76057dcaa0702a6e8d9e773bf07d5b11">int16_t</a> = std::int16_t</td></tr>
<tr class="separator:a76057dcaa0702a6e8d9e773bf07d5b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c55bf09e463d214a43d2bd7ceab7753"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7c55bf09e463d214a43d2bd7ceab7753">uint32_t</a> = std::uint32_t</td></tr>
<tr class="separator:a7c55bf09e463d214a43d2bd7ceab7753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f80e711ed71e4073df27290bfc78ff6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4f80e711ed71e4073df27290bfc78ff6">int32_t</a> = std::int32_t</td></tr>
<tr class="separator:a4f80e711ed71e4073df27290bfc78ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85445a07c77c6f3645992c10121518b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad85445a07c77c6f3645992c10121518b">uint64_t</a> = std::uint64_t</td></tr>
<tr class="separator:ad85445a07c77c6f3645992c10121518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bef31b992d634256c4fb4a3d70295d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af7bef31b992d634256c4fb4a3d70295d">int64_t</a> = std::int64_t</td></tr>
<tr class="separator:af7bef31b992d634256c4fb4a3d70295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f14fad13f3505c22aab07eb88865fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a15f14fad13f3505c22aab07eb88865fd">int_fast16_t</a> = std::int_fast16_t</td></tr>
<tr class="separator:a15f14fad13f3505c22aab07eb88865fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45edbae979af563e6a1e39fd1aad3911"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> = <a class="el" href="namespacepcl_1_1detail.html#a3f3400ba40ee203c842481cfbb716900">detail::int_type_t</a>&lt; <a class="el" href="namespacepcl_1_1detail.html#a485d0d8c7a7b9981ac9e76ab821a38e4">detail::index_type_size</a>, <a class="el" href="namespacepcl_1_1detail.html#a0d5f9ba23dbec1366c9021dc149c9925">detail::index_type_signed</a> &gt;</td></tr>
<tr class="memdesc:a45edbae979af563e6a1e39fd1aad3911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for an index in PCL.  <a href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">More...</a><br /></td></tr>
<tr class="separator:a45edbae979af563e6a1e39fd1aad3911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61689ac607f746f728bb76bc14fe8ca4"><td class="memTemplParams" colspan="2">template&lt;typename Allocator  = std::allocator&lt;index_t&gt;&gt; </td></tr>
<tr class="memitem:a61689ac607f746f728bb76bc14fe8ca4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a> = std::vector&lt; <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a>, Allocator &gt;</td></tr>
<tr class="memdesc:a61689ac607f746f728bb76bc14fe8ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indices in PCL.  <a href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">More...</a><br /></td></tr>
<tr class="separator:a61689ac607f746f728bb76bc14fe8ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfe09b8680e7129dd0fd6177c1a2ce6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> = <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt;&gt;</td></tr>
<tr class="memdesc:a8bfe09b8680e7129dd0fd6177c1a2ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indices in PCL.  <a href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">More...</a><br /></td></tr>
<tr class="separator:a8bfe09b8680e7129dd0fd6177c1a2ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdee5c37c9776ce9fe8ac34046e1a914"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abdee5c37c9776ce9fe8ac34046e1a914">VerticesPtr</a> = <a class="el" href="structpcl_1_1_vertices.html#ac423acc8c8d9084051d9fff52b1bcb41">Vertices::Ptr</a></td></tr>
<tr class="separator:abdee5c37c9776ce9fe8ac34046e1a914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b106b17af05ea1d78e23219b6c0f44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af9b106b17af05ea1d78e23219b6c0f44">VerticesConstPtr</a> = <a class="el" href="structpcl_1_1_vertices.html#a3afb695a1378f1172a4c403e51977bb7">Vertices::ConstPtr</a></td></tr>
<tr class="separator:af9b106b17af05ea1d78e23219b6c0f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74051d0f43fd3965ec5ebda52b618cb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af74051d0f43fd3965ec5ebda52b618cb">Depth2DComparisonFeatureHandler</a> = <a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a>&lt; float, 1 &gt;</td></tr>
<tr class="separator:af74051d0f43fd3965ec5ebda52b618cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c8397d4916e88919dfff21affdcff0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af7c8397d4916e88919dfff21affdcff0">IntensityDepth2DComparisonFeatureHandler</a> = <a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a>&lt; float, 2 &gt;</td></tr>
<tr class="separator:af7c8397d4916e88919dfff21affdcff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602d4fccbde6fa569a838c7d996d0ff0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a602d4fccbde6fa569a838c7d996d0ff0">RGB2DComparisonFeatureHandler</a> = <a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a>&lt; float, 3 &gt;</td></tr>
<tr class="separator:a602d4fccbde6fa569a838c7d996d0ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078d333d3243aff41962f7b883ff259b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a078d333d3243aff41962f7b883ff259b">RGBD2DComparisonFeatureHandler</a> = <a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a>&lt; float, 4 &gt;</td></tr>
<tr class="separator:a078d333d3243aff41962f7b883ff259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35860b9680fcc149a898d96be9ea42f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af35860b9680fcc149a898d96be9ea42f">ScaledDepth2DComparisonFeatureHandler</a> = <a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler.html">ScaledMultiChannel2DComparisonFeatureHandler</a>&lt; float, 1, 0, true &gt;</td></tr>
<tr class="separator:af35860b9680fcc149a898d96be9ea42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5843f883e140428b9f0f03d8d0455cdc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5843f883e140428b9f0f03d8d0455cdc">ScaledIntensityDepth2DComparisonFeatureHandler</a> = <a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler.html">ScaledMultiChannel2DComparisonFeatureHandler</a>&lt; float, 2, 1, true &gt;</td></tr>
<tr class="separator:a5843f883e140428b9f0f03d8d0455cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350f3897d97d00f3b16508688452f315"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a350f3897d97d00f3b16508688452f315">ScaledRGBD2DComparisonFeatureHandler</a> = <a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler.html">ScaledMultiChannel2DComparisonFeatureHandler</a>&lt; float, 4, 3, true &gt;</td></tr>
<tr class="separator:a350f3897d97d00f3b16508688452f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e303fcb18e6a8446fba6b20a36ace41"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3e303fcb18e6a8446fba6b20a36ace41">ScaledDepth2DComparisonFeatureHandlerCCodeGenerator</a> = <a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler_c_code_generator.html">ScaledMultiChannel2DComparisonFeatureHandlerCCodeGenerator</a>&lt; float, 1, 0, true &gt;</td></tr>
<tr class="separator:a3e303fcb18e6a8446fba6b20a36ace41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369bca4fc510e61a4665dfe7e093c532"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a369bca4fc510e61a4665dfe7e093c532">Depth2DDataSet</a> = <a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a>&lt; float, 1 &gt;</td></tr>
<tr class="separator:a369bca4fc510e61a4665dfe7e093c532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8f5d269106c9c72c96a1f212d0f699"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6d8f5d269106c9c72c96a1f212d0f699">IntensityDepth2DDataSet</a> = <a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a>&lt; float, 2 &gt;</td></tr>
<tr class="separator:a6d8f5d269106c9c72c96a1f212d0f699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7257d59131d79d55e123ab1835a0615a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7257d59131d79d55e123ab1835a0615a">RGB2DDataSet</a> = <a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a>&lt; float, 3 &gt;</td></tr>
<tr class="separator:a7257d59131d79d55e123ab1835a0615a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30133320fad91e06bfd7c23a9cbf31f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab30133320fad91e06bfd7c23a9cbf31f">RGBD2DDataSet</a> = <a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a>&lt; float, 4 &gt;</td></tr>
<tr class="separator:ab30133320fad91e06bfd7c23a9cbf31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18edc4d3bcf513ada24a49d7cc903e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae18edc4d3bcf513ada24a49d7cc903e2">IndicesClusters</a> = std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt;</td></tr>
<tr class="separator:ae18edc4d3bcf513ada24a49d7cc903e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d7c1bc2ca9355df8370f91c7129367"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a07d7c1bc2ca9355df8370f91c7129367">IndicesClustersPtr</a> = shared_ptr&lt; std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &gt;</td></tr>
<tr class="separator:a07d7c1bc2ca9355df8370f91c7129367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73675f80e6c9c5474fb417e452e3ae10"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:a73675f80e6c9c5474fb417e452e3ae10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a73675f80e6c9c5474fb417e452e3ae10">MovingLeastSquaresOMP</a> = <a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a>&lt; PointInT, PointOutT &gt;</td></tr>
<tr class="separator:a73675f80e6c9c5474fb417e452e3ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a617dd0c1fbdf854bfbfb9ef2943665ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a617dd0c1fbdf854bfbfb9ef2943665ab">ColorLUTName</a> { <a class="el" href="namespacepcl.html#a617dd0c1fbdf854bfbfb9ef2943665aba4583b0f87c691c76ca961b2bcbd99eea">LUT_GLASBEY</a>, 
<a class="el" href="namespacepcl.html#a617dd0c1fbdf854bfbfb9ef2943665aba63f4dba9bc10114af8e426b4b878d854">LUT_VIRIDIS</a>
 }</td></tr>
<tr class="separator:a617dd0c1fbdf854bfbfb9ef2943665ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223710941333ffcbfd147e4f4c9a1485"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485">InterpolationType</a> { <br />
&#160;&#160;<a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485a803e6fa833a297b2e4c193665afc9175">BORDER_CONSTANT</a> = 0, 
<a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485af797a53aacb461b965a9947dec460430">BORDER_REPLICATE</a> = 1, 
<a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485a16c6595a6e0b3cdf525407618970c281">BORDER_REFLECT</a> = 2, 
<a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485ad7055354bdf79e8e3eab3057d2b0002b">BORDER_WRAP</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485a26da236fd0703b20c18e7ee64cb6422b">BORDER_REFLECT_101</a> = 4, 
<a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485a3a32eebd60519ff9455caef22c5ec636">BORDER_TRANSPARENT</a> = 5, 
<a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485a6882b27e8124f30b8dda1eacb40049bf">BORDER_DEFAULT</a> = BORDER_REFLECT_101
<br />
 }</td></tr>
<tr class="separator:a223710941333ffcbfd147e4f4c9a1485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d37f00989a9de11b48deb263649463c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga9d37f00989a9de11b48deb263649463c">NormType</a> { <br />
&#160;&#160;<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463cac3661be4b6e0d59a4c7b59a788cfc072">L1</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca98099ccc2b42084990c7a6caac1d03f1">L2_SQR</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca784d9a41bb0a8d74c4bbb384b5186c44">L2</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca731833ab377b1fbe2ea5968c44a1664f">LINF</a>, 
<br />
&#160;&#160;<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463cae072ec2ac425bed6c2f5a0781f0bf24f">JM</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca4da495e4c1d4f4415a13df5a1d55c545">SUBLINEAR</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463cad3f14cd5f1b7951b16422d8372b40177">CS</a>, 
<br />
&#160;&#160;<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca873d59723678e9e5d0a4c82d95c0e10e">DIV</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca5bf10e0499f79b70241e2eb83d0bcec3">PF</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca5c1d5fa96c1a1d9ee8a3d65459576e1f">K</a>, 
<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca8bf338ed604013b750528812f883f95b">KL</a>, 
<br />
&#160;&#160;<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca2ab2951d1cd80c4e5374046b5d670527">HIK</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9d37f00989a9de11b48deb263649463c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that defines all the types of norms available.  <a href="group__common.html#ga9d37f00989a9de11b48deb263649463c">More...</a><br /></td></tr>
<tr class="separator:ga9d37f00989a9de11b48deb263649463c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b4e0dcfd710e4c96737e6012b318e8b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga7b4e0dcfd710e4c96737e6012b318e8b">BorderTrait</a> { <br />
&#160;&#160;<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8baba2ab46c88349350939f52bbd63cde63">BORDER_TRAIT__OBSTACLE_BORDER</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8babbe3c6413874052b1bd961efd024e707">BORDER_TRAIT__SHADOW_BORDER</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8baed1fff632898caa19ba9c1b15e639c6e">BORDER_TRAIT__VEIL_POINT</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8bac33023b67fa7bef437316f060a45680a">BORDER_TRAIT__SHADOW_BORDER_TOP</a>, 
<br />
&#160;&#160;<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba02629b93f54ba6f5df84c201841a6885">BORDER_TRAIT__SHADOW_BORDER_RIGHT</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba930363a872a79a7d81d6e4205855776c">BORDER_TRAIT__SHADOW_BORDER_BOTTOM</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba68f048247d59b845f64a0c2f98e49200">BORDER_TRAIT__SHADOW_BORDER_LEFT</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba0126deec3b7ff7353d146e637f5079b0">BORDER_TRAIT__OBSTACLE_BORDER_TOP</a>, 
<br />
&#160;&#160;<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba95274e6ae483a678bfff02bee92a199f">BORDER_TRAIT__OBSTACLE_BORDER_RIGHT</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba9a16989fdc97f0d09f1602922ff5b915">BORDER_TRAIT__OBSTACLE_BORDER_BOTTOM</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba639881dfaa920ff16178ccd10032596c">BORDER_TRAIT__OBSTACLE_BORDER_LEFT</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba15f4b2984e8c57fd9e343d4ef7ecfbf5">BORDER_TRAIT__VEIL_POINT_TOP</a>, 
<br />
&#160;&#160;<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba0c79af62cb33c6b991a5560dcae502fe">BORDER_TRAIT__VEIL_POINT_RIGHT</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba58422e9652213c3b66933e6488e6934f">BORDER_TRAIT__VEIL_POINT_BOTTOM</a>, 
<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8bab835d36d98c678431e97796376690219">BORDER_TRAIT__VEIL_POINT_LEFT</a>
<br />
 }</td></tr>
<tr class="memdesc:ga7b4e0dcfd710e4c96737e6012b318e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specification of the fields for BorderDescription::traits.  <a href="group__common.html#ga7b4e0dcfd710e4c96737e6012b318e8b">More...</a><br /></td></tr>
<tr class="separator:ga7b4e0dcfd710e4c96737e6012b318e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8641d101f171b274f12109790e901ce9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8641d101f171b274f12109790e901ce9">HistogramInterpolationMethod</a> { <a class="el" href="namespacepcl.html#a8641d101f171b274f12109790e901ce9a2bdcddf8f35b06e8a55bca0993d705f3">INTERP_NONE</a>, 
<a class="el" href="namespacepcl.html#a8641d101f171b274f12109790e901ce9a836169fc1160e312ad956b61217ce6cd">INTERP_TRILINEAR</a>, 
<a class="el" href="namespacepcl.html#a8641d101f171b274f12109790e901ce9a30f66feb3d9607adffeb47e4f35d54db">INTERP_QUADRILINEAR</a>
 }</td></tr>
<tr class="memdesc:a8641d101f171b274f12109790e901ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different histogram interpolation methods.  <a href="namespacepcl.html#a8641d101f171b274f12109790e901ce9">More...</a><br /></td></tr>
<tr class="separator:a8641d101f171b274f12109790e901ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abf3814082bdf420e4b982589a19132"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1abf3814082bdf420e4b982589a19132">MorphologicalOperators</a> { <a class="el" href="namespacepcl.html#a1abf3814082bdf420e4b982589a19132afa7ee0adaca2e021db766ea40d8cf2cd">MORPH_OPEN</a>, 
<a class="el" href="namespacepcl.html#a1abf3814082bdf420e4b982589a19132a4535f9a5ab1beb172e6b1e14af5cdf54">MORPH_CLOSE</a>, 
<a class="el" href="namespacepcl.html#a1abf3814082bdf420e4b982589a19132a43abb981b536d88ac5e404d7f34a49bf">MORPH_DILATE</a>, 
<a class="el" href="namespacepcl.html#a1abf3814082bdf420e4b982589a19132ab60c42a20c8242ec0333b7415e2ad1d7">MORPH_ERODE</a>
 }</td></tr>
<tr class="separator:a1abf3814082bdf420e4b982589a19132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801a3c83fe807097c9aded5534df1394"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394">SacModel</a> { <br />
&#160;&#160;<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a18287528357b660304c7898255b0f265">SACMODEL_PLANE</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394af97be98df30ad2277e89e4654f9fc00f">SACMODEL_LINE</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a8d442cc79de3f633de403d7e336d694f">SACMODEL_CIRCLE2D</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a5168c77f12c90ddf4a4e69afc548bd2d">SACMODEL_CIRCLE3D</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a1c3b2cdb06cb0408096fd8665ef6c2d9">SACMODEL_SPHERE</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a0443d444406073767838dcd2c82b167a">SACMODEL_CYLINDER</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394ab78d4832df346f641e0d36706e45f6d6">SACMODEL_CONE</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394af02c2306587428bf9507c5ad2acf9f49">SACMODEL_TORUS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a4a3c2702b22089e23b5e2c076d27117f">SACMODEL_PARALLEL_LINE</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a5770604131930b45726976c8cf5a69c6">SACMODEL_PERPENDICULAR_PLANE</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394ab396dcfd75bf7a67ac9ea1cadd707cd9">SACMODEL_PARALLEL_LINES</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a9b60ab55e63967c7178830079684126b">SACMODEL_NORMAL_PLANE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a5b41f78278e0495a11023662955b122b">SACMODEL_NORMAL_SPHERE</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394ad649a6f9e77fe3258fbec7a256fe939c">SACMODEL_REGISTRATION</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a216dc9817b402ca947c9f4df601f3a43">SACMODEL_REGISTRATION_2D</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a18d9ef635b85360c19f9c7ef22bff1fe">SACMODEL_PARALLEL_PLANE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a543a8987f718193f0c55f09b93e811e2">SACMODEL_NORMAL_PARALLEL_PLANE</a>, 
<a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394a5d348749f0ff932efd504ae3718b6fce">SACMODEL_STICK</a>
<br />
 }</td></tr>
<tr class="separator:a801a3c83fe807097c9aded5534df1394"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3177c2c084674693cc38f03e80b6ad77"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga3177c2c084674693cc38f03e80b6ad77">rad2deg</a> (float alpha)</td></tr>
<tr class="memdesc:ga3177c2c084674693cc38f03e80b6ad77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an angle from radians to degrees.  <a href="group__common.html#ga3177c2c084674693cc38f03e80b6ad77">More...</a><br /></td></tr>
<tr class="separator:ga3177c2c084674693cc38f03e80b6ad77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b0ce695e2a10abb0130bcb5cf90eb6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">deg2rad</a> (float alpha)</td></tr>
<tr class="memdesc:ga25b0ce695e2a10abb0130bcb5cf90eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an angle from degrees to radians.  <a href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">More...</a><br /></td></tr>
<tr class="separator:ga25b0ce695e2a10abb0130bcb5cf90eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997c583b8ac57ffa9ad9e7321b4673e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga997c583b8ac57ffa9ad9e7321b4673e5">rad2deg</a> (double alpha)</td></tr>
<tr class="memdesc:ga997c583b8ac57ffa9ad9e7321b4673e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an angle from radians to degrees.  <a href="group__common.html#ga997c583b8ac57ffa9ad9e7321b4673e5">More...</a><br /></td></tr>
<tr class="separator:ga997c583b8ac57ffa9ad9e7321b4673e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78fe9974ed54012d6cf057afda5d3350"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga78fe9974ed54012d6cf057afda5d3350">deg2rad</a> (double alpha)</td></tr>
<tr class="memdesc:ga78fe9974ed54012d6cf057afda5d3350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an angle from degrees to radians.  <a href="group__common.html#ga78fe9974ed54012d6cf057afda5d3350">More...</a><br /></td></tr>
<tr class="separator:ga78fe9974ed54012d6cf057afda5d3350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b37d5c19b2773954bbc5320f011f3ec"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga3b37d5c19b2773954bbc5320f011f3ec">normAngle</a> (float alpha)</td></tr>
<tr class="memdesc:ga3b37d5c19b2773954bbc5320f011f3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an angle to (-PI, PI].  <a href="group__common.html#ga3b37d5c19b2773954bbc5320f011f3ec">More...</a><br /></td></tr>
<tr class="separator:ga3b37d5c19b2773954bbc5320f011f3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e32b0632e12d5a051cb8b04ea5f5ca0"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:a4e32b0632e12d5a051cb8b04ea5f5ca0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4e32b0632e12d5a051cb8b04ea5f5ca0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpcl_1_1_bivariate_polynomial_t.html">BivariatePolynomialT</a>&lt; real &gt; &amp;p)</td></tr>
<tr class="separator:a4e32b0632e12d5a051cb8b04ea5f5ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5729fae15603888b49743b118025290"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaf5729fae15603888b49743b118025290"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaf5729fae15603888b49743b118025290">compute3DCentroid</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gaf5729fae15603888b49743b118025290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D (X-Y-Z) centroid of a set of points and return it as a 3D vector.  <a href="group__common.html#gaf5729fae15603888b49743b118025290">More...</a><br /></td></tr>
<tr class="separator:gaf5729fae15603888b49743b118025290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac050f06179c72e8bc2665faf7f42a0aa"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ac050f06179c72e8bc2665faf7f42a0aa"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ac050f06179c72e8bc2665faf7f42a0aa">compute3DCentroid</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, Eigen::Vector4f &amp;centroid)</td></tr>
<tr class="separator:ac050f06179c72e8bc2665faf7f42a0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda9ffdc3a6bb85098aa16e61d668682"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:afda9ffdc3a6bb85098aa16e61d668682"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#afda9ffdc3a6bb85098aa16e61d668682">compute3DCentroid</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, Eigen::Vector4d &amp;centroid)</td></tr>
<tr class="separator:afda9ffdc3a6bb85098aa16e61d668682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26f5d53ac5362b04a5c8ed68c4c39038"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga26f5d53ac5362b04a5c8ed68c4c39038"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga26f5d53ac5362b04a5c8ed68c4c39038">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga26f5d53ac5362b04a5c8ed68c4c39038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D (X-Y-Z) centroid of a set of points and return it as a 3D vector.  <a href="group__common.html#ga26f5d53ac5362b04a5c8ed68c4c39038">More...</a><br /></td></tr>
<tr class="separator:ga26f5d53ac5362b04a5c8ed68c4c39038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23daec3829d2d4100a2f185372b3753a"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a23daec3829d2d4100a2f185372b3753a"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a23daec3829d2d4100a2f185372b3753a">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Vector4f &amp;centroid)</td></tr>
<tr class="separator:a23daec3829d2d4100a2f185372b3753a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f00705f1116eb69a984286e1e1d2b9"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a81f00705f1116eb69a984286e1e1d2b9"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a81f00705f1116eb69a984286e1e1d2b9">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Vector4d &amp;centroid)</td></tr>
<tr class="separator:a81f00705f1116eb69a984286e1e1d2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd1abc9deae9bb71dea8e6c1fd24af9"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gadfd1abc9deae9bb71dea8e6c1fd24af9"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gadfd1abc9deae9bb71dea8e6c1fd24af9">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gadfd1abc9deae9bb71dea8e6c1fd24af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D (X-Y-Z) centroid of a set of points using their indices and return it as a 3D vector.  <a href="group__common.html#gadfd1abc9deae9bb71dea8e6c1fd24af9">More...</a><br /></td></tr>
<tr class="separator:gadfd1abc9deae9bb71dea8e6c1fd24af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7910e9ffc3a073679a0b87e73223d493"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a7910e9ffc3a073679a0b87e73223d493"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7910e9ffc3a073679a0b87e73223d493">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Vector4f &amp;centroid)</td></tr>
<tr class="separator:a7910e9ffc3a073679a0b87e73223d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83cfc8af6f93b041f24fe2f4c6fa19c"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:aa83cfc8af6f93b041f24fe2f4c6fa19c"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aa83cfc8af6f93b041f24fe2f4c6fa19c">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Vector4d &amp;centroid)</td></tr>
<tr class="separator:aa83cfc8af6f93b041f24fe2f4c6fa19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057c72764dfcd1276f7fe19bbfb380a7"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga057c72764dfcd1276f7fe19bbfb380a7"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga057c72764dfcd1276f7fe19bbfb380a7">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga057c72764dfcd1276f7fe19bbfb380a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D (X-Y-Z) centroid of a set of points using their indices and return it as a 3D vector.  <a href="group__common.html#ga057c72764dfcd1276f7fe19bbfb380a7">More...</a><br /></td></tr>
<tr class="separator:ga057c72764dfcd1276f7fe19bbfb380a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4605825a1d7113456c905716c518e73"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:af4605825a1d7113456c905716c518e73"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af4605825a1d7113456c905716c518e73">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Vector4f &amp;centroid)</td></tr>
<tr class="separator:af4605825a1d7113456c905716c518e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202572bfcc54d5262fb2ab3a695d7682"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a202572bfcc54d5262fb2ab3a695d7682"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a202572bfcc54d5262fb2ab3a695d7682">compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Vector4d &amp;centroid)</td></tr>
<tr class="separator:a202572bfcc54d5262fb2ab3a695d7682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac36b146ec26b1ceb7be43a9ecaa010c4">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 covariance matrix of a given set of points.  <a href="group__common.html#gac36b146ec26b1ceb7be43a9ecaa010c4">More...</a><br /></td></tr>
<tr class="separator:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a519f0128baede6be874e0947ad8147"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a9a519f0128baede6be874e0947ad8147"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9a519f0128baede6be874e0947ad8147">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Vector4f &amp;centroid, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:a9a519f0128baede6be874e0947ad8147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4e482f26037bee30f64693f33fa98e"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a8b4e482f26037bee30f64693f33fa98e"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8b4e482f26037bee30f64693f33fa98e">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Vector4d &amp;centroid, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:a8b4e482f26037bee30f64693f33fa98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ea605f439a80daf6348547379bad8e"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gab5ea605f439a80daf6348547379bad8e"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gab5ea605f439a80daf6348547379bad8e">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gab5ea605f439a80daf6348547379bad8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normalized the 3x3 covariance matrix of a given set of points.  <a href="group__common.html#gab5ea605f439a80daf6348547379bad8e">More...</a><br /></td></tr>
<tr class="separator:gab5ea605f439a80daf6348547379bad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c34bc132bc8d638839f1ca4e8ddea0f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a7c34bc132bc8d638839f1ca4e8ddea0f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7c34bc132bc8d638839f1ca4e8ddea0f">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Vector4f &amp;centroid, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:a7c34bc132bc8d638839f1ca4e8ddea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf7877e22ed85622d8eea00880f7d35"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a5cf7877e22ed85622d8eea00880f7d35"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5cf7877e22ed85622d8eea00880f7d35">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Vector4d &amp;centroid, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:a5cf7877e22ed85622d8eea00880f7d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2680eec49635c40687ab378bde204fdc"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga2680eec49635c40687ab378bde204fdc"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga2680eec49635c40687ab378bde204fdc">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:ga2680eec49635c40687ab378bde204fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 covariance matrix of a given set of points using their indices.  <a href="group__common.html#ga2680eec49635c40687ab378bde204fdc">More...</a><br /></td></tr>
<tr class="separator:ga2680eec49635c40687ab378bde204fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1e69343ca8a48a910292d60a5a98ca"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a4c1e69343ca8a48a910292d60a5a98ca"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4c1e69343ca8a48a910292d60a5a98ca">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4f &amp;centroid, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:a4c1e69343ca8a48a910292d60a5a98ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cbcfc83901cd5e6508a3e57323ee44"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ae0cbcfc83901cd5e6508a3e57323ee44"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae0cbcfc83901cd5e6508a3e57323ee44">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4d &amp;centroid, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:ae0cbcfc83901cd5e6508a3e57323ee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35305b1593d5417be615e940383f4ced"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga35305b1593d5417be615e940383f4ced"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga35305b1593d5417be615e940383f4ced">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:ga35305b1593d5417be615e940383f4ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 covariance matrix of a given set of points using their indices.  <a href="group__common.html#ga35305b1593d5417be615e940383f4ced">More...</a><br /></td></tr>
<tr class="separator:ga35305b1593d5417be615e940383f4ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327ececf41f1808237b5d7ef6f96494e"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a327ececf41f1808237b5d7ef6f96494e"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a327ececf41f1808237b5d7ef6f96494e">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Vector4f &amp;centroid, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:a327ececf41f1808237b5d7ef6f96494e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74070eb55600644b3f8de2d4d8d08bd2"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a74070eb55600644b3f8de2d4d8d08bd2"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a74070eb55600644b3f8de2d4d8d08bd2">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Vector4d &amp;centroid, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:a74070eb55600644b3f8de2d4d8d08bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c9e7cc83ff0b2619c466ac7f45e952"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga41c9e7cc83ff0b2619c466ac7f45e952"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga41c9e7cc83ff0b2619c466ac7f45e952">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:ga41c9e7cc83ff0b2619c466ac7f45e952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix of a given set of points using their indices.  <a href="group__common.html#ga41c9e7cc83ff0b2619c466ac7f45e952">More...</a><br /></td></tr>
<tr class="separator:ga41c9e7cc83ff0b2619c466ac7f45e952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7afbcb20c186f0d3ee47b0f387ca54f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ae7afbcb20c186f0d3ee47b0f387ca54f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae7afbcb20c186f0d3ee47b0f387ca54f">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4f &amp;centroid, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:ae7afbcb20c186f0d3ee47b0f387ca54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0bf09f6b75ddb89ee99272606fa8bc"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ada0bf09f6b75ddb89ee99272606fa8bc"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ada0bf09f6b75ddb89ee99272606fa8bc">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4d &amp;centroid, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:ada0bf09f6b75ddb89ee99272606fa8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb4158efe784f3d3a765f0747b13a80"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gadfb4158efe784f3d3a765f0747b13a80"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gadfb4158efe784f3d3a765f0747b13a80">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gadfb4158efe784f3d3a765f0747b13a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix of a given set of points using their indices.  <a href="group__common.html#gadfb4158efe784f3d3a765f0747b13a80">More...</a><br /></td></tr>
<tr class="separator:gadfb4158efe784f3d3a765f0747b13a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8883fe1fb7c5c9de850f6520b68509f8"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a8883fe1fb7c5c9de850f6520b68509f8"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8883fe1fb7c5c9de850f6520b68509f8">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Vector4f &amp;centroid, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:a8883fe1fb7c5c9de850f6520b68509f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe0230defb5a7854e0234234c21506b"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a5fe0230defb5a7854e0234234c21506b"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5fe0230defb5a7854e0234234c21506b">computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Vector4d &amp;centroid, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:a5fe0230defb5a7854e0234234c21506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72dfb6e965df9752c88790e026a8ab5f"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga72dfb6e965df9752c88790e026a8ab5f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga72dfb6e965df9752c88790e026a8ab5f">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga72dfb6e965df9752c88790e026a8ab5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop.  <a href="group__common.html#ga72dfb6e965df9752c88790e026a8ab5f">More...</a><br /></td></tr>
<tr class="separator:ga72dfb6e965df9752c88790e026a8ab5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc2ea3fcf34548958ee0d7e691fd150"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a8cc2ea3fcf34548958ee0d7e691fd150"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8cc2ea3fcf34548958ee0d7e691fd150">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix3f &amp;covariance_matrix, Eigen::Vector4f &amp;centroid)</td></tr>
<tr class="separator:a8cc2ea3fcf34548958ee0d7e691fd150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21277bc4c42f68a98091745b9fd8232f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a21277bc4c42f68a98091745b9fd8232f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a21277bc4c42f68a98091745b9fd8232f">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix3d &amp;covariance_matrix, Eigen::Vector4d &amp;centroid)</td></tr>
<tr class="separator:a21277bc4c42f68a98091745b9fd8232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70c66f08214fb34784483627e5fc913"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaf70c66f08214fb34784483627e5fc913"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaf70c66f08214fb34784483627e5fc913">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gaf70c66f08214fb34784483627e5fc913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop.  <a href="group__common.html#gaf70c66f08214fb34784483627e5fc913">More...</a><br /></td></tr>
<tr class="separator:gaf70c66f08214fb34784483627e5fc913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764daf3dce844d19e671d65954b626bd"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a764daf3dce844d19e671d65954b626bd"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a764daf3dce844d19e671d65954b626bd">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix3f &amp;covariance_matrix, Eigen::Vector4f &amp;centroid)</td></tr>
<tr class="separator:a764daf3dce844d19e671d65954b626bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba133631e4a1c60f26412cd917d25a2"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a1ba133631e4a1c60f26412cd917d25a2"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1ba133631e4a1c60f26412cd917d25a2">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix3d &amp;covariance_matrix, Eigen::Vector4d &amp;centroid)</td></tr>
<tr class="separator:a1ba133631e4a1c60f26412cd917d25a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d7bf1a81f21fb97505c91957b7f033"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gac4d7bf1a81f21fb97505c91957b7f033"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac4d7bf1a81f21fb97505c91957b7f033">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gac4d7bf1a81f21fb97505c91957b7f033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop.  <a href="group__common.html#gac4d7bf1a81f21fb97505c91957b7f033">More...</a><br /></td></tr>
<tr class="separator:gac4d7bf1a81f21fb97505c91957b7f033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84951a6b448e68f38b93db5d657c833"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ac84951a6b448e68f38b93db5d657c833"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ac84951a6b448e68f38b93db5d657c833">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix3f &amp;covariance_matrix, Eigen::Vector4f &amp;centroid)</td></tr>
<tr class="separator:ac84951a6b448e68f38b93db5d657c833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff94982be65cb242843ce845a9fa1be"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:aeff94982be65cb242843ce845a9fa1be"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aeff94982be65cb242843ce845a9fa1be">computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix3d &amp;covariance_matrix, Eigen::Vector4d &amp;centroid)</td></tr>
<tr class="separator:aeff94982be65cb242843ce845a9fa1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5956698bec9ece7a491ad2fbbfbe6bc1"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga5956698bec9ece7a491ad2fbbfbe6bc1"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga5956698bec9ece7a491ad2fbbfbe6bc1">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:ga5956698bec9ece7a491ad2fbbfbe6bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix for a already demeaned point cloud.  <a href="group__common.html#ga5956698bec9ece7a491ad2fbbfbe6bc1">More...</a><br /></td></tr>
<tr class="separator:ga5956698bec9ece7a491ad2fbbfbe6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1792af32d68f02d0ae84aea7c25cf6d3"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a1792af32d68f02d0ae84aea7c25cf6d3"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1792af32d68f02d0ae84aea7c25cf6d3">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:a1792af32d68f02d0ae84aea7c25cf6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc2952e9da0204aed64bb967886240c"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a8cc2952e9da0204aed64bb967886240c"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8cc2952e9da0204aed64bb967886240c">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:a8cc2952e9da0204aed64bb967886240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1be0e0d9c0edfe771edb0eca57b8650"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gae1be0e0d9c0edfe771edb0eca57b8650"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gae1be0e0d9c0edfe771edb0eca57b8650">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gae1be0e0d9c0edfe771edb0eca57b8650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix for a already demeaned point cloud.  <a href="group__common.html#gae1be0e0d9c0edfe771edb0eca57b8650">More...</a><br /></td></tr>
<tr class="separator:gae1be0e0d9c0edfe771edb0eca57b8650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2804d83d939167e5dfce426d4039ab3f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a2804d83d939167e5dfce426d4039ab3f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2804d83d939167e5dfce426d4039ab3f">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:a2804d83d939167e5dfce426d4039ab3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c48ee806ee373875f1cdd8b9091236"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:af2c48ee806ee373875f1cdd8b9091236"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af2c48ee806ee373875f1cdd8b9091236">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:af2c48ee806ee373875f1cdd8b9091236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3ff94b2145fb22871e41e87ee495b2"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gacf3ff94b2145fb22871e41e87ee495b2"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gacf3ff94b2145fb22871e41e87ee495b2">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gacf3ff94b2145fb22871e41e87ee495b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix for a already demeaned point cloud.  <a href="group__common.html#gacf3ff94b2145fb22871e41e87ee495b2">More...</a><br /></td></tr>
<tr class="separator:gacf3ff94b2145fb22871e41e87ee495b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b7fbcd5a7bf264c08d5b7b534d34fe"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a63b7fbcd5a7bf264c08d5b7b534d34fe"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a63b7fbcd5a7bf264c08d5b7b534d34fe">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix3f &amp;covariance_matrix)</td></tr>
<tr class="separator:a63b7fbcd5a7bf264c08d5b7b534d34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad570c977482c84dc1fd2ec82ff664bc5"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ad570c977482c84dc1fd2ec82ff664bc5"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad570c977482c84dc1fd2ec82ff664bc5">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix3d &amp;covariance_matrix)</td></tr>
<tr class="separator:ad570c977482c84dc1fd2ec82ff664bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f82fbd4e17063ab86287a2543bdea88"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga7f82fbd4e17063ab86287a2543bdea88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga7f82fbd4e17063ab86287a2543bdea88">demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, int npts=0)</td></tr>
<tr class="memdesc:ga7f82fbd4e17063ab86287a2543bdea88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation.  <a href="group__common.html#ga7f82fbd4e17063ab86287a2543bdea88">More...</a><br /></td></tr>
<tr class="separator:ga7f82fbd4e17063ab86287a2543bdea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0212a746948007708bcfaa4117ea7461"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a0212a746948007708bcfaa4117ea7461"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0212a746948007708bcfaa4117ea7461">demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Vector4f &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, int npts=0)</td></tr>
<tr class="separator:a0212a746948007708bcfaa4117ea7461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71766012ea8618588baa1dc073dac1b4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a71766012ea8618588baa1dc073dac1b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a71766012ea8618588baa1dc073dac1b4">demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Vector4d &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, int npts=0)</td></tr>
<tr class="separator:a71766012ea8618588baa1dc073dac1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7953d5001218e840a3a10a2c8649461e"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga7953d5001218e840a3a10a2c8649461e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga7953d5001218e840a3a10a2c8649461e">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga7953d5001218e840a3a10a2c8649461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation.  <a href="group__common.html#ga7953d5001218e840a3a10a2c8649461e">More...</a><br /></td></tr>
<tr class="separator:ga7953d5001218e840a3a10a2c8649461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ca17f3decd37c512d958afa4d88ce0"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ae1ca17f3decd37c512d958afa4d88ce0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae1ca17f3decd37c512d958afa4d88ce0">demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Vector4f &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="separator:ae1ca17f3decd37c512d958afa4d88ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afc80fd70f4436ccce44de9241a1ba3"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a6afc80fd70f4436ccce44de9241a1ba3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6afc80fd70f4436ccce44de9241a1ba3">demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Vector4d &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="separator:a6afc80fd70f4436ccce44de9241a1ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776aeabe20fa3eb55e6283fea0476f6a"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga776aeabe20fa3eb55e6283fea0476f6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga776aeabe20fa3eb55e6283fea0476f6a">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga776aeabe20fa3eb55e6283fea0476f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation.  <a href="group__common.html#ga776aeabe20fa3eb55e6283fea0476f6a">More...</a><br /></td></tr>
<tr class="separator:ga776aeabe20fa3eb55e6283fea0476f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aca32be73611921c4a0ece73818465"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a47aca32be73611921c4a0ece73818465"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a47aca32be73611921c4a0ece73818465">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4f &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="separator:a47aca32be73611921c4a0ece73818465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3c09b0bae4898312b3f1720cf35d77"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ade3c09b0bae4898312b3f1720cf35d77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ade3c09b0bae4898312b3f1720cf35d77">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4d &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="separator:ade3c09b0bae4898312b3f1720cf35d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516ff833c2593ba6e53d369b25989f81"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga516ff833c2593ba6e53d369b25989f81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga516ff833c2593ba6e53d369b25989f81">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga516ff833c2593ba6e53d369b25989f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation.  <a href="group__common.html#ga516ff833c2593ba6e53d369b25989f81">More...</a><br /></td></tr>
<tr class="separator:ga516ff833c2593ba6e53d369b25989f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9d4b8b8ac294c8273318b7af44b477"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a1b9d4b8b8ac294c8273318b7af44b477"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1b9d4b8b8ac294c8273318b7af44b477">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Vector4f &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="separator:a1b9d4b8b8ac294c8273318b7af44b477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989ce2a2f9a6f14cbfefee1a3eaa40e6"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a989ce2a2f9a6f14cbfefee1a3eaa40e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a989ce2a2f9a6f14cbfefee1a3eaa40e6">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Vector4d &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="separator:a989ce2a2f9a6f14cbfefee1a3eaa40e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553c2ce698f074fe38d74f01b57a3343"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga553c2ce698f074fe38d74f01b57a3343"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga553c2ce698f074fe38d74f01b57a3343">demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;cloud_out, int npts=0)</td></tr>
<tr class="memdesc:ga553c2ce698f074fe38d74f01b57a3343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="group__common.html#ga553c2ce698f074fe38d74f01b57a3343">More...</a><br /></td></tr>
<tr class="separator:ga553c2ce698f074fe38d74f01b57a3343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a74008d2df6abde28a843a243ef011"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ae5a74008d2df6abde28a843a243ef011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae5a74008d2df6abde28a843a243ef011">demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Vector4f &amp;centroid, Eigen::MatrixXf &amp;cloud_out, int npts=0)</td></tr>
<tr class="separator:ae5a74008d2df6abde28a843a243ef011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a54767789c47edda970ae0cc04aee33"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a3a54767789c47edda970ae0cc04aee33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3a54767789c47edda970ae0cc04aee33">demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Vector4d &amp;centroid, Eigen::MatrixXd &amp;cloud_out, int npts=0)</td></tr>
<tr class="separator:a3a54767789c47edda970ae0cc04aee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19c71709093628e61037337056b99fa"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gae19c71709093628e61037337056b99fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gae19c71709093628e61037337056b99fa">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gae19c71709093628e61037337056b99fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="group__common.html#gae19c71709093628e61037337056b99fa">More...</a><br /></td></tr>
<tr class="separator:gae19c71709093628e61037337056b99fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfb2a1c7a8437bac36540227bc55888"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a8dfb2a1c7a8437bac36540227bc55888"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8dfb2a1c7a8437bac36540227bc55888">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const Eigen::Vector4f &amp;centroid, Eigen::MatrixXf &amp;cloud_out)</td></tr>
<tr class="separator:a8dfb2a1c7a8437bac36540227bc55888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9820d1ad515c00d37ef4c7594b27d1ab"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a9820d1ad515c00d37ef4c7594b27d1ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9820d1ad515c00d37ef4c7594b27d1ab">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const Eigen::Vector4d &amp;centroid, Eigen::MatrixXd &amp;cloud_out)</td></tr>
<tr class="separator:a9820d1ad515c00d37ef4c7594b27d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743fe66a6743b81611c70acd59c0d680"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga743fe66a6743b81611c70acd59c0d680"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga743fe66a6743b81611c70acd59c0d680">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga743fe66a6743b81611c70acd59c0d680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="group__common.html#ga743fe66a6743b81611c70acd59c0d680">More...</a><br /></td></tr>
<tr class="separator:ga743fe66a6743b81611c70acd59c0d680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cff987767d4fb99e5ddb8fbe6c72e4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ad4cff987767d4fb99e5ddb8fbe6c72e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad4cff987767d4fb99e5ddb8fbe6c72e4">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4f &amp;centroid, Eigen::MatrixXf &amp;cloud_out)</td></tr>
<tr class="separator:ad4cff987767d4fb99e5ddb8fbe6c72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10afd64292643e9d04ffcf12b876069"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ae10afd64292643e9d04ffcf12b876069"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae10afd64292643e9d04ffcf12b876069">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4d &amp;centroid, Eigen::MatrixXd &amp;cloud_out)</td></tr>
<tr class="separator:ae10afd64292643e9d04ffcf12b876069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539a53e4b17ad9ed2f00ae8b2e464221"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga539a53e4b17ad9ed2f00ae8b2e464221"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga539a53e4b17ad9ed2f00ae8b2e464221">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga539a53e4b17ad9ed2f00ae8b2e464221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="group__common.html#ga539a53e4b17ad9ed2f00ae8b2e464221">More...</a><br /></td></tr>
<tr class="separator:ga539a53e4b17ad9ed2f00ae8b2e464221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7d5505eb5192ddae706e461dc91c8b"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a9f7d5505eb5192ddae706e461dc91c8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9f7d5505eb5192ddae706e461dc91c8b">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Vector4f &amp;centroid, Eigen::MatrixXf &amp;cloud_out)</td></tr>
<tr class="separator:a9f7d5505eb5192ddae706e461dc91c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593f079cc31336760d9e5b8a9b3ec5e4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a593f079cc31336760d9e5b8a9b3ec5e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a593f079cc31336760d9e5b8a9b3ec5e4">demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Vector4d &amp;centroid, Eigen::MatrixXd &amp;cloud_out)</td></tr>
<tr class="separator:a593f079cc31336760d9e5b8a9b3ec5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d047d6f7b50a2d81306cc59ac927179"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga4d047d6f7b50a2d81306cc59ac927179"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4d047d6f7b50a2d81306cc59ac927179">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga4d047d6f7b50a2d81306cc59ac927179"><td class="mdescLeft">&#160;</td><td class="mdescRight">General, all purpose nD centroid estimation for a set of points using their indices.  <a href="group__common.html#ga4d047d6f7b50a2d81306cc59ac927179">More...</a><br /></td></tr>
<tr class="separator:ga4d047d6f7b50a2d81306cc59ac927179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12a9c691a9dad8617f06110dcdf337c"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ab12a9c691a9dad8617f06110dcdf337c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab12a9c691a9dad8617f06110dcdf337c">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::VectorXf &amp;centroid)</td></tr>
<tr class="separator:ab12a9c691a9dad8617f06110dcdf337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b8336923506cbc45f1b848abfffce8"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a49b8336923506cbc45f1b848abfffce8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a49b8336923506cbc45f1b848abfffce8">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::VectorXd &amp;centroid)</td></tr>
<tr class="separator:a49b8336923506cbc45f1b848abfffce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac394645bca960356e4d1aee5e75b92d"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaac394645bca960356e4d1aee5e75b92d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaac394645bca960356e4d1aee5e75b92d">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gaac394645bca960356e4d1aee5e75b92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">General, all purpose nD centroid estimation for a set of points using their indices.  <a href="group__common.html#gaac394645bca960356e4d1aee5e75b92d">More...</a><br /></td></tr>
<tr class="separator:gaac394645bca960356e4d1aee5e75b92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43810ff669042a89dde7e36ac7ddad2c"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a43810ff669042a89dde7e36ac7ddad2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a43810ff669042a89dde7e36ac7ddad2c">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::VectorXf &amp;centroid)</td></tr>
<tr class="separator:a43810ff669042a89dde7e36ac7ddad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409ee00ada6c43ab1efaa61a43c0c930"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a409ee00ada6c43ab1efaa61a43c0c930"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a409ee00ada6c43ab1efaa61a43c0c930">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::VectorXd &amp;centroid)</td></tr>
<tr class="separator:a409ee00ada6c43ab1efaa61a43c0c930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9654681b5a78f1e3ad5566de05e1d638"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga9654681b5a78f1e3ad5566de05e1d638"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga9654681b5a78f1e3ad5566de05e1d638">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga9654681b5a78f1e3ad5566de05e1d638"><td class="mdescLeft">&#160;</td><td class="mdescRight">General, all purpose nD centroid estimation for a set of points using their indices.  <a href="group__common.html#ga9654681b5a78f1e3ad5566de05e1d638">More...</a><br /></td></tr>
<tr class="separator:ga9654681b5a78f1e3ad5566de05e1d638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdac43d0a93611d8e8a6759942d31c1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a7fdac43d0a93611d8e8a6759942d31c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7fdac43d0a93611d8e8a6759942d31c1">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::VectorXf &amp;centroid)</td></tr>
<tr class="separator:a7fdac43d0a93611d8e8a6759942d31c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cd43a281c8a8e8a21ce454604bb13a"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ad5cd43a281c8a8e8a21ce454604bb13a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad5cd43a281c8a8e8a21ce454604bb13a">computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::VectorXd &amp;centroid)</td></tr>
<tr class="separator:ad5cd43a281c8a8e8a21ce454604bb13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ba1c9605f3bb1e3063e30fa04857c2"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ga24ba1c9605f3bb1e3063e30fa04857c2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga24ba1c9605f3bb1e3063e30fa04857c2">computeCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud, PointOutT &amp;centroid)</td></tr>
<tr class="memdesc:ga24ba1c9605f3bb1e3063e30fa04857c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the centroid of a set of points and return it as a point.  <a href="group__common.html#ga24ba1c9605f3bb1e3063e30fa04857c2">More...</a><br /></td></tr>
<tr class="separator:ga24ba1c9605f3bb1e3063e30fa04857c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e10574ff42edc90e7dd583a36e94ce6"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ga9e10574ff42edc90e7dd583a36e94ce6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga9e10574ff42edc90e7dd583a36e94ce6">computeCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, PointOutT &amp;centroid)</td></tr>
<tr class="memdesc:ga9e10574ff42edc90e7dd583a36e94ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the centroid of a set of points and return it as a point.  <a href="group__common.html#ga9e10574ff42edc90e7dd583a36e94ce6">More...</a><br /></td></tr>
<tr class="separator:ga9e10574ff42edc90e7dd583a36e94ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52af9f3d2f13a7753dd7189878b97391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a52af9f3d2f13a7753dd7189878b97391">getRandomColor</a> (double min=0.2, double max=2.8)</td></tr>
<tr class="separator:a52af9f3d2f13a7753dd7189878b97391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54999c02ba9bee56404539747b0fda51"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga54999c02ba9bee56404539747b0fda51">getAngle3D</a> (const Eigen::Vector4f &amp;v1, const Eigen::Vector4f &amp;v2, const bool in_degree=false)</td></tr>
<tr class="memdesc:ga54999c02ba9bee56404539747b0fda51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the smallest angle between two 3D vectors in radians (default) or degree.  <a href="group__common.html#ga54999c02ba9bee56404539747b0fda51">More...</a><br /></td></tr>
<tr class="separator:ga54999c02ba9bee56404539747b0fda51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c74d7c459961a2650c22eff8126aef8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga8c74d7c459961a2650c22eff8126aef8">getAngle3D</a> (const Eigen::Vector3f &amp;v1, const Eigen::Vector3f &amp;v2, const bool in_degree=false)</td></tr>
<tr class="memdesc:ga8c74d7c459961a2650c22eff8126aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the smallest angle between two 3D vectors in radians (default) or degree.  <a href="group__common.html#ga8c74d7c459961a2650c22eff8126aef8">More...</a><br /></td></tr>
<tr class="separator:ga8c74d7c459961a2650c22eff8126aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3349ce9c26d4acbb1adae1e9b2d5f7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga3349ce9c26d4acbb1adae1e9b2d5f7e5">getMeanStd</a> (const std::vector&lt; float &gt; &amp;values, double &amp;mean, double &amp;stddev)</td></tr>
<tr class="memdesc:ga3349ce9c26d4acbb1adae1e9b2d5f7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute both the mean and the standard deviation of an array of values.  <a href="group__common.html#ga3349ce9c26d4acbb1adae1e9b2d5f7e5">More...</a><br /></td></tr>
<tr class="separator:ga3349ce9c26d4acbb1adae1e9b2d5f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa67d411e0077c68c31adbc7d0d995e9c"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaa67d411e0077c68c31adbc7d0d995e9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaa67d411e0077c68c31adbc7d0d995e9c">getPointsInBox</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices)</td></tr>
<tr class="memdesc:gaa67d411e0077c68c31adbc7d0d995e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a set of points residing in a box given its bounds.  <a href="group__common.html#gaa67d411e0077c68c31adbc7d0d995e9c">More...</a><br /></td></tr>
<tr class="separator:gaa67d411e0077c68c31adbc7d0d995e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1583a71aef0f54550adef0ebfef89edd"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga1583a71aef0f54550adef0ebfef89edd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga1583a71aef0f54550adef0ebfef89edd">getMaxDistance</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Vector4f &amp;pivot_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:ga1583a71aef0f54550adef0ebfef89edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the point at maximum distance from a given point and a given pointcloud.  <a href="group__common.html#ga1583a71aef0f54550adef0ebfef89edd">More...</a><br /></td></tr>
<tr class="separator:ga1583a71aef0f54550adef0ebfef89edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43df2b30eedda61e26d132db661cf2ec"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga43df2b30eedda61e26d132db661cf2ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga43df2b30eedda61e26d132db661cf2ec">getMaxDistance</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4f &amp;pivot_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:ga43df2b30eedda61e26d132db661cf2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the point at maximum distance from a given point and a given pointcloud.  <a href="group__common.html#ga43df2b30eedda61e26d132db661cf2ec">More...</a><br /></td></tr>
<tr class="separator:ga43df2b30eedda61e26d132db661cf2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3166f09aafd659f69dc75e63f5e10f81"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga3166f09aafd659f69dc75e63f5e10f81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3166f09aafd659f69dc75e63f5e10f81">getMinMax3D</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;min_pt, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;max_pt)</td></tr>
<tr class="memdesc:ga3166f09aafd659f69dc75e63f5e10f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud.  <a href="group__common.html#ga3166f09aafd659f69dc75e63f5e10f81">More...</a><br /></td></tr>
<tr class="separator:ga3166f09aafd659f69dc75e63f5e10f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9010977f5e52b35b484be7624df3f8"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gafd9010977f5e52b35b484be7624df3f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gafd9010977f5e52b35b484be7624df3f8">getMinMax3D</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:gafd9010977f5e52b35b484be7624df3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud.  <a href="group__common.html#gafd9010977f5e52b35b484be7624df3f8">More...</a><br /></td></tr>
<tr class="separator:gafd9010977f5e52b35b484be7624df3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e38f91f115922ef4aa80328b6da28f5"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga8e38f91f115922ef4aa80328b6da28f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga8e38f91f115922ef4aa80328b6da28f5">getMinMax3D</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:ga8e38f91f115922ef4aa80328b6da28f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud.  <a href="group__common.html#ga8e38f91f115922ef4aa80328b6da28f5">More...</a><br /></td></tr>
<tr class="separator:ga8e38f91f115922ef4aa80328b6da28f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41eb246206d51f77a8cb82b5d963e6a2"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga41eb246206d51f77a8cb82b5d963e6a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga41eb246206d51f77a8cb82b5d963e6a2">getMinMax3D</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:ga41eb246206d51f77a8cb82b5d963e6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud.  <a href="group__common.html#ga41eb246206d51f77a8cb82b5d963e6a2">More...</a><br /></td></tr>
<tr class="separator:ga41eb246206d51f77a8cb82b5d963e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64d6ba9e834d29feda71a76d3ec841f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gab64d6ba9e834d29feda71a76d3ec841f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gab64d6ba9e834d29feda71a76d3ec841f">getCircumcircleRadius</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pa, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pb, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pc)</td></tr>
<tr class="memdesc:gab64d6ba9e834d29feda71a76d3ec841f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the radius of a circumscribed circle for a triangle formed of three points pa, pb, and pc.  <a href="group__common.html#gab64d6ba9e834d29feda71a76d3ec841f">More...</a><br /></td></tr>
<tr class="separator:gab64d6ba9e834d29feda71a76d3ec841f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacff2e632283be60810678d329b166ec"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaacff2e632283be60810678d329b166ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaacff2e632283be60810678d329b166ec">getMinMax</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;histogram, int len, float &amp;min_p, float &amp;max_p)</td></tr>
<tr class="memdesc:gaacff2e632283be60810678d329b166ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on a point histogram.  <a href="group__common.html#gaacff2e632283be60810678d329b166ec">More...</a><br /></td></tr>
<tr class="separator:gaacff2e632283be60810678d329b166ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9e18520c49be76f2a28834e2da8a56"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga1a9e18520c49be76f2a28834e2da8a56"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga1a9e18520c49be76f2a28834e2da8a56">calculatePolygonArea</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:ga1a9e18520c49be76f2a28834e2da8a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the area of a polygon given a point cloud that defines the polygon.  <a href="group__common.html#ga1a9e18520c49be76f2a28834e2da8a56">More...</a><br /></td></tr>
<tr class="separator:ga1a9e18520c49be76f2a28834e2da8a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287e6ce2d4be348c059baf31eaf2dd54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga287e6ce2d4be348c059baf31eaf2dd54">getMinMax</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, int idx, const std::string &amp;field_name, float &amp;min_p, float &amp;max_p)</td></tr>
<tr class="memdesc:ga287e6ce2d4be348c059baf31eaf2dd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on a point histogram.  <a href="group__common.html#ga287e6ce2d4be348c059baf31eaf2dd54">More...</a><br /></td></tr>
<tr class="separator:ga287e6ce2d4be348c059baf31eaf2dd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb684087702126b29c8b99f1e2c2786b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gacb684087702126b29c8b99f1e2c2786b">getMeanStdDev</a> (const std::vector&lt; float &gt; &amp;values, double &amp;mean, double &amp;stddev)</td></tr>
<tr class="memdesc:gacb684087702126b29c8b99f1e2c2786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute both the mean and the standard deviation of an array of values.  <a href="group__common.html#gacb684087702126b29c8b99f1e2c2786b">More...</a><br /></td></tr>
<tr class="separator:gacb684087702126b29c8b99f1e2c2786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab978bf1754771246b2f140a5b52a8f8b"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:gab978bf1754771246b2f140a5b52a8f8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gab978bf1754771246b2f140a5b52a8f8b">copyPoint</a> (const PointInT &amp;point_in, PointOutT &amp;point_out)</td></tr>
<tr class="memdesc:gab978bf1754771246b2f140a5b52a8f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the fields of a source point into a target point.  <a href="group__common.html#gab978bf1754771246b2f140a5b52a8f8b">More...</a><br /></td></tr>
<tr class="separator:gab978bf1754771246b2f140a5b52a8f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee346a92c01c042ffae2907ae5c93c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga4ee346a92c01c042ffae2907ae5c93c5">lineToLineSegment</a> (const Eigen::VectorXf &amp;line_a, const Eigen::VectorXf &amp;line_b, Eigen::Vector4f &amp;pt1_seg, Eigen::Vector4f &amp;pt2_seg)</td></tr>
<tr class="memdesc:ga4ee346a92c01c042ffae2907ae5c93c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shortest 3D segment between two 3D lines.  <a href="group__common.html#ga4ee346a92c01c042ffae2907ae5c93c5">More...</a><br /></td></tr>
<tr class="separator:ga4ee346a92c01c042ffae2907ae5c93c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9217ecd4cc14221f178af07a16ef75d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gad9217ecd4cc14221f178af07a16ef75d">sqrPointToLineDistance</a> (const Eigen::Vector4f &amp;pt, const Eigen::Vector4f &amp;line_pt, const Eigen::Vector4f &amp;line_dir)</td></tr>
<tr class="memdesc:gad9217ecd4cc14221f178af07a16ef75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the square distance from a point to a line (represented by a point and a direction)  <a href="group__common.html#gad9217ecd4cc14221f178af07a16ef75d">More...</a><br /></td></tr>
<tr class="separator:gad9217ecd4cc14221f178af07a16ef75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6aa7accd68832e8a4d4707c358e40f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga3d6aa7accd68832e8a4d4707c358e40f">sqrPointToLineDistance</a> (const Eigen::Vector4f &amp;pt, const Eigen::Vector4f &amp;line_pt, const Eigen::Vector4f &amp;line_dir, const double sqr_length)</td></tr>
<tr class="memdesc:ga3d6aa7accd68832e8a4d4707c358e40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the square distance from a point to a line (represented by a point and a direction)  <a href="group__common.html#ga3d6aa7accd68832e8a4d4707c358e40f">More...</a><br /></td></tr>
<tr class="separator:ga3d6aa7accd68832e8a4d4707c358e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ceb9b4896578ed075a36ad3937ee26"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga30ceb9b4896578ed075a36ad3937ee26"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga30ceb9b4896578ed075a36ad3937ee26">getMaxSegment</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pmin, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pmax)</td></tr>
<tr class="memdesc:ga30ceb9b4896578ed075a36ad3937ee26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum segment in a given set of points, and return the minimum and maximum points.  <a href="group__common.html#ga30ceb9b4896578ed075a36ad3937ee26">More...</a><br /></td></tr>
<tr class="separator:ga30ceb9b4896578ed075a36ad3937ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e677fb3cb3143a9665d1eb0bf5f1b0"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga29e677fb3cb3143a9665d1eb0bf5f1b0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga29e677fb3cb3143a9665d1eb0bf5f1b0">getMaxSegment</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pmin, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pmax)</td></tr>
<tr class="memdesc:ga29e677fb3cb3143a9665d1eb0bf5f1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum segment in a given set of points, and return the minimum and maximum points.  <a href="group__common.html#ga29e677fb3cb3143a9665d1eb0bf5f1b0">More...</a><br /></td></tr>
<tr class="separator:ga29e677fb3cb3143a9665d1eb0bf5f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ecc173df18d9175dee9f4dd042390b"><td class="memTemplParams" colspan="2">template&lt;typename PointType1 , typename PointType2 &gt; </td></tr>
<tr class="memitem:a28ecc173df18d9175dee9f4dd042390b"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a28ecc173df18d9175dee9f4dd042390b">squaredEuclideanDistance</a> (const PointType1 &amp;p1, const PointType2 &amp;p2)</td></tr>
<tr class="memdesc:a28ecc173df18d9175dee9f4dd042390b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the squared euclidean distance between the two given points.  <a href="namespacepcl.html#a28ecc173df18d9175dee9f4dd042390b">More...</a><br /></td></tr>
<tr class="separator:a28ecc173df18d9175dee9f4dd042390b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce728864fe6aa3af8783cb0a963a4b1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acce728864fe6aa3af8783cb0a963a4b1"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#acce728864fe6aa3af8783cb0a963a4b1">squaredEuclideanDistance</a> (const <a class="el" href="structpcl_1_1_point_x_y.html">PointXY</a> &amp;p1, const <a class="el" href="structpcl_1_1_point_x_y.html">PointXY</a> &amp;p2)</td></tr>
<tr class="memdesc:acce728864fe6aa3af8783cb0a963a4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the squared euclidean distance between the two given points.  <a href="namespacepcl.html#acce728864fe6aa3af8783cb0a963a4b1">More...</a><br /></td></tr>
<tr class="separator:acce728864fe6aa3af8783cb0a963a4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e1d23717813eb053a0eb51411a4a23"><td class="memTemplParams" colspan="2">template&lt;typename PointType1 , typename PointType2 &gt; </td></tr>
<tr class="memitem:a73e1d23717813eb053a0eb51411a4a23"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a73e1d23717813eb053a0eb51411a4a23">euclideanDistance</a> (const PointType1 &amp;p1, const PointType2 &amp;p2)</td></tr>
<tr class="memdesc:a73e1d23717813eb053a0eb51411a4a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the euclidean distance between the two given points.  <a href="namespacepcl.html#a73e1d23717813eb053a0eb51411a4a23">More...</a><br /></td></tr>
<tr class="separator:a73e1d23717813eb053a0eb51411a4a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d949061a580b72ae999742cc0690a1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Roots &gt; </td></tr>
<tr class="memitem:ae4d949061a580b72ae999742cc0690a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae4d949061a580b72ae999742cc0690a1">computeRoots2</a> (const Scalar &amp;b, const Scalar &amp;c, Roots &amp;roots)</td></tr>
<tr class="memdesc:ae4d949061a580b72ae999742cc0690a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the roots of a quadratic polynom x^2 + b*x + c = 0.  <a href="namespacepcl.html#ae4d949061a580b72ae999742cc0690a1">More...</a><br /></td></tr>
<tr class="separator:ae4d949061a580b72ae999742cc0690a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa08a43e19cb9280ac6e205ab53b651"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Roots &gt; </td></tr>
<tr class="memitem:aefa08a43e19cb9280ac6e205ab53b651"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aefa08a43e19cb9280ac6e205ab53b651">computeRoots</a> (const Matrix &amp;m, Roots &amp;roots)</td></tr>
<tr class="memdesc:aefa08a43e19cb9280ac6e205ab53b651"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the roots of the characteristic polynomial of the input matrix m, which are the eigenvalues  <a href="namespacepcl.html#aefa08a43e19cb9280ac6e205ab53b651">More...</a><br /></td></tr>
<tr class="separator:aefa08a43e19cb9280ac6e205ab53b651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72970b7435480c0c1827c8e74bc1d605"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga72970b7435480c0c1827c8e74bc1d605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga72970b7435480c0c1827c8e74bc1d605">eigen22</a> (const Matrix &amp;mat, typename Matrix::Scalar &amp;eigenvalue, Vector &amp;eigenvector)</td></tr>
<tr class="memdesc:ga72970b7435480c0c1827c8e74bc1d605"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine the smallest eigenvalue and its corresponding eigenvector  <a href="group__common.html#ga72970b7435480c0c1827c8e74bc1d605">More...</a><br /></td></tr>
<tr class="separator:ga72970b7435480c0c1827c8e74bc1d605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fdd69805d49c416393c604f9f209113"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga4fdd69805d49c416393c604f9f209113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4fdd69805d49c416393c604f9f209113">eigen22</a> (const Matrix &amp;mat, Matrix &amp;eigenvectors, Vector &amp;eigenvalues)</td></tr>
<tr class="memdesc:ga4fdd69805d49c416393c604f9f209113"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine the smallest eigenvalue and its corresponding eigenvector  <a href="group__common.html#ga4fdd69805d49c416393c604f9f209113">More...</a><br /></td></tr>
<tr class="separator:ga4fdd69805d49c416393c604f9f209113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c9b186d04d2e8a868e058473214622"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga11c9b186d04d2e8a868e058473214622"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga11c9b186d04d2e8a868e058473214622">computeCorrespondingEigenVector</a> (const Matrix &amp;mat, const typename Matrix::Scalar &amp;eigenvalue, Vector &amp;eigenvector)</td></tr>
<tr class="memdesc:ga11c9b186d04d2e8a868e058473214622"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the corresponding eigenvector to the given eigenvalue of the symmetric positive semi definite input matrix  <a href="group__common.html#ga11c9b186d04d2e8a868e058473214622">More...</a><br /></td></tr>
<tr class="separator:ga11c9b186d04d2e8a868e058473214622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca873868052e7d26efcf4b684a17bef2"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:gaca873868052e7d26efcf4b684a17bef2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaca873868052e7d26efcf4b684a17bef2">eigen33</a> (const Matrix &amp;mat, typename Matrix::Scalar &amp;eigenvalue, Vector &amp;eigenvector)</td></tr>
<tr class="memdesc:gaca873868052e7d26efcf4b684a17bef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the eigenvector and eigenvalue of the smallest eigenvalue of the symmetric positive semi definite input matrix  <a href="group__common.html#gaca873868052e7d26efcf4b684a17bef2">More...</a><br /></td></tr>
<tr class="separator:gaca873868052e7d26efcf4b684a17bef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a1ba2729012164635113224cb211581"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga3a1ba2729012164635113224cb211581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3a1ba2729012164635113224cb211581">eigen33</a> (const Matrix &amp;mat, Vector &amp;evals)</td></tr>
<tr class="memdesc:ga3a1ba2729012164635113224cb211581"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the eigenvalues of the symmetric positive semi definite input matrix  <a href="group__common.html#ga3a1ba2729012164635113224cb211581">More...</a><br /></td></tr>
<tr class="separator:ga3a1ba2729012164635113224cb211581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d78c3e9c0f3f58a0806499ae6ed97b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga76d78c3e9c0f3f58a0806499ae6ed97b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga76d78c3e9c0f3f58a0806499ae6ed97b">eigen33</a> (const Matrix &amp;mat, Matrix &amp;evecs, Vector &amp;evals)</td></tr>
<tr class="memdesc:ga76d78c3e9c0f3f58a0806499ae6ed97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the eigenvalues and corresponding eigenvectors of the symmetric positive semi definite input matrix  <a href="group__common.html#ga76d78c3e9c0f3f58a0806499ae6ed97b">More...</a><br /></td></tr>
<tr class="separator:ga76d78c3e9c0f3f58a0806499ae6ed97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09b0c9a50601f3ae20a7babfd9a8d2d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:gad09b0c9a50601f3ae20a7babfd9a8d2d"><td class="memTemplItemLeft" align="right" valign="top">Matrix::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gad09b0c9a50601f3ae20a7babfd9a8d2d">invert2x2</a> (const Matrix &amp;matrix, Matrix &amp;inverse)</td></tr>
<tr class="memdesc:gad09b0c9a50601f3ae20a7babfd9a8d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inverse of a 2x2 matrix.  <a href="group__common.html#gad09b0c9a50601f3ae20a7babfd9a8d2d">More...</a><br /></td></tr>
<tr class="separator:gad09b0c9a50601f3ae20a7babfd9a8d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503f55a565c260660c6ac0461f17fa8f"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:ga503f55a565c260660c6ac0461f17fa8f"><td class="memTemplItemLeft" align="right" valign="top">Matrix::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga503f55a565c260660c6ac0461f17fa8f">invert3x3SymMatrix</a> (const Matrix &amp;matrix, Matrix &amp;inverse)</td></tr>
<tr class="memdesc:ga503f55a565c260660c6ac0461f17fa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inverse of a 3x3 symmetric matrix.  <a href="group__common.html#ga503f55a565c260660c6ac0461f17fa8f">More...</a><br /></td></tr>
<tr class="separator:ga503f55a565c260660c6ac0461f17fa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb12d1f85437aafb0a3ac12af5633400"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:gabb12d1f85437aafb0a3ac12af5633400"><td class="memTemplItemLeft" align="right" valign="top">Matrix::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gabb12d1f85437aafb0a3ac12af5633400">invert3x3Matrix</a> (const Matrix &amp;matrix, Matrix &amp;inverse)</td></tr>
<tr class="memdesc:gabb12d1f85437aafb0a3ac12af5633400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inverse of a general 3x3 matrix.  <a href="group__common.html#gabb12d1f85437aafb0a3ac12af5633400">More...</a><br /></td></tr>
<tr class="separator:gabb12d1f85437aafb0a3ac12af5633400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d0048ba1efd11359011eb47f6c92fa"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:ga44d0048ba1efd11359011eb47f6c92fa"><td class="memTemplItemLeft" align="right" valign="top">Matrix::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga44d0048ba1efd11359011eb47f6c92fa">determinant3x3Matrix</a> (const Matrix &amp;matrix)</td></tr>
<tr class="memdesc:ga44d0048ba1efd11359011eb47f6c92fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the determinant of a 3x3 matrix.  <a href="group__common.html#ga44d0048ba1efd11359011eb47f6c92fa">More...</a><br /></td></tr>
<tr class="separator:ga44d0048ba1efd11359011eb47f6c92fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf457d33994792e63129de9709dcdf329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaf457d33994792e63129de9709dcdf329">getTransFromUnitVectorsZY</a> (const Eigen::Vector3f &amp;z_axis, const Eigen::Vector3f &amp;y_direction, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:gaf457d33994792e63129de9709dcdf329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#gaf457d33994792e63129de9709dcdf329">More...</a><br /></td></tr>
<tr class="separator:gaf457d33994792e63129de9709dcdf329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d47eda3c3f5f91125296fd7d202ebb"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga58d47eda3c3f5f91125296fd7d202ebb">getTransFromUnitVectorsZY</a> (const Eigen::Vector3f &amp;z_axis, const Eigen::Vector3f &amp;y_direction)</td></tr>
<tr class="memdesc:ga58d47eda3c3f5f91125296fd7d202ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga58d47eda3c3f5f91125296fd7d202ebb">More...</a><br /></td></tr>
<tr class="separator:ga58d47eda3c3f5f91125296fd7d202ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8319aa7921bdc742a9d0f95458e9cfe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga8319aa7921bdc742a9d0f95458e9cfe0">getTransFromUnitVectorsXY</a> (const Eigen::Vector3f &amp;x_axis, const Eigen::Vector3f &amp;y_direction, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:ga8319aa7921bdc742a9d0f95458e9cfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>x_axis</em> into (1,0,0) and <em>y_direction</em> into a vector with z=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga8319aa7921bdc742a9d0f95458e9cfe0">More...</a><br /></td></tr>
<tr class="separator:ga8319aa7921bdc742a9d0f95458e9cfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8933c653f39db3636bfbdd262278edcb"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga8933c653f39db3636bfbdd262278edcb">getTransFromUnitVectorsXY</a> (const Eigen::Vector3f &amp;x_axis, const Eigen::Vector3f &amp;y_direction)</td></tr>
<tr class="memdesc:ga8933c653f39db3636bfbdd262278edcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>x_axis</em> into (1,0,0) and <em>y_direction</em> into a vector with z=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga8933c653f39db3636bfbdd262278edcb">More...</a><br /></td></tr>
<tr class="separator:ga8933c653f39db3636bfbdd262278edcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1f523f342ff69277f23ea9f02fc5a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga7d1f523f342ff69277f23ea9f02fc5a6">getTransformationFromTwoUnitVectors</a> (const Eigen::Vector3f &amp;y_direction, const Eigen::Vector3f &amp;z_axis, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:ga7d1f523f342ff69277f23ea9f02fc5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga7d1f523f342ff69277f23ea9f02fc5a6">More...</a><br /></td></tr>
<tr class="separator:ga7d1f523f342ff69277f23ea9f02fc5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada89edf1699e05ecf7355738e9f56f6b"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gada89edf1699e05ecf7355738e9f56f6b">getTransformationFromTwoUnitVectors</a> (const Eigen::Vector3f &amp;y_direction, const Eigen::Vector3f &amp;z_axis)</td></tr>
<tr class="memdesc:gada89edf1699e05ecf7355738e9f56f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#gada89edf1699e05ecf7355738e9f56f6b">More...</a><br /></td></tr>
<tr class="separator:gada89edf1699e05ecf7355738e9f56f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4375e99ec2ae368eec9379f506568611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga4375e99ec2ae368eec9379f506568611">getTransformationFromTwoUnitVectorsAndOrigin</a> (const Eigen::Vector3f &amp;y_direction, const Eigen::Vector3f &amp;z_axis, const Eigen::Vector3f &amp;origin, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:ga4375e99ec2ae368eec9379f506568611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation that will translate <em>origin</em> to (0,0,0) and rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga4375e99ec2ae368eec9379f506568611">More...</a><br /></td></tr>
<tr class="separator:ga4375e99ec2ae368eec9379f506568611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637da495fec59c1c1d186aa6e3bac15b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga637da495fec59c1c1d186aa6e3bac15b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga637da495fec59c1c1d186aa6e3bac15b">getEulerAngles</a> (const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;t, Scalar &amp;roll, Scalar &amp;pitch, Scalar &amp;yaw)</td></tr>
<tr class="memdesc:ga637da495fec59c1c1d186aa6e3bac15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the Euler angles (XYZ-convention) from the given transformation.  <a href="group__common.html#ga637da495fec59c1c1d186aa6e3bac15b">More...</a><br /></td></tr>
<tr class="separator:ga637da495fec59c1c1d186aa6e3bac15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd94c8354eb65dffae3769da8fcc06a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1dd94c8354eb65dffae3769da8fcc06a">getEulerAngles</a> (const Eigen::Affine3f &amp;t, float &amp;roll, float &amp;pitch, float &amp;yaw)</td></tr>
<tr class="separator:a1dd94c8354eb65dffae3769da8fcc06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcee7a7a354c7b761b46999ea946a2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8fcee7a7a354c7b761b46999ea946a2b">getEulerAngles</a> (const Eigen::Affine3d &amp;t, double &amp;roll, double &amp;pitch, double &amp;yaw)</td></tr>
<tr class="separator:a8fcee7a7a354c7b761b46999ea946a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e52d439a979e71096f4dd50f1298f32"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga3e52d439a979e71096f4dd50f1298f32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3e52d439a979e71096f4dd50f1298f32">getTranslationAndEulerAngles</a> (const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;t, Scalar &amp;x, Scalar &amp;y, Scalar &amp;z, Scalar &amp;roll, Scalar &amp;pitch, Scalar &amp;yaw)</td></tr>
<tr class="memdesc:ga3e52d439a979e71096f4dd50f1298f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract x,y,z and the Euler angles (XYZ-convention) from the given transformation.  <a href="group__common.html#ga3e52d439a979e71096f4dd50f1298f32">More...</a><br /></td></tr>
<tr class="separator:ga3e52d439a979e71096f4dd50f1298f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f85a8959dbec57e64840ee80c20f816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8f85a8959dbec57e64840ee80c20f816">getTranslationAndEulerAngles</a> (const Eigen::Affine3f &amp;t, float &amp;x, float &amp;y, float &amp;z, float &amp;roll, float &amp;pitch, float &amp;yaw)</td></tr>
<tr class="separator:a8f85a8959dbec57e64840ee80c20f816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5de15e37a0ff9f56f2cd9e942f44cd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad5de15e37a0ff9f56f2cd9e942f44cd6">getTranslationAndEulerAngles</a> (const Eigen::Affine3d &amp;t, double &amp;x, double &amp;y, double &amp;z, double &amp;roll, double &amp;pitch, double &amp;yaw)</td></tr>
<tr class="separator:ad5de15e37a0ff9f56f2cd9e942f44cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc746d1fd72f99fee462ed1a9e4abea"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga5cc746d1fd72f99fee462ed1a9e4abea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga5cc746d1fd72f99fee462ed1a9e4abea">getTransformation</a> (Scalar x, Scalar y, Scalar z, Scalar roll, Scalar pitch, Scalar yaw, Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;t)</td></tr>
<tr class="memdesc:ga5cc746d1fd72f99fee462ed1a9e4abea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation from the given translation and Euler angles (XYZ-convention)  <a href="group__common.html#ga5cc746d1fd72f99fee462ed1a9e4abea">More...</a><br /></td></tr>
<tr class="separator:ga5cc746d1fd72f99fee462ed1a9e4abea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8678bc9ac51ff4a0dc27cd543b6ac84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aa8678bc9ac51ff4a0dc27cd543b6ac84">getTransformation</a> (float x, float y, float z, float roll, float pitch, float yaw, Eigen::Affine3f &amp;t)</td></tr>
<tr class="separator:aa8678bc9ac51ff4a0dc27cd543b6ac84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f0e4ca5bc914138112691e0632b49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aab2f0e4ca5bc914138112691e0632b49">getTransformation</a> (double x, double y, double z, double roll, double pitch, double yaw, Eigen::Affine3d &amp;t)</td></tr>
<tr class="separator:aab2f0e4ca5bc914138112691e0632b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49a34180e337479ddeda21222882124"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaf49a34180e337479ddeda21222882124">getTransformation</a> (float x, float y, float z, float roll, float pitch, float yaw)</td></tr>
<tr class="memdesc:gaf49a34180e337479ddeda21222882124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation from the given translation and Euler angles (XYZ-convention)  <a href="group__common.html#gaf49a34180e337479ddeda21222882124">More...</a><br /></td></tr>
<tr class="separator:gaf49a34180e337479ddeda21222882124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc18ebcacd806fd0c9336fe2f8b7208c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:gacc18ebcacd806fd0c9336fe2f8b7208c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gacc18ebcacd806fd0c9336fe2f8b7208c">saveBinary</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, std::ostream &amp;file)</td></tr>
<tr class="memdesc:gacc18ebcacd806fd0c9336fe2f8b7208c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a matrix to an output stream.  <a href="group__common.html#gacc18ebcacd806fd0c9336fe2f8b7208c">More...</a><br /></td></tr>
<tr class="separator:gacc18ebcacd806fd0c9336fe2f8b7208c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5281205532955d384c8aa22ff4ff5e80"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ga5281205532955d384c8aa22ff4ff5e80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga5281205532955d384c8aa22ff4ff5e80">loadBinary</a> (Eigen::MatrixBase&lt; Derived &gt; const &amp;matrix, std::istream &amp;file)</td></tr>
<tr class="memdesc:ga5281205532955d384c8aa22ff4ff5e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix from an input stream.  <a href="group__common.html#ga5281205532955d384c8aa22ff4ff5e80">More...</a><br /></td></tr>
<tr class="separator:ga5281205532955d384c8aa22ff4ff5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65861ea96a34a05b42fea5ada648c8bf"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename OtherDerived &gt; </td></tr>
<tr class="memitem:a65861ea96a34a05b42fea5ada648c8bf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::internal::umeyama_transform_matrix_type&lt; Derived, OtherDerived &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a65861ea96a34a05b42fea5ada648c8bf">umeyama</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;src, const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;dst, bool with_scaling=false)</td></tr>
<tr class="memdesc:a65861ea96a34a05b42fea5ada648c8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transformation between two point sets.  <a href="namespacepcl.html#a65861ea96a34a05b42fea5ada648c8bf">More...</a><br /></td></tr>
<tr class="separator:a65861ea96a34a05b42fea5ada648c8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5b5b7345fac388db975e1eb5577628"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5a5b5b7345fac388db975e1eb5577628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5a5b5b7345fac388db975e1eb5577628">transformPoint</a> (const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;point_in, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;point_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="memdesc:a5a5b5b7345fac388db975e1eb5577628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point using an affine matrix.  <a href="namespacepcl.html#a5a5b5b7345fac388db975e1eb5577628">More...</a><br /></td></tr>
<tr class="separator:a5a5b5b7345fac388db975e1eb5577628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacbba9c2228c2dc21aa4aa3e2fb5b03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aeacbba9c2228c2dc21aa4aa3e2fb5b03">transformPoint</a> (const Eigen::Vector3f &amp;point_in, Eigen::Vector3f &amp;point_out, const Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="separator:aeacbba9c2228c2dc21aa4aa3e2fb5b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78eee91f5fe85181edebfcdf871109cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a78eee91f5fe85181edebfcdf871109cb">transformPoint</a> (const Eigen::Vector3d &amp;point_in, Eigen::Vector3d &amp;point_out, const Eigen::Affine3d &amp;transformation)</td></tr>
<tr class="separator:a78eee91f5fe85181edebfcdf871109cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a9da67d327b4940e73e18fd2970775"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a63a9da67d327b4940e73e18fd2970775"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a63a9da67d327b4940e73e18fd2970775">transformVector</a> (const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;vector_in, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;vector_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="memdesc:a63a9da67d327b4940e73e18fd2970775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a vector using an affine matrix.  <a href="namespacepcl.html#a63a9da67d327b4940e73e18fd2970775">More...</a><br /></td></tr>
<tr class="separator:a63a9da67d327b4940e73e18fd2970775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae310fc96b4f9e6829d99c6a873ac4b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae310fc96b4f9e6829d99c6a873ac4b10">transformVector</a> (const Eigen::Vector3f &amp;vector_in, Eigen::Vector3f &amp;vector_out, const Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="separator:ae310fc96b4f9e6829d99c6a873ac4b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2183a5dca6c3c71d150d44bf7a042f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ade2183a5dca6c3c71d150d44bf7a042f">transformVector</a> (const Eigen::Vector3d &amp;vector_in, Eigen::Vector3d &amp;vector_out, const Eigen::Affine3d &amp;transformation)</td></tr>
<tr class="separator:ade2183a5dca6c3c71d150d44bf7a042f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fd28edbb46c951a2ed1da38c32ec86"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a76fd28edbb46c951a2ed1da38c32ec86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a76fd28edbb46c951a2ed1da38c32ec86">transformLine</a> (const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;line_in, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;line_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="memdesc:a76fd28edbb46c951a2ed1da38c32ec86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a line using an affine matrix.  <a href="namespacepcl.html#a76fd28edbb46c951a2ed1da38c32ec86">More...</a><br /></td></tr>
<tr class="separator:a76fd28edbb46c951a2ed1da38c32ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997d49a6f1c11be29bf3db6a7ad1c93b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a997d49a6f1c11be29bf3db6a7ad1c93b">transformLine</a> (const Eigen::VectorXf &amp;line_in, Eigen::VectorXf &amp;line_out, const Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="separator:a997d49a6f1c11be29bf3db6a7ad1c93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd0ac90e227ddbac62b981045f7ee76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2fd0ac90e227ddbac62b981045f7ee76">transformLine</a> (const Eigen::VectorXd &amp;line_in, Eigen::VectorXd &amp;line_out, const Eigen::Affine3d &amp;transformation)</td></tr>
<tr class="separator:a2fd0ac90e227ddbac62b981045f7ee76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350ec0c9c7e7fbac1581dc01db77d5e6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a350ec0c9c7e7fbac1581dc01db77d5e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a350ec0c9c7e7fbac1581dc01db77d5e6">transformPlane</a> (const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_in, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="memdesc:a350ec0c9c7e7fbac1581dc01db77d5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform plane vectors using an affine matrix.  <a href="namespacepcl.html#a350ec0c9c7e7fbac1581dc01db77d5e6">More...</a><br /></td></tr>
<tr class="separator:a350ec0c9c7e7fbac1581dc01db77d5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667af5d4074fc5bf917549b1ecc28ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a667af5d4074fc5bf917549b1ecc28ea6">transformPlane</a> (const Eigen::Matrix&lt; double, 4, 1 &gt; &amp;plane_in, Eigen::Matrix&lt; double, 4, 1 &gt; &amp;plane_out, const Eigen::Transform&lt; double, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="separator:a667af5d4074fc5bf917549b1ecc28ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51632e4157f725102a3ae373981eab8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a51632e4157f725102a3ae373981eab8c">transformPlane</a> (const Eigen::Matrix&lt; float, 4, 1 &gt; &amp;plane_in, Eigen::Matrix&lt; float, 4, 1 &gt; &amp;plane_out, const Eigen::Transform&lt; float, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="separator:a51632e4157f725102a3ae373981eab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ce9e89d1fd409e8e2217da8d3b3c8a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a08ce9e89d1fd409e8e2217da8d3b3c8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a08ce9e89d1fd409e8e2217da8d3b3c8a">transformPlane</a> (const <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a> plane_in, <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a> plane_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="memdesc:a08ce9e89d1fd409e8e2217da8d3b3c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform plane vectors using an affine matrix.  <a href="namespacepcl.html#a08ce9e89d1fd409e8e2217da8d3b3c8a">More...</a><br /></td></tr>
<tr class="separator:a08ce9e89d1fd409e8e2217da8d3b3c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41234b4e47f34a90944122bc441ebda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab41234b4e47f34a90944122bc441ebda">transformPlane</a> (const <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a> plane_in, <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a> plane_out, const Eigen::Transform&lt; double, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="separator:ab41234b4e47f34a90944122bc441ebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a18cf3648dc9cc2d0889d1616c4ca8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8a18cf3648dc9cc2d0889d1616c4ca8f">transformPlane</a> (const <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a> plane_in, <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a> plane_out, const Eigen::Transform&lt; float, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="separator:a8a18cf3648dc9cc2d0889d1616c4ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073da9b1c5ee4fd5ac15eccd804995f7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a073da9b1c5ee4fd5ac15eccd804995f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a073da9b1c5ee4fd5ac15eccd804995f7">checkCoordinateSystem</a> (const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;line_x, const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;line_y, const Scalar norm_limit=1e-3, const Scalar dot_limit=1e-3)</td></tr>
<tr class="memdesc:a073da9b1c5ee4fd5ac15eccd804995f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check coordinate system integrity.  <a href="namespacepcl.html#a073da9b1c5ee4fd5ac15eccd804995f7">More...</a><br /></td></tr>
<tr class="separator:a073da9b1c5ee4fd5ac15eccd804995f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f18110e59c57b715ed3d378d18f433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a10f18110e59c57b715ed3d378d18f433">checkCoordinateSystem</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;line_x, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;line_y, const double norm_limit=1e-3, const double dot_limit=1e-3)</td></tr>
<tr class="separator:a10f18110e59c57b715ed3d378d18f433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f202bbd62dd1a8d828500e4bff778"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a915f202bbd62dd1a8d828500e4bff778">checkCoordinateSystem</a> (const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &amp;line_x, const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &amp;line_y, const float norm_limit=1e-3, const float dot_limit=1e-3)</td></tr>
<tr class="separator:a915f202bbd62dd1a8d828500e4bff778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089e47fff14e983bc229b7e82f00f4ad"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a089e47fff14e983bc229b7e82f00f4ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a089e47fff14e983bc229b7e82f00f4ad">checkCoordinateSystem</a> (const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;origin, const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;x_direction, const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;y_direction, const Scalar norm_limit=1e-3, const Scalar dot_limit=1e-3)</td></tr>
<tr class="memdesc:a089e47fff14e983bc229b7e82f00f4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check coordinate system integrity.  <a href="namespacepcl.html#a089e47fff14e983bc229b7e82f00f4ad">More...</a><br /></td></tr>
<tr class="separator:a089e47fff14e983bc229b7e82f00f4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d7af22d0df41b705c51af741aef133"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aa5d7af22d0df41b705c51af741aef133">checkCoordinateSystem</a> (const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;origin, const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;x_direction, const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;y_direction, const double norm_limit=1e-3, const double dot_limit=1e-3)</td></tr>
<tr class="separator:aa5d7af22d0df41b705c51af741aef133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e85af115a167f7fdf7feaeb86e759a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9e85af115a167f7fdf7feaeb86e759a9">checkCoordinateSystem</a> (const Eigen::Matrix&lt; float, 3, 1 &gt; &amp;origin, const Eigen::Matrix&lt; float, 3, 1 &gt; &amp;x_direction, const Eigen::Matrix&lt; float, 3, 1 &gt; &amp;y_direction, const float norm_limit=1e-3, const float dot_limit=1e-3)</td></tr>
<tr class="separator:a9e85af115a167f7fdf7feaeb86e759a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ec11d4f29c5c8a5b6220c0838a294f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a71ec11d4f29c5c8a5b6220c0838a294f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a71ec11d4f29c5c8a5b6220c0838a294f">transformBetween2CoordinateSystems</a> (const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; from_line_x, const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; from_line_y, const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; to_line_x, const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; to_line_y, Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="memdesc:a71ec11d4f29c5c8a5b6220c0838a294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the transformation between two coordinate systems.  <a href="namespacepcl.html#a71ec11d4f29c5c8a5b6220c0838a294f">More...</a><br /></td></tr>
<tr class="separator:a71ec11d4f29c5c8a5b6220c0838a294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc8393db8572b2e75f7dc880315d04c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2cc8393db8572b2e75f7dc880315d04c">transformBetween2CoordinateSystems</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; from_line_x, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; from_line_y, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; to_line_x, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; to_line_y, Eigen::Transform&lt; double, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="separator:a2cc8393db8572b2e75f7dc880315d04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040e5a468379787b82aa58540cda0a8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a040e5a468379787b82aa58540cda0a8e">transformBetween2CoordinateSystems</a> (const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; from_line_x, const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; from_line_y, const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; to_line_x, const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; to_line_y, Eigen::Transform&lt; float, 3, Eigen::Affine &gt; &amp;transformation)</td></tr>
<tr class="separator:a040e5a468379787b82aa58540cda0a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65492f5cdc563cd60c2267366788d077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a65492f5cdc563cd60c2267366788d077">getAllPcdFilesInDirectory</a> (const std::string &amp;directory, std::vector&lt; std::string &gt; &amp;file_names)</td></tr>
<tr class="memdesc:a65492f5cdc563cd60c2267366788d077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all *.pcd files in the directory and return them sorted.  <a href="namespacepcl.html#a65492f5cdc563cd60c2267366788d077">More...</a><br /></td></tr>
<tr class="separator:a65492f5cdc563cd60c2267366788d077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fba9b71d0b5ddc824cc3555c258513"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a77fba9b71d0b5ddc824cc3555c258513">getFilenameWithoutPath</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a77fba9b71d0b5ddc824cc3555c258513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the path from the given string and return only the filename (the remaining string after the last '/')  <a href="namespacepcl.html#a77fba9b71d0b5ddc824cc3555c258513">More...</a><br /></td></tr>
<tr class="separator:a77fba9b71d0b5ddc824cc3555c258513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45ced9a4448cf680b2e5da96f4e9aea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af45ced9a4448cf680b2e5da96f4e9aea">getFilenameWithoutExtension</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:af45ced9a4448cf680b2e5da96f4e9aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the extension from the given string and return only the filename (everything before the last '.  <a href="namespacepcl.html#af45ced9a4448cf680b2e5da96f4e9aea">More...</a><br /></td></tr>
<tr class="separator:af45ced9a4448cf680b2e5da96f4e9aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40c9e0ff704ed675e3300ed02451796"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae40c9e0ff704ed675e3300ed02451796">getFileExtension</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:ae40c9e0ff704ed675e3300ed02451796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file extension from the given string (the remaining string after the last '.  <a href="namespacepcl.html#ae40c9e0ff704ed675e3300ed02451796">More...</a><br /></td></tr>
<tr class="separator:ae40c9e0ff704ed675e3300ed02451796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac36b146ec26b1ceb7be43a9ecaa010c4">computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 covariance matrix of a given set of points.  <a href="group__common.html#gac36b146ec26b1ceb7be43a9ecaa010c4">More...</a><br /></td></tr>
<tr class="separator:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d365f5e3c7400a13c55d001ed76e35b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga4d365f5e3c7400a13c55d001ed76e35b">lineWithLineIntersection</a> (const Eigen::VectorXf &amp;line_a, const Eigen::VectorXf &amp;line_b, Eigen::Vector4f &amp;point, double sqr_eps=1e-4)</td></tr>
<tr class="memdesc:ga4d365f5e3c7400a13c55d001ed76e35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection of a two 3D lines in space as a 3D point.  <a href="group__common.html#ga4d365f5e3c7400a13c55d001ed76e35b">More...</a><br /></td></tr>
<tr class="separator:ga4d365f5e3c7400a13c55d001ed76e35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee7c3cfcb96e3884199191a9c24f6f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaeee7c3cfcb96e3884199191a9c24f6f0">lineWithLineIntersection</a> (const <a class="el" href="structpcl_1_1_model_coefficients.html">pcl::ModelCoefficients</a> &amp;line_a, const <a class="el" href="structpcl_1_1_model_coefficients.html">pcl::ModelCoefficients</a> &amp;line_b, Eigen::Vector4f &amp;point, double sqr_eps=1e-4)</td></tr>
<tr class="memdesc:gaeee7c3cfcb96e3884199191a9c24f6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection of a two 3D lines in space as a 3D point.  <a href="group__common.html#gaeee7c3cfcb96e3884199191a9c24f6f0">More...</a><br /></td></tr>
<tr class="separator:gaeee7c3cfcb96e3884199191a9c24f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f34b2d4af408c1e4c13414ee32451f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a96f34b2d4af408c1e4c13414ee32451f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a96f34b2d4af408c1e4c13414ee32451f">planeWithPlaneIntersection</a> (const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_a, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_b, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;line, double angular_tolerance)</td></tr>
<tr class="memdesc:a96f34b2d4af408c1e4c13414ee32451f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the line of intersection of two non-parallel planes using lagrange multipliers.  <a href="namespacepcl.html#a96f34b2d4af408c1e4c13414ee32451f">More...</a><br /></td></tr>
<tr class="separator:a96f34b2d4af408c1e4c13414ee32451f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2602bbf77a4278ada7b16d88fd35d7b3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a2602bbf77a4278ada7b16d88fd35d7b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2602bbf77a4278ada7b16d88fd35d7b3">threePlanesIntersection</a> (const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_a, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_b, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_c, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;intersection_point, double determinant_tolerance)</td></tr>
<tr class="memdesc:a2602bbf77a4278ada7b16d88fd35d7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the point of intersection of three non-parallel planes by solving the equations.  <a href="namespacepcl.html#a2602bbf77a4278ada7b16d88fd35d7b3">More...</a><br /></td></tr>
<tr class="separator:a2602bbf77a4278ada7b16d88fd35d7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9e56869486f44e2caa30a584c1b734"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaad9e56869486f44e2caa30a584c1b734"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaad9e56869486f44e2caa30a584c1b734">getFieldIndex</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const std::string &amp;field_name, std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:gaad9e56869486f44e2caa30a584c1b734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specified field (i.e., dimension/channel)  <a href="group__common.html#gaad9e56869486f44e2caa30a584c1b734">More...</a><br /></td></tr>
<tr class="separator:gaad9e56869486f44e2caa30a584c1b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f637d9f7422a769448983af5fcbdeb"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga21f637d9f7422a769448983af5fcbdeb"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga21f637d9f7422a769448983af5fcbdeb">getFieldIndex</a> (const std::string &amp;field_name, std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:ga21f637d9f7422a769448983af5fcbdeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specified field (i.e., dimension/channel)  <a href="group__common.html#ga21f637d9f7422a769448983af5fcbdeb">More...</a><br /></td></tr>
<tr class="separator:ga21f637d9f7422a769448983af5fcbdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c5daaf825f6cc4a3fb93a8544d6bdc4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga3c5daaf825f6cc4a3fb93a8544d6bdc4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3c5daaf825f6cc4a3fb93a8544d6bdc4">getFieldIndex</a> (const std::string &amp;field_name, const std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:ga3c5daaf825f6cc4a3fb93a8544d6bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specified field (i.e., dimension/channel)  <a href="group__common.html#ga3c5daaf825f6cc4a3fb93a8544d6bdc4">More...</a><br /></td></tr>
<tr class="separator:ga3c5daaf825f6cc4a3fb93a8544d6bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ff830572b7cbf2fd8ce335fd9ca4fb"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaa2ff830572b7cbf2fd8ce335fd9ca4fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaa2ff830572b7cbf2fd8ce335fd9ca4fb">getFields</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:gaa2ff830572b7cbf2fd8ce335fd9ca4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of available fields (i.e., dimension/channel)  <a href="group__common.html#gaa2ff830572b7cbf2fd8ce335fd9ca4fb">More...</a><br /></td></tr>
<tr class="separator:gaa2ff830572b7cbf2fd8ce335fd9ca4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae88a16c0d6d70da8978ead0bb4e8e766"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gae88a16c0d6d70da8978ead0bb4e8e766"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gae88a16c0d6d70da8978ead0bb4e8e766">getFields</a> (std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:gae88a16c0d6d70da8978ead0bb4e8e766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of available fields (i.e., dimension/channel)  <a href="group__common.html#gae88a16c0d6d70da8978ead0bb4e8e766">More...</a><br /></td></tr>
<tr class="separator:gae88a16c0d6d70da8978ead0bb4e8e766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8788f010a13b19fc04d9dc2305fde22"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gac8788f010a13b19fc04d9dc2305fde22"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac8788f010a13b19fc04d9dc2305fde22">getFields</a> ()</td></tr>
<tr class="memdesc:gac8788f010a13b19fc04d9dc2305fde22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of available fields (i.e., dimension/channel)  <a href="group__common.html#gac8788f010a13b19fc04d9dc2305fde22">More...</a><br /></td></tr>
<tr class="separator:gac8788f010a13b19fc04d9dc2305fde22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabed3f370d11ba5dc154d79e682d35b4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaabed3f370d11ba5dc154d79e682d35b4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaabed3f370d11ba5dc154d79e682d35b4">getFieldsList</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud)</td></tr>
<tr class="memdesc:gaabed3f370d11ba5dc154d79e682d35b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all fields available in a given cloud.  <a href="group__common.html#gaabed3f370d11ba5dc154d79e682d35b4">More...</a><br /></td></tr>
<tr class="separator:gaabed3f370d11ba5dc154d79e682d35b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff182bca8d0295d727baaa1fd368c6ad"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:gaff182bca8d0295d727baaa1fd368c6ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaff182bca8d0295d727baaa1fd368c6ad">copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gaff182bca8d0295d727baaa1fd368c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all the fields from a given point cloud into a new point cloud.  <a href="group__common.html#gaff182bca8d0295d727baaa1fd368c6ad">More...</a><br /></td></tr>
<tr class="separator:gaff182bca8d0295d727baaa1fd368c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63889e8e562908917ec218b86ef826b4"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename IndicesVectorAllocator &gt; </td></tr>
<tr class="memitem:ga63889e8e562908917ec218b86ef826b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga63889e8e562908917ec218b86ef826b4">copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; IndicesVectorAllocator &gt; &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga63889e8e562908917ec218b86ef826b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga63889e8e562908917ec218b86ef826b4">More...</a><br /></td></tr>
<tr class="separator:ga63889e8e562908917ec218b86ef826b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c154414777ed872edea44560502922e"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT , typename IndicesVectorAllocator &gt; </td></tr>
<tr class="memitem:ga5c154414777ed872edea44560502922e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga5c154414777ed872edea44560502922e">copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; IndicesVectorAllocator &gt; &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga5c154414777ed872edea44560502922e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga5c154414777ed872edea44560502922e">More...</a><br /></td></tr>
<tr class="separator:ga5c154414777ed872edea44560502922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ece0c2faffdb26cd75417200454577"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga44ece0c2faffdb26cd75417200454577"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga44ece0c2faffdb26cd75417200454577">copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga44ece0c2faffdb26cd75417200454577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga44ece0c2faffdb26cd75417200454577">More...</a><br /></td></tr>
<tr class="separator:ga44ece0c2faffdb26cd75417200454577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67ab079e174e900e6e0b235fb88d7160"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ga67ab079e174e900e6e0b235fb88d7160"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga67ab079e174e900e6e0b235fb88d7160">copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga67ab079e174e900e6e0b235fb88d7160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga67ab079e174e900e6e0b235fb88d7160">More...</a><br /></td></tr>
<tr class="separator:ga67ab079e174e900e6e0b235fb88d7160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafe5bf1194ffaad83a2fc04cde6b20e4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaafe5bf1194ffaad83a2fc04cde6b20e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaafe5bf1194ffaad83a2fc04cde6b20e4">copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gaafe5bf1194ffaad83a2fc04cde6b20e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#gaafe5bf1194ffaad83a2fc04cde6b20e4">More...</a><br /></td></tr>
<tr class="separator:gaafe5bf1194ffaad83a2fc04cde6b20e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ab28ac738a42a65f9f2033d6b33252"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:gaa5ab28ac738a42a65f9f2033d6b33252"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaa5ab28ac738a42a65f9f2033d6b33252">copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud_in, const std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gaa5ab28ac738a42a65f9f2033d6b33252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#gaa5ab28ac738a42a65f9f2033d6b33252">More...</a><br /></td></tr>
<tr class="separator:gaa5ab28ac738a42a65f9f2033d6b33252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6add803f86fd16a998dce541e9ef402"><td class="memTemplParams" colspan="2">template&lt;typename PointIn1T , typename PointIn2T , typename PointOutT &gt; </td></tr>
<tr class="memitem:gac6add803f86fd16a998dce541e9ef402"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac6add803f86fd16a998dce541e9ef402">concatenateFields</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointIn1T &gt; &amp;cloud1_in, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointIn2T &gt; &amp;cloud2_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gac6add803f86fd16a998dce541e9ef402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two datasets representing different fields.  <a href="group__common.html#gac6add803f86fd16a998dce541e9ef402">More...</a><br /></td></tr>
<tr class="separator:gac6add803f86fd16a998dce541e9ef402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d12b955edd61947ed984e46d65b0046"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga4d12b955edd61947ed984e46d65b0046"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4d12b955edd61947ed984e46d65b0046">copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, int top, int bottom, int left, int right, <a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485">pcl::InterpolationType</a> border_type, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;value)</td></tr>
<tr class="memdesc:ga4d12b955edd61947ed984e46d65b0046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a point cloud inside a larger one interpolating borders.  <a href="group__common.html#ga4d12b955edd61947ed984e46d65b0046">More...</a><br /></td></tr>
<tr class="separator:ga4d12b955edd61947ed984e46d65b0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047d812778a099ab333c847342c4b6bf"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga047d812778a099ab333c847342c4b6bf"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga047d812778a099ab333c847342c4b6bf">selectNorm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim, <a class="el" href="group__common.html#ga9d37f00989a9de11b48deb263649463c">NormType</a> norm_type)</td></tr>
<tr class="memdesc:ga047d812778a099ab333c847342c4b6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that calculates any norm type available, based on the norm_type variable.  <a href="group__common.html#ga047d812778a099ab333c847342c4b6bf">More...</a><br /></td></tr>
<tr class="separator:ga047d812778a099ab333c847342c4b6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d1e988b461de40a26b4e4e9e93ce55"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga61d1e988b461de40a26b4e4e9e93ce55"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga61d1e988b461de40a26b4e4e9e93ce55">L1_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga61d1e988b461de40a26b4e4e9e93ce55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L1 norm of the vector between two points.  <a href="group__common.html#ga61d1e988b461de40a26b4e4e9e93ce55">More...</a><br /></td></tr>
<tr class="separator:ga61d1e988b461de40a26b4e4e9e93ce55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf034c4bca3fc85c1e6d27d893c2936a5"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:gaf034c4bca3fc85c1e6d27d893c2936a5"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaf034c4bca3fc85c1e6d27d893c2936a5">L2_Norm_SQR</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:gaf034c4bca3fc85c1e6d27d893c2936a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared L2 norm of the vector between two points.  <a href="group__common.html#gaf034c4bca3fc85c1e6d27d893c2936a5">More...</a><br /></td></tr>
<tr class="separator:gaf034c4bca3fc85c1e6d27d893c2936a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70456fbb6c67cf3c1229e19c831b30ac"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga70456fbb6c67cf3c1229e19c831b30ac"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga70456fbb6c67cf3c1229e19c831b30ac">L2_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga70456fbb6c67cf3c1229e19c831b30ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2 norm of the vector between two points.  <a href="group__common.html#ga70456fbb6c67cf3c1229e19c831b30ac">More...</a><br /></td></tr>
<tr class="separator:ga70456fbb6c67cf3c1229e19c831b30ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63fded8c9593744836d761940cab9350"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga63fded8c9593744836d761940cab9350"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga63fded8c9593744836d761940cab9350">Linf_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga63fded8c9593744836d761940cab9350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L-infinity norm of the vector between two points.  <a href="group__common.html#ga63fded8c9593744836d761940cab9350">More...</a><br /></td></tr>
<tr class="separator:ga63fded8c9593744836d761940cab9350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45baeaeb21308cd128a7c44ab786552c"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga45baeaeb21308cd128a7c44ab786552c"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga45baeaeb21308cd128a7c44ab786552c">JM_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga45baeaeb21308cd128a7c44ab786552c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the JM norm of the vector between two points.  <a href="group__common.html#ga45baeaeb21308cd128a7c44ab786552c">More...</a><br /></td></tr>
<tr class="separator:ga45baeaeb21308cd128a7c44ab786552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb2818b6fa817f3ada41296793283a1"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga0eb2818b6fa817f3ada41296793283a1"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga0eb2818b6fa817f3ada41296793283a1">B_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga0eb2818b6fa817f3ada41296793283a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the B norm of the vector between two points.  <a href="group__common.html#ga0eb2818b6fa817f3ada41296793283a1">More...</a><br /></td></tr>
<tr class="separator:ga0eb2818b6fa817f3ada41296793283a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac986c55a5b8850fec89cd26c46303747"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:gac986c55a5b8850fec89cd26c46303747"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac986c55a5b8850fec89cd26c46303747">Sublinear_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:gac986c55a5b8850fec89cd26c46303747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sublinear norm of the vector between two points.  <a href="group__common.html#gac986c55a5b8850fec89cd26c46303747">More...</a><br /></td></tr>
<tr class="separator:gac986c55a5b8850fec89cd26c46303747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e43f6ae7f0607bfdedaea512c510ff8"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga7e43f6ae7f0607bfdedaea512c510ff8"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga7e43f6ae7f0607bfdedaea512c510ff8">CS_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga7e43f6ae7f0607bfdedaea512c510ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the CS norm of the vector between two points.  <a href="group__common.html#ga7e43f6ae7f0607bfdedaea512c510ff8">More...</a><br /></td></tr>
<tr class="separator:ga7e43f6ae7f0607bfdedaea512c510ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b5c722d30c22652327a1481528224e"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:gae8b5c722d30c22652327a1481528224e"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gae8b5c722d30c22652327a1481528224e">Div_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:gae8b5c722d30c22652327a1481528224e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the div norm of the vector between two points.  <a href="group__common.html#gae8b5c722d30c22652327a1481528224e">More...</a><br /></td></tr>
<tr class="separator:gae8b5c722d30c22652327a1481528224e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf977fbc818d41de61285d1da0521991a"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:gaf977fbc818d41de61285d1da0521991a"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaf977fbc818d41de61285d1da0521991a">PF_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim, float P1, float P2)</td></tr>
<tr class="memdesc:gaf977fbc818d41de61285d1da0521991a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the PF norm of the vector between two points.  <a href="group__common.html#gaf977fbc818d41de61285d1da0521991a">More...</a><br /></td></tr>
<tr class="separator:gaf977fbc818d41de61285d1da0521991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df86a6dafef9778fb8df865ad54e28f"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga4df86a6dafef9778fb8df865ad54e28f"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4df86a6dafef9778fb8df865ad54e28f">K_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim, float P1, float P2)</td></tr>
<tr class="memdesc:ga4df86a6dafef9778fb8df865ad54e28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the K norm of the vector between two points.  <a href="group__common.html#ga4df86a6dafef9778fb8df865ad54e28f">More...</a><br /></td></tr>
<tr class="separator:ga4df86a6dafef9778fb8df865ad54e28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga186a26b9face0cfb0fea3d6eb37f909b"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga186a26b9face0cfb0fea3d6eb37f909b"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga186a26b9face0cfb0fea3d6eb37f909b">KL_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga186a26b9face0cfb0fea3d6eb37f909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the KL between two discrete probability density functions.  <a href="group__common.html#ga186a26b9face0cfb0fea3d6eb37f909b">More...</a><br /></td></tr>
<tr class="separator:ga186a26b9face0cfb0fea3d6eb37f909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86297c76ef1756ff1db90d8e39c14fa3"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga86297c76ef1756ff1db90d8e39c14fa3"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga86297c76ef1756ff1db90d8e39c14fa3">HIK_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga86297c76ef1756ff1db90d8e39c14fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the HIK norm of the vector between two points.  <a href="group__common.html#ga86297c76ef1756ff1db90d8e39c14fa3">More...</a><br /></td></tr>
<tr class="separator:ga86297c76ef1756ff1db90d8e39c14fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660ae8fd684c5ea2223b5b81fc46c2c1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a660ae8fd684c5ea2223b5b81fc46c2c1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a660ae8fd684c5ea2223b5b81fc46c2c1">estimateProjectionMatrix</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr cloud, Eigen::Matrix&lt; float, 3, 4, Eigen::RowMajor &gt; &amp;projection_matrix, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices={})</td></tr>
<tr class="memdesc:a660ae8fd684c5ea2223b5b81fc46c2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the projection matrix P = K * (R|-R*t) from organized point clouds, with K = [[fx, s, cx], [0, fy, cy], [0, 0, 1]] R = rotation matrix and t = translation vector <br  />
  <a href="namespacepcl.html#a660ae8fd684c5ea2223b5b81fc46c2c1">More...</a><br /></td></tr>
<tr class="separator:a660ae8fd684c5ea2223b5b81fc46c2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d532f7f2b4d7bba78d13701d3a33d8"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga52d532f7f2b4d7bba78d13701d3a33d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga52d532f7f2b4d7bba78d13701d3a33d8">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga52d532f7f2b4d7bba78d13701d3a33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform.  <a href="group__common.html#ga52d532f7f2b4d7bba78d13701d3a33d8">More...</a><br /></td></tr>
<tr class="separator:ga52d532f7f2b4d7bba78d13701d3a33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938b05611e2f2cfa64839852b4d69df8"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga938b05611e2f2cfa64839852b4d69df8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga938b05611e2f2cfa64839852b4d69df8">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga938b05611e2f2cfa64839852b4d69df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform.  <a href="group__common.html#ga938b05611e2f2cfa64839852b4d69df8">More...</a><br /></td></tr>
<tr class="separator:ga938b05611e2f2cfa64839852b4d69df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bb12134125eaf406cc32e1939f4c60"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:a41bb12134125eaf406cc32e1939f4c60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a41bb12134125eaf406cc32e1939f4c60">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:a41bb12134125eaf406cc32e1939f4c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="namespacepcl.html#a41bb12134125eaf406cc32e1939f4c60">More...</a><br /></td></tr>
<tr class="separator:a41bb12134125eaf406cc32e1939f4c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eede6083fd2722d5b1f3d241c3d126"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ab3eede6083fd2722d5b1f3d241c3d126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab3eede6083fd2722d5b1f3d241c3d126">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ab3eede6083fd2722d5b1f3d241c3d126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="namespacepcl.html#ab3eede6083fd2722d5b1f3d241c3d126">More...</a><br /></td></tr>
<tr class="separator:ab3eede6083fd2722d5b1f3d241c3d126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff524851ffbcbefdbef2277134382906"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaff524851ffbcbefdbef2277134382906"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaff524851ffbcbefdbef2277134382906">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;offset, const Eigen::Quaternion&lt; Scalar &gt; &amp;rotation, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:gaff524851ffbcbefdbef2277134382906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform defined by a 3D offset and a quaternion.  <a href="group__common.html#gaff524851ffbcbefdbef2277134382906">More...</a><br /></td></tr>
<tr class="separator:gaff524851ffbcbefdbef2277134382906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d67c0cd4ebb26d770c338d93884974a"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga1d67c0cd4ebb26d770c338d93884974a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga1d67c0cd4ebb26d770c338d93884974a">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;offset, const Eigen::Quaternion&lt; Scalar &gt; &amp;rotation, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga1d67c0cd4ebb26d770c338d93884974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="group__common.html#ga1d67c0cd4ebb26d770c338d93884974a">More...</a><br /></td></tr>
<tr class="separator:ga1d67c0cd4ebb26d770c338d93884974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bd2c5ea1258af3a45483dd1341aa429"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga1bd2c5ea1258af3a45483dd1341aa429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga1bd2c5ea1258af3a45483dd1341aa429">transformPoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform)</td></tr>
<tr class="memdesc:ga1bd2c5ea1258af3a45483dd1341aa429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point with members x,y,z.  <a href="group__common.html#ga1bd2c5ea1258af3a45483dd1341aa429">More...</a><br /></td></tr>
<tr class="separator:ga1bd2c5ea1258af3a45483dd1341aa429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eddef43d5bd5211fcbd774c87962314"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga6eddef43d5bd5211fcbd774c87962314"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga6eddef43d5bd5211fcbd774c87962314">transformPointWithNormal</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform)</td></tr>
<tr class="memdesc:ga6eddef43d5bd5211fcbd774c87962314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point with members x,y,z,normal_x,normal_y,normal_z.  <a href="group__common.html#ga6eddef43d5bd5211fcbd774c87962314">More...</a><br /></td></tr>
<tr class="separator:ga6eddef43d5bd5211fcbd774c87962314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed11aa1fcb5be47d1217ea9aff75df6"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:a7ed11aa1fcb5be47d1217ea9aff75df6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7ed11aa1fcb5be47d1217ea9aff75df6">getPrincipalTransformation</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform)</td></tr>
<tr class="memdesc:a7ed11aa1fcb5be47d1217ea9aff75df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the principal (PCA-based) alignment of the point cloud.  <a href="namespacepcl.html#a7ed11aa1fcb5be47d1217ea9aff75df6">More...</a><br /></td></tr>
<tr class="separator:a7ed11aa1fcb5be47d1217ea9aff75df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425e0506b2af1892e706a2375b9fd0bc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a425e0506b2af1892e706a2375b9fd0bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a425e0506b2af1892e706a2375b9fd0bc">planeWithPlaneIntersection</a> (const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_a, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_b, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;line, double angular_tolerance=0.1)</td></tr>
<tr class="memdesc:a425e0506b2af1892e706a2375b9fd0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the line of intersection of two non-parallel planes using lagrange multipliers.  <a href="namespacepcl.html#a425e0506b2af1892e706a2375b9fd0bc">More...</a><br /></td></tr>
<tr class="separator:a425e0506b2af1892e706a2375b9fd0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc420a405fdf57c19edd9e91d240269b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abc420a405fdf57c19edd9e91d240269b">planeWithPlaneIntersection</a> (const Eigen::Vector4f &amp;plane_a, const Eigen::Vector4f &amp;plane_b, Eigen::VectorXf &amp;line, double angular_tolerance=0.1)</td></tr>
<tr class="separator:abc420a405fdf57c19edd9e91d240269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646a946951d9293cee2500342f8ab08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6646a946951d9293cee2500342f8ab08">planeWithPlaneIntersection</a> (const Eigen::Vector4d &amp;plane_a, const Eigen::Vector4d &amp;plane_b, Eigen::VectorXd &amp;line, double angular_tolerance=0.1)</td></tr>
<tr class="separator:a6646a946951d9293cee2500342f8ab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2056989ddf42f3c88d85b4d0e5c79a7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac2056989ddf42f3c88d85b4d0e5c79a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ac2056989ddf42f3c88d85b4d0e5c79a7">threePlanesIntersection</a> (const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_a, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_b, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;plane_c, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;intersection_point, double determinant_tolerance=1e-6)</td></tr>
<tr class="memdesc:ac2056989ddf42f3c88d85b4d0e5c79a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the point of intersection of three non-parallel planes by solving the equations.  <a href="namespacepcl.html#ac2056989ddf42f3c88d85b4d0e5c79a7">More...</a><br /></td></tr>
<tr class="separator:ac2056989ddf42f3c88d85b4d0e5c79a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecefc6e2d9503d55e2433ef05006a7c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aecefc6e2d9503d55e2433ef05006a7c7">threePlanesIntersection</a> (const Eigen::Vector4f &amp;plane_a, const Eigen::Vector4f &amp;plane_b, const Eigen::Vector4f &amp;plane_c, Eigen::Vector3f &amp;intersection_point, double determinant_tolerance=1e-6)</td></tr>
<tr class="separator:aecefc6e2d9503d55e2433ef05006a7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64550b12c7a235265268291080372169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a64550b12c7a235265268291080372169">threePlanesIntersection</a> (const Eigen::Vector4d &amp;plane_a, const Eigen::Vector4d &amp;plane_b, const Eigen::Vector4d &amp;plane_c, Eigen::Vector3d &amp;intersection_point, double determinant_tolerance=1e-6)</td></tr>
<tr class="separator:a64550b12c7a235265268291080372169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc4b9a4e25de1d0b00db4e41f0ad682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga2bc4b9a4e25de1d0b00db4e41f0ad682">getFieldIndex</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ga2bc4b9a4e25de1d0b00db4e41f0ad682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specified field (i.e., dimension/channel)  <a href="group__common.html#ga2bc4b9a4e25de1d0b00db4e41f0ad682">More...</a><br /></td></tr>
<tr class="separator:ga2bc4b9a4e25de1d0b00db4e41f0ad682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769f320a73865c3fe30cb96c0f932e76"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga769f320a73865c3fe30cb96c0f932e76">getFieldsList</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud)</td></tr>
<tr class="memdesc:ga769f320a73865c3fe30cb96c0f932e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the available point cloud fields as a space separated string.  <a href="group__common.html#ga769f320a73865c3fe30cb96c0f932e76">More...</a><br /></td></tr>
<tr class="separator:ga769f320a73865c3fe30cb96c0f932e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ff4ee40cd3c49c7500905f59f37536"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga83ff4ee40cd3c49c7500905f59f37536">getFieldSize</a> (const int datatype)</td></tr>
<tr class="memdesc:ga83ff4ee40cd3c49c7500905f59f37536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the size of a specific field data type in bytes.  <a href="group__common.html#ga83ff4ee40cd3c49c7500905f59f37536">More...</a><br /></td></tr>
<tr class="separator:ga83ff4ee40cd3c49c7500905f59f37536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ba6d86b4a32723833f26ca2a8dc70d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ac8ba6d86b4a32723833f26ca2a8dc70d">getFieldsSizes</a> (const std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;fields, std::vector&lt; int &gt; &amp;field_sizes)</td></tr>
<tr class="memdesc:ac8ba6d86b4a32723833f26ca2a8dc70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a vector with the sizes of all valid fields (e.g., not "_")  <a href="namespacepcl.html#ac8ba6d86b4a32723833f26ca2a8dc70d">More...</a><br /></td></tr>
<tr class="separator:ac8ba6d86b4a32723833f26ca2a8dc70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac282d255323a916e942f85b7f16740e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gac282d255323a916e942f85b7f16740e3">getFieldType</a> (const int size, char type)</td></tr>
<tr class="memdesc:gac282d255323a916e942f85b7f16740e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the type of the <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> from a specific size and type.  <a href="group__common.html#gac282d255323a916e942f85b7f16740e3">More...</a><br /></td></tr>
<tr class="separator:gac282d255323a916e942f85b7f16740e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a4eaf1f19dd043252a0b93ac975a10"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gac4a4eaf1f19dd043252a0b93ac975a10">getFieldType</a> (const int type)</td></tr>
<tr class="memdesc:gac4a4eaf1f19dd043252a0b93ac975a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the type of the <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> from a specific <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> as a char.  <a href="group__common.html#gac4a4eaf1f19dd043252a0b93ac975a10">More...</a><br /></td></tr>
<tr class="separator:gac4a4eaf1f19dd043252a0b93ac975a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffcf78b18f7bf6e262782ff7c8050b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4ffcf78b18f7bf6e262782ff7c8050b4">interpolatePointIndex</a> (int p, int length, <a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485">InterpolationType</a> type)</td></tr>
<tr class="separator:a4ffcf78b18f7bf6e262782ff7c8050b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb52cf90499012944c9fa22a9f5b2996"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaeb52cf90499012944c9fa22a9f5b2996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaeb52cf90499012944c9fa22a9f5b2996">concatenate</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud1, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud2, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gaeb52cf90499012944c9fa22a9f5b2996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two pcl::PointCloud&lt;PointT&gt;  <a href="group__common.html#gaeb52cf90499012944c9fa22a9f5b2996">More...</a><br /></td></tr>
<tr class="separator:gaeb52cf90499012944c9fa22a9f5b2996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f7e6227f4c26b09c2b3652650894dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaa8f7e6227f4c26b09c2b3652650894dd">concatenate</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud1, const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud2, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:gaa8f7e6227f4c26b09c2b3652650894dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a>.  <a href="group__common.html#gaa8f7e6227f4c26b09c2b3652650894dd">More...</a><br /></td></tr>
<tr class="separator:gaa8f7e6227f4c26b09c2b3652650894dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2f1eca95783c3d8d5a6104ae005efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gafc2f1eca95783c3d8d5a6104ae005efe">concatenate</a> (const <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;mesh1, const <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;mesh2, <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;mesh_out)</td></tr>
<tr class="memdesc:gafc2f1eca95783c3d8d5a6104ae005efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a>.  <a href="group__common.html#gafc2f1eca95783c3d8d5a6104ae005efe">More...</a><br /></td></tr>
<tr class="separator:gafc2f1eca95783c3d8d5a6104ae005efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaebfbeb8e50f90057188131228b2e8b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaaebfbeb8e50f90057188131228b2e8b6">concatenatePointCloud</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud1, const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud2, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:gaaebfbeb8e50f90057188131228b2e8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a>.  <a href="group__common.html#gaaebfbeb8e50f90057188131228b2e8b6">More...</a><br /></td></tr>
<tr class="separator:gaaebfbeb8e50f90057188131228b2e8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e4d41367cf18852d8aab9cc1e5391a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga11e4d41367cf18852d8aab9cc1e5391a">copyPointCloud</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:ga11e4d41367cf18852d8aab9cc1e5391a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga11e4d41367cf18852d8aab9cc1e5391a">More...</a><br /></td></tr>
<tr class="separator:ga11e4d41367cf18852d8aab9cc1e5391a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cad93c0d80f18cb825489e6fd0ed519"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga1cad93c0d80f18cb825489e6fd0ed519">copyPointCloud</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_in, const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; Eigen::aligned_allocator&lt; int &gt; &gt; &amp;indices, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:ga1cad93c0d80f18cb825489e6fd0ed519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga1cad93c0d80f18cb825489e6fd0ed519">More...</a><br /></td></tr>
<tr class="separator:ga1cad93c0d80f18cb825489e6fd0ed519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6c02fe197e0ea6ca249c46dda0e602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga1c6c02fe197e0ea6ca249c46dda0e602">copyPointCloud</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_in, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:ga1c6c02fe197e0ea6ca249c46dda0e602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy fields and point cloud data from <em>cloud_in</em> to <em>cloud_out</em>.  <a href="group__common.html#ga1c6c02fe197e0ea6ca249c46dda0e602">More...</a><br /></td></tr>
<tr class="separator:ga1c6c02fe197e0ea6ca249c46dda0e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e28fae1c62a5cd3ba7b741f75d3e4b"><td class="memTemplParams" colspan="2">template&lt;typename Point1T , typename Point2T &gt; </td></tr>
<tr class="memitem:ab1e28fae1c62a5cd3ba7b741f75d3e4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab1e28fae1c62a5cd3ba7b741f75d3e4b">isSamePointType</a> ()</td></tr>
<tr class="memdesc:ab1e28fae1c62a5cd3ba7b741f75d3e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two given point types are the same or not.  <a href="namespacepcl.html#ab1e28fae1c62a5cd3ba7b741f75d3e4b">More...</a><br /></td></tr>
<tr class="separator:ab1e28fae1c62a5cd3ba7b741f75d3e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54f3a282986844fc7a804242504461e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gac54f3a282986844fc7a804242504461e">concatenateFields</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud1_in, const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud2_in, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:gac54f3a282986844fc7a804242504461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two datasets representing different fields.  <a href="group__common.html#gac54f3a282986844fc7a804242504461e">More...</a><br /></td></tr>
<tr class="separator:gac54f3a282986844fc7a804242504461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d121a64a02046c1c38485ea1fad953e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga6d121a64a02046c1c38485ea1fad953e">getPointCloudAsEigen</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;in, Eigen::MatrixXf &amp;out)</td></tr>
<tr class="memdesc:ga6d121a64a02046c1c38485ea1fad953e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the XYZ dimensions of a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> into <a class="el" href="namespace_eigen.html">Eigen</a> format.  <a href="group__common.html#ga6d121a64a02046c1c38485ea1fad953e">More...</a><br /></td></tr>
<tr class="separator:ga6d121a64a02046c1c38485ea1fad953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a91d95901fcbac4a753a4212cfbf221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga7a91d95901fcbac4a753a4212cfbf221">getEigenAsPointCloud</a> (Eigen::MatrixXf &amp;in, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;out)</td></tr>
<tr class="memdesc:ga7a91d95901fcbac4a753a4212cfbf221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the XYZ dimensions from an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf into a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> message.  <a href="group__common.html#ga7a91d95901fcbac4a753a4212cfbf221">More...</a><br /></td></tr>
<tr class="separator:ga7a91d95901fcbac4a753a4212cfbf221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adb775f2d234f57c4e7c1209eb95a1d"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a2adb775f2d234f57c4e7c1209eb95a1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">isFinite</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt)</td></tr>
<tr class="memdesc:a2adb775f2d234f57c4e7c1209eb95a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the 3D components of a point are all finite param[in] pt point to be tested return true if finite, false otherwise.  <a href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">More...</a><br /></td></tr>
<tr class="separator:a2adb775f2d234f57c4e7c1209eb95a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6109e92464c36a97c430673de3051e42"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6109e92464c36a97c430673de3051e42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6109e92464c36a97c430673de3051e42">isFinite&lt; pcl::Axis &gt;</a> (const <a class="el" href="structpcl_1_1_axis.html">pcl::Axis</a> &amp;)</td></tr>
<tr class="separator:a6109e92464c36a97c430673de3051e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de9a778c79fd01e22547a031a56740a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3de9a778c79fd01e22547a031a56740a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3de9a778c79fd01e22547a031a56740a">isFinite&lt; pcl::BRISKSignature512 &gt;</a> (const <a class="el" href="structpcl_1_1_b_r_i_s_k_signature512.html">pcl::BRISKSignature512</a> &amp;)</td></tr>
<tr class="separator:a3de9a778c79fd01e22547a031a56740a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68686bc9f758b0e536106c09e42f7ab2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a68686bc9f758b0e536106c09e42f7ab2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a68686bc9f758b0e536106c09e42f7ab2">isFinite&lt; pcl::BorderDescription &gt;</a> (const <a class="el" href="structpcl_1_1_border_description.html">pcl::BorderDescription</a> &amp;)</td></tr>
<tr class="separator:a68686bc9f758b0e536106c09e42f7ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206b8c7c106c4d9d7e917761f35df9c5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a206b8c7c106c4d9d7e917761f35df9c5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a206b8c7c106c4d9d7e917761f35df9c5">isFinite&lt; pcl::Boundary &gt;</a> (const <a class="el" href="structpcl_1_1_boundary.html">pcl::Boundary</a> &amp;)</td></tr>
<tr class="separator:a206b8c7c106c4d9d7e917761f35df9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab813ac49dfae6d8e63ad62f28c9a0494"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab813ac49dfae6d8e63ad62f28c9a0494"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab813ac49dfae6d8e63ad62f28c9a0494">isFinite&lt; pcl::ESFSignature640 &gt;</a> (const <a class="el" href="structpcl_1_1_e_s_f_signature640.html">pcl::ESFSignature640</a> &amp;)</td></tr>
<tr class="separator:ab813ac49dfae6d8e63ad62f28c9a0494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020eefa3852acf44161d192426a6931a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a020eefa3852acf44161d192426a6931a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a020eefa3852acf44161d192426a6931a">isFinite&lt; pcl::FPFHSignature33 &gt;</a> (const <a class="el" href="structpcl_1_1_f_p_f_h_signature33.html">pcl::FPFHSignature33</a> &amp;)</td></tr>
<tr class="separator:a020eefa3852acf44161d192426a6931a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553636c8ec38aaac63a5f7413ee94edc"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a553636c8ec38aaac63a5f7413ee94edc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a553636c8ec38aaac63a5f7413ee94edc">isFinite&lt; pcl::Intensity &gt;</a> (const <a class="el" href="structpcl_1_1_intensity.html">pcl::Intensity</a> &amp;)</td></tr>
<tr class="separator:a553636c8ec38aaac63a5f7413ee94edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0d0c04fa6120c091744698b409af27"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8b0d0c04fa6120c091744698b409af27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8b0d0c04fa6120c091744698b409af27">isFinite&lt; pcl::IntensityGradient &gt;</a> (const <a class="el" href="structpcl_1_1_intensity_gradient.html">pcl::IntensityGradient</a> &amp;)</td></tr>
<tr class="separator:a8b0d0c04fa6120c091744698b409af27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aababd240de792e41b9dbeff10f3f77d7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aababd240de792e41b9dbeff10f3f77d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aababd240de792e41b9dbeff10f3f77d7">isFinite&lt; pcl::Label &gt;</a> (const <a class="el" href="structpcl_1_1_label.html">pcl::Label</a> &amp;)</td></tr>
<tr class="separator:aababd240de792e41b9dbeff10f3f77d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28eaa01a82e41dabf54825ee6e89634e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a28eaa01a82e41dabf54825ee6e89634e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a28eaa01a82e41dabf54825ee6e89634e">isFinite&lt; pcl::MomentInvariants &gt;</a> (const <a class="el" href="structpcl_1_1_moment_invariants.html">pcl::MomentInvariants</a> &amp;)</td></tr>
<tr class="separator:a28eaa01a82e41dabf54825ee6e89634e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e61f396c39343c2d5bad73aad0d4ba8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4e61f396c39343c2d5bad73aad0d4ba8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4e61f396c39343c2d5bad73aad0d4ba8">isFinite&lt; pcl::NormalBasedSignature12 &gt;</a> (const <a class="el" href="structpcl_1_1_normal_based_signature12.html">pcl::NormalBasedSignature12</a> &amp;)</td></tr>
<tr class="separator:a4e61f396c39343c2d5bad73aad0d4ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b143169967583a7d4ab3cf6ce47002a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1b143169967583a7d4ab3cf6ce47002a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1b143169967583a7d4ab3cf6ce47002a">isFinite&lt; pcl::PFHRGBSignature250 &gt;</a> (const <a class="el" href="structpcl_1_1_p_f_h_r_g_b_signature250.html">pcl::PFHRGBSignature250</a> &amp;)</td></tr>
<tr class="separator:a1b143169967583a7d4ab3cf6ce47002a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7238f6a28e8867df6173d1cc4abc6fff"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7238f6a28e8867df6173d1cc4abc6fff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7238f6a28e8867df6173d1cc4abc6fff">isFinite&lt; pcl::PFHSignature125 &gt;</a> (const <a class="el" href="structpcl_1_1_p_f_h_signature125.html">pcl::PFHSignature125</a> &amp;)</td></tr>
<tr class="separator:a7238f6a28e8867df6173d1cc4abc6fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d1bd954e61a6bb139d7103309c8ec2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a05d1bd954e61a6bb139d7103309c8ec2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a05d1bd954e61a6bb139d7103309c8ec2">isFinite&lt; pcl::PPFRGBSignature &gt;</a> (const <a class="el" href="structpcl_1_1_p_p_f_r_g_b_signature.html">pcl::PPFRGBSignature</a> &amp;)</td></tr>
<tr class="separator:a05d1bd954e61a6bb139d7103309c8ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc686eef9a0e685d22f2bfd3e0ef3316"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afc686eef9a0e685d22f2bfd3e0ef3316"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#afc686eef9a0e685d22f2bfd3e0ef3316">isFinite&lt; pcl::PPFSignature &gt;</a> (const <a class="el" href="structpcl_1_1_p_p_f_signature.html">pcl::PPFSignature</a> &amp;)</td></tr>
<tr class="separator:afc686eef9a0e685d22f2bfd3e0ef3316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5302304032aa948f9aaede456dd97803"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5302304032aa948f9aaede456dd97803"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5302304032aa948f9aaede456dd97803">isFinite&lt; pcl::PrincipalCurvatures &gt;</a> (const <a class="el" href="structpcl_1_1_principal_curvatures.html">pcl::PrincipalCurvatures</a> &amp;)</td></tr>
<tr class="separator:a5302304032aa948f9aaede456dd97803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412254387bbfda50c4f9529fbedd0681"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a412254387bbfda50c4f9529fbedd0681"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a412254387bbfda50c4f9529fbedd0681">isFinite&lt; pcl::PrincipalRadiiRSD &gt;</a> (const <a class="el" href="structpcl_1_1_principal_radii_r_s_d.html">pcl::PrincipalRadiiRSD</a> &amp;)</td></tr>
<tr class="separator:a412254387bbfda50c4f9529fbedd0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af741156132ea869caf8e3abcae0bef79"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af741156132ea869caf8e3abcae0bef79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af741156132ea869caf8e3abcae0bef79">isFinite&lt; pcl::RGB &gt;</a> (const <a class="el" href="structpcl_1_1_r_g_b.html">pcl::RGB</a> &amp;)</td></tr>
<tr class="separator:af741156132ea869caf8e3abcae0bef79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4643e7ad834118b6f442fea09d7dd"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2de4643e7ad834118b6f442fea09d7dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2de4643e7ad834118b6f442fea09d7dd">isFinite&lt; pcl::ReferenceFrame &gt;</a> (const <a class="el" href="structpcl_1_1_reference_frame.html">pcl::ReferenceFrame</a> &amp;)</td></tr>
<tr class="separator:a2de4643e7ad834118b6f442fea09d7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cad31cd72f1528a92232ebdf5972db"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a41cad31cd72f1528a92232ebdf5972db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a41cad31cd72f1528a92232ebdf5972db">isFinite&lt; pcl::SHOT1344 &gt;</a> (const <a class="el" href="structpcl_1_1_s_h_o_t1344.html">pcl::SHOT1344</a> &amp;)</td></tr>
<tr class="separator:a41cad31cd72f1528a92232ebdf5972db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd3800e7cf0c93aade46b89a878259"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa3bd3800e7cf0c93aade46b89a878259"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aa3bd3800e7cf0c93aade46b89a878259">isFinite&lt; pcl::SHOT352 &gt;</a> (const <a class="el" href="structpcl_1_1_s_h_o_t352.html">pcl::SHOT352</a> &amp;)</td></tr>
<tr class="separator:aa3bd3800e7cf0c93aade46b89a878259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725293aecc4839d0b143cf8b746f8cc0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a725293aecc4839d0b143cf8b746f8cc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a725293aecc4839d0b143cf8b746f8cc0">isFinite&lt; pcl::ShapeContext1980 &gt;</a> (const <a class="el" href="structpcl_1_1_shape_context1980.html">pcl::ShapeContext1980</a> &amp;)</td></tr>
<tr class="separator:a725293aecc4839d0b143cf8b746f8cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57267afe0572573812cf800186b456d4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a57267afe0572573812cf800186b456d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a57267afe0572573812cf800186b456d4">isFinite&lt; pcl::UniqueShapeContext1960 &gt;</a> (const <a class="el" href="structpcl_1_1_unique_shape_context1960.html">pcl::UniqueShapeContext1960</a> &amp;)</td></tr>
<tr class="separator:a57267afe0572573812cf800186b456d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8988331282d31b4ee08d45613208836"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac8988331282d31b4ee08d45613208836"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ac8988331282d31b4ee08d45613208836">isFinite&lt; pcl::VFHSignature308 &gt;</a> (const <a class="el" href="structpcl_1_1_v_f_h_signature308.html">pcl::VFHSignature308</a> &amp;)</td></tr>
<tr class="separator:ac8988331282d31b4ee08d45613208836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdc544044cf19ed4232e20f2155cdcc"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aecdc544044cf19ed4232e20f2155cdcc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aecdc544044cf19ed4232e20f2155cdcc">isFinite&lt; pcl::PointXY &gt;</a> (const <a class="el" href="structpcl_1_1_point_x_y.html">pcl::PointXY</a> &amp;p)</td></tr>
<tr class="separator:aecdc544044cf19ed4232e20f2155cdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb1a21ad498163af58a167ba5e642a5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0fb1a21ad498163af58a167ba5e642a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0fb1a21ad498163af58a167ba5e642a5">isFinite&lt; pcl::Normal &gt;</a> (const <a class="el" href="structpcl_1_1_normal.html">pcl::Normal</a> &amp;n)</td></tr>
<tr class="separator:a0fb1a21ad498163af58a167ba5e642a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b31aaaf53decaf828a4b05ce9c6f908"><td class="memTemplParams" colspan="2">template&lt;typename PointT , traits::HasNoXY&lt; PointT &gt;  = true&gt; </td></tr>
<tr class="memitem:a9b31aaaf53decaf828a4b05ce9c6f908"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9b31aaaf53decaf828a4b05ce9c6f908">isXYFinite</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;) noexcept</td></tr>
<tr class="separator:a9b31aaaf53decaf828a4b05ce9c6f908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0863d8e9957d47a89538a631122efd9"><td class="memTemplParams" colspan="2">template&lt;typename PointT , traits::HasNoXYZ&lt; PointT &gt;  = true&gt; </td></tr>
<tr class="memitem:af0863d8e9957d47a89538a631122efd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af0863d8e9957d47a89538a631122efd9">isXYZFinite</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;) noexcept</td></tr>
<tr class="separator:af0863d8e9957d47a89538a631122efd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6edf907fde79bd98e96c15424f74dfe"><td class="memTemplParams" colspan="2">template&lt;typename PointT , traits::HasNoNormal&lt; PointT &gt;  = true&gt; </td></tr>
<tr class="memitem:ab6edf907fde79bd98e96c15424f74dfe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab6edf907fde79bd98e96c15424f74dfe">isNormalFinite</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;) noexcept</td></tr>
<tr class="separator:ab6edf907fde79bd98e96c15424f74dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c61f301e3be16c5cc1c423ad7041eaf"><td class="memTemplParams" colspan="2">template&lt;typename PointT , traits::HasXY&lt; PointT &gt;  = true&gt; </td></tr>
<tr class="memitem:a2c61f301e3be16c5cc1c423ad7041eaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2c61f301e3be16c5cc1c423ad7041eaf">isXYFinite</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt) noexcept</td></tr>
<tr class="separator:a2c61f301e3be16c5cc1c423ad7041eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2af6706fa91836eaa079a9b1a857a50"><td class="memTemplParams" colspan="2">template&lt;typename PointT , traits::HasXYZ&lt; PointT &gt;  = true&gt; </td></tr>
<tr class="memitem:ad2af6706fa91836eaa079a9b1a857a50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad2af6706fa91836eaa079a9b1a857a50">isXYZFinite</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt) noexcept</td></tr>
<tr class="separator:ad2af6706fa91836eaa079a9b1a857a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd17db3d296f3f15e66344e37eb9032"><td class="memTemplParams" colspan="2">template&lt;typename PointT , traits::HasNormal&lt; PointT &gt;  = true&gt; </td></tr>
<tr class="memitem:a6cd17db3d296f3f15e66344e37eb9032"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6cd17db3d296f3f15e66344e37eb9032">isNormalFinite</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt) noexcept</td></tr>
<tr class="separator:a6cd17db3d296f3f15e66344e37eb9032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad020aa327df4698f74845eab051fee9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad020aa327df4698f74845eab051fee9c">getCameraMatrixFromProjectionMatrix</a> (const Eigen::Matrix&lt; float, 3, 4, Eigen::RowMajor &gt; &amp;projection_matrix, Eigen::Matrix3f &amp;camera_matrix)</td></tr>
<tr class="memdesc:ad020aa327df4698f74845eab051fee9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the camera matrix from the given projection matrix.  <a href="namespacepcl.html#ad020aa327df4698f74845eab051fee9c">More...</a><br /></td></tr>
<tr class="separator:ad020aa327df4698f74845eab051fee9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09b8b74e8f5988cbef7b8eb60d0fcfb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af09b8b74e8f5988cbef7b8eb60d0fcfb">getTime</a> ()</td></tr>
<tr class="separator:af09b8b74e8f5988cbef7b8eb60d0fcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab6dcd277c78349b0e2fbc93c685589"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a1ab6dcd277c78349b0e2fbc93c685589"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1ab6dcd277c78349b0e2fbc93c685589">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Affine3f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a1ab6dcd277c78349b0e2fbc93c685589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3230afc385ffd571b5697cbcb1772d"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a6a3230afc385ffd571b5697cbcb1772d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6a3230afc385ffd571b5697cbcb1772d">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Affine3f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a6a3230afc385ffd571b5697cbcb1772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9afb23505913d26d9a1f06242d8eefa"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaa9afb23505913d26d9a1f06242d8eefa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaa9afb23505913d26d9a1f06242d8eefa">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:gaa9afb23505913d26d9a1f06242d8eefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform.  <a href="group__common.html#gaa9afb23505913d26d9a1f06242d8eefa">More...</a><br /></td></tr>
<tr class="separator:gaa9afb23505913d26d9a1f06242d8eefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98254c7dd344ae3907cc5ab149ecd046"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a98254c7dd344ae3907cc5ab149ecd046"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a98254c7dd344ae3907cc5ab149ecd046">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Affine3f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a98254c7dd344ae3907cc5ab149ecd046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747aa1efb26bb28eb16a5a8495167f59"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a747aa1efb26bb28eb16a5a8495167f59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a747aa1efb26bb28eb16a5a8495167f59">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Affine3f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a747aa1efb26bb28eb16a5a8495167f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae7b7ff14e3fc9919d117bffa0398ad"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:afae7b7ff14e3fc9919d117bffa0398ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#afae7b7ff14e3fc9919d117bffa0398ad">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Affine3f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:afae7b7ff14e3fc9919d117bffa0398ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2010514a42ccb4cb04eb47d5920de6e5"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:a2010514a42ccb4cb04eb47d5920de6e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2010514a42ccb4cb04eb47d5920de6e5">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:a2010514a42ccb4cb04eb47d5920de6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="namespacepcl.html#a2010514a42ccb4cb04eb47d5920de6e5">More...</a><br /></td></tr>
<tr class="separator:a2010514a42ccb4cb04eb47d5920de6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d49d40760b5f64b82295e7d50e67f66"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a7d49d40760b5f64b82295e7d50e67f66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7d49d40760b5f64b82295e7d50e67f66">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Affine3f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a7d49d40760b5f64b82295e7d50e67f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac841d05d13c925f3a3a8090d9d7ff24d"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gac841d05d13c925f3a3a8090d9d7ff24d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac841d05d13c925f3a3a8090d9d7ff24d">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:gac841d05d13c925f3a3a8090d9d7ff24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform defined by a 4x4 matrix.  <a href="group__common.html#gac841d05d13c925f3a3a8090d9d7ff24d">More...</a><br /></td></tr>
<tr class="separator:gac841d05d13c925f3a3a8090d9d7ff24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbe4956d1c8fb785a97df6708d57c56"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:aefbe4956d1c8fb785a97df6708d57c56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aefbe4956d1c8fb785a97df6708d57c56">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix4f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:aefbe4956d1c8fb785a97df6708d57c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69421534f84d8c43314da4753e01b825"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga69421534f84d8c43314da4753e01b825"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga69421534f84d8c43314da4753e01b825">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga69421534f84d8c43314da4753e01b825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform defined by a 4x4 matrix.  <a href="group__common.html#ga69421534f84d8c43314da4753e01b825">More...</a><br /></td></tr>
<tr class="separator:ga69421534f84d8c43314da4753e01b825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861030ddf3bd17ed84672785fc9c4472"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a861030ddf3bd17ed84672785fc9c4472"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a861030ddf3bd17ed84672785fc9c4472">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix4f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a861030ddf3bd17ed84672785fc9c4472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033e051c786ec84f52598ab711a74a4e"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga033e051c786ec84f52598ab711a74a4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga033e051c786ec84f52598ab711a74a4e">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga033e051c786ec84f52598ab711a74a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform defined by a 4x4 matrix.  <a href="group__common.html#ga033e051c786ec84f52598ab711a74a4e">More...</a><br /></td></tr>
<tr class="separator:ga033e051c786ec84f52598ab711a74a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef7fc8ea3f5d9784d15586eec0d5c77"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:aaef7fc8ea3f5d9784d15586eec0d5c77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aaef7fc8ea3f5d9784d15586eec0d5c77">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix4f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:aaef7fc8ea3f5d9784d15586eec0d5c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga01dcf9e24dec3109a0c8a8b8f2e24bcc">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="group__common.html#ga01dcf9e24dec3109a0c8a8b8f2e24bcc">More...</a><br /></td></tr>
<tr class="separator:ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6c26cfe6720871853f991ba2013fdf"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a9c6c26cfe6720871853f991ba2013fdf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9c6c26cfe6720871853f991ba2013fdf">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix4f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a9c6c26cfe6720871853f991ba2013fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8602e00dcd5398692bc0582db76e1ef3"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga8602e00dcd5398692bc0582db76e1ef3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga8602e00dcd5398692bc0582db76e1ef3">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga8602e00dcd5398692bc0582db76e1ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="group__common.html#ga8602e00dcd5398692bc0582db76e1ef3">More...</a><br /></td></tr>
<tr class="separator:ga8602e00dcd5398692bc0582db76e1ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7674476fbb6b9b66c00883721a18e0"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a4b7674476fbb6b9b66c00883721a18e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4b7674476fbb6b9b66c00883721a18e0">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix4f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a4b7674476fbb6b9b66c00883721a18e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a78021ef33dad9e3d44e6275768760b"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga3a78021ef33dad9e3d44e6275768760b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3a78021ef33dad9e3d44e6275768760b">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga3a78021ef33dad9e3d44e6275768760b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="group__common.html#ga3a78021ef33dad9e3d44e6275768760b">More...</a><br /></td></tr>
<tr class="separator:ga3a78021ef33dad9e3d44e6275768760b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310b1980cf614a10ed3be69930267431"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a310b1980cf614a10ed3be69930267431"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a310b1980cf614a10ed3be69930267431">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix4f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="separator:a310b1980cf614a10ed3be69930267431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58c0696cdc30b705ab4dac46fa4898"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:aad58c0696cdc30b705ab4dac46fa4898"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aad58c0696cdc30b705ab4dac46fa4898">transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Vector3f &amp;offset, const Eigen::Quaternionf &amp;rotation, bool copy_all_fields=true)</td></tr>
<tr class="separator:aad58c0696cdc30b705ab4dac46fa4898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0190c799174d6565db2994f9b4f0898d"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a0190c799174d6565db2994f9b4f0898d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0190c799174d6565db2994f9b4f0898d">transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Vector3f &amp;offset, const Eigen::Quaternionf &amp;rotation, bool copy_all_fields=true)</td></tr>
<tr class="separator:a0190c799174d6565db2994f9b4f0898d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eebb98525a1ce95bdf822c892e9f897"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a6eebb98525a1ce95bdf822c892e9f897"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6eebb98525a1ce95bdf822c892e9f897">transformPoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const Eigen::Affine3f &amp;transform)</td></tr>
<tr class="separator:a6eebb98525a1ce95bdf822c892e9f897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb382fa277fd5e69472ec3c878e6692"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:aadb382fa277fd5e69472ec3c878e6692"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aadb382fa277fd5e69472ec3c878e6692">transformPointWithNormal</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const Eigen::Affine3f &amp;transform)</td></tr>
<tr class="separator:aadb382fa277fd5e69472ec3c878e6692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e76309712edfe31e5da22b6f4307a87"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a9e76309712edfe31e5da22b6f4307a87"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9e76309712edfe31e5da22b6f4307a87">getPrincipalTransformation</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Affine3f &amp;transform)</td></tr>
<tr class="separator:a9e76309712edfe31e5da22b6f4307a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1e6bf082a51cc2d633495a03a18a6a"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a8b1e6bf082a51cc2d633495a03a18a6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a8b1e6bf082a51cc2d633495a03a18a6a">createMapping</a> (const std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;msg_fields, <a class="el" href="namespacepcl.html#ae716f0bdfbc7ae033006733a42fb6b63">MsgFieldMap</a> &amp;field_map)</td></tr>
<tr class="separator:a8b1e6bf082a51cc2d633495a03a18a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad435776e0d3cc620a42468c85ad060b6"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ad435776e0d3cc620a42468c85ad060b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad435776e0d3cc620a42468c85ad060b6">fromPCLPointCloud2</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;msg, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#ae716f0bdfbc7ae033006733a42fb6b63">MsgFieldMap</a> &amp;field_map)</td></tr>
<tr class="memdesc:ad435776e0d3cc620a42468c85ad060b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary data blob into a pcl::PointCloud&lt;T&gt; object using a field_map.  <a href="namespacepcl.html#ad435776e0d3cc620a42468c85ad060b6">More...</a><br /></td></tr>
<tr class="separator:ad435776e0d3cc620a42468c85ad060b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aca82e188e18a7c9a71324e9610ec9"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a89aca82e188e18a7c9a71324e9610ec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a89aca82e188e18a7c9a71324e9610ec9">fromPCLPointCloud2</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;msg, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud)</td></tr>
<tr class="memdesc:a89aca82e188e18a7c9a71324e9610ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary data blob into a pcl::PointCloud&lt;T&gt; object.  <a href="namespacepcl.html#a89aca82e188e18a7c9a71324e9610ec9">More...</a><br /></td></tr>
<tr class="separator:a89aca82e188e18a7c9a71324e9610ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ae5cefc55b6418e1389136c8e8ee96"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a71ae5cefc55b6418e1389136c8e8ee96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a71ae5cefc55b6418e1389136c8e8ee96">toPCLPointCloud2</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;msg)</td></tr>
<tr class="memdesc:a71ae5cefc55b6418e1389136c8e8ee96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pcl::PointCloud&lt;T&gt; object to a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary data blob.  <a href="namespacepcl.html#a71ae5cefc55b6418e1389136c8e8ee96">More...</a><br /></td></tr>
<tr class="separator:a71ae5cefc55b6418e1389136c8e8ee96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac1ad597aa12ea57af7b3095abf30f7"><td class="memTemplParams" colspan="2">template&lt;typename CloudT &gt; </td></tr>
<tr class="memitem:acac1ad597aa12ea57af7b3095abf30f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#acac1ad597aa12ea57af7b3095abf30f7">toPCLPointCloud2</a> (const CloudT &amp;cloud, <a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> &amp;msg)</td></tr>
<tr class="memdesc:acac1ad597aa12ea57af7b3095abf30f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> fields of a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> into <a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> format.  <a href="namespacepcl.html#acac1ad597aa12ea57af7b3095abf30f7">More...</a><br /></td></tr>
<tr class="separator:acac1ad597aa12ea57af7b3095abf30f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27d2fbd536cc9ea7cf83412ce71db08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad27d2fbd536cc9ea7cf83412ce71db08">toPCLPointCloud2</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, <a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> &amp;msg)</td></tr>
<tr class="memdesc:ad27d2fbd536cc9ea7cf83412ce71db08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> fields of a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> msg into <a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> format.  <a href="namespacepcl.html#ad27d2fbd536cc9ea7cf83412ce71db08">More...</a><br /></td></tr>
<tr class="separator:ad27d2fbd536cc9ea7cf83412ce71db08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83830868a12eca592bd12b5b9d62f9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a83830868a12eca592bd12b5b9d62f9e2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a> &amp;c)</td></tr>
<tr class="memdesc:a83830868a12eca592bd12b5b9d62f9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded &lt;&lt; operator  <a href="namespacepcl.html#a83830868a12eca592bd12b5b9d62f9e2">More...</a><br /></td></tr>
<tr class="separator:a83830868a12eca592bd12b5b9d62f9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb3b1113c4cbc0af51c6542b2eb9101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abcb3b1113c4cbc0af51c6542b2eb9101">getRejectedQueryIndices</a> (const <a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">pcl::Correspondences</a> &amp;correspondences_before, const <a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">pcl::Correspondences</a> &amp;correspondences_after, <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, bool presorting_required=true)</td></tr>
<tr class="memdesc:abcb3b1113c4cbc0af51c6542b2eb9101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the query points of correspondences that are present in one correspondence vector but not in the other, e.g., to compare correspondences before and after rejection.  <a href="namespacepcl.html#abcb3b1113c4cbc0af51c6542b2eb9101">More...</a><br /></td></tr>
<tr class="separator:abcb3b1113c4cbc0af51c6542b2eb9101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9683d853583c45c7bc4da676bc46ec7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga9683d853583c45c7bc4da676bc46ec7d">isBetterCorrespondence</a> (const <a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a> &amp;pc1, const <a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a> &amp;pc2)</td></tr>
<tr class="memdesc:ga9683d853583c45c7bc4da676bc46ec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> to enable us to sort a vector of PointCorrespondences according to their scores using std::sort (begin(), end(), isBetterCorrespondence);.  <a href="group__common.html#ga9683d853583c45c7bc4da676bc46ec7d">More...</a><br /></td></tr>
<tr class="separator:ga9683d853583c45c7bc4da676bc46ec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bacf4c58070af4db6464e7c6a0bac26"><td class="memTemplParams" colspan="2">template&lt;typename Sequence , typename F &gt; </td></tr>
<tr class="memitem:a5bacf4c58070af4db6464e7c6a0bac26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5bacf4c58070af4db6464e7c6a0bac26">for_each_type</a> (F f)</td></tr>
<tr class="separator:a5bacf4c58070af4db6464e7c6a0bac26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259fa5168292d2f0a5bbfee6208304a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a259fa5168292d2f0a5bbfee6208304a4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z.html">PointXYZ</a> &amp;p)</td></tr>
<tr class="separator:a259fa5168292d2f0a5bbfee6208304a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab125cc601b291e5d99552aafce17a53e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab125cc601b291e5d99552aafce17a53e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &amp;p)</td></tr>
<tr class="separator:ab125cc601b291e5d99552aafce17a53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec9af0fa6d2045038d97086d2564b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aeec9af0fa6d2045038d97086d2564b04">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_intensity.html">Intensity</a> &amp;p)</td></tr>
<tr class="separator:aeec9af0fa6d2045038d97086d2564b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2821e799172bdcc306b9efd1f759b63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae2821e799172bdcc306b9efd1f759b63">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_intensity8u.html">Intensity8u</a> &amp;p)</td></tr>
<tr class="separator:ae2821e799172bdcc306b9efd1f759b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bc5840d2339ab463518c23d2eec429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a61bc5840d2339ab463518c23d2eec429">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_intensity32u.html">Intensity32u</a> &amp;p)</td></tr>
<tr class="separator:a61bc5840d2339ab463518c23d2eec429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502d6cf6fd2b60cbed256dfa64574eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a502d6cf6fd2b60cbed256dfa64574eb4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_i.html">PointXYZI</a> &amp;p)</td></tr>
<tr class="separator:a502d6cf6fd2b60cbed256dfa64574eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0503cf66eb447c6a1d6f460f3c5265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#adc0503cf66eb447c6a1d6f460f3c5265">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_l.html">PointXYZL</a> &amp;p)</td></tr>
<tr class="separator:adc0503cf66eb447c6a1d6f460f3c5265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcc1cb564b3460bc9f09a0ff4fb0dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5fcc1cb564b3460bc9f09a0ff4fb0dc9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_label.html">Label</a> &amp;p)</td></tr>
<tr class="separator:a5fcc1cb564b3460bc9f09a0ff4fb0dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae032ca18d8a2d681bb9c6f61dc47722a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae032ca18d8a2d681bb9c6f61dc47722a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a> &amp;p)</td></tr>
<tr class="separator:ae032ca18d8a2d681bb9c6f61dc47722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90abb02fce3fae16f4f6812fba2027a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a90abb02fce3fae16f4f6812fba2027a1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &amp;p)</td></tr>
<tr class="separator:a90abb02fce3fae16f4f6812fba2027a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d43ea244ae0faf522aebc5559673fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9d43ea244ae0faf522aebc5559673fa8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_l.html">PointXYZRGBL</a> &amp;p)</td></tr>
<tr class="separator:a9d43ea244ae0faf522aebc5559673fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194bce1cd392f2839fdf417016be09f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a194bce1cd392f2839fdf417016be09f1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;p)</td></tr>
<tr class="separator:a194bce1cd392f2839fdf417016be09f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d15602f8e84118e21dc97048232d5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5d15602f8e84118e21dc97048232d5c6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y.html">PointXY</a> &amp;p)</td></tr>
<tr class="separator:a5d15602f8e84118e21dc97048232d5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad38e7946d98cae3c778e06ecbaa4df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aad38e7946d98cae3c778e06ecbaa4df9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_u_v.html">PointUV</a> &amp;p)</td></tr>
<tr class="separator:aad38e7946d98cae3c778e06ecbaa4df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf0dccceb5499828fdeb277ec86ee24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0cf0dccceb5499828fdeb277ec86ee24">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_interest_point.html">InterestPoint</a> &amp;p)</td></tr>
<tr class="separator:a0cf0dccceb5499828fdeb277ec86ee24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c5f8626f928698f5b3a8967f0b046a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae7c5f8626f928698f5b3a8967f0b046a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_normal.html">Normal</a> &amp;p)</td></tr>
<tr class="separator:ae7c5f8626f928698f5b3a8967f0b046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ec5383674604eedd381f0c379b04f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a87ec5383674604eedd381f0c379b04f5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_axis.html">Axis</a> &amp;p)</td></tr>
<tr class="separator:a87ec5383674604eedd381f0c379b04f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412c39716aa2a36ff6ab9ade75c169c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a412c39716aa2a36ff6ab9ade75c169c4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_normal.html">PointNormal</a> &amp;p)</td></tr>
<tr class="separator:a412c39716aa2a36ff6ab9ade75c169c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509826a38db4aeebcf04422c06dda97a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a509826a38db4aeebcf04422c06dda97a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_normal.html">PointXYZRGBNormal</a> &amp;p)</td></tr>
<tr class="separator:a509826a38db4aeebcf04422c06dda97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23eb640f2481ebea8e9b2c9428ea213f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a23eb640f2481ebea8e9b2c9428ea213f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_i_normal.html">PointXYZINormal</a> &amp;p)</td></tr>
<tr class="separator:a23eb640f2481ebea8e9b2c9428ea213f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bd0eda0fca53206e567da9048be531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a06bd0eda0fca53206e567da9048be531">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_x_y_z_l_normal.html">PointXYZLNormal</a> &amp;p)</td></tr>
<tr class="separator:a06bd0eda0fca53206e567da9048be531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad2d3d0146b30ce1ea5d3d816caec10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4ad2d3d0146b30ce1ea5d3d816caec10">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;p)</td></tr>
<tr class="separator:a4ad2d3d0146b30ce1ea5d3d816caec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa69fd139cdf30136859e5c44171ce84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aaa69fd139cdf30136859e5c44171ce84">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_with_viewpoint.html">PointWithViewpoint</a> &amp;p)</td></tr>
<tr class="separator:aaa69fd139cdf30136859e5c44171ce84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8528949adf7d108f67295784ea8f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1e8528949adf7d108f67295784ea8f4c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_moment_invariants.html">MomentInvariants</a> &amp;p)</td></tr>
<tr class="separator:a1e8528949adf7d108f67295784ea8f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab08c0deb092684b90e6bf986bd77e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aab08c0deb092684b90e6bf986bd77e4f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_principal_radii_r_s_d.html">PrincipalRadiiRSD</a> &amp;p)</td></tr>
<tr class="separator:aab08c0deb092684b90e6bf986bd77e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee8aad293f74d3742a25238a786c2e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9ee8aad293f74d3742a25238a786c2e9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_boundary.html">Boundary</a> &amp;p)</td></tr>
<tr class="separator:a9ee8aad293f74d3742a25238a786c2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2458afa4cdfef33ff38dace1ad221e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2458afa4cdfef33ff38dace1ad221e73">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_principal_curvatures.html">PrincipalCurvatures</a> &amp;p)</td></tr>
<tr class="separator:a2458afa4cdfef33ff38dace1ad221e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105b339fcb7ac0a6adc12d4d7d8b6054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a105b339fcb7ac0a6adc12d4d7d8b6054">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_p_f_h_signature125.html">PFHSignature125</a> &amp;p)</td></tr>
<tr class="separator:a105b339fcb7ac0a6adc12d4d7d8b6054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d52efa0d7cbf23909bd816bb0a1c666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3d52efa0d7cbf23909bd816bb0a1c666">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_p_f_h_r_g_b_signature250.html">PFHRGBSignature250</a> &amp;p)</td></tr>
<tr class="separator:a3d52efa0d7cbf23909bd816bb0a1c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c118315e1092054d743db6c859d40a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a63c118315e1092054d743db6c859d40a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_p_p_f_signature.html">PPFSignature</a> &amp;p)</td></tr>
<tr class="separator:a63c118315e1092054d743db6c859d40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13addefb957e51551de773268c65c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae13addefb957e51551de773268c65c82">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_c_p_p_f_signature.html">CPPFSignature</a> &amp;p)</td></tr>
<tr class="separator:ae13addefb957e51551de773268c65c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8cfa2a02fbd9dac7f8122dcf6e2bb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abc8cfa2a02fbd9dac7f8122dcf6e2bb7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_p_p_f_r_g_b_signature.html">PPFRGBSignature</a> &amp;p)</td></tr>
<tr class="separator:abc8cfa2a02fbd9dac7f8122dcf6e2bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4534a2c1bd0618b111647e999e77df33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4534a2c1bd0618b111647e999e77df33">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_normal_based_signature12.html">NormalBasedSignature12</a> &amp;p)</td></tr>
<tr class="separator:a4534a2c1bd0618b111647e999e77df33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ae936041311537e8a56dec6159ced9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aa6ae936041311537e8a56dec6159ced9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_shape_context1980.html">ShapeContext1980</a> &amp;p)</td></tr>
<tr class="separator:aa6ae936041311537e8a56dec6159ced9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d952d1be42065f1810999eccc365ddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5d952d1be42065f1810999eccc365ddf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_unique_shape_context1960.html">UniqueShapeContext1960</a> &amp;p)</td></tr>
<tr class="separator:a5d952d1be42065f1810999eccc365ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b039494767b268e50f0a1bb2976fa48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2b039494767b268e50f0a1bb2976fa48">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_s_h_o_t352.html">SHOT352</a> &amp;p)</td></tr>
<tr class="separator:a2b039494767b268e50f0a1bb2976fa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d41b561831d49b78d04200ee37d3002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0d41b561831d49b78d04200ee37d3002">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_s_h_o_t1344.html">SHOT1344</a> &amp;p)</td></tr>
<tr class="separator:a0d41b561831d49b78d04200ee37d3002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19343463a3278d1d0e3db79c4e018aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a19343463a3278d1d0e3db79c4e018aaa">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_reference_frame.html">ReferenceFrame</a> &amp;p)</td></tr>
<tr class="separator:a19343463a3278d1d0e3db79c4e018aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de48790dd4f9e19c9a1550fb848ea3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3de48790dd4f9e19c9a1550fb848ea3d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_f_p_f_h_signature33.html">FPFHSignature33</a> &amp;p)</td></tr>
<tr class="separator:a3de48790dd4f9e19c9a1550fb848ea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1608e058a8bc248efa6f5220e655cff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1608e058a8bc248efa6f5220e655cff7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_v_f_h_signature308.html">VFHSignature308</a> &amp;p)</td></tr>
<tr class="separator:a1608e058a8bc248efa6f5220e655cff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90501d20b65f614f006f508b852e5770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a90501d20b65f614f006f508b852e5770">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_g_r_s_d_signature21.html">GRSDSignature21</a> &amp;p)</td></tr>
<tr class="separator:a90501d20b65f614f006f508b852e5770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0225d96d6b8de7b63f878ccbe58c1e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0225d96d6b8de7b63f878ccbe58c1e82">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_b_r_i_s_k_signature512.html">BRISKSignature512</a> &amp;p)</td></tr>
<tr class="separator:a0225d96d6b8de7b63f878ccbe58c1e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc7a0ea4cd99f38691a573b989f5540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1dc7a0ea4cd99f38691a573b989f5540">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_e_s_f_signature640.html">ESFSignature640</a> &amp;p)</td></tr>
<tr class="separator:a1dc7a0ea4cd99f38691a573b989f5540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebc412871f2707e575fa34ce572572a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aaebc412871f2707e575fa34ce572572a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_g_a_s_d_signature512.html">GASDSignature512</a> &amp;p)</td></tr>
<tr class="separator:aaebc412871f2707e575fa34ce572572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18dfb13fd6d95ba40ccad228917d1b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aa18dfb13fd6d95ba40ccad228917d1b2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_g_a_s_d_signature984.html">GASDSignature984</a> &amp;p)</td></tr>
<tr class="separator:aa18dfb13fd6d95ba40ccad228917d1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fab9179c9352d802406f948da4951b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a01fab9179c9352d802406f948da4951b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_g_a_s_d_signature7992.html">GASDSignature7992</a> &amp;p)</td></tr>
<tr class="separator:a01fab9179c9352d802406f948da4951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20aa5d2c41247323461c041a257f1bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af20aa5d2c41247323461c041a257f1bc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_g_f_p_f_h_signature16.html">GFPFHSignature16</a> &amp;p)</td></tr>
<tr class="separator:af20aa5d2c41247323461c041a257f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fe4f8c4719b2ffbc7b617333767f46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a45fe4f8c4719b2ffbc7b617333767f46">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_narf36.html">Narf36</a> &amp;p)</td></tr>
<tr class="separator:a45fe4f8c4719b2ffbc7b617333767f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1153a607ce169857125edae09cfe39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5b1153a607ce169857125edae09cfe39">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_border_description.html">BorderDescription</a> &amp;p)</td></tr>
<tr class="separator:a5b1153a607ce169857125edae09cfe39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac837bb01edfb9daaec3f6c6459662445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ac837bb01edfb9daaec3f6c6459662445">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_intensity_gradient.html">IntensityGradient</a> &amp;p)</td></tr>
<tr class="separator:ac837bb01edfb9daaec3f6c6459662445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ce409883a619f6e9b4bfb3ce61d0c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af6ce409883a619f6e9b4bfb3ce61d0c7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_with_scale.html">PointWithScale</a> &amp;p)</td></tr>
<tr class="separator:af6ce409883a619f6e9b4bfb3ce61d0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c99ce77bc64a87b38980b612e31c921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a1c99ce77bc64a87b38980b612e31c921">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_surfel.html">PointSurfel</a> &amp;p)</td></tr>
<tr class="separator:a1c99ce77bc64a87b38980b612e31c921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72338648bb90c152d9877996101dc59e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a72338648bb90c152d9877996101dc59e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_point_d_e_m.html">PointDEM</a> &amp;p)</td></tr>
<tr class="separator:a72338648bb90c152d9877996101dc59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4827eb3b63ef3565d88791ff9d674eb5"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a4827eb3b63ef3565d88791ff9d674eb5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4827eb3b63ef3565d88791ff9d674eb5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_histogram.html">Histogram</a>&lt; N &gt; &amp;p)</td></tr>
<tr class="separator:a4827eb3b63ef3565d88791ff9d674eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0472aa62fb36ea477ef66c191c8626"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Args&gt; </td></tr>
<tr class="memitem:abf0472aa62fb36ea477ef66c191c8626"><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abf0472aa62fb36ea477ef66c191c8626">make_shared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abf0472aa62fb36ea477ef66c191c8626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pcl::shared_ptr compliant with type T's allocation policy.  <a href="namespacepcl.html#abf0472aa62fb36ea477ef66c191c8626">More...</a><br /></td></tr>
<tr class="separator:abf0472aa62fb36ea477ef66c191c8626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf1fb9037c2eca16a673118288a876f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aadf1fb9037c2eca16a673118288a876f">operator&lt;&lt;</a> (std::ostream &amp;s, const ::<a class="el" href="structpcl_1_1_model_coefficients.html">pcl::ModelCoefficients</a> &amp;v)</td></tr>
<tr class="separator:aadf1fb9037c2eca16a673118288a876f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc69cba7bca0412b28149e727ce56be"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3bc69cba7bca0412b28149e727ce56be">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structpcl_1_1_p_c_l_header.html">PCLHeader</a> &amp;h)</td></tr>
<tr class="separator:a3bc69cba7bca0412b28149e727ce56be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe79fa3e470b2634599cd18aae729fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abe79fa3e470b2634599cd18aae729fe3">operator==</a> (const <a class="el" href="structpcl_1_1_p_c_l_header.html">PCLHeader</a> &amp;lhs, const <a class="el" href="structpcl_1_1_p_c_l_header.html">PCLHeader</a> &amp;rhs)</td></tr>
<tr class="separator:abe79fa3e470b2634599cd18aae729fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f264d661418058c6ff558ccb6d3cb4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af6f264d661418058c6ff558ccb6d3cb4">operator&lt;&lt;</a> (std::ostream &amp;s, const ::<a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> &amp;v)</td></tr>
<tr class="separator:af6f264d661418058c6ff558ccb6d3cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308f9f5919e442b1b4b084b0fdcc4a05"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a308f9f5919e442b1b4b084b0fdcc4a05">operator&lt;&lt;</a> (std::ostream &amp;s, const ::<a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;v)</td></tr>
<tr class="separator:a308f9f5919e442b1b4b084b0fdcc4a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74d14f268f3e1f29df2503dac6c3ac4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab74d14f268f3e1f29df2503dac6c3ac4">operator&lt;&lt;</a> (std::ostream &amp;s, const ::<a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &amp;v)</td></tr>
<tr class="separator:ab74d14f268f3e1f29df2503dac6c3ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af8b9bfb52f728a1ea55a8a4603f3ac"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a9af8b9bfb52f728a1ea55a8a4603f3ac"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9af8b9bfb52f728a1ea55a8a4603f3ac">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;p)</td></tr>
<tr class="separator:a9af8b9bfb52f728a1ea55a8a4603f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d33a86f7112fc2695d5644a299e6bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae7d33a86f7112fc2695d5644a299e6bd">PointXYZRGBtoXYZI</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &amp;in, <a class="el" href="structpcl_1_1_point_x_y_z_i.html">PointXYZI</a> &amp;out)</td></tr>
<tr class="memdesc:ae7d33a86f7112fc2695d5644a299e6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XYZRGB point type to a XYZI.  <a href="namespacepcl.html#ae7d33a86f7112fc2695d5644a299e6bd">More...</a><br /></td></tr>
<tr class="separator:ae7d33a86f7112fc2695d5644a299e6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8711ab975e8f5ee58602540bab56c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab8711ab975e8f5ee58602540bab56c63">PointRGBtoI</a> (const <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &amp;in, <a class="el" href="structpcl_1_1_intensity.html">Intensity</a> &amp;out)</td></tr>
<tr class="memdesc:ab8711ab975e8f5ee58602540bab56c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point type to a I.  <a href="namespacepcl.html#ab8711ab975e8f5ee58602540bab56c63">More...</a><br /></td></tr>
<tr class="separator:ab8711ab975e8f5ee58602540bab56c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0c42f809f6b1a1a74460b4e7e29284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#adb0c42f809f6b1a1a74460b4e7e29284">PointRGBtoI</a> (const <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &amp;in, <a class="el" href="structpcl_1_1_intensity8u.html">Intensity8u</a> &amp;out)</td></tr>
<tr class="memdesc:adb0c42f809f6b1a1a74460b4e7e29284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point type to a I.  <a href="namespacepcl.html#adb0c42f809f6b1a1a74460b4e7e29284">More...</a><br /></td></tr>
<tr class="separator:adb0c42f809f6b1a1a74460b4e7e29284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3428719f9ea8012a746c56929fd3d331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3428719f9ea8012a746c56929fd3d331">PointRGBtoI</a> (const <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &amp;in, <a class="el" href="structpcl_1_1_intensity32u.html">Intensity32u</a> &amp;out)</td></tr>
<tr class="memdesc:a3428719f9ea8012a746c56929fd3d331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point type to a I.  <a href="namespacepcl.html#a3428719f9ea8012a746c56929fd3d331">More...</a><br /></td></tr>
<tr class="separator:a3428719f9ea8012a746c56929fd3d331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535c726cf92e7201f369715f9eef5902"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a535c726cf92e7201f369715f9eef5902">PointXYZRGBtoXYZHSV</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &amp;in, <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;out)</td></tr>
<tr class="memdesc:a535c726cf92e7201f369715f9eef5902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XYZRGB point type to a XYZHSV.  <a href="namespacepcl.html#a535c726cf92e7201f369715f9eef5902">More...</a><br /></td></tr>
<tr class="separator:a535c726cf92e7201f369715f9eef5902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73954cca0b970cb4aae7db33a568998a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a73954cca0b970cb4aae7db33a568998a">PointXYZRGBAtoXYZHSV</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a> &amp;in, <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;out)</td></tr>
<tr class="memdesc:a73954cca0b970cb4aae7db33a568998a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XYZRGBA point type to a XYZHSV.  <a href="namespacepcl.html#a73954cca0b970cb4aae7db33a568998a">More...</a><br /></td></tr>
<tr class="separator:a73954cca0b970cb4aae7db33a568998a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688582cb4b66085025fb42e354ac37fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a688582cb4b66085025fb42e354ac37fa">PointXYZHSVtoXYZRGB</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;in, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &amp;out)</td></tr>
<tr class="separator:a688582cb4b66085025fb42e354ac37fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dd2e3220f2c19ff79b9665fd90b94e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a28dd2e3220f2c19ff79b9665fd90b94e">PointCloudRGBtoI</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &gt; &amp;in, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_intensity.html">Intensity</a> &gt; &amp;out)</td></tr>
<tr class="memdesc:a28dd2e3220f2c19ff79b9665fd90b94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud to an <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a>.  <a href="namespacepcl.html#a28dd2e3220f2c19ff79b9665fd90b94e">More...</a><br /></td></tr>
<tr class="separator:a28dd2e3220f2c19ff79b9665fd90b94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea9b6d24e68456c7827fcade6f32e39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aaea9b6d24e68456c7827fcade6f32e39">PointCloudRGBtoI</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &gt; &amp;in, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_intensity8u.html">Intensity8u</a> &gt; &amp;out)</td></tr>
<tr class="memdesc:aaea9b6d24e68456c7827fcade6f32e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud to an <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a>.  <a href="namespacepcl.html#aaea9b6d24e68456c7827fcade6f32e39">More...</a><br /></td></tr>
<tr class="separator:aaea9b6d24e68456c7827fcade6f32e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7dd592ee87bfcb46f923a5e1465922"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0c7dd592ee87bfcb46f923a5e1465922">PointCloudRGBtoI</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &gt; &amp;in, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_intensity32u.html">Intensity32u</a> &gt; &amp;out)</td></tr>
<tr class="memdesc:a0c7dd592ee87bfcb46f923a5e1465922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud to an <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a>.  <a href="namespacepcl.html#a0c7dd592ee87bfcb46f923a5e1465922">More...</a><br /></td></tr>
<tr class="separator:a0c7dd592ee87bfcb46f923a5e1465922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9b69a70749ba22828986131fb9b2d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aeb9b69a70749ba22828986131fb9b2d9">PointCloudXYZRGBtoXYZHSV</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &gt; &amp;in, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &gt; &amp;out)</td></tr>
<tr class="memdesc:aeb9b69a70749ba22828986131fb9b2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XYZRGB point cloud to a XYZHSV.  <a href="namespacepcl.html#aeb9b69a70749ba22828986131fb9b2d9">More...</a><br /></td></tr>
<tr class="separator:aeb9b69a70749ba22828986131fb9b2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3f94312acc1926da5f1ab7174e9b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4c3f94312acc1926da5f1ab7174e9b79">PointCloudXYZRGBAtoXYZHSV</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a> &gt; &amp;in, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &gt; &amp;out)</td></tr>
<tr class="memdesc:a4c3f94312acc1926da5f1ab7174e9b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XYZRGB point cloud to a XYZHSV.  <a href="namespacepcl.html#a4c3f94312acc1926da5f1ab7174e9b79">More...</a><br /></td></tr>
<tr class="separator:a4c3f94312acc1926da5f1ab7174e9b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55e56a236bab4680054f866be7396c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af55e56a236bab4680054f866be7396c2">PointCloudXYZRGBtoXYZI</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &gt; &amp;in, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_i.html">PointXYZI</a> &gt; &amp;out)</td></tr>
<tr class="memdesc:af55e56a236bab4680054f866be7396c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XYZRGB point cloud to a XYZI.  <a href="namespacepcl.html#af55e56a236bab4680054f866be7396c2">More...</a><br /></td></tr>
<tr class="separator:af55e56a236bab4680054f866be7396c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe8ed3ea926b449a3936b3d2eba3693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abbe8ed3ea926b449a3936b3d2eba3693">PointCloudDepthAndRGBtoXYZRGBA</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_intensity.html">Intensity</a> &gt; &amp;depth, const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &gt; &amp;image, const float &amp;focal, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a> &gt; &amp;out)</td></tr>
<tr class="memdesc:abbe8ed3ea926b449a3936b3d2eba3693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert registered Depth image and <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> image to PointCloudXYZRGBA.  <a href="namespacepcl.html#abbe8ed3ea926b449a3936b3d2eba3693">More...</a><br /></td></tr>
<tr class="separator:abbe8ed3ea926b449a3936b3d2eba3693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc72bf72c8fb262df806d469cf72a05"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abfc72bf72c8fb262df806d469cf72a05">operator&lt;&lt;</a> (std::ostream &amp;s, const ::<a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;v)</td></tr>
<tr class="separator:abfc72bf72c8fb262df806d469cf72a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1aabda7f7d9292915b26e52bae7f5d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9f1aabda7f7d9292915b26e52bae7f5d">operator&lt;&lt;</a> (std::ostream &amp;s, const ::<a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;v)</td></tr>
<tr class="separator:a9f1aabda7f7d9292915b26e52bae7f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0fa7ba4f8d3ff01a3e4332f96d6b85"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7e0fa7ba4f8d3ff01a3e4332f96d6b85">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;r)</td></tr>
<tr class="memdesc:a7e0fa7ba4f8d3ff01a3e4332f96d6b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">/ingroup range_image  <a href="namespacepcl.html#a7e0fa7ba4f8d3ff01a3e4332f96d6b85">More...</a><br /></td></tr>
<tr class="separator:a7e0fa7ba4f8d3ff01a3e4332f96d6b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10806d2fbd7a668419758e64a49b04"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename ValT &gt; </td></tr>
<tr class="memitem:a0d10806d2fbd7a668419758e64a49b04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0d10806d2fbd7a668419758e64a49b04">setFieldValue</a> (<a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt, std::size_t field_offset, const ValT &amp;value)</td></tr>
<tr class="memdesc:a0d10806d2fbd7a668419758e64a49b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value at a specified field in a point.  <a href="namespacepcl.html#a0d10806d2fbd7a668419758e64a49b04">More...</a><br /></td></tr>
<tr class="separator:a0d10806d2fbd7a668419758e64a49b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c52389c21abb3bf0c01b1bcefa414b"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename ValT &gt; </td></tr>
<tr class="memitem:a40c52389c21abb3bf0c01b1bcefa414b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a40c52389c21abb3bf0c01b1bcefa414b">getFieldValue</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pt, std::size_t field_offset, ValT &amp;value)</td></tr>
<tr class="memdesc:a40c52389c21abb3bf0c01b1bcefa414b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value at a specified field in a point.  <a href="namespacepcl.html#a40c52389c21abb3bf0c01b1bcefa414b">More...</a><br /></td></tr>
<tr class="separator:a40c52389c21abb3bf0c01b1bcefa414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f82c5c83fe221b70f6793cd8649a0f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a31f82c5c83fe221b70f6793cd8649a0f">operator&lt;&lt;</a> (std::ostream &amp;s, const ::<a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &amp;v)</td></tr>
<tr class="separator:a31f82c5c83fe221b70f6793cd8649a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958402ff7ac412afde20b65945a0f197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a958402ff7ac412afde20b65945a0f197">computeCPPFPairFeature</a> (const Eigen::Vector4f &amp;p1, const Eigen::Vector4f &amp;n1, const Eigen::Vector4i &amp;c1, const Eigen::Vector4f &amp;p2, const Eigen::Vector4f &amp;n2, const Eigen::Vector4i &amp;c2, float &amp;f1, float &amp;f2, float &amp;f3, float &amp;f4, float &amp;f5, float &amp;f6, float &amp;f7, float &amp;f8, float &amp;f9, float &amp;f10)</td></tr>
<tr class="separator:a958402ff7ac412afde20b65945a0f197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5798e2ee9ef558efd8a9f1da82c5eb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__features.html#gae5798e2ee9ef558efd8a9f1da82c5eb1">solvePlaneParameters</a> (const Eigen::Matrix3f &amp;covariance_matrix, const Eigen::Vector4f &amp;point, Eigen::Vector4f &amp;plane_parameters, float &amp;curvature)</td></tr>
<tr class="memdesc:gae5798e2ee9ef558efd8a9f1da82c5eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the eigenvalues and eigenvectors of a given 3x3 covariance matrix, and estimate the least-squares plane normal and surface curvature.  <a href="group__features.html#gae5798e2ee9ef558efd8a9f1da82c5eb1">More...</a><br /></td></tr>
<tr class="separator:gae5798e2ee9ef558efd8a9f1da82c5eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78bd0e1c11a8a299ef98209b6360f8fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__features.html#ga78bd0e1c11a8a299ef98209b6360f8fe">solvePlaneParameters</a> (const Eigen::Matrix3f &amp;covariance_matrix, float &amp;nx, float &amp;ny, float &amp;nz, float &amp;curvature)</td></tr>
<tr class="memdesc:ga78bd0e1c11a8a299ef98209b6360f8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the eigenvalues and eigenvectors of a given 3x3 covariance matrix, and estimate the least-squares plane normal and surface curvature.  <a href="group__features.html#ga78bd0e1c11a8a299ef98209b6360f8fe">More...</a><br /></td></tr>
<tr class="separator:ga78bd0e1c11a8a299ef98209b6360f8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d909a2e60dc70d67db592dbe67a7cc8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4d909a2e60dc70d67db592dbe67a7cc8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_range_image_border_extractor_1_1_parameters.html">RangeImageBorderExtractor::Parameters</a> &amp;p)</td></tr>
<tr class="separator:a4d909a2e60dc70d67db592dbe67a7cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd392447cd77d22a66f1f7b885f923e1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gacd392447cd77d22a66f1f7b885f923e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#gacd392447cd77d22a66f1f7b885f923e1">computePointNormal</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Vector4f &amp;plane_parameters, float &amp;curvature)</td></tr>
<tr class="memdesc:gacd392447cd77d22a66f1f7b885f923e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Least-Squares plane fit for a given set of points, and return the estimated plane parameters together with the surface curvature.  <a href="group__features.html#gacd392447cd77d22a66f1f7b885f923e1">More...</a><br /></td></tr>
<tr class="separator:gacd392447cd77d22a66f1f7b885f923e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d659f19211c7b81cd2a3100f3f6dd30"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga6d659f19211c7b81cd2a3100f3f6dd30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#ga6d659f19211c7b81cd2a3100f3f6dd30">computePointNormal</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const std::vector&lt; int &gt; &amp;indices, Eigen::Vector4f &amp;plane_parameters, float &amp;curvature)</td></tr>
<tr class="memdesc:ga6d659f19211c7b81cd2a3100f3f6dd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Least-Squares plane fit for a given set of points, using their indices, and return the estimated plane parameters together with the surface curvature.  <a href="group__features.html#ga6d659f19211c7b81cd2a3100f3f6dd30">More...</a><br /></td></tr>
<tr class="separator:ga6d659f19211c7b81cd2a3100f3f6dd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53df49d690e1cb76cd1f53495508bff1"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga53df49d690e1cb76cd1f53495508bff1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#ga53df49d690e1cb76cd1f53495508bff1">flipNormalTowardsViewpoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, float vp_x, float vp_y, float vp_z, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;normal)</td></tr>
<tr class="memdesc:ga53df49d690e1cb76cd1f53495508bff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip (in place) the estimated normal of a point towards a given viewpoint.  <a href="group__features.html#ga53df49d690e1cb76cd1f53495508bff1">More...</a><br /></td></tr>
<tr class="separator:ga53df49d690e1cb76cd1f53495508bff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56793b5c90e46de7c0ec910f505bca89"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga56793b5c90e46de7c0ec910f505bca89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#ga56793b5c90e46de7c0ec910f505bca89">flipNormalTowardsViewpoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, float vp_x, float vp_y, float vp_z, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;normal)</td></tr>
<tr class="memdesc:ga56793b5c90e46de7c0ec910f505bca89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip (in place) the estimated normal of a point towards a given viewpoint.  <a href="group__features.html#ga56793b5c90e46de7c0ec910f505bca89">More...</a><br /></td></tr>
<tr class="separator:ga56793b5c90e46de7c0ec910f505bca89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc981cb599bd53b6f1d66e7fd932e493"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gadc981cb599bd53b6f1d66e7fd932e493"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#gadc981cb599bd53b6f1d66e7fd932e493">flipNormalTowardsViewpoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, float vp_x, float vp_y, float vp_z, float &amp;nx, float &amp;ny, float &amp;nz)</td></tr>
<tr class="memdesc:gadc981cb599bd53b6f1d66e7fd932e493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip (in place) the estimated normal of a point towards a given viewpoint.  <a href="group__features.html#gadc981cb599bd53b6f1d66e7fd932e493">More...</a><br /></td></tr>
<tr class="separator:gadc981cb599bd53b6f1d66e7fd932e493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace4366799f7d9e9b75ab95a3aef6234d"><td class="memTemplParams" colspan="2">template&lt;typename PointNT &gt; </td></tr>
<tr class="memitem:gace4366799f7d9e9b75ab95a3aef6234d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#gace4366799f7d9e9b75ab95a3aef6234d">flipNormalTowardsNormalsMean</a> (<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; const &amp;normal_cloud, std::vector&lt; int &gt; const &amp;normal_indices, Eigen::Vector3f &amp;normal)</td></tr>
<tr class="memdesc:gace4366799f7d9e9b75ab95a3aef6234d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip (in place) normal to get the same sign of the mean of the normals specified by normal_indices.  <a href="group__features.html#gace4366799f7d9e9b75ab95a3aef6234d">More...</a><br /></td></tr>
<tr class="separator:gace4366799f7d9e9b75ab95a3aef6234d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacfebe0c36e7d879e48bd3f163aec3c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__features.html#gaacfebe0c36e7d879e48bd3f163aec3c9">computePairFeatures</a> (const Eigen::Vector4f &amp;p1, const Eigen::Vector4f &amp;n1, const Eigen::Vector4f &amp;p2, const Eigen::Vector4f &amp;n2, float &amp;f1, float &amp;f2, float &amp;f3, float &amp;f4)</td></tr>
<tr class="memdesc:gaacfebe0c36e7d879e48bd3f163aec3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 4-tuple representation containing the three angles and one distance between two points represented by Cartesian coordinates and normals.  <a href="group__features.html#gaacfebe0c36e7d879e48bd3f163aec3c9">More...</a><br /></td></tr>
<tr class="separator:gaacfebe0c36e7d879e48bd3f163aec3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d38530c7cb65fcb872a72f9cba9224a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2d38530c7cb65fcb872a72f9cba9224a">computeRGBPairFeatures</a> (const Eigen::Vector4f &amp;p1, const Eigen::Vector4f &amp;n1, const Eigen::Vector4i &amp;colors1, const Eigen::Vector4f &amp;p2, const Eigen::Vector4f &amp;n2, const Eigen::Vector4i &amp;colors2, float &amp;f1, float &amp;f2, float &amp;f3, float &amp;f4, float &amp;f5, float &amp;f6, float &amp;f7)</td></tr>
<tr class="separator:a2d38530c7cb65fcb872a72f9cba9224a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ba5cb8070fc19db8939ca20c9131c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a135ba5cb8070fc19db8939ca20c9131c">computePPFPairFeature</a> (const Eigen::Vector4f &amp;p1, const Eigen::Vector4f &amp;n1, const Eigen::Vector4f &amp;p2, const Eigen::Vector4f &amp;n2, float &amp;f1, float &amp;f2, float &amp;f3, float &amp;f4)</td></tr>
<tr class="separator:a135ba5cb8070fc19db8939ca20c9131c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c7f523d0882cc9e9a4273b0276d4ab"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gaa0c7f523d0882cc9e9a4273b0276d4ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#gaa0c7f523d0882cc9e9a4273b0276d4ab">getFeaturePointCloud</a> (const std::vector&lt; Eigen::MatrixXf, Eigen::aligned_allocator&lt; Eigen::MatrixXf &gt; &gt; &amp;histograms2D, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_histogram.html">Histogram</a>&lt; N &gt; &gt; &amp;histogramsPC)</td></tr>
<tr class="memdesc:gaa0c7f523d0882cc9e9a4273b0276d4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a list of 2D matrices into a point cloud containing the values in a vector (Histogram&lt;N&gt;).  <a href="group__features.html#gaa0c7f523d0882cc9e9a4273b0276d4ab">More...</a><br /></td></tr>
<tr class="separator:gaa0c7f523d0882cc9e9a4273b0276d4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dbf59841afa23ed43c4e7f19fdd60cc"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointNT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ga2dbf59841afa23ed43c4e7f19fdd60cc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXf&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#ga2dbf59841afa23ed43c4e7f19fdd60cc">computeRSD</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;surface, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; &amp;normals, const std::vector&lt; int &gt; &amp;indices, double max_dist, int nr_subdiv, double plane_radius, PointOutT &amp;radii, bool compute_histogram=false)</td></tr>
<tr class="memdesc:ga2dbf59841afa23ed43c4e7f19fdd60cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the Radius-based Surface Descriptor (RSD) for a given point based on its spatial neighborhood of 3D points with normals.  <a href="group__features.html#ga2dbf59841afa23ed43c4e7f19fdd60cc">More...</a><br /></td></tr>
<tr class="separator:ga2dbf59841afa23ed43c4e7f19fdd60cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab613e1f38731c3438c9b668876ce7d73"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointNT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ab613e1f38731c3438c9b668876ce7d73"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXf&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ab613e1f38731c3438c9b668876ce7d73">computeRSD</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt;::ConstPtr &amp;surface, typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt;::ConstPtr &amp;normals, const std::vector&lt; int &gt; &amp;indices, double max_dist, int nr_subdiv, double plane_radius, PointOutT &amp;radii, bool compute_histogram=false)</td></tr>
<tr class="separator:ab613e1f38731c3438c9b668876ce7d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae16db095da8018c41f079266787ec2fe"><td class="memTemplParams" colspan="2">template&lt;typename PointNT , typename PointOutT &gt; </td></tr>
<tr class="memitem:gae16db095da8018c41f079266787ec2fe"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXf&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__features.html#gae16db095da8018c41f079266787ec2fe">computeRSD</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; &amp;normals, const std::vector&lt; int &gt; &amp;indices, const std::vector&lt; float &gt; &amp;sqr_dists, double max_dist, int nr_subdiv, double plane_radius, PointOutT &amp;radii, bool compute_histogram=false)</td></tr>
<tr class="memdesc:gae16db095da8018c41f079266787ec2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the Radius-based Surface Descriptor (RSD) for a given point based on its spatial neighborhood of 3D points with normals.  <a href="group__features.html#gae16db095da8018c41f079266787ec2fe">More...</a><br /></td></tr>
<tr class="separator:gae16db095da8018c41f079266787ec2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b743bb42924485015453de79a8d5b"><td class="memTemplParams" colspan="2">template&lt;typename PointNT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ae41b743bb42924485015453de79a8d5b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXf&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae41b743bb42924485015453de79a8d5b">computeRSD</a> (typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt;::ConstPtr &amp;normals, const std::vector&lt; int &gt; &amp;indices, const std::vector&lt; float &gt; &amp;sqr_dists, double max_dist, int nr_subdiv, double plane_radius, PointOutT &amp;radii, bool compute_histogram=false)</td></tr>
<tr class="separator:ae41b743bb42924485015453de79a8d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac463283a9e9c18a66d3d29b28a575064"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gac463283a9e9c18a66d3d29b28a575064"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gac463283a9e9c18a66d3d29b28a575064">removeNaNFromPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, std::vector&lt; int &gt; &amp;index)</td></tr>
<tr class="memdesc:gac463283a9e9c18a66d3d29b28a575064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes points with x, y, or z equal to NaN.  <a href="group__filters.html#gac463283a9e9c18a66d3d29b28a575064">More...</a><br /></td></tr>
<tr class="separator:gac463283a9e9c18a66d3d29b28a575064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3d46551e2cf34aca3ffa5cf919c432"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga2b3d46551e2cf34aca3ffa5cf919c432"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#ga2b3d46551e2cf34aca3ffa5cf919c432">removeNaNNormalsFromPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, std::vector&lt; int &gt; &amp;index)</td></tr>
<tr class="memdesc:ga2b3d46551e2cf34aca3ffa5cf919c432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes points that have their normals invalid (i.e., equal to NaN)  <a href="group__filters.html#ga2b3d46551e2cf34aca3ffa5cf919c432">More...</a><br /></td></tr>
<tr class="separator:ga2b3d46551e2cf34aca3ffa5cf919c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4fb955a5a842af97545db7beee1da1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaab4fb955a5a842af97545db7beee1da1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gaab4fb955a5a842af97545db7beee1da1">removeNaNFromPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, std::vector&lt; int &gt; &amp;index)</td></tr>
<tr class="memdesc:gaab4fb955a5a842af97545db7beee1da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes points with x, y, or z equal to NaN (dry run).  <a href="group__filters.html#gaab4fb955a5a842af97545db7beee1da1">More...</a><br /></td></tr>
<tr class="separator:gaab4fb955a5a842af97545db7beee1da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gab8ec453347225d3a0d34c70e0a9ee223">applyMorphologicalOperator</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud_in, float resolution, const int morphological_operator, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gab8ec453347225d3a0d34c70e0a9ee223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply morphological operator to the z dimension of the input point cloud.  <a href="group__filters.html#gab8ec453347225d3a0d34c70e0a9ee223">More...</a><br /></td></tr>
<tr class="separator:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gab8ec453347225d3a0d34c70e0a9ee223">applyMorphologicalOperator</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud_in, float resolution, const int morphological_operator, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gab8ec453347225d3a0d34c70e0a9ee223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply morphological operator to the z dimension of the input point cloud.  <a href="group__filters.html#gab8ec453347225d3a0d34c70e0a9ee223">More...</a><br /></td></tr>
<tr class="separator:gab8ec453347225d3a0d34c70e0a9ee223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae214195ebaa483f7966c685656b1a2fd"><td class="memTemplParams" colspan="2">template&lt;typename NormalT &gt; </td></tr>
<tr class="memitem:gae214195ebaa483f7966c685656b1a2fd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gae214195ebaa483f7966c685656b1a2fd">assignNormalWeights</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt; &amp;cloud, int index, const std::vector&lt; int &gt; &amp;k_indices, const std::vector&lt; float &gt; &amp;k_sqr_distances)</td></tr>
<tr class="memdesc:gae214195ebaa483f7966c685656b1a2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign weights of nearby normals used for refinement.  <a href="group__filters.html#gae214195ebaa483f7966c685656b1a2fd">More...</a><br /></td></tr>
<tr class="separator:gae214195ebaa483f7966c685656b1a2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e839ff3bbae897de75ffaa70e096236"><td class="memTemplParams" colspan="2">template&lt;typename NormalT &gt; </td></tr>
<tr class="memitem:ga4e839ff3bbae897de75ffaa70e096236"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#ga4e839ff3bbae897de75ffaa70e096236">refineNormal</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &gt; &amp;cloud, int index, const std::vector&lt; int &gt; &amp;k_indices, const std::vector&lt; float &gt; &amp;k_sqr_distances, <a class="el" href="structpcl_1_1_normal.html">NormalT</a> &amp;point)</td></tr>
<tr class="memdesc:ga4e839ff3bbae897de75ffaa70e096236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine an indexed point based on its neighbors, this function only writes to the normal_* fields.  <a href="group__filters.html#ga4e839ff3bbae897de75ffaa70e096236">More...</a><br /></td></tr>
<tr class="separator:ga4e839ff3bbae897de75ffaa70e096236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a441489f0bebaf4e8a9b8be46bbff67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a7a441489f0bebaf4e8a9b8be46bbff67">getMinMax3D</a> (const <a class="el" href="namespacepcl.html#ad64de997fa516c97e85cf8dc9d72146d">pcl::PCLPointCloud2ConstPtr</a> &amp;cloud, int x_idx, int y_idx, int z_idx, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:a7a441489f0bebaf4e8a9b8be46bbff67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum and minimum points in 3D from a given point cloud.  <a href="namespacepcl.html#a7a441489f0bebaf4e8a9b8be46bbff67">More...</a><br /></td></tr>
<tr class="separator:a7a441489f0bebaf4e8a9b8be46bbff67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428a43d62bc58194cfb861a1cc707263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a428a43d62bc58194cfb861a1cc707263">getMinMax3D</a> (const <a class="el" href="namespacepcl.html#ad64de997fa516c97e85cf8dc9d72146d">pcl::PCLPointCloud2ConstPtr</a> &amp;cloud, int x_idx, int y_idx, int z_idx, const std::string &amp;distance_field_name, float min_distance, float max_distance, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative=false)</td></tr>
<tr class="memdesc:a428a43d62bc58194cfb861a1cc707263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum and minimum points in 3D from a given point cloud.  <a href="namespacepcl.html#a428a43d62bc58194cfb861a1cc707263">More...</a><br /></td></tr>
<tr class="separator:a428a43d62bc58194cfb861a1cc707263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa333cb2c210067835f11bf84feb659"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filters.html#gaffa333cb2c210067835f11bf84feb659">getHalfNeighborCellIndices</a> ()</td></tr>
<tr class="memdesc:gaffa333cb2c210067835f11bf84feb659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relative cell indices of the "upper half" 13 neighbors.  <a href="group__filters.html#gaffa333cb2c210067835f11bf84feb659">More...</a><br /></td></tr>
<tr class="separator:gaffa333cb2c210067835f11bf84feb659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a35c2d72627c558cb22b85d1f2c0679"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filters.html#ga6a35c2d72627c558cb22b85d1f2c0679">getAllNeighborCellIndices</a> ()</td></tr>
<tr class="memdesc:ga6a35c2d72627c558cb22b85d1f2c0679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relative cell indices of all the 26 neighbors.  <a href="group__filters.html#ga6a35c2d72627c558cb22b85d1f2c0679">More...</a><br /></td></tr>
<tr class="separator:ga6a35c2d72627c558cb22b85d1f2c0679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff287f132f05316c896e410d689569b"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaaff287f132f05316c896e410d689569b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#gaaff287f132f05316c896e410d689569b">getMinMax3D</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud, const std::string &amp;distance_field_name, float min_distance, float max_distance, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative=false)</td></tr>
<tr class="memdesc:gaaff287f132f05316c896e410d689569b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud, without considering points outside of a distance threshold from the laser origin.  <a href="group__filters.html#gaaff287f132f05316c896e410d689569b">More...</a><br /></td></tr>
<tr class="separator:gaaff287f132f05316c896e410d689569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858a35c4936ab692a6893bf71ab8a59a"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga858a35c4936ab692a6893bf71ab8a59a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filters.html#ga858a35c4936ab692a6893bf71ab8a59a">getMinMax3D</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud, const std::vector&lt; int &gt; &amp;indices, const std::string &amp;distance_field_name, float min_distance, float max_distance, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, bool limit_negative=false)</td></tr>
<tr class="memdesc:ga858a35c4936ab692a6893bf71ab8a59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud, without considering points outside of a distance threshold from the laser origin.  <a href="group__filters.html#ga858a35c4936ab692a6893bf71ab8a59a">More...</a><br /></td></tr>
<tr class="separator:ga858a35c4936ab692a6893bf71ab8a59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838f3e1252e58be919249a1bddff97e6"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a838f3e1252e58be919249a1bddff97e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a838f3e1252e58be919249a1bddff97e6">approximatePolygon</a> (const <a class="el" href="classpcl_1_1_planar_polygon.html">PlanarPolygon</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;polygon, <a class="el" href="classpcl_1_1_planar_polygon.html">PlanarPolygon</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;approx_polygon, float threshold, bool refine=false, bool closed=true)</td></tr>
<tr class="memdesc:a838f3e1252e58be919249a1bddff97e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">see approximatePolygon2D  <a href="namespacepcl.html#a838f3e1252e58be919249a1bddff97e6">More...</a><br /></td></tr>
<tr class="separator:a838f3e1252e58be919249a1bddff97e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c67ad60b6d7bec3243f3ab850ecb7d"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a10c67ad60b6d7bec3243f3ab850ecb7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a10c67ad60b6d7bec3243f3ab850ecb7d">approximatePolygon2D</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::VectorType &amp;polygon, typename <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::VectorType &amp;approx_polygon, float threshold, bool refine=false, bool closed=true)</td></tr>
<tr class="memdesc:a10c67ad60b6d7bec3243f3ab850ecb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an approximate polygon to given 2D contour.  <a href="namespacepcl.html#a10c67ad60b6d7bec3243f3ab850ecb7d">More...</a><br /></td></tr>
<tr class="separator:a10c67ad60b6d7bec3243f3ab850ecb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9287d2c4eee3af2533e5b3dd3e61ac69"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a9287d2c4eee3af2533e5b3dd3e61ac69"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; Type &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a9287d2c4eee3af2533e5b3dd3e61ac69">copyValueString</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, const unsigned int point_index, const int point_size, const unsigned int field_idx, const unsigned int fields_count, std::ostream &amp;stream)</td></tr>
<tr class="memdesc:a9287d2c4eee3af2533e5b3dd3e61ac69"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a value of type Type (uchar, char, uint, int, float, double, ...) into a stringstream.  <a href="namespacepcl.html#a9287d2c4eee3af2533e5b3dd3e61ac69">More...</a><br /></td></tr>
<tr class="separator:a9287d2c4eee3af2533e5b3dd3e61ac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88882b0bf00c4f33c3a8c593dd9ad1f1"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a88882b0bf00c4f33c3a8c593dd9ad1f1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral&lt; Type &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a88882b0bf00c4f33c3a8c593dd9ad1f1">copyValueString</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, const unsigned int point_index, const int point_size, const unsigned int field_idx, const unsigned int fields_count, std::ostream &amp;stream)</td></tr>
<tr class="separator:a88882b0bf00c4f33c3a8c593dd9ad1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f18c6e45e183d003b410bcc6212cf52"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5f18c6e45e183d003b410bcc6212cf52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a5f18c6e45e183d003b410bcc6212cf52">copyValueString&lt; std::int8_t &gt;</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, const unsigned int point_index, const int point_size, const unsigned int field_idx, const unsigned int fields_count, std::ostream &amp;stream)</td></tr>
<tr class="separator:a5f18c6e45e183d003b410bcc6212cf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29ba375961de1791a710ebdc08be151"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae29ba375961de1791a710ebdc08be151"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae29ba375961de1791a710ebdc08be151">copyValueString&lt; std::uint8_t &gt;</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, const unsigned int point_index, const int point_size, const unsigned int field_idx, const unsigned int fields_count, std::ostream &amp;stream)</td></tr>
<tr class="separator:ae29ba375961de1791a710ebdc08be151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5e574e0b62d33b5eef0b8a3513841b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0e5e574e0b62d33b5eef0b8a3513841b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; Type &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0e5e574e0b62d33b5eef0b8a3513841b">isValueFinite</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, const unsigned int point_index, const int point_size, const unsigned int field_idx, const unsigned int fields_count)</td></tr>
<tr class="memdesc:a0e5e574e0b62d33b5eef0b8a3513841b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given value of type Type (uchar, char, uint, int, float, double, ...) is finite or not.  <a href="namespacepcl.html#a0e5e574e0b62d33b5eef0b8a3513841b">More...</a><br /></td></tr>
<tr class="separator:a0e5e574e0b62d33b5eef0b8a3513841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4239e936efbf42ad0e5da571863b5b56"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a4239e936efbf42ad0e5da571863b5b56"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral&lt; Type &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4239e936efbf42ad0e5da571863b5b56">isValueFinite</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;, const unsigned int, const int, const unsigned int, const unsigned int)</td></tr>
<tr class="separator:a4239e936efbf42ad0e5da571863b5b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae70f37202b99e3b5141bec4eed26b7e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aae70f37202b99e3b5141bec4eed26b7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aae70f37202b99e3b5141bec4eed26b7e">copyStringValue</a> (const std::string &amp;st, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, unsigned int point_index, unsigned int field_idx, unsigned int fields_count)</td></tr>
<tr class="memdesc:aae70f37202b99e3b5141bec4eed26b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one single value of type T (uchar, char, uint, int, float, double, ...) from a string.  <a href="namespacepcl.html#aae70f37202b99e3b5141bec4eed26b7e">More...</a><br /></td></tr>
<tr class="separator:aae70f37202b99e3b5141bec4eed26b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f236818f0518be865257e4cccfb6574"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3f236818f0518be865257e4cccfb6574"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3f236818f0518be865257e4cccfb6574">copyStringValue&lt; std::int8_t &gt;</a> (const std::string &amp;st, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, unsigned int point_index, unsigned int field_idx, unsigned int fields_count)</td></tr>
<tr class="separator:a3f236818f0518be865257e4cccfb6574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6935fca775b09562df04e9639e777276"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6935fca775b09562df04e9639e777276"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a6935fca775b09562df04e9639e777276">copyStringValue&lt; std::uint8_t &gt;</a> (const std::string &amp;st, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, unsigned int point_index, unsigned int field_idx, unsigned int fields_count)</td></tr>
<tr class="separator:a6935fca775b09562df04e9639e777276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf72a3e909eaac4e666bc4ef0f835f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a2bf72a3e909eaac4e666bc4ef0f835f8">lzfCompress</a> (const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)</td></tr>
<tr class="memdesc:a2bf72a3e909eaac4e666bc4ef0f835f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress in_len bytes stored at the memory block starting at <em>in_data</em> and write the result to <em>out_data</em>, up to a maximum length of <em>out_len</em> bytes using Marc Lehmann's LZF algorithm.  <a href="namespacepcl.html#a2bf72a3e909eaac4e666bc4ef0f835f8">More...</a><br /></td></tr>
<tr class="separator:a2bf72a3e909eaac4e666bc4ef0f835f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a8f0773d828ec6a82d88c575aa783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ae90a8f0773d828ec6a82d88c575aa783">lzfDecompress</a> (const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)</td></tr>
<tr class="memdesc:ae90a8f0773d828ec6a82d88c575aa783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress data compressed with the <em>lzfCompress</em> function and stored at location <em>in_data</em> and length <em>in_len</em>.  <a href="namespacepcl.html#ae90a8f0773d828ec6a82d88c575aa783">More...</a><br /></td></tr>
<tr class="separator:ae90a8f0773d828ec6a82d88c575aa783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd56f18f3f25c562a9c0a5699ddca644"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gacd56f18f3f25c562a9c0a5699ddca644"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kdtree.html#gacd56f18f3f25c562a9c0a5699ddca644">getApproximateIndices</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud_in, const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud_ref, std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:gacd56f18f3f25c562a9c0a5699ddca644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a set of approximate indices for a given point cloud into a reference point cloud.  <a href="group__kdtree.html#gacd56f18f3f25c562a9c0a5699ddca644">More...</a><br /></td></tr>
<tr class="separator:gacd56f18f3f25c562a9c0a5699ddca644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfed6928dedab2be1e51d7c151e9c78a"><td class="memTemplParams" colspan="2">template&lt;typename Point1T , typename Point2T &gt; </td></tr>
<tr class="memitem:gadfed6928dedab2be1e51d7c151e9c78a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kdtree.html#gadfed6928dedab2be1e51d7c151e9c78a">getApproximateIndices</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; Point1T &gt;::ConstPtr &amp;cloud_in, const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; Point2T &gt;::ConstPtr &amp;cloud_ref, std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:gadfed6928dedab2be1e51d7c151e9c78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a set of approximate indices for a given point cloud into a reference point cloud.  <a href="group__kdtree.html#gadfed6928dedab2be1e51d7c151e9c78a">More...</a><br /></td></tr>
<tr class="separator:gadfed6928dedab2be1e51d7c151e9c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada721c18f588e62bda0c25a7931c97be"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keypoints.html#gada721c18f588e62bda0c25a7931c97be">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_narf_keypoint_1_1_parameters.html">NarfKeypoint::Parameters</a> &amp;p)</td></tr>
<tr class="separator:gada721c18f588e62bda0c25a7931c97be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf291c3601778128223fda6010b6e910"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#adf291c3601778128223fda6010b6e910">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structpcl_1_1_gradient_x_y.html">GradientXY</a> &amp;p)</td></tr>
<tr class="separator:adf291c3601778128223fda6010b6e910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11183c5f2385e531fb9f4d323d629c39"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a11183c5f2385e531fb9f4d323d629c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a11183c5f2385e531fb9f4d323d629c39">read</a> (std::istream &amp;stream, Type &amp;value)</td></tr>
<tr class="memdesc:a11183c5f2385e531fb9f4d323d629c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading data from a stream.  <a href="namespacepcl.html#a11183c5f2385e531fb9f4d323d629c39">More...</a><br /></td></tr>
<tr class="separator:a11183c5f2385e531fb9f4d323d629c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d824ba34337b87d2c56385523965543"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a0d824ba34337b87d2c56385523965543"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a0d824ba34337b87d2c56385523965543">read</a> (std::istream &amp;stream, Type *value, int nr_values)</td></tr>
<tr class="memdesc:a0d824ba34337b87d2c56385523965543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading data arrays from a stream.  <a href="namespacepcl.html#a0d824ba34337b87d2c56385523965543">More...</a><br /></td></tr>
<tr class="separator:a0d824ba34337b87d2c56385523965543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc72ecd1c10de3620edb3e5a419d77d5"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:abc72ecd1c10de3620edb3e5a419d77d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abc72ecd1c10de3620edb3e5a419d77d5">write</a> (std::ostream &amp;stream, Type value)</td></tr>
<tr class="memdesc:abc72ecd1c10de3620edb3e5a419d77d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing data to a stream.  <a href="namespacepcl.html#abc72ecd1c10de3620edb3e5a419d77d5">More...</a><br /></td></tr>
<tr class="separator:abc72ecd1c10de3620edb3e5a419d77d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8ed85949c0e5ee02fac957cd7b3196"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a3a8ed85949c0e5ee02fac957cd7b3196"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3a8ed85949c0e5ee02fac957cd7b3196">write</a> (std::ostream &amp;stream, Type *value, int nr_values)</td></tr>
<tr class="memdesc:a3a8ed85949c0e5ee02fac957cd7b3196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing data arrays to a stream.  <a href="namespacepcl.html#a3a8ed85949c0e5ee02fac957cd7b3196">More...</a><br /></td></tr>
<tr class="separator:a3a8ed85949c0e5ee02fac957cd7b3196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533cac294e33dd8ea02b8bcecb1155e8"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:a533cac294e33dd8ea02b8bcecb1155e8"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a533cac294e33dd8ea02b8bcecb1155e8">getMeanPointDensity</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud, float max_dist, int nr_threads=1)</td></tr>
<tr class="memdesc:a533cac294e33dd8ea02b8bcecb1155e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean point density of a given point cloud.  <a href="namespacepcl.html#a533cac294e33dd8ea02b8bcecb1155e8">More...</a><br /></td></tr>
<tr class="separator:a533cac294e33dd8ea02b8bcecb1155e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb16be13e9916aeae094e1d151ba17f8"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:aeb16be13e9916aeae094e1d151ba17f8"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aeb16be13e9916aeae094e1d151ba17f8">getMeanPointDensity</a> (const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;cloud, const std::vector&lt; int &gt; &amp;indices, float max_dist, int nr_threads=1)</td></tr>
<tr class="memdesc:aeb16be13e9916aeae094e1d151ba17f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean point density of a given point cloud.  <a href="namespacepcl.html#aeb16be13e9916aeae094e1d151ba17f8">More...</a><br /></td></tr>
<tr class="separator:aeb16be13e9916aeae094e1d151ba17f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23810514c001fdc966f3db72456ee128"><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr class="memitem:a23810514c001fdc966f3db72456ee128"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a23810514c001fdc966f3db72456ee128">projectPoint</a> (const Point &amp;p, const Eigen::Vector4f &amp;model_coefficients, Point &amp;q)</td></tr>
<tr class="memdesc:a23810514c001fdc966f3db72456ee128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a point on a planar model given by a set of normalized coefficients.  <a href="namespacepcl.html#a23810514c001fdc966f3db72456ee128">More...</a><br /></td></tr>
<tr class="separator:a23810514c001fdc966f3db72456ee128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ccc1f67a12a93c3930c91116ff8120"><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr class="memitem:gaa4ccc1f67a12a93c3930c91116ff8120"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sample__consensus.html#gaa4ccc1f67a12a93c3930c91116ff8120">pointToPlaneDistanceSigned</a> (const Point &amp;p, double a, double b, double c, double d)</td></tr>
<tr class="memdesc:gaa4ccc1f67a12a93c3930c91116ff8120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from a point to a plane (signed) defined by ax+by+cz+d=0.  <a href="group__sample__consensus.html#gaa4ccc1f67a12a93c3930c91116ff8120">More...</a><br /></td></tr>
<tr class="separator:gaa4ccc1f67a12a93c3930c91116ff8120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0254d8592884aedfd4daeb631cf3247"><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr class="memitem:gaf0254d8592884aedfd4daeb631cf3247"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sample__consensus.html#gaf0254d8592884aedfd4daeb631cf3247">pointToPlaneDistanceSigned</a> (const Point &amp;p, const Eigen::Vector4f &amp;plane_coefficients)</td></tr>
<tr class="memdesc:gaf0254d8592884aedfd4daeb631cf3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from a point to a plane (signed) defined by ax+by+cz+d=0.  <a href="group__sample__consensus.html#gaf0254d8592884aedfd4daeb631cf3247">More...</a><br /></td></tr>
<tr class="separator:gaf0254d8592884aedfd4daeb631cf3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbab932cbacef63d51404db8cc1a862f"><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr class="memitem:gabbab932cbacef63d51404db8cc1a862f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sample__consensus.html#gabbab932cbacef63d51404db8cc1a862f">pointToPlaneDistance</a> (const Point &amp;p, double a, double b, double c, double d)</td></tr>
<tr class="memdesc:gabbab932cbacef63d51404db8cc1a862f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from a point to a plane (unsigned) defined by ax+by+cz+d=0.  <a href="group__sample__consensus.html#gabbab932cbacef63d51404db8cc1a862f">More...</a><br /></td></tr>
<tr class="separator:gabbab932cbacef63d51404db8cc1a862f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ba25b6b496cf05b52b7e639c4c19e0"><td class="memTemplParams" colspan="2">template&lt;typename Point &gt; </td></tr>
<tr class="memitem:gad5ba25b6b496cf05b52b7e639c4c19e0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sample__consensus.html#gad5ba25b6b496cf05b52b7e639c4c19e0">pointToPlaneDistance</a> (const Point &amp;p, const Eigen::Vector4f &amp;plane_coefficients)</td></tr>
<tr class="memdesc:gad5ba25b6b496cf05b52b7e639c4c19e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from a point to a plane (unsigned) defined by ax+by+cz+d=0.  <a href="group__sample__consensus.html#gad5ba25b6b496cf05b52b7e639c4c19e0">More...</a><br /></td></tr>
<tr class="separator:gad5ba25b6b496cf05b52b7e639c4c19e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c5f0a1d0ca0dac743de3bf976834c1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga40c5f0a1d0ca0dac743de3bf976834c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga40c5f0a1d0ca0dac743de3bf976834c1">extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const typename <a class="el" href="classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &gt; &amp;clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td></tr>
<tr class="memdesc:ga40c5f0a1d0ca0dac743de3bf976834c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="group__segmentation.html#ga40c5f0a1d0ca0dac743de3bf976834c1">More...</a><br /></td></tr>
<tr class="separator:ga40c5f0a1d0ca0dac743de3bf976834c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1512739d4fd761c49372d140bcdd92b1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga1512739d4fd761c49372d140bcdd92b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga1512739d4fd761c49372d140bcdd92b1">extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const std::vector&lt; int &gt; &amp;indices, const typename <a class="el" href="classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &gt; &amp;clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td></tr>
<tr class="memdesc:ga1512739d4fd761c49372d140bcdd92b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="group__segmentation.html#ga1512739d4fd761c49372d140bcdd92b1">More...</a><br /></td></tr>
<tr class="separator:ga1512739d4fd761c49372d140bcdd92b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2906d5886306876c13c6d31a02d30c8"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Normal &gt; </td></tr>
<tr class="memitem:gac2906d5886306876c13c6d31a02d30c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#gac2906d5886306876c13c6d31a02d30c8">extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">Normal</a> &gt; &amp;normals, float tolerance, const typename <a class="el" href="classpcl_1_1_kd_tree.html">KdTree</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &amp;tree, std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &gt; &amp;clusters, double eps_angle, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td></tr>
<tr class="memdesc:gac2906d5886306876c13c6d31a02d30c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation.  <a href="group__segmentation.html#gac2906d5886306876c13c6d31a02d30c8">More...</a><br /></td></tr>
<tr class="separator:gac2906d5886306876c13c6d31a02d30c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ff98a381b5f6857fa4e54b96fdd22a"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Normal &gt; </td></tr>
<tr class="memitem:ga61ff98a381b5f6857fa4e54b96fdd22a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga61ff98a381b5f6857fa4e54b96fdd22a">extractEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_normal.html">Normal</a> &gt; &amp;normals, const std::vector&lt; int &gt; &amp;indices, const typename <a class="el" href="classpcl_1_1_kd_tree.html">KdTree</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &gt; &amp;clusters, double eps_angle, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=(std::numeric_limits&lt; int &gt;::max)())</td></tr>
<tr class="memdesc:ga61ff98a381b5f6857fa4e54b96fdd22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the euclidean distance between points, and the normal angular deviation.  <a href="group__segmentation.html#ga61ff98a381b5f6857fa4e54b96fdd22a">More...</a><br /></td></tr>
<tr class="separator:ga61ff98a381b5f6857fa4e54b96fdd22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae88095505f2cbfbef301795b0f4cf5c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#gae88095505f2cbfbef301795b0f4cf5c6">comparePointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;b)</td></tr>
<tr class="memdesc:gae88095505f2cbfbef301795b0f4cf5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort clusters method (for std::sort).  <a href="group__segmentation.html#gae88095505f2cbfbef301795b0f4cf5c6">More...</a><br /></td></tr>
<tr class="separator:gae88095505f2cbfbef301795b0f4cf5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga752cd549cf401bbefa861807781e937d"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga752cd549cf401bbefa861807781e937d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga752cd549cf401bbefa861807781e937d">extractLabeledEuclideanClusters</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const typename <a class="el" href="classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &amp;tree, float tolerance, std::vector&lt; std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &gt; &gt; &amp;labeled_clusters, unsigned int min_pts_per_cluster=1, unsigned int max_pts_per_cluster=std::numeric_limits&lt; unsigned int &gt;::max(), unsigned int max_label=std::numeric_limits&lt; unsigned int &gt;::max())</td></tr>
<tr class="memdesc:ga752cd549cf401bbefa861807781e937d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="group__segmentation.html#ga752cd549cf401bbefa861807781e937d">More...</a><br /></td></tr>
<tr class="separator:ga752cd549cf401bbefa861807781e937d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d36abe92bc812f65d08618fda89123"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga45d36abe92bc812f65d08618fda89123">compareLabeledPointClusters</a> (const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;a, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;b)</td></tr>
<tr class="memdesc:ga45d36abe92bc812f65d08618fda89123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort clusters method (for std::sort).  <a href="group__segmentation.html#ga45d36abe92bc812f65d08618fda89123">More...</a><br /></td></tr>
<tr class="separator:ga45d36abe92bc812f65d08618fda89123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga0a21f5679b1644a7894f2f14ee1bbe37">isPointIn2DPolygon</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose method for checking if a 3D point is inside or outside a given 2D polygon.  <a href="group__segmentation.html#ga0a21f5679b1644a7894f2f14ee1bbe37">More...</a><br /></td></tr>
<tr class="separator:ga0a21f5679b1644a7894f2f14ee1bbe37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga5c5f766262ec4eae1af76df2bc0afc64">isXYPointIn2DXYPolygon</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a 2d point (X and Y coordinates considered only!) is inside or outside a given polygon.  <a href="group__segmentation.html#ga5c5f766262ec4eae1af76df2bc0afc64">More...</a><br /></td></tr>
<tr class="separator:ga5c5f766262ec4eae1af76df2bc0afc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e51fd3658ed051b4f6cc0c0340bde2c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4e51fd3658ed051b4f6cc0c0340bde2c"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a4e51fd3658ed051b4f6cc0c0340bde2c">squaredEuclideanDistance</a> (const <a class="el" href="structpcl_1_1segmentation_1_1grabcut_1_1_color.html">pcl::segmentation::grabcut::Color</a> &amp;c1, const <a class="el" href="structpcl_1_1segmentation_1_1grabcut_1_1_color.html">pcl::segmentation::grabcut::Color</a> &amp;c2)</td></tr>
<tr class="separator:a4e51fd3658ed051b4f6cc0c0340bde2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22143206fbf09462bb365a5df39e6452"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a22143206fbf09462bb365a5df39e6452">comparePair</a> (std::pair&lt; float, int &gt; i, std::pair&lt; float, int &gt; j)</td></tr>
<tr class="memdesc:a22143206fbf09462bb365a5df39e6452"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used as a comparator for sorting.  <a href="namespacepcl.html#a22143206fbf09462bb365a5df39e6452">More...</a><br /></td></tr>
<tr class="separator:a22143206fbf09462bb365a5df39e6452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5891c20fc0abc04063e117afaa8554d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga5891c20fc0abc04063e117afaa8554d6">seededHueSegmentation</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &gt; &amp;cloud, const <a class="el" href="classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &gt;::Ptr &amp;tree, float tolerance, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_in, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_out, float delta_hue=0.0)</td></tr>
<tr class="memdesc:ga5891c20fc0abc04063e117afaa8554d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="group__segmentation.html#ga5891c20fc0abc04063e117afaa8554d6">More...</a><br /></td></tr>
<tr class="separator:ga5891c20fc0abc04063e117afaa8554d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf25653016cc78d6cf7adad3651b0d7ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__segmentation.html#gaf25653016cc78d6cf7adad3651b0d7ed">seededHueSegmentation</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &gt; &amp;cloud, const <a class="el" href="classpcl_1_1search_1_1_search.html">search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_l.html">PointXYZRGBL</a> &gt;::Ptr &amp;tree, float tolerance, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_in, <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices_out, float delta_hue=0.0)</td></tr>
<tr class="memdesc:gaf25653016cc78d6cf7adad3651b0d7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a region of space into clusters based on the Euclidean distance between points.  <a href="group__segmentation.html#gaf25653016cc78d6cf7adad3651b0d7ed">More...</a><br /></td></tr>
<tr class="separator:gaf25653016cc78d6cf7adad3651b0d7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd433527a00085583fa1e8eb31cba0f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga5fd433527a00085583fa1e8eb31cba0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentation.html#ga5fd433527a00085583fa1e8eb31cba0f">getPointCloudDifference</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;src, double threshold, const typename <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &amp;tree, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;output)</td></tr>
<tr class="memdesc:ga5fd433527a00085583fa1e8eb31cba0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the difference between two aligned point clouds as another point cloud, given a distance threshold.  <a href="group__segmentation.html#ga5fd433527a00085583fa1e8eb31cba0f">More...</a><br /></td></tr>
<tr class="separator:ga5fd433527a00085583fa1e8eb31cba0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd2c4f8400b2f4f32e850c73000eb09"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:acdd2c4f8400b2f4f32e850c73000eb09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#acdd2c4f8400b2f4f32e850c73000eb09">getPointCloudDifference</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;src, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;, double threshold, const typename <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &amp;tree, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;output)</td></tr>
<tr class="separator:acdd2c4f8400b2f4f32e850c73000eb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2c84a845c4ff4a41d6bc425ebde3f5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d2c84a845c4ff4a41d6bc425ebde3f5"><td class="memTemplItemLeft" align="right" valign="top">short int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a3d2c84a845c4ff4a41d6bc425ebde3f5">doStereoRatioFilter</a> (const T *const acc, short int dbest, T sad_min, int ratio_filter, int maxdisp, int precision=100)</td></tr>
<tr class="separator:a3d2c84a845c4ff4a41d6bc425ebde3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650c751be24e00fa2992c4935300a892"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a650c751be24e00fa2992c4935300a892"><td class="memTemplItemLeft" align="right" valign="top">short int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a650c751be24e00fa2992c4935300a892">doStereoPeakFilter</a> (const T *const acc, short int dbest, int peak_filter, int maxdisp)</td></tr>
<tr class="separator:a650c751be24e00fa2992c4935300a892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29068d47bc7d9776344c7a7947cead1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surface.html#ga29068d47bc7d9776344c7a7947cead1d">comparePoints2D</a> (const std::pair&lt; int, Eigen::Vector4f &gt; &amp;p1, const std::pair&lt; int, Eigen::Vector4f &gt; &amp;p2)</td></tr>
<tr class="memdesc:ga29068d47bc7d9776344c7a7947cead1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort 2D points in a vector structure.  <a href="group__surface.html#ga29068d47bc7d9776344c7a7947cead1d">More...</a><br /></td></tr>
<tr class="separator:ga29068d47bc7d9776344c7a7947cead1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dde43ef7735e68f5c69f25501557611"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surface.html#ga9dde43ef7735e68f5c69f25501557611">isVisible</a> (const Eigen::Vector2f &amp;X, const Eigen::Vector2f &amp;S1, const Eigen::Vector2f &amp;S2, const Eigen::Vector2f &amp;R=Eigen::Vector2f::Zero())</td></tr>
<tr class="memdesc:ga9dde43ef7735e68f5c69f25501557611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a point X is visible from point R (or the origin) when taking into account the segment between the points S1 and S2.  <a href="group__surface.html#ga9dde43ef7735e68f5c69f25501557611">More...</a><br /></td></tr>
<tr class="separator:ga9dde43ef7735e68f5c69f25501557611"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af681d81612b8475461f95bb45eb458de"><td class="memItemLeft" align="right" valign="top">const static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af681d81612b8475461f95bb45eb458de">SAC_RANSAC</a> = 0</td></tr>
<tr class="separator:af681d81612b8475461f95bb45eb458de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec2d9927927653af6d842971d4a514c"><td class="memItemLeft" align="right" valign="top">const static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#abec2d9927927653af6d842971d4a514c">SAC_LMEDS</a> = 1</td></tr>
<tr class="separator:abec2d9927927653af6d842971d4a514c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15196d038687c175f9e80d9288cbc2a7"><td class="memItemLeft" align="right" valign="top">const static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a15196d038687c175f9e80d9288cbc2a7">SAC_MSAC</a> = 2</td></tr>
<tr class="separator:a15196d038687c175f9e80d9288cbc2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939bbfaac918c8fbc2f5a7bcc17e9c05"><td class="memItemLeft" align="right" valign="top">const static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a939bbfaac918c8fbc2f5a7bcc17e9c05">SAC_RRANSAC</a> = 3</td></tr>
<tr class="separator:a939bbfaac918c8fbc2f5a7bcc17e9c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6bb33f62c5027a735f7195d34660b9"><td class="memItemLeft" align="right" valign="top">const static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aab6bb33f62c5027a735f7195d34660b9">SAC_RMSAC</a> = 4</td></tr>
<tr class="separator:aab6bb33f62c5027a735f7195d34660b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952325f9e9d892a2c3f0a47cf10351f4"><td class="memItemLeft" align="right" valign="top">const static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a952325f9e9d892a2c3f0a47cf10351f4">SAC_MLESAC</a> = 5</td></tr>
<tr class="separator:a952325f9e9d892a2c3f0a47cf10351f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829773f124635b23ee974e7e145dd3ea"><td class="memItemLeft" align="right" valign="top">const static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a829773f124635b23ee974e7e145dd3ea">SAC_PROSAC</a> = 6</td></tr>
<tr class="separator:a829773f124635b23ee974e7e145dd3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca325832bef94391fd46c45a952081ea"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#aca325832bef94391fd46c45a952081ea">I_SHIFT_EP</a> [12][2]</td></tr>
<tr class="memdesc:aca325832bef94391fd46c45a952081ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 12 edges of a cell.  <a href="namespacepcl.html#aca325832bef94391fd46c45a952081ea">More...</a><br /></td></tr>
<tr class="separator:aca325832bef94391fd46c45a952081ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84721a0872dda8ea38b5f3fd306c88f8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#a84721a0872dda8ea38b5f3fd306c88f8">I_SHIFT_PT</a> [4]</td></tr>
<tr class="separator:a84721a0872dda8ea38b5f3fd306c88f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42bfadb1ac9576b4390c409f29bbbd1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#ad42bfadb1ac9576b4390c409f29bbbd1">I_SHIFT_EDGE</a> [3][2]</td></tr>
<tr class="separator:ad42bfadb1ac9576b4390c409f29bbbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46e561a1ed94889f2d0b343293087e5"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#af46e561a1ed94889f2d0b343293087e5">edgeTable</a> [256]</td></tr>
<tr class="separator:af46e561a1ed94889f2d0b343293087e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf90f2950487a5a98d46da99e58ea04"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepcl.html#afaf90f2950487a5a98d46da99e58ea04">triTable</a> [256][16]</td></tr>
<tr class="separator:afaf90f2950487a5a98d46da99e58ea04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad407d69b35fab38328de6519fc5971b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad407d69b35fab38328de6519fc5971b5">&#9670;&nbsp;</a></span>Array3fMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ad407d69b35fab38328de6519fc5971b5">pcl::Array3fMap</a> = typedef Eigen::Map&lt;Eigen::Array3f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00176">176</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="abd080c373c46953232448f70566dbeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd080c373c46953232448f70566dbeca">&#9670;&nbsp;</a></span>Array3fMapConst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#abd080c373c46953232448f70566dbeca">pcl::Array3fMapConst</a> = typedef const Eigen::Map&lt;const Eigen::Array3f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00177">177</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a934d06850ba45c8cc47e5cdc6da0b0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934d06850ba45c8cc47e5cdc6da0b0ce">&#9670;&nbsp;</a></span>Array4fMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a934d06850ba45c8cc47e5cdc6da0b0ce">pcl::Array4fMap</a> = typedef Eigen::Map&lt;Eigen::Array4f, Eigen::Aligned&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00178">178</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a8bbe388fc6305729a2005fb6b30cf1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbe388fc6305729a2005fb6b30cf1fb">&#9670;&nbsp;</a></span>Array4fMapConst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a8bbe388fc6305729a2005fb6b30cf1fb">pcl::Array4fMapConst</a> = typedef const Eigen::Map&lt;const Eigen::Array4f, Eigen::Aligned&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00179">179</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a3f368bb27adce3e34778c4da706d99cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f368bb27adce3e34778c4da706d99cc">&#9670;&nbsp;</a></span>BivariatePolynomial</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a3f368bb27adce3e34778c4da706d99cc">pcl::BivariatePolynomial</a> = typedef <a class="el" href="classpcl_1_1_bivariate_polynomial_t.html">BivariatePolynomialT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bivariate__polynomial_8h_source.html#l00138">138</a> of file <a class="el" href="bivariate__polynomial_8h_source.html">bivariate_polynomial.h</a>.</p>

</div>
</div>
<a id="a50f06eaf95ee8d0c6af44271124a3660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f06eaf95ee8d0c6af44271124a3660">&#9670;&nbsp;</a></span>BivariatePolynomiald</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a50f06eaf95ee8d0c6af44271124a3660">pcl::BivariatePolynomiald</a> = typedef <a class="el" href="classpcl_1_1_bivariate_polynomial_t.html">BivariatePolynomialT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bivariate__polynomial_8h_source.html#l00137">137</a> of file <a class="el" href="bivariate__polynomial_8h_source.html">bivariate_polynomial.h</a>.</p>

</div>
</div>
<a id="a5f8e904e5c6f763188a410832f96ac00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8e904e5c6f763188a410832f96ac00">&#9670;&nbsp;</a></span>Correspondences</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">pcl::Correspondences</a> = typedef std::vector&lt; <a class="el" href="structpcl_1_1_correspondence.html">pcl::Correspondence</a>, Eigen::aligned_allocator&lt;<a class="el" href="structpcl_1_1_correspondence.html">pcl::Correspondence</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="correspondence_8h_source.html#l00089">89</a> of file <a class="el" href="correspondence_8h_source.html">correspondence.h</a>.</p>

</div>
</div>
<a id="a359b3e0a2e6a4f2d71b22cb32004862d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359b3e0a2e6a4f2d71b22cb32004862d">&#9670;&nbsp;</a></span>CorrespondencesConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a359b3e0a2e6a4f2d71b22cb32004862d">pcl::CorrespondencesConstPtr</a> = typedef shared_ptr&lt;const <a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">Correspondences</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="correspondence_8h_source.html#l00091">91</a> of file <a class="el" href="correspondence_8h_source.html">correspondence.h</a>.</p>

</div>
</div>
<a id="a12f6f222e9a2be3c0fa8cdf49903c1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f6f222e9a2be3c0fa8cdf49903c1aa">&#9670;&nbsp;</a></span>CorrespondencesPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a12f6f222e9a2be3c0fa8cdf49903c1aa">pcl::CorrespondencesPtr</a> = typedef shared_ptr&lt;<a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">Correspondences</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="correspondence_8h_source.html#l00090">90</a> of file <a class="el" href="correspondence_8h_source.html">correspondence.h</a>.</p>

</div>
</div>
<a id="af74051d0f43fd3965ec5ebda52b618cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74051d0f43fd3965ec5ebda52b618cb">&#9670;&nbsp;</a></span>Depth2DComparisonFeatureHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#af74051d0f43fd3965ec5ebda52b618cb">pcl::Depth2DComparisonFeatureHandler</a> = typedef <a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a>&lt;float, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html#l00445">445</a> of file <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html">multi_channel_2d_comparison_feature_handler.h</a>.</p>

</div>
</div>
<a id="a369bca4fc510e61a4665dfe7e093c532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369bca4fc510e61a4665dfe7e093c532">&#9670;&nbsp;</a></span>Depth2DDataSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a369bca4fc510e61a4665dfe7e093c532">pcl::Depth2DDataSet</a> = typedef <a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a>&lt;float, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__data__set_8h_source.html#l00245">245</a> of file <a class="el" href="multi__channel__2d__data__set_8h_source.html">multi_channel_2d_data_set.h</a>.</p>

</div>
</div>
<a id="a7ba82385a43e15881364be0c2e3d4296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba82385a43e15881364be0c2e3d4296">&#9670;&nbsp;</a></span>GlasbeyLUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a7ba82385a43e15881364be0c2e3d4296">pcl::GlasbeyLUT</a> = typedef <a class="el" href="classpcl_1_1_color_l_u_t.html">ColorLUT</a>&lt;<a class="el" href="namespacepcl.html#a617dd0c1fbdf854bfbfb9ef2943665aba4583b0f87c691c76ca961b2bcbd99eea">pcl::LUT_GLASBEY</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="colors_8h_source.html#l00083">83</a> of file <a class="el" href="colors_8h_source.html">colors.h</a>.</p>

</div>
</div>
<a id="af2169862b7553da3717fe1c1df021a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2169862b7553da3717fe1c1df021a2f">&#9670;&nbsp;</a></span>HeaderConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#af2169862b7553da3717fe1c1df021a2f">pcl::HeaderConstPtr</a> = typedef <a class="el" href="structpcl_1_1_p_c_l_header.html#a8d3dfee745a5d239e2e7f7d5972621cd">PCLHeader::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_header_8h_source.html#l00027">27</a> of file <a class="el" href="_p_c_l_header_8h_source.html">PCLHeader.h</a>.</p>

</div>
</div>
<a id="a022355a03682d73506ff03a07099e238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022355a03682d73506ff03a07099e238">&#9670;&nbsp;</a></span>HeaderPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a022355a03682d73506ff03a07099e238">pcl::HeaderPtr</a> = typedef <a class="el" href="structpcl_1_1_p_c_l_header.html#a55b3c053bb47cda7ff147d98c050543b">PCLHeader::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_header_8h_source.html#l00026">26</a> of file <a class="el" href="_p_c_l_header_8h_source.html">PCLHeader.h</a>.</p>

</div>
</div>
<a id="a45edbae979af563e6a1e39fd1aad3911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45edbae979af563e6a1e39fd1aad3911">&#9670;&nbsp;</a></span>index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">pcl::index_t</a> = typedef <a class="el" href="namespacepcl_1_1detail.html#a3f3400ba40ee203c842481cfbb716900">detail::int_type_t</a>&lt;<a class="el" href="namespacepcl_1_1detail.html#a485d0d8c7a7b9981ac9e76ab821a38e4">detail::index_type_size</a>, <a class="el" href="namespacepcl_1_1detail.html#a0d5f9ba23dbec1366c9021dc149c9925">detail::index_type_signed</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for an index in PCL. </p>
<p>Default index_t = int for PCL 1.11, std::int32_t for PCL &gt;= 1.12 </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00136">136</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a8bfe09b8680e7129dd0fd6177c1a2ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfe09b8680e7129dd0fd6177c1a2ce6">&#9670;&nbsp;</a></span>Indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> = typedef <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for indices in PCL. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00149">149</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a61689ac607f746f728bb76bc14fe8ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61689ac607f746f728bb76bc14fe8ca4">&#9670;&nbsp;</a></span>IndicesAllocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator  = std::allocator&lt;index_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">pcl::IndicesAllocator</a> = typedef std::vector&lt;<a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a>, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for indices in PCL. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Remove with C++20 </dd></dl>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00144">144</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="ae18edc4d3bcf513ada24a49d7cc903e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18edc4d3bcf513ada24a49d7cc903e2">&#9670;&nbsp;</a></span>IndicesClusters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ae18edc4d3bcf513ada24a49d7cc903e2">pcl::IndicesClusters</a> = typedef std::vector&lt;<a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conditional__euclidean__clustering_8h_source.html#l00049">49</a> of file <a class="el" href="conditional__euclidean__clustering_8h_source.html">conditional_euclidean_clustering.h</a>.</p>

</div>
</div>
<a id="a07d7c1bc2ca9355df8370f91c7129367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d7c1bc2ca9355df8370f91c7129367">&#9670;&nbsp;</a></span>IndicesClustersPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a07d7c1bc2ca9355df8370f91c7129367">pcl::IndicesClustersPtr</a> = typedef shared_ptr&lt;std::vector&lt;<a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conditional__euclidean__clustering_8h_source.html#l00050">50</a> of file <a class="el" href="conditional__euclidean__clustering_8h_source.html">conditional_euclidean_clustering.h</a>.</p>

</div>
</div>
<a id="a011f84e43d80cb736d9ec9abd0930024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011f84e43d80cb736d9ec9abd0930024">&#9670;&nbsp;</a></span>IndicesConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a011f84e43d80cb736d9ec9abd0930024">pcl::IndicesConstPtr</a> = typedef shared_ptr&lt;const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pcl__base_8h_source.html#l00062">62</a> of file <a class="el" href="pcl__base_8h_source.html">pcl_base.h</a>.</p>

</div>
</div>
<a id="ab11731b62628e35f6adc312d1cdaf372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11731b62628e35f6adc312d1cdaf372">&#9670;&nbsp;</a></span>IndicesPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">pcl::IndicesPtr</a> = typedef shared_ptr&lt;<a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pcl__base_8h_source.html#l00061">61</a> of file <a class="el" href="pcl__base_8h_source.html">pcl_base.h</a>.</p>

</div>
</div>
<a id="a76057dcaa0702a6e8d9e773bf07d5b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76057dcaa0702a6e8d9e773bf07d5b11">&#9670;&nbsp;</a></span>int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a76057dcaa0702a6e8d9e773bf07d5b11">pcl::int16_t</a> = typedef std::int16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00057">57</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a4f80e711ed71e4073df27290bfc78ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f80e711ed71e4073df27290bfc78ff6">&#9670;&nbsp;</a></span>int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a4f80e711ed71e4073df27290bfc78ff6">pcl::int32_t</a> = typedef std::int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00059">59</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="af7bef31b992d634256c4fb4a3d70295d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bef31b992d634256c4fb4a3d70295d">&#9670;&nbsp;</a></span>int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#af7bef31b992d634256c4fb4a3d70295d">pcl::int64_t</a> = typedef std::int64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00061">61</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="abf3b61cc55405d1a0c938d0c57cd59fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3b61cc55405d1a0c938d0c57cd59fa">&#9670;&nbsp;</a></span>int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#abf3b61cc55405d1a0c938d0c57cd59fa">pcl::int8_t</a> = typedef std::int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00055">55</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a15f14fad13f3505c22aab07eb88865fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f14fad13f3505c22aab07eb88865fd">&#9670;&nbsp;</a></span>int_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a15f14fad13f3505c22aab07eb88865fd">pcl::int_fast16_t</a> = typedef std::int_fast16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00062">62</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="af7c8397d4916e88919dfff21affdcff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c8397d4916e88919dfff21affdcff0">&#9670;&nbsp;</a></span>IntensityDepth2DComparisonFeatureHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#af7c8397d4916e88919dfff21affdcff0">pcl::IntensityDepth2DComparisonFeatureHandler</a> = typedef <a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a>&lt;float, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html#l00447">447</a> of file <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html">multi_channel_2d_comparison_feature_handler.h</a>.</p>

</div>
</div>
<a id="a6d8f5d269106c9c72c96a1f212d0f699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8f5d269106c9c72c96a1f212d0f699">&#9670;&nbsp;</a></span>IntensityDepth2DDataSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a6d8f5d269106c9c72c96a1f212d0f699">pcl::IntensityDepth2DDataSet</a> = typedef <a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a>&lt;float, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__data__set_8h_source.html#l00246">246</a> of file <a class="el" href="multi__channel__2d__data__set_8h_source.html">multi_channel_2d_data_set.h</a>.</p>

</div>
</div>
<a id="a8212c54e01f75c163675dd96006e07d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8212c54e01f75c163675dd96006e07d0">&#9670;&nbsp;</a></span>ModelCoefficientsConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a8212c54e01f75c163675dd96006e07d0">pcl::ModelCoefficientsConstPtr</a> = typedef <a class="el" href="structpcl_1_1_model_coefficients.html#ae10f3f75a03c6513e1665cd28ea50881">ModelCoefficients::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_model_coefficients_8h_source.html#l00028">28</a> of file <a class="el" href="_model_coefficients_8h_source.html">ModelCoefficients.h</a>.</p>

</div>
</div>
<a id="ad856b1db80591d2019b5781993550c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad856b1db80591d2019b5781993550c83">&#9670;&nbsp;</a></span>ModelCoefficientsPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ad856b1db80591d2019b5781993550c83">pcl::ModelCoefficientsPtr</a> = typedef <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">ModelCoefficients::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_model_coefficients_8h_source.html#l00027">27</a> of file <a class="el" href="_model_coefficients_8h_source.html">ModelCoefficients.h</a>.</p>

</div>
</div>
<a id="a73675f80e6c9c5474fb417e452e3ae10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73675f80e6c9c5474fb417e452e3ae10">&#9670;&nbsp;</a></span>MovingLeastSquaresOMP</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a73675f80e6c9c5474fb417e452e3ae10">pcl::MovingLeastSquaresOMP</a> = typedef <a class="el" href="classpcl_1_1_moving_least_squares.html">MovingLeastSquares</a>&lt;PointInT, PointOutT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mls_8h_source.html#l00750">750</a> of file <a class="el" href="mls_8h_source.html">mls.h</a>.</p>

</div>
</div>
<a id="ae716f0bdfbc7ae033006733a42fb6b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae716f0bdfbc7ae033006733a42fb6b63">&#9670;&nbsp;</a></span>MsgFieldMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ae716f0bdfbc7ae033006733a42fb6b63">pcl::MsgFieldMap</a> = typedef std::vector&lt;<a class="el" href="structpcl_1_1detail_1_1_field_mapping.html">detail::FieldMapping</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00072">72</a> of file <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html">point_cloud.h</a>.</p>

</div>
</div>
<a id="ab09315268fe8cf472847ea6f7e6f786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09315268fe8cf472847ea6f7e6f786e">&#9670;&nbsp;</a></span>PCLImageConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ab09315268fe8cf472847ea6f7e6f786e">pcl::PCLImageConstPtr</a> = typedef <a class="el" href="structpcl_1_1_p_c_l_image.html#aa6866e76de8f68a5b0cf16ffc62dff87">PCLImage::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_image_8h_source.html#l00029">29</a> of file <a class="el" href="_p_c_l_image_8h_source.html">PCLImage.h</a>.</p>

</div>
</div>
<a id="ae135037ab459b4319a895d765758a57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae135037ab459b4319a895d765758a57a">&#9670;&nbsp;</a></span>PCLImagePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ae135037ab459b4319a895d765758a57a">pcl::PCLImagePtr</a> = typedef <a class="el" href="structpcl_1_1_p_c_l_image.html#ac6b9a9cd5f96ca68e8bc15b7db7846cb">PCLImage::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_image_8h_source.html#l00028">28</a> of file <a class="el" href="_p_c_l_image_8h_source.html">PCLImage.h</a>.</p>

</div>
</div>
<a id="ad64de997fa516c97e85cf8dc9d72146d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64de997fa516c97e85cf8dc9d72146d">&#9670;&nbsp;</a></span>PCLPointCloud2ConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ad64de997fa516c97e85cf8dc9d72146d">pcl::PCLPointCloud2ConstPtr</a> = typedef <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html#ad44a1f084d41d5bac3d41fe247364bb5">PCLPointCloud2::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00090">90</a> of file <a class="el" href="_p_c_l_point_cloud2_8h_source.html">PCLPointCloud2.h</a>.</p>

</div>
</div>
<a id="a73ae712f092fbdb4a77bddd2310cdab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ae712f092fbdb4a77bddd2310cdab5">&#9670;&nbsp;</a></span>PCLPointCloud2Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a73ae712f092fbdb4a77bddd2310cdab5">pcl::PCLPointCloud2Ptr</a> = typedef <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html#a5123c3c0386ccc5efd7d7a3b70fdc9bc">PCLPointCloud2::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00089">89</a> of file <a class="el" href="_p_c_l_point_cloud2_8h_source.html">PCLPointCloud2.h</a>.</p>

</div>
</div>
<a id="a0442b7abe91ce5799302859bee6d6f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0442b7abe91ce5799302859bee6d6f86">&#9670;&nbsp;</a></span>PCLPointFieldConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a0442b7abe91ce5799302859bee6d6f86">pcl::PCLPointFieldConstPtr</a> = typedef <a class="el" href="structpcl_1_1_p_c_l_point_field.html#ab719c9f0266eec0d4cd59b76f73b894f">PCLPointField::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_point_field_8h_source.html#l00034">34</a> of file <a class="el" href="_p_c_l_point_field_8h_source.html">PCLPointField.h</a>.</p>

</div>
</div>
<a id="ab8e42abe7fe47c172f71d02855e1136d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e42abe7fe47c172f71d02855e1136d">&#9670;&nbsp;</a></span>PCLPointFieldPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ab8e42abe7fe47c172f71d02855e1136d">pcl::PCLPointFieldPtr</a> = typedef <a class="el" href="structpcl_1_1_p_c_l_point_field.html#afaf15e7f600289cc628874bc9b87de61">PCLPointField::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_point_field_8h_source.html#l00033">33</a> of file <a class="el" href="_p_c_l_point_field_8h_source.html">PCLPointField.h</a>.</p>

</div>
</div>
<a id="ab76674024fd731f2ee3974c518576e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76674024fd731f2ee3974c518576e53">&#9670;&nbsp;</a></span>PointCorrespondences3DVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ab76674024fd731f2ee3974c518576e53">pcl::PointCorrespondences3DVector</a> = typedef std::vector&lt;<a class="el" href="structpcl_1_1_point_correspondence3_d.html">PointCorrespondence3D</a>, Eigen::aligned_allocator&lt;<a class="el" href="structpcl_1_1_point_correspondence3_d.html">PointCorrespondence3D</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="correspondence_8h_source.html#l00124">124</a> of file <a class="el" href="correspondence_8h_source.html">correspondence.h</a>.</p>

</div>
</div>
<a id="adaa4bb55445446ac9dad1ccd1d87b861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa4bb55445446ac9dad1ccd1d87b861">&#9670;&nbsp;</a></span>PointCorrespondences6DVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#adaa4bb55445446ac9dad1ccd1d87b861">pcl::PointCorrespondences6DVector</a> = typedef std::vector&lt;<a class="el" href="structpcl_1_1_point_correspondence6_d.html">PointCorrespondence6D</a>, Eigen::aligned_allocator&lt;<a class="el" href="structpcl_1_1_point_correspondence6_d.html">PointCorrespondence6D</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="correspondence_8h_source.html#l00138">138</a> of file <a class="el" href="correspondence_8h_source.html">correspondence.h</a>.</p>

</div>
</div>
<a id="aaf931dfa9573efdfea6ca35cb8a52993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf931dfa9573efdfea6ca35cb8a52993">&#9670;&nbsp;</a></span>PointIndicesConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#aaf931dfa9573efdfea6ca35cb8a52993">pcl::PointIndicesConstPtr</a> = typedef <a class="el" href="structpcl_1_1_point_indices.html#a6880da079270712d46b0bb348cf124bc">PointIndices::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_point_indices_8h_source.html#l00027">27</a> of file <a class="el" href="_point_indices_8h_source.html">PointIndices.h</a>.</p>

</div>
</div>
<a id="a9648b74014e6b52eb855a7f75dad9806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9648b74014e6b52eb855a7f75dad9806">&#9670;&nbsp;</a></span>PointIndicesPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a9648b74014e6b52eb855a7f75dad9806">pcl::PointIndicesPtr</a> = typedef <a class="el" href="structpcl_1_1_point_indices.html#a3c574b78dfbe67c93d09acdbc8ecc499">PointIndices::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_point_indices_8h_source.html#l00026">26</a> of file <a class="el" href="_point_indices_8h_source.html">PointIndices.h</a>.</p>

</div>
</div>
<a id="a0da120eaa8024e3bf1ef6a4c4ec29f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da120eaa8024e3bf1ef6a4c4ec29f32">&#9670;&nbsp;</a></span>PolygonMeshConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a0da120eaa8024e3bf1ef6a4c4ec29f32">pcl::PolygonMeshConstPtr</a> = typedef <a class="el" href="structpcl_1_1_polygon_mesh.html#ae9324cf4996134d4d1b8034b3fceee90">PolygonMesh::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_polygon_mesh_8h_source.html#l00102">102</a> of file <a class="el" href="_polygon_mesh_8h_source.html">PolygonMesh.h</a>.</p>

</div>
</div>
<a id="a52624ff976b10c9bc0bbec9fec13c5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52624ff976b10c9bc0bbec9fec13c5f3">&#9670;&nbsp;</a></span>PolygonMeshPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a52624ff976b10c9bc0bbec9fec13c5f3">pcl::PolygonMeshPtr</a> = typedef <a class="el" href="structpcl_1_1_polygon_mesh.html#a99c6fe1a6692ce2d9cd51363e254e554">PolygonMesh::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_polygon_mesh_8h_source.html#l00101">101</a> of file <a class="el" href="_polygon_mesh_8h_source.html">PolygonMesh.h</a>.</p>

</div>
</div>
<a id="a8bb0aae9ce07363038a232bdf3aea749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb0aae9ce07363038a232bdf3aea749">&#9670;&nbsp;</a></span>PolynomialCalculations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a8bb0aae9ce07363038a232bdf3aea749">pcl::PolynomialCalculations</a> = typedef <a class="el" href="classpcl_1_1_polynomial_calculations_t.html">PolynomialCalculationsT</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial__calculations_8h_source.html#l00124">124</a> of file <a class="el" href="polynomial__calculations_8h_source.html">polynomial_calculations.h</a>.</p>

</div>
</div>
<a id="a34e00f23039fed247228ae9ae17325e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e00f23039fed247228ae9ae17325e0">&#9670;&nbsp;</a></span>PolynomialCalculationsd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a34e00f23039fed247228ae9ae17325e0">pcl::PolynomialCalculationsd</a> = typedef <a class="el" href="classpcl_1_1_polynomial_calculations_t.html">PolynomialCalculationsT</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial__calculations_8h_source.html#l00123">123</a> of file <a class="el" href="polynomial__calculations_8h_source.html">polynomial_calculations.h</a>.</p>

</div>
</div>
<a id="a602d4fccbde6fa569a838c7d996d0ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602d4fccbde6fa569a838c7d996d0ff0">&#9670;&nbsp;</a></span>RGB2DComparisonFeatureHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a602d4fccbde6fa569a838c7d996d0ff0">pcl::RGB2DComparisonFeatureHandler</a> = typedef <a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a>&lt;float, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html#l00448">448</a> of file <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html">multi_channel_2d_comparison_feature_handler.h</a>.</p>

</div>
</div>
<a id="a7257d59131d79d55e123ab1835a0615a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7257d59131d79d55e123ab1835a0615a">&#9670;&nbsp;</a></span>RGB2DDataSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a7257d59131d79d55e123ab1835a0615a">pcl::RGB2DDataSet</a> = typedef <a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a>&lt;float, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__data__set_8h_source.html#l00247">247</a> of file <a class="el" href="multi__channel__2d__data__set_8h_source.html">multi_channel_2d_data_set.h</a>.</p>

</div>
</div>
<a id="a078d333d3243aff41962f7b883ff259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078d333d3243aff41962f7b883ff259b">&#9670;&nbsp;</a></span>RGBD2DComparisonFeatureHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a078d333d3243aff41962f7b883ff259b">pcl::RGBD2DComparisonFeatureHandler</a> = typedef <a class="el" href="classpcl_1_1_multi_channel2_d_comparison_feature_handler.html">MultiChannel2DComparisonFeatureHandler</a>&lt;float, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html#l00449">449</a> of file <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html">multi_channel_2d_comparison_feature_handler.h</a>.</p>

</div>
</div>
<a id="ab30133320fad91e06bfd7c23a9cbf31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30133320fad91e06bfd7c23a9cbf31f">&#9670;&nbsp;</a></span>RGBD2DDataSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ab30133320fad91e06bfd7c23a9cbf31f">pcl::RGBD2DDataSet</a> = typedef <a class="el" href="classpcl_1_1_multi_channel2_d_data_set.html">MultiChannel2DDataSet</a>&lt;float, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__data__set_8h_source.html#l00248">248</a> of file <a class="el" href="multi__channel__2d__data__set_8h_source.html">multi_channel_2d_data_set.h</a>.</p>

</div>
</div>
<a id="af35860b9680fcc149a898d96be9ea42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35860b9680fcc149a898d96be9ea42f">&#9670;&nbsp;</a></span>ScaledDepth2DComparisonFeatureHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#af35860b9680fcc149a898d96be9ea42f">pcl::ScaledDepth2DComparisonFeatureHandler</a> = typedef <a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler.html">ScaledMultiChannel2DComparisonFeatureHandler</a>&lt;float, 1, 0, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html#l00452">452</a> of file <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html">multi_channel_2d_comparison_feature_handler.h</a>.</p>

</div>
</div>
<a id="a3e303fcb18e6a8446fba6b20a36ace41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e303fcb18e6a8446fba6b20a36ace41">&#9670;&nbsp;</a></span>ScaledDepth2DComparisonFeatureHandlerCCodeGenerator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a3e303fcb18e6a8446fba6b20a36ace41">pcl::ScaledDepth2DComparisonFeatureHandlerCCodeGenerator</a> = typedef <a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler_c_code_generator.html">ScaledMultiChannel2DComparisonFeatureHandlerCCodeGenerator</a>&lt;float, 1, 0, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html#l00459">459</a> of file <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html">multi_channel_2d_comparison_feature_handler.h</a>.</p>

</div>
</div>
<a id="a5843f883e140428b9f0f03d8d0455cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5843f883e140428b9f0f03d8d0455cdc">&#9670;&nbsp;</a></span>ScaledIntensityDepth2DComparisonFeatureHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a5843f883e140428b9f0f03d8d0455cdc">pcl::ScaledIntensityDepth2DComparisonFeatureHandler</a> = typedef <a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler.html">ScaledMultiChannel2DComparisonFeatureHandler</a>&lt;float, 2, 1, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html#l00454">454</a> of file <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html">multi_channel_2d_comparison_feature_handler.h</a>.</p>

</div>
</div>
<a id="a350f3897d97d00f3b16508688452f315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350f3897d97d00f3b16508688452f315">&#9670;&nbsp;</a></span>ScaledRGBD2DComparisonFeatureHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a350f3897d97d00f3b16508688452f315">pcl::ScaledRGBD2DComparisonFeatureHandler</a> = typedef <a class="el" href="classpcl_1_1_scaled_multi_channel2_d_comparison_feature_handler.html">ScaledMultiChannel2DComparisonFeatureHandler</a>&lt;float, 4, 3, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html#l00456">456</a> of file <a class="el" href="multi__channel__2d__comparison__feature__handler_8h_source.html">multi_channel_2d_comparison_feature_handler.h</a>.</p>

</div>
</div>
<a id="a73edca3e6c28df5ff439bce6a795d635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73edca3e6c28df5ff439bce6a795d635">&#9670;&nbsp;</a></span>TextureMeshConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a73edca3e6c28df5ff439bce6a795d635">pcl::TextureMeshConstPtr</a> = typedef <a class="el" href="structpcl_1_1_texture_mesh.html#ab7696e9d1c3660272032c20b65e88fc7">TextureMesh::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_texture_mesh_8h_source.html#l00104">104</a> of file <a class="el" href="_texture_mesh_8h_source.html">TextureMesh.h</a>.</p>

</div>
</div>
<a id="a35a4202aed992879df6a4c58fb7ed82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a4202aed992879df6a4c58fb7ed82e">&#9670;&nbsp;</a></span>TextureMeshPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a35a4202aed992879df6a4c58fb7ed82e">pcl::TextureMeshPtr</a> = typedef <a class="el" href="structpcl_1_1_texture_mesh.html#adeefe5363d8f45241db45422f733ab57">TextureMesh::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_texture_mesh_8h_source.html#l00103">103</a> of file <a class="el" href="_texture_mesh_8h_source.html">TextureMesh.h</a>.</p>

</div>
</div>
<a id="a318eea0dc010eb432540e93fb326903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318eea0dc010eb432540e93fb326903b">&#9670;&nbsp;</a></span>uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a318eea0dc010eb432540e93fb326903b">pcl::uint16_t</a> = typedef std::uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00056">56</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a7c55bf09e463d214a43d2bd7ceab7753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c55bf09e463d214a43d2bd7ceab7753">&#9670;&nbsp;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a7c55bf09e463d214a43d2bd7ceab7753">pcl::uint32_t</a> = typedef std::uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00058">58</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="ad85445a07c77c6f3645992c10121518b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85445a07c77c6f3645992c10121518b">&#9670;&nbsp;</a></span>uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ad85445a07c77c6f3645992c10121518b">pcl::uint64_t</a> = typedef std::uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00060">60</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="aea8ace9e1a2351f301fd4b89b2940811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8ace9e1a2351f301fd4b89b2940811">&#9670;&nbsp;</a></span>uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#aea8ace9e1a2351f301fd4b89b2940811">pcl::uint8_t</a> = typedef std::uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00054">54</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a8e50f13135d27977665a621922ce6f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e50f13135d27977665a621922ce6f15">&#9670;&nbsp;</a></span>Vector3c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a8e50f13135d27977665a621922ce6f15">pcl::Vector3c</a> = typedef Eigen::Matrix&lt;std::uint8_t, 3, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00185">185</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="ac0e24d7da943faacfceecdd0d52ef704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e24d7da943faacfceecdd0d52ef704">&#9670;&nbsp;</a></span>Vector3cMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ac0e24d7da943faacfceecdd0d52ef704">pcl::Vector3cMap</a> = typedef Eigen::Map&lt;<a class="el" href="namespacepcl.html#a8e50f13135d27977665a621922ce6f15">Vector3c</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00186">186</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a6fac8027055b30756aeaa4a2143a4c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fac8027055b30756aeaa4a2143a4c1b">&#9670;&nbsp;</a></span>Vector3cMapConst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a6fac8027055b30756aeaa4a2143a4c1b">pcl::Vector3cMapConst</a> = typedef const Eigen::Map&lt;const <a class="el" href="namespacepcl.html#a8e50f13135d27977665a621922ce6f15">Vector3c</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00187">187</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a76b40c6dea7a9ea4d94e83519bdbe38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b40c6dea7a9ea4d94e83519bdbe38a">&#9670;&nbsp;</a></span>Vector3fMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a76b40c6dea7a9ea4d94e83519bdbe38a">pcl::Vector3fMap</a> = typedef Eigen::Map&lt;Eigen::Vector3f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00180">180</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a6646587b6e57635d1fa584cd7186ecc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6646587b6e57635d1fa584cd7186ecc9">&#9670;&nbsp;</a></span>Vector3fMapConst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a6646587b6e57635d1fa584cd7186ecc9">pcl::Vector3fMapConst</a> = typedef const Eigen::Map&lt;const Eigen::Vector3f&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00181">181</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a84f12fe818900868f62f44cbe3e69070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f12fe818900868f62f44cbe3e69070">&#9670;&nbsp;</a></span>Vector4c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a84f12fe818900868f62f44cbe3e69070">pcl::Vector4c</a> = typedef Eigen::Matrix&lt;std::uint8_t, 4, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00188">188</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a3aef7c957446afe2803849e70a77ba97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aef7c957446afe2803849e70a77ba97">&#9670;&nbsp;</a></span>Vector4cMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a3aef7c957446afe2803849e70a77ba97">pcl::Vector4cMap</a> = typedef Eigen::Map&lt;<a class="el" href="namespacepcl.html#a84f12fe818900868f62f44cbe3e69070">Vector4c</a>, Eigen::Aligned&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00189">189</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a2dbed164f7149b4fec73541a52633f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbed164f7149b4fec73541a52633f33">&#9670;&nbsp;</a></span>Vector4cMapConst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a2dbed164f7149b4fec73541a52633f33">pcl::Vector4cMapConst</a> = typedef const Eigen::Map&lt;const <a class="el" href="namespacepcl.html#a84f12fe818900868f62f44cbe3e69070">Vector4c</a>, Eigen::Aligned&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00190">190</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a2577a5ee21a3af86d334a1d8f2824a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2577a5ee21a3af86d334a1d8f2824a25">&#9670;&nbsp;</a></span>Vector4fMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a2577a5ee21a3af86d334a1d8f2824a25">pcl::Vector4fMap</a> = typedef Eigen::Map&lt;Eigen::Vector4f, Eigen::Aligned&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00182">182</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a868c010207876ae6613dc04f5e9f9e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868c010207876ae6613dc04f5e9f9e46">&#9670;&nbsp;</a></span>Vector4fMapConst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a868c010207876ae6613dc04f5e9f9e46">pcl::Vector4fMapConst</a> = typedef const Eigen::Map&lt;const Eigen::Vector4f, Eigen::Aligned&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l00183">183</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

</div>
</div>
<a id="a76216d9ffebafc2fd60d2c21885ae86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76216d9ffebafc2fd60d2c21885ae86b">&#9670;&nbsp;</a></span>VectorAverage2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a76216d9ffebafc2fd60d2c21885ae86b">pcl::VectorAverage2f</a> = typedef <a class="el" href="classpcl_1_1_vector_average.html">VectorAverage</a>&lt;float, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector__average_8h_source.html#l00115">115</a> of file <a class="el" href="vector__average_8h_source.html">vector_average.h</a>.</p>

</div>
</div>
<a id="a0669ff605ec2dcbf01300e309fc658f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0669ff605ec2dcbf01300e309fc658f2">&#9670;&nbsp;</a></span>VectorAverage3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a0669ff605ec2dcbf01300e309fc658f2">pcl::VectorAverage3f</a> = typedef <a class="el" href="classpcl_1_1_vector_average.html">VectorAverage</a>&lt;float, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector__average_8h_source.html#l00116">116</a> of file <a class="el" href="vector__average_8h_source.html">vector_average.h</a>.</p>

</div>
</div>
<a id="a66951b4ad71c91a0b49545ac199ba38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66951b4ad71c91a0b49545ac199ba38a">&#9670;&nbsp;</a></span>VectorAverage4f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a66951b4ad71c91a0b49545ac199ba38a">pcl::VectorAverage4f</a> = typedef <a class="el" href="classpcl_1_1_vector_average.html">VectorAverage</a>&lt;float, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector__average_8h_source.html#l00117">117</a> of file <a class="el" href="vector__average_8h_source.html">vector_average.h</a>.</p>

</div>
</div>
<a id="af9b106b17af05ea1d78e23219b6c0f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b106b17af05ea1d78e23219b6c0f44">&#9670;&nbsp;</a></span>VerticesConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#af9b106b17af05ea1d78e23219b6c0f44">pcl::VerticesConstPtr</a> = typedef <a class="el" href="structpcl_1_1_vertices.html#a3afb695a1378f1172a4c403e51977bb7">Vertices::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_vertices_8h_source.html#l00029">29</a> of file <a class="el" href="_vertices_8h_source.html">Vertices.h</a>.</p>

</div>
</div>
<a id="abdee5c37c9776ce9fe8ac34046e1a914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdee5c37c9776ce9fe8ac34046e1a914">&#9670;&nbsp;</a></span>VerticesPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#abdee5c37c9776ce9fe8ac34046e1a914">pcl::VerticesPtr</a> = typedef <a class="el" href="structpcl_1_1_vertices.html#ac423acc8c8d9084051d9fff52b1bcb41">Vertices::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_vertices_8h_source.html#l00028">28</a> of file <a class="el" href="_vertices_8h_source.html">Vertices.h</a>.</p>

</div>
</div>
<a id="a25f5a094c924a88a345aae1da1cb9aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f5a094c924a88a345aae1da1cb9aba">&#9670;&nbsp;</a></span>ViridisLUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#a25f5a094c924a88a345aae1da1cb9aba">pcl::ViridisLUT</a> = typedef <a class="el" href="classpcl_1_1_color_l_u_t.html">ColorLUT</a>&lt;<a class="el" href="namespacepcl.html#a617dd0c1fbdf854bfbfb9ef2943665aba63f4dba9bc10114af8e426b4b878d854">pcl::LUT_VIRIDIS</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="colors_8h_source.html#l00084">84</a> of file <a class="el" href="colors_8h_source.html">colors.h</a>.</p>

</div>
</div>
<a id="ac6a3f6db24e4059a582c45b8650bf9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a3f6db24e4059a582c45b8650bf9d2">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepcl.html#ac6a3f6db24e4059a582c45b8650bf9d2">pcl::void_t</a> = typedef void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00245">245</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a617dd0c1fbdf854bfbfb9ef2943665ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617dd0c1fbdf854bfbfb9ef2943665ab">&#9670;&nbsp;</a></span>ColorLUTName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepcl.html#a617dd0c1fbdf854bfbfb9ef2943665ab">pcl::ColorLUTName</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a617dd0c1fbdf854bfbfb9ef2943665aba4583b0f87c691c76ca961b2bcbd99eea"></a>LUT_GLASBEY&#160;</td><td class="fielddoc"><p>Color lookup table consisting of 256 colors structured in a maximally discontinuous manner. </p>
<p>Generated using the method of Glasbey et al. (see <a href="https://github.com/taketwo/glasbey">https://github.com/taketwo/glasbey</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="a617dd0c1fbdf854bfbfb9ef2943665aba63f4dba9bc10114af8e426b4b878d854"></a>LUT_VIRIDIS&#160;</td><td class="fielddoc"><p>A perceptually uniform colormap created by Stéfan van der Walt and Nathaniel Smith for the Python matplotlib library. </p>
<p>(see <a href="https://youtu.be/xAoljeRJ3lU">https://youtu.be/xAoljeRJ3lU</a> for background and overview) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="colors_8h_source.html#l00049">49</a> of file <a class="el" href="colors_8h_source.html">colors.h</a>.</p>

</div>
</div>
<a id="a8641d101f171b274f12109790e901ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8641d101f171b274f12109790e901ce9">&#9670;&nbsp;</a></span>HistogramInterpolationMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepcl.html#a8641d101f171b274f12109790e901ce9">pcl::HistogramInterpolationMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different histogram interpolation methods. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8641d101f171b274f12109790e901ce9a2bdcddf8f35b06e8a55bca0993d705f3"></a>INTERP_NONE&#160;</td><td class="fielddoc"><p>no interpolation </p>
</td></tr>
<tr><td class="fieldname"><a id="a8641d101f171b274f12109790e901ce9a836169fc1160e312ad956b61217ce6cd"></a>INTERP_TRILINEAR&#160;</td><td class="fielddoc"><p>trilinear interpolation </p>
</td></tr>
<tr><td class="fieldname"><a id="a8641d101f171b274f12109790e901ce9a30f66feb3d9607adffeb47e4f35d54db"></a>INTERP_QUADRILINEAR&#160;</td><td class="fielddoc"><p>quadrilinear interpolation </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="gasd_8h_source.html#l00048">48</a> of file <a class="el" href="gasd_8h_source.html">gasd.h</a>.</p>

</div>
</div>
<a id="a223710941333ffcbfd147e4f4c9a1485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223710941333ffcbfd147e4f4c9a1485">&#9670;&nbsp;</a></span>InterpolationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485">pcl::InterpolationType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a223710941333ffcbfd147e4f4c9a1485a803e6fa833a297b2e4c193665afc9175"></a>BORDER_CONSTANT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a223710941333ffcbfd147e4f4c9a1485af797a53aacb461b965a9947dec460430"></a>BORDER_REPLICATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a223710941333ffcbfd147e4f4c9a1485a16c6595a6e0b3cdf525407618970c281"></a>BORDER_REFLECT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a223710941333ffcbfd147e4f4c9a1485ad7055354bdf79e8e3eab3057d2b0002b"></a>BORDER_WRAP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a223710941333ffcbfd147e4f4c9a1485a26da236fd0703b20c18e7ee64cb6422b"></a>BORDER_REFLECT_101&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a223710941333ffcbfd147e4f4c9a1485a3a32eebd60519ff9455caef22c5ec636"></a>BORDER_TRANSPARENT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a223710941333ffcbfd147e4f4c9a1485a6882b27e8124f30b8dda1eacb40049bf"></a>BORDER_DEFAULT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00255">255</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="a1abf3814082bdf420e4b982589a19132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abf3814082bdf420e4b982589a19132">&#9670;&nbsp;</a></span>MorphologicalOperators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepcl.html#a1abf3814082bdf420e4b982589a19132">pcl::MorphologicalOperators</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1abf3814082bdf420e4b982589a19132afa7ee0adaca2e021db766ea40d8cf2cd"></a>MORPH_OPEN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1abf3814082bdf420e4b982589a19132a4535f9a5ab1beb172e6b1e14af5cdf54"></a>MORPH_CLOSE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1abf3814082bdf420e4b982589a19132a43abb981b536d88ac5e404d7f34a49bf"></a>MORPH_DILATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1abf3814082bdf420e4b982589a19132ab60c42a20c8242ec0333b7415e2ad1d7"></a>MORPH_ERODE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="morphological__filter_8h_source.html#l00052">52</a> of file <a class="el" href="morphological__filter_8h_source.html">morphological_filter.h</a>.</p>

</div>
</div>
<a id="a801a3c83fe807097c9aded5534df1394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801a3c83fe807097c9aded5534df1394">&#9670;&nbsp;</a></span>SacModel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepcl.html#a801a3c83fe807097c9aded5534df1394">pcl::SacModel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a18287528357b660304c7898255b0f265"></a>SACMODEL_PLANE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394af97be98df30ad2277e89e4654f9fc00f"></a>SACMODEL_LINE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a8d442cc79de3f633de403d7e336d694f"></a>SACMODEL_CIRCLE2D&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a5168c77f12c90ddf4a4e69afc548bd2d"></a>SACMODEL_CIRCLE3D&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a1c3b2cdb06cb0408096fd8665ef6c2d9"></a>SACMODEL_SPHERE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a0443d444406073767838dcd2c82b167a"></a>SACMODEL_CYLINDER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394ab78d4832df346f641e0d36706e45f6d6"></a>SACMODEL_CONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394af02c2306587428bf9507c5ad2acf9f49"></a>SACMODEL_TORUS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a4a3c2702b22089e23b5e2c076d27117f"></a>SACMODEL_PARALLEL_LINE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a5770604131930b45726976c8cf5a69c6"></a>SACMODEL_PERPENDICULAR_PLANE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394ab396dcfd75bf7a67ac9ea1cadd707cd9"></a>SACMODEL_PARALLEL_LINES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a9b60ab55e63967c7178830079684126b"></a>SACMODEL_NORMAL_PLANE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a5b41f78278e0495a11023662955b122b"></a>SACMODEL_NORMAL_SPHERE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394ad649a6f9e77fe3258fbec7a256fe939c"></a>SACMODEL_REGISTRATION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a216dc9817b402ca947c9f4df601f3a43"></a>SACMODEL_REGISTRATION_2D&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a18d9ef635b85360c19f9c7ef22bff1fe"></a>SACMODEL_PARALLEL_PLANE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a543a8987f718193f0c55f09b93e811e2"></a>SACMODEL_NORMAL_PARALLEL_PLANE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a801a3c83fe807097c9aded5534df1394a5d348749f0ff932efd504ae3718b6fce"></a>SACMODEL_STICK&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="model__types_8h_source.html#l00045">45</a> of file <a class="el" href="model__types_8h_source.html">model_types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a838f3e1252e58be919249a1bddff97e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838f3e1252e58be919249a1bddff97e6">&#9670;&nbsp;</a></span>approximatePolygon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::approximatePolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_planar_polygon.html">PlanarPolygon</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_planar_polygon.html">PlanarPolygon</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>approx_polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refine</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see approximatePolygon2D </p>
<dl class="section author"><dt>Author</dt><dd>Suat Gedikli <a href="#" onclick="location.href='mai'+'lto:'+'ged'+'ik'+'li@'+'wi'+'llo'+'wg'+'ara'+'ge'+'.co'+'m'; return false;">gedik<span style="display: none;">.nosp@m.</span>li@w<span style="display: none;">.nosp@m.</span>illow<span style="display: none;">.nosp@m.</span>gara<span style="display: none;">.nosp@m.</span>ge.co<span style="display: none;">.nosp@m.</span>m</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="polygon__operations_8hpp_source.html#l00043">43</a> of file <a class="el" href="polygon__operations_8hpp_source.html">polygon_operations.hpp</a>.</p>

<p class="reference">References <a class="el" href="planar__polygon_8h_source.html#l00120">pcl::PlanarPolygon&lt; PointT &gt;::getCoefficients()</a>, <a class="el" href="planar__polygon_8h_source.html#l00087">pcl::PlanarPolygon&lt; PointT &gt;::getContour()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00466">pcl::PointCloud&lt; PointT &gt;::resize()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00459">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="a10c67ad60b6d7bec3243f3ab850ecb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c67ad60b6d7bec3243f3ab850ecb7d">&#9670;&nbsp;</a></span>approximatePolygon2D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::approximatePolygon2D </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::VectorType &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::VectorType &amp;&#160;</td>
          <td class="paramname"><em>approx_polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refine</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an approximate polygon to given 2D contour. </p>
<p>Uses just X and Y values. </p><dl class="section note"><dt>Note</dt><dd>if refinement is not turned on, the resulting polygon will contain points from the original contour with their original z values (if any) </dd>
<dd>
if refinement is turned on, the z values of the refined polygon are not valid and should be set to 0 if point contains z attribute. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon</td><td>input polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">approx_polygon</td><td>approximate polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>maximum allowed distance of an input vertex to an output edge </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">refine</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">closed</td><td>whether it is a closed polygon or a polyline </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Suat Gedikli <a href="#" onclick="location.href='mai'+'lto:'+'ged'+'ik'+'li@'+'wi'+'llo'+'wg'+'ara'+'ge'+'.co'+'m'; return false;">gedik<span style="display: none;">.nosp@m.</span>li@w<span style="display: none;">.nosp@m.</span>illow<span style="display: none;">.nosp@m.</span>gara<span style="display: none;">.nosp@m.</span>ge.co<span style="display: none;">.nosp@m.</span>m</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="polygon__operations_8hpp_source.html#l00071">71</a> of file <a class="el" href="polygon__operations_8hpp_source.html">polygon_operations.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00616">pcl::PointCloud&lt; PointT &gt;::clear()</a>, <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00133">eigen22()</a>, <a class="el" href="pcl__macros_8h_source.html#l00202">M_SQRT1_2</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00491">pcl::PointCloud&lt; PointT &gt;::push_back()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00460">pcl::PointCloud&lt; PointT &gt;::reserve()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00459">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="aa5d7af22d0df41b705c51af741aef133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d7af22d0df41b705c51af741aef133">&#9670;&nbsp;</a></span>checkCoordinateSystem() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::checkCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>norm_limit</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dot_limit</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00644">644</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a10f18110e59c57b715ed3d378d18f433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f18110e59c57b715ed3d378d18f433">&#9670;&nbsp;</a></span>checkCoordinateSystem() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::checkCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>norm_limit</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dot_limit</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00602">602</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a9e85af115a167f7fdf7feaeb86e759a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e85af115a167f7fdf7feaeb86e759a9">&#9670;&nbsp;</a></span>checkCoordinateSystem() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::checkCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; float, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; float, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; float, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>norm_limit</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>dot_limit</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00660">660</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a915f202bbd62dd1a8d828500e4bff778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915f202bbd62dd1a8d828500e4bff778">&#9670;&nbsp;</a></span>checkCoordinateSystem() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::checkCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>norm_limit</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>dot_limit</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00611">611</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a089e47fff14e983bc229b7e82f00f4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089e47fff14e983bc229b7e82f00f4ad">&#9670;&nbsp;</a></span>checkCoordinateSystem() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::checkCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>norm_limit</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>dot_limit</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check coordinate system integrity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>the origin of the coordinate system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_direction</td><td>the first axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_direction</td><td>the second axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm_limit</td><td>the limit to ignore norm rounding errors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dot_limit</td><td>the limit to ignore dot product rounding errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the coordinate system is consistent, false otherwise.</dd></dl>
<p>Read the other variant for more information </p>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00630">630</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a073da9b1c5ee4fd5ac15eccd804995f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073da9b1c5ee4fd5ac15eccd804995f7">&#9670;&nbsp;</a></span>checkCoordinateSystem() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::checkCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>norm_limit</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>dot_limit</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check coordinate system integrity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">line_x</td><td>the first axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_y</td><td>the second axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm_limit</td><td>the limit to ignore norm rounding errors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dot_limit</td><td>the limit to ignore dot product rounding errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the coordinate system is consistent, false otherwise.</dd></dl>
<p>Lines must be filled in this form:<br  />
line[0-2] = Origin coordinates of the vector<br  />
line[3-5] = Direction vector</p>
<p>Can be used like this :<br  />
line_x = X axis and line_y = Y axis<br  />
line_x = Z axis and line_y = X axis<br  />
line_x = Y axis and line_y = Z axis<br  />
Because X^Y = Z, Z^X = Y and Y^Z = X. Do NOT invert line order !</p>
<p>Determine whether a coordinate system is consistent or not by checking :<br  />
Line origins: They must be the same for the 2 lines<br  />
Norm: The 2 lines must be normalized<br  />
Dot products: Must be 0 or perpendicular vectors </p>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00788">788</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00854">transformBetween2CoordinateSystems()</a>.</p>

</div>
</div>
<a id="a22143206fbf09462bb365a5df39e6452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22143206fbf09462bb365a5df39e6452">&#9670;&nbsp;</a></span>comparePair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::comparePair </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; float, int &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; float, int &gt;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is used as a comparator for sorting. </p>

<p class="definition">Definition at line <a class="el" href="region__growing_8h_source.html#l00342">342</a> of file <a class="el" href="region__growing_8h_source.html">region_growing.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="region__growing__rgb_8hpp_source.html#l00368">pcl::RegionGrowingRGB&lt; PointT, NormalT &gt;::applyRegionMergingAlgorithm()</a>, <a class="el" href="region__growing_8hpp_source.html#l00376">pcl::RegionGrowing&lt; PointT, pcl::Normal &gt;::applySmoothRegionGrowingAlgorithm()</a>, and <a class="el" href="region__growing__rgb_8hpp_source.html#l00530">pcl::RegionGrowingRGB&lt; PointT, NormalT &gt;::findRegionNeighbours()</a>.</p>

</div>
</div>
<a id="aa83cfc8af6f93b041f24fe2f4c6fa19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83cfc8af6f93b041f24fe2f4c6fa19c">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00133">133</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a7910e9ffc3a073679a0b87e73223d493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7910e9ffc3a073679a0b87e73223d493">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00125">125</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a202572bfcc54d5262fb2ab3a695d7682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202572bfcc54d5262fb2ab3a695d7682">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00164">164</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="af4605825a1d7113456c905716c518e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4605825a1d7113456c905716c518e73">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00156">156</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a81f00705f1116eb69a984286e1e1d2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f00705f1116eb69a984286e1e1d2b9">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00103">103</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a23daec3829d2d4100a2f185372b3753a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23daec3829d2d4100a2f185372b3753a">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00096">96</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="afda9ffdc3a6bb85098aa16e61d668682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda9ffdc3a6bb85098aa16e61d668682">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00077">77</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ac050f06179c72e8bc2665faf7f42a0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac050f06179c72e8bc2665faf7f42a0aa">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00070">70</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a8b4e482f26037bee30f64693f33fa98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4e482f26037bee30f64693f33fa98e">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00198">198</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a9a519f0128baede6be874e0947ad8147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a519f0128baede6be874e0947ad8147">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00190">190</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ae0cbcfc83901cd5e6508a3e57323ee44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cbcfc83901cd5e6508a3e57323ee44">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00268">268</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a4c1e69343ca8a48a910292d60a5a98ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1e69343ca8a48a910292d60a5a98ca">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00259">259</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="af2c48ee806ee373875f1cdd8b9091236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c48ee806ee373875f1cdd8b9091236">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00552">552</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a2804d83d939167e5dfce426d4039ab3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2804d83d939167e5dfce426d4039ab3f">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00544">544</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a74070eb55600644b3f8de2d4d8d08bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74070eb55600644b3f8de2d4d8d08bd2">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00305">305</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a327ececf41f1808237b5d7ef6f96494e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327ececf41f1808237b5d7ef6f96494e">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00296">296</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ad570c977482c84dc1fd2ec82ff664bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad570c977482c84dc1fd2ec82ff664bc5">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00585">585</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a63b7fbcd5a7bf264c08d5b7b534d34fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b7fbcd5a7bf264c08d5b7b534d34fe">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00577">577</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a8cc2952e9da0204aed64bb967886240c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc2952e9da0204aed64bb967886240c">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00520">520</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a1792af32d68f02d0ae84aea7c25cf6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1792af32d68f02d0ae84aea7c25cf6d3">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00513">513</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a5cf7877e22ed85622d8eea00880f7d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf7877e22ed85622d8eea00880f7d35">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00232">232</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a7c34bc132bc8d638839f1ca4e8ddea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c34bc132bc8d638839f1ca4e8ddea0f">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00224">224</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ada0bf09f6b75ddb89ee99272606fa8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0bf09f6b75ddb89ee99272606fa8bc">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00344">344</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ae7afbcb20c186f0d3ee47b0f387ca54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7afbcb20c186f0d3ee47b0f387ca54f">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00335">335</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a5fe0230defb5a7854e0234234c21506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe0230defb5a7854e0234234c21506b">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00382">382</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a8883fe1fb7c5c9de850f6520b68509f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8883fe1fb7c5c9de850f6520b68509f8">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00373">373</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a958402ff7ac412afde20b65945a0f197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958402ff7ac412afde20b65945a0f197">&#9670;&nbsp;</a></span>computeCPPFPairFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::computeCPPFPairFeature </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4i &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4i &amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f10</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n1</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n2</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c1</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c2</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f1</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f2</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f3</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f4</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f5</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f6</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f7</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f8</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f9</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f10</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ba133631e4a1c60f26412cd917d25a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba133631e4a1c60f26412cd917d25a2">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00452">452</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a764daf3dce844d19e671d65954b626bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764daf3dce844d19e671d65954b626bd">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00443">443</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="aeff94982be65cb242843ce845a9fa1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff94982be65cb242843ce845a9fa1be">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00489">489</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ac84951a6b448e68f38b93db5d657c833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84951a6b448e68f38b93db5d657c833">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00480">480</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a21277bc4c42f68a98091745b9fd8232f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21277bc4c42f68a98091745b9fd8232f">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00416">416</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a8cc2ea3fcf34548958ee0d7e691fd150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc2ea3fcf34548958ee0d7e691fd150">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00408">408</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a409ee00ada6c43ab1efaa61a43c0c930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409ee00ada6c43ab1efaa61a43c0c930">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00918">918</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a43810ff669042a89dde7e36ac7ddad2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43810ff669042a89dde7e36ac7ddad2c">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00910">910</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ad5cd43a281c8a8e8a21ce454604bb13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cd43a281c8a8e8a21ce454604bb13a">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00946">946</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a7fdac43d0a93611d8e8a6759942d31c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdac43d0a93611d8e8a6759942d31c1">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00938">938</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a49b8336923506cbc45f1b848abfffce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b8336923506cbc45f1b848abfffce8">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00891">891</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ab12a9c691a9dad8617f06110dcdf337c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12a9c691a9dad8617f06110dcdf337c">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00884">884</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a135ba5cb8070fc19db8939ca20c9131c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135ba5cb8070fc19db8939ca20c9131c">&#9670;&nbsp;</a></span>computePPFPairFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::computePPFPairFeature </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n1</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n2</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f1</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f2</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f3</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f4</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d38530c7cb65fcb872a72f9cba9224a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d38530c7cb65fcb872a72f9cba9224a">&#9670;&nbsp;</a></span>computeRGBPairFeatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::computeRGBPairFeatures </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4i &amp;&#160;</td>
          <td class="paramname"><em>colors1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4i &amp;&#160;</td>
          <td class="paramname"><em>colors2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="pfhrgb_8hpp_source.html#l00064">pcl::PFHRGBEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePointPFHRGBSignature()</a>, and <a class="el" href="pfhrgb_8hpp_source.html#l00047">pcl::PFHRGBEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeRGBPairFeatures()</a>.</p>

</div>
</div>
<a id="aefa08a43e19cb9280ac6e205ab53b651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa08a43e19cb9280ac6e205ab53b651">&#9670;&nbsp;</a></span>computeRoots()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Roots &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeRoots </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Roots &amp;&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the roots of the characteristic polynomial of the input matrix m, which are the eigenvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">roots</td><td>roots of the characteristic polynomial of the input matrix m, which are the eigenvalues </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00068">68</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00053">computeRoots2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="vector__average_8hpp_source.html#l00156">pcl::VectorAverage&lt; real, dimension &gt;::doPCA()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00296">eigen33()</a>.</p>

</div>
</div>
<a id="ae4d949061a580b72ae999742cc0690a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d949061a580b72ae999742cc0690a1">&#9670;&nbsp;</a></span>computeRoots2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Roots &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeRoots2 </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Roots &amp;&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the roots of a quadratic polynom x^2 + b*x + c = 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>linear parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>constant parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">roots</td><td>solutions of x^2 + b*x + c = 0 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00053">53</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00068">computeRoots()</a>.</p>

</div>
</div>
<a id="ab613e1f38731c3438c9b668876ce7d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab613e1f38731c3438c9b668876ce7d73">&#9670;&nbsp;</a></span>computeRSD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointNT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXf pcl::computeRSD </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_subdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>plane_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOutT &amp;&#160;</td>
          <td class="paramname"><em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_histogram</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Scheduled for removal in version 1 . 12 : "use computeRSD() overload that takes input point clouds by const reference" <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="rsd_8h_source.html#l00095">95</a> of file <a class="el" href="rsd_8h_source.html">rsd.h</a>.</p>

<p class="reference">References <a class="el" href="rsd_8hpp_source.html#l00049">computeRSD()</a>.</p>

</div>
</div>
<a id="ae41b743bb42924485015453de79a8d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41b743bb42924485015453de79a8d5b">&#9670;&nbsp;</a></span>computeRSD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXf pcl::computeRSD </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqr_dists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_subdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>plane_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOutT &amp;&#160;</td>
          <td class="paramname"><em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_histogram</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Scheduled for removal in version 1 . 12 : "use computeRSD() overload that takes input point cloud by const reference" <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="rsd_8h_source.html#l00121">121</a> of file <a class="el" href="rsd_8h_source.html">rsd.h</a>.</p>

<p class="reference">References <a class="el" href="rsd_8hpp_source.html#l00049">computeRSD()</a>.</p>

</div>
</div>
<a id="aae70f37202b99e3b5141bec4eed26b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae70f37202b99e3b5141bec4eed26b7e">&#9670;&nbsp;</a></span>copyStringValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyStringValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy one single value of type T (uchar, char, uint, int, float, double, ...) from a string. </p>
<p>Uses aoti/atof to do the conversion. Checks if the st is "nan" and converts it accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td>the string containing the value to convert and copy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud</td><td>the cloud to copy it to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_index</td><td>the index of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_idx</td><td>the index of the dimension/field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields_count</td><td>the current fields count </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00339">339</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00031">pcl::PCLPointCloud2::is_dense</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00026">pcl::PCLPointCloud2::point_step</a>.</p>

</div>
</div>
<a id="a3f236818f0518be865257e4cccfb6574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f236818f0518be865257e4cccfb6574">&#9670;&nbsp;</a></span>copyStringValue&lt; std::int8_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepcl.html#aae70f37202b99e3b5141bec4eed26b7e">pcl::copyStringValue</a>&lt; std::int8_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00362">362</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00031">pcl::PCLPointCloud2::is_dense</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00026">pcl::PCLPointCloud2::point_step</a>.</p>

</div>
</div>
<a id="a6935fca775b09562df04e9639e777276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6935fca775b09562df04e9639e777276">&#9670;&nbsp;</a></span>copyStringValue&lt; std::uint8_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepcl.html#aae70f37202b99e3b5141bec4eed26b7e">pcl::copyStringValue</a>&lt; std::uint8_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00388">388</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00031">pcl::PCLPointCloud2::is_dense</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00026">pcl::PCLPointCloud2::point_step</a>.</p>

</div>
</div>
<a id="a9287d2c4eee3af2533e5b3dd3e61ac69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9287d2c4eee3af2533e5b3dd3e61ac69">&#9670;&nbsp;</a></span>copyValueString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point&lt;Type&gt;::value&gt; pcl::copyValueString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>point_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts a value of type Type (uchar, char, uint, int, float, double, ...) into a stringstream. </p>
<p>If the value is NaN, it inserts "nan".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the cloud to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_index</td><td>the index of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_size</td><td>the size of the point in the cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_idx</td><td>the index of the dimension/field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields_count</td><td>the current fields count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>the ostringstream to copy into </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00236">236</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>.</p>

</div>
</div>
<a id="a88882b0bf00c4f33c3a8c593dd9ad1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88882b0bf00c4f33c3a8c593dd9ad1f1">&#9670;&nbsp;</a></span>copyValueString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral&lt;Type&gt;::value&gt; pcl::copyValueString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>point_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00253">253</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>.</p>

</div>
</div>
<a id="a5f18c6e45e183d003b410bcc6212cf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f18c6e45e183d003b410bcc6212cf52">&#9670;&nbsp;</a></span>copyValueString&lt; std::int8_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepcl.html#a9287d2c4eee3af2533e5b3dd3e61ac69">pcl::copyValueString</a>&lt; std::int8_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>point_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00266">266</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>.</p>

</div>
</div>
<a id="ae29ba375961de1791a710ebdc08be151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29ba375961de1791a710ebdc08be151">&#9670;&nbsp;</a></span>copyValueString&lt; std::uint8_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepcl.html#a9287d2c4eee3af2533e5b3dd3e61ac69">pcl::copyValueString</a>&lt; std::uint8_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>point_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00280">280</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>.</p>

</div>
</div>
<a id="a8b1e6bf082a51cc2d633495a03a18a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1e6bf082a51cc2d633495a03a18a6a">&#9670;&nbsp;</a></span>createMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::createMapping </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#ae716f0bdfbc7ae033006733a42fb6b63">MsgFieldMap</a> &amp;&#160;</td>
          <td class="paramname"><em>field_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>One could construct a pathological case where the struct has a field where the serialized data has padding </dd></dl>

<p class="definition">Definition at line <a class="el" href="conversions_8h_source.html#l00124">124</a> of file <a class="el" href="conversions_8h_source.html">conversions.h</a>.</p>

<p class="reference">References <a class="el" href="conversions_8h_source.html#l00116">pcl::detail::fieldOrdering()</a>.</p>

</div>
</div>
<a id="a9820d1ad515c00d37ef4c7594b27d1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9820d1ad515c00d37ef4c7594b27d1ab">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00767">767</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a8dfb2a1c7a8437bac36540227bc55888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfb2a1c7a8437bac36540227bc55888">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00759">759</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ae10afd64292643e9d04ffcf12b876069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10afd64292643e9d04ffcf12b876069">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00799">799</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ade3c09b0bae4898312b3f1720cf35d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3c09b0bae4898312b3f1720cf35d77">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00673">673</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ad4cff987767d4fb99e5ddb8fbe6c72e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cff987767d4fb99e5ddb8fbe6c72e4">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00790">790</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a47aca32be73611921c4a0ece73818465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47aca32be73611921c4a0ece73818465">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00664">664</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a593f079cc31336760d9e5b8a9b3ec5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593f079cc31336760d9e5b8a9b3ec5e4">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00832">832</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a989ce2a2f9a6f14cbfefee1a3eaa40e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989ce2a2f9a6f14cbfefee1a3eaa40e6">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00704">704</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a9f7d5505eb5192ddae706e461dc91c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7d5505eb5192ddae706e461dc91c8b">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00823">823</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a1b9d4b8b8ac294c8273318b7af44b477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9d4b8b8ac294c8273318b7af44b477">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00695">695</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a3a54767789c47edda970ae0cc04aee33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a54767789c47edda970ae0cc04aee33">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00737">737</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a6afc80fd70f4436ccce44de9241a1ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afc80fd70f4436ccce44de9241a1ba3">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00643">643</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a71766012ea8618588baa1dc073dac1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71766012ea8618588baa1dc073dac1b4">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00615">615</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ae5a74008d2df6abde28a843a243ef011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a74008d2df6abde28a843a243ef011">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00728">728</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="ae1ca17f3decd37c512d958afa4d88ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ca17f3decd37c512d958afa4d88ce0">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00635">635</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a0212a746948007708bcfaa4117ea7461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0212a746948007708bcfaa4117ea7461">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="centroid_8h_source.html#l00606">606</a> of file <a class="el" href="centroid_8h_source.html">centroid.h</a>.</p>

</div>
</div>
<a id="a650c751be24e00fa2992c4935300a892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650c751be24e00fa2992c4935300a892">&#9670;&nbsp;</a></span>doStereoPeakFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short int pcl::doStereoPeakFilter </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>dbest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>peak_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxdisp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stereo__matching_8h_source.html#l00068">68</a> of file <a class="el" href="stereo__matching_8h_source.html">stereo_matching.h</a>.</p>

</div>
</div>
<a id="a3d2c84a845c4ff4a41d6bc425ebde3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2c84a845c4ff4a41d6bc425ebde3f5">&#9670;&nbsp;</a></span>doStereoRatioFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short int pcl::doStereoRatioFilter </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>dbest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>sad_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ratio_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxdisp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stereo__matching_8h_source.html#l00048">48</a> of file <a class="el" href="stereo__matching_8h_source.html">stereo_matching.h</a>.</p>

</div>
</div>
<a id="a660ae8fd684c5ea2223b5b81fc46c2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660ae8fd684c5ea2223b5b81fc46c2c1">&#9670;&nbsp;</a></span>estimateProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double pcl::estimateProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the projection matrix P = K * (R|-R*t) from organized point clouds, with K = [[fx, s, cx], [0, fy, cy], [0, 0, 1]] R = rotation matrix and t = translation vector <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>input cloud. Must be organized and from a projective device. e.g. stereo or kinect, ... </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projection_matrix</td><td>output projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>The indices to be used to determine the projection matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resudial error. A high residual indicates, that the point cloud was not from a projective device. </dd></dl>

<p class="definition">Definition at line <a class="el" href="projection__matrix_8hpp_source.html#l00081">81</a> of file <a class="el" href="projection__matrix_8hpp_source.html">projection_matrix.hpp</a>.</p>

<p class="reference">References <a class="el" href="norms_8h_source.html#l00054">B</a>, <a class="el" href="cloud__iterator_8hpp_source.html#l00523">pcl::ConstCloudIterator&lt; PointT &gt;::getCurrentPointIndex()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="projection__matrix_8hpp_source.html#l00054">pcl::common::internal::makeSymmetric()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="a73e1d23717813eb053a0eb51411a4a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e1d23717813eb053a0eb51411a4a23">&#9670;&nbsp;</a></span>euclideanDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType1 , typename PointType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::euclideanDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType1 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType2 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the euclidean distance between the two given points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>the second point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00201">201</a> of file <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html">distances.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00179">squaredEuclideanDistance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ia__fpcs_8hpp_source.html#l00580">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, pcl::Normal, float &gt;::bruteForceCorrespondences()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00714">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, pcl::Normal, float &gt;::checkBaseMatch()</a>, <a class="el" href="esf_8hpp_source.html#l00052">pcl::ESFEstimation&lt; PointInT, PointOutT &gt;::computeESF()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00634">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, pcl::Normal, float &gt;::determineBaseMatches()</a>, <a class="el" href="esf_8hpp_source.html#l00481">pcl::ESFEstimation&lt; PointInT, PointOutT &gt;::scale_points_unit_sphere()</a>, <a class="el" href="ia__ransac_8hpp_source.html#l00076">pcl::SampleConsensusInitialAlignment&lt; PointSource, PointTarget, FeatureT &gt;::selectSamples()</a>, and <a class="el" href="texture__mapping_8hpp_source.html#l00627">pcl::TextureMapping&lt; PointInT &gt;::showOcclusions()</a>.</p>

</div>
</div>
<a id="a5bacf4c58070af4db6464e7c6a0bac26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bacf4c58070af4db6464e7c6a0bac26">&#9670;&nbsp;</a></span>for_each_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sequence , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::for_each_type </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="for__each__type_8h_source.html#l00093">93</a> of file <a class="el" href="for__each__type_8h_source.html">for_each_type.h</a>.</p>

</div>
</div>
<a id="a89aca82e188e18a7c9a71324e9610ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89aca82e188e18a7c9a71324e9610ec9">&#9670;&nbsp;</a></span>fromPCLPointCloud2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::fromPCLPointCloud2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary data blob into a pcl::PointCloud&lt;T&gt; object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>the <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary blob </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud</td><td>the resultant pcl::PointCloud&lt;T&gt; </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_8h_source.html#l00229">229</a> of file <a class="el" href="conversions_8h_source.html">conversions.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>, and <a class="el" href="conversions_8h_source.html#l00168">fromPCLPointCloud2()</a>.</p>

</div>
</div>
<a id="ad435776e0d3cc620a42468c85ad060b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad435776e0d3cc620a42468c85ad060b6">&#9670;&nbsp;</a></span>fromPCLPointCloud2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::fromPCLPointCloud2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#ae716f0bdfbc7ae033006733a42fb6b63">MsgFieldMap</a> &amp;&#160;</td>
          <td class="paramname"><em>field_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary data blob into a pcl::PointCloud&lt;T&gt; object using a field_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>the <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary blob </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud</td><td>the resultant pcl::PointCloud&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_map</td><td>a MsgFieldMap object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use fromPCLPointCloud2 (<a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a>, PointCloud&lt;T&gt;) directly or create you own MsgFieldMap using:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="namespacepcl.html#ae716f0bdfbc7ae033006733a42fb6b63">MsgFieldMap</a> field_map;</div>
<div class="line">createMapping&lt;PointT&gt; (msg.fields, field_map);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="conversions_8h_source.html#l00168">168</a> of file <a class="el" href="conversions_8h_source.html">conversions.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00017">pcl::PCLPointCloud2::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00019">pcl::PCLPointCloud2::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00031">pcl::PCLPointCloud2::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00026">pcl::PCLPointCloud2::point_step</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00027">pcl::PCLPointCloud2::row_step</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00020">pcl::PCLPointCloud2::width</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="conversions_8h_source.html#l00229">fromPCLPointCloud2()</a>, <a class="el" href="standalone__marching__cubes_8hpp_source.html#l00094">pcl::gpu::kinfuLS::StandaloneMarchingCubes&lt; PointT &gt;::getMeshesFromTSDFVector()</a>, <a class="el" href="texture__mapping_8hpp_source.html#l00287">pcl::TextureMapping&lt; PointInT &gt;::mapMultipleTexturesToMeshUV()</a>, <a class="el" href="pcd__grabber_8h_source.html#l00206">pcl::PCDGrabber&lt; PointT &gt;::operator[]()</a>, <a class="el" href="image__grabber_8h_source.html#l00272">pcl::ImageGrabber&lt; PointT &gt;::operator[]()</a>, <a class="el" href="stereo__grabber_8h_source.html#l00171">pcl::StereoGrabber&lt; PointT &gt;::publish()</a>, <a class="el" href="pcd__grabber_8h_source.html#l00228">pcl::PCDGrabber&lt; PointT &gt;::publish()</a>, <a class="el" href="image__grabber_8h_source.html#l00294">pcl::ImageGrabber&lt; PointT &gt;::publish()</a>, <a class="el" href="octree__base__node_8hpp_source.html#l01375">pcl::outofcore::OutofcoreOctreeBaseNode::queryBBIncludes()</a>, <a class="el" href="ifs__io_8h_source.html#l00124">pcl::IFSReader::read()</a>, <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00141">pcl::FileReader::read()</a>, <a class="el" href="ply__io_8h_source.html#l00202">pcl::PLYReader::read()</a>, <a class="el" href="obj__io_8h_source.html#l00232">pcl::OBJReader::read()</a>, <a class="el" href="pcd__io_8h_source.html#l00276">pcl::PCDReader::read()</a>, <a class="el" href="texture__mapping_8hpp_source.html#l00470">pcl::TextureMapping&lt; PointInT &gt;::removeOccludedPoints()</a>, <a class="el" href="standalone__marching__cubes_8hpp_source.html#l00249">pcl::gpu::kinfuLS::StandaloneMarchingCubes&lt; PointT &gt;::runMarchingCubes()</a>, <a class="el" href="correspondence__estimation__backprojection_8h_source.html#l00133">pcl::registration::CorrespondenceEstimationBackProjection&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setSourceNormals()</a>, <a class="el" href="correspondence__estimation__normal__shooting_8h_source.html#l00143">pcl::registration::CorrespondenceEstimationNormalShooting&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setSourceNormals()</a>, <a class="el" href="correspondence__rejection__surface__normal_8h_source.html#l00279">pcl::registration::CorrespondenceRejectorSurfaceNormal::setSourceNormals()</a>, <a class="el" href="correspondence__rejection__organized__boundary_8h_source.html#l00100">pcl::registration::CorrespondenceRejectionOrganizedBoundary::setSourcePoints()</a>, <a class="el" href="correspondence__rejection__sample__consensus_8h_source.html#l00133">pcl::registration::CorrespondenceRejectorSampleConsensus&lt; PointT &gt;::setSourcePoints()</a>, <a class="el" href="correspondence__rejection__poly_8h_source.html#l00135">pcl::registration::CorrespondenceRejectorPoly&lt; SourceT, TargetT &gt;::setSourcePoints()</a>, <a class="el" href="correspondence__rejection__median__distance_8h_source.html#l00138">pcl::registration::CorrespondenceRejectorMedianDistance::setSourcePoints()</a>, <a class="el" href="correspondence__rejection__var__trimmed_8h_source.html#l00145">pcl::registration::CorrespondenceRejectorVarTrimmed::setSourcePoints()</a>, <a class="el" href="correspondence__rejection__distance_8h_source.html#l00148">pcl::registration::CorrespondenceRejectorDistance::setSourcePoints()</a>, <a class="el" href="correspondence__rejection__surface__normal_8h_source.html#l00247">pcl::registration::CorrespondenceRejectorSurfaceNormal::setSourcePoints()</a>, <a class="el" href="correspondence__estimation__backprojection_8h_source.html#l00147">pcl::registration::CorrespondenceEstimationBackProjection&lt; PointSource, PointTarget, NormalT, Scalar &gt;::setTargetNormals()</a>, <a class="el" href="correspondence__rejection__surface__normal_8h_source.html#l00295">pcl::registration::CorrespondenceRejectorSurfaceNormal::setTargetNormals()</a>, <a class="el" href="correspondence__rejection__organized__boundary_8h_source.html#l00114">pcl::registration::CorrespondenceRejectionOrganizedBoundary::setTargetPoints()</a>, <a class="el" href="correspondence__rejection__sample__consensus_8h_source.html#l00147">pcl::registration::CorrespondenceRejectorSampleConsensus&lt; PointT &gt;::setTargetPoints()</a>, <a class="el" href="correspondence__rejection__poly_8h_source.html#l00149">pcl::registration::CorrespondenceRejectorPoly&lt; SourceT, TargetT &gt;::setTargetPoints()</a>, <a class="el" href="correspondence__rejection__median__distance_8h_source.html#l00152">pcl::registration::CorrespondenceRejectorMedianDistance::setTargetPoints()</a>, <a class="el" href="correspondence__rejection__var__trimmed_8h_source.html#l00159">pcl::registration::CorrespondenceRejectorVarTrimmed::setTargetPoints()</a>, <a class="el" href="correspondence__rejection__distance_8h_source.html#l00162">pcl::registration::CorrespondenceRejectorDistance::setTargetPoints()</a>, <a class="el" href="correspondence__rejection__surface__normal_8h_source.html#l00263">pcl::registration::CorrespondenceRejectorSurfaceNormal::setTargetPoints()</a>, <a class="el" href="texture__mapping_8hpp_source.html#l00706">pcl::TextureMapping&lt; PointInT &gt;::showOcclusions()</a>, <a class="el" href="texture__mapping_8hpp_source.html#l00541">pcl::TextureMapping&lt; PointInT &gt;::sortFacesByCamera()</a>, <a class="el" href="texture__mapping_8hpp_source.html#l00718">pcl::TextureMapping&lt; PointInT &gt;::textureMeshwithMultipleCameras()</a>, and <a class="el" href="mesh__conversion_8h_source.html#l00088">pcl::geometry::toHalfEdgeMesh()</a>.</p>

</div>
</div>
<a id="a65492f5cdc563cd60c2267366788d077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65492f5cdc563cd60c2267366788d077">&#9670;&nbsp;</a></span>getAllPcdFilesInDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getAllPcdFilesInDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>file_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all *.pcd files in the directory and return them sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>the directory to be searched </td></tr>
    <tr><td class="paramname">file_names</td><td>the resulting (sorted) list of .pcd files </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="file__io_8hpp_source.html#l00054">54</a> of file <a class="el" href="file__io_8hpp_source.html">file_io.hpp</a>.</p>

</div>
</div>
<a id="ad020aa327df4698f74845eab051fee9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad020aa327df4698f74845eab051fee9c">&#9670;&nbsp;</a></span>getCameraMatrixFromProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::getCameraMatrixFromProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; float, 3, 4, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3f &amp;&#160;</td>
          <td class="paramname"><em>camera_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the camera matrix from the given projection matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This method does NOT use a RQ decomposition, but uses the fact that the left 3x3 matrix P' of P squared eliminates the rotational part. P' = K * R -&gt; P' * P'^T = K * R * R^T * K = K * K^T </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">projection_matrix</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">camera_matrix</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="organized_8hpp_source.html#l00330">pcl::search::OrganizedNeighbor&lt; PointT &gt;::computeCameraMatrix()</a>.</p>

</div>
</div>
<a id="a8fcee7a7a354c7b761b46999ea946a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcee7a7a354c7b761b46999ea946a2b">&#9670;&nbsp;</a></span>getEulerAngles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getEulerAngles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3d &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00275">275</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a1dd94c8354eb65dffae3769da8fcc06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd94c8354eb65dffae3769da8fcc06a">&#9670;&nbsp;</a></span>getEulerAngles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getEulerAngles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00269">269</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ac8ba6d86b4a32723833f26ca2a8dc70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ba6d86b4a32723833f26ca2a8dc70d">&#9670;&nbsp;</a></span>getFieldsSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::getFieldsSizes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a vector with the sizes of all valid fields (e.g., not "_") </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td>the input vector containing the fields </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field_sizes</td><td>the resultant field sizes in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40c52389c21abb3bf0c01b1bcefa414b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c52389c21abb3bf0c01b1bcefa414b">&#9670;&nbsp;</a></span>getFieldValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename ValT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getFieldValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>field_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValT &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value at a specified field in a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>the point to get the value from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_offset</td><td>the offset of the field </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>the value to retrieve </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00239">239</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ae40c9e0ff704ed675e3300ed02451796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40c9e0ff704ed675e3300ed02451796">&#9670;&nbsp;</a></span>getFileExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcl::getFileExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the file extension from the given string (the remaining string after the last '. </p>
<p>') </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>input</em> 's file extension </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__io_8hpp_source.html#l00088">88</a> of file <a class="el" href="file__io_8hpp_source.html">file_io.hpp</a>.</p>

</div>
</div>
<a id="af45ced9a4448cf680b2e5da96f4e9aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45ced9a4448cf680b2e5da96f4e9aea">&#9670;&nbsp;</a></span>getFilenameWithoutExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcl::getFilenameWithoutExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the extension from the given string and return only the filename (everything before the last '. </p>
<p>') </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input filename (with the file extension) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting filename, stripped of its extension </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__io_8hpp_source.html#l00082">82</a> of file <a class="el" href="file__io_8hpp_source.html">file_io.hpp</a>.</p>

</div>
</div>
<a id="a77fba9b71d0b5ddc824cc3555c258513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fba9b71d0b5ddc824cc3555c258513">&#9670;&nbsp;</a></span>getFilenameWithoutPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcl::getFilenameWithoutPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the path from the given string and return only the filename (the remaining string after the last '/') </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input filename (with full path) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting filename, stripped of the path </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__io_8hpp_source.html#l00076">76</a> of file <a class="el" href="file__io_8hpp_source.html">file_io.hpp</a>.</p>

</div>
</div>
<a id="aeb16be13e9916aeae094e1d151ba17f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb16be13e9916aeae094e1d151ba17f8">&#9670;&nbsp;</a></span>getMeanPointDensity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::getMeanPointDensity </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the mean point density of a given point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>pointer to the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of point indices to use from <em>cloud</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_dist</td><td>maximum distance of a point to be considered as a neighbor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nr_threads</td><td>number of threads to use (default = 1, only used if OpenMP flag is set) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mean point density of a given point cloud </dd></dl>

<p class="definition">Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00087">87</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p class="reference">References <a class="el" href="utils_8h_source.html#l00062">pcl::utils::ignore()</a>, <a class="el" href="kdtree_8hpp_source.html#l00088">pcl::search::KdTree&lt; PointT, Tree &gt;::nearestKSearch()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, and <a class="el" href="kdtree_8hpp_source.html#l00077">pcl::search::KdTree&lt; PointT, Tree &gt;::setInputCloud()</a>.</p>

</div>
</div>
<a id="a533cac294e33dd8ea02b8bcecb1155e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533cac294e33dd8ea02b8bcecb1155e8">&#9670;&nbsp;</a></span>getMeanPointDensity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::getMeanPointDensity </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the mean point density of a given point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>pointer to the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_dist</td><td>maximum distance of a point to be considered as a neighbor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nr_threads</td><td>number of threads to use (default = 1, only used if OpenMP flag is set) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mean point density of a given point cloud </dd></dl>

<p class="definition">Definition at line <a class="el" href="ia__fpcs_8hpp_source.html#l00050">50</a> of file <a class="el" href="ia__fpcs_8hpp_source.html">ia_fpcs.hpp</a>.</p>

<p class="reference">References <a class="el" href="utils_8h_source.html#l00062">pcl::utils::ignore()</a>, <a class="el" href="kdtree_8hpp_source.html#l00088">pcl::search::KdTree&lt; PointT, Tree &gt;::nearestKSearch()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="kdtree_8hpp_source.html#l00077">pcl::search::KdTree&lt; PointT, Tree &gt;::setInputCloud()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00459">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="a428a43d62bc58194cfb861a1cc707263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428a43d62bc58194cfb861a1cc707263">&#9670;&nbsp;</a></span>getMinMax3D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::getMinMax3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#ad64de997fa516c97e85cf8dc9d72146d">pcl::PCLPointCloud2ConstPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>distance_field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limit_negative</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the maximum and minimum points in 3D from a given point cloud. </p>
<dl class="section note"><dt>Note</dt><dd>Performs internal data filtering as well. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the pointer to a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_idx</td><td>the index of the X channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_idx</td><td>the index of the Y channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_idx</td><td>the index of the Z channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance_field_name</td><td>the name of the dimension to filter data along to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_distance</td><td>the minimum acceptable value in <em>distance_field_name</em> data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_distance</td><td>the maximum acceptable value in <em>distance_field_name</em> data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_pt</td><td>the minimum data point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_pt</td><td>the maximum data point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit_negative</td><td><b>false</b> if data <b>inside</b> of the [min_distance; max_distance] interval should be considered, <b>true</b> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a441489f0bebaf4e8a9b8be46bbff67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a441489f0bebaf4e8a9b8be46bbff67">&#9670;&nbsp;</a></span>getMinMax3D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::getMinMax3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#ad64de997fa516c97e85cf8dc9d72146d">pcl::PCLPointCloud2ConstPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the maximum and minimum points in 3D from a given point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the pointer to a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_idx</td><td>the index of the X channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_idx</td><td>the index of the Y channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_idx</td><td>the index of the Z channel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_pt</td><td>the minimum data point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_pt</td><td>the maximum data point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdd2c4f8400b2f4f32e850c73000eb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd2c4f8400b2f4f32e850c73000eb09">&#9670;&nbsp;</a></span>getPointCloudDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getPointCloudDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Scheduled for removal in version 1 . 12 : "tgt parameter is not used; it is deprecated and will be removed in future releases" <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="segment__differences_8h_source.html#l00064">64</a> of file <a class="el" href="segment__differences_8h_source.html">segment_differences.h</a>.</p>

</div>
</div>
<a id="a9e76309712edfe31e5da22b6f4307a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e76309712edfe31e5da22b6f4307a87">&#9670;&nbsp;</a></span>getPrincipalTransformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::getPrincipalTransformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00491">491</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a7ed11aa1fcb5be47d1217ea9aff75df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed11aa1fcb5be47d1217ea9aff75df6">&#9670;&nbsp;</a></span>getPrincipalTransformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::getPrincipalTransformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the principal (PCA-based) alignment of the point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transform</td><td>the resultant transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ratio lambda1/lambda2 or lambda2/lambda3, whatever is closer to 1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the return value is close to one then the transformation might be not unique -&gt; two principal directions have almost same variance (extend) </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00460">460</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00485">computeMeanAndCovarianceMatrix()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00296">eigen33()</a>.</p>

</div>
</div>
<a id="a52af9f3d2f13a7753dd7189878b97391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52af9f3d2f13a7753dd7189878b97391">&#9670;&nbsp;</a></span>getRandomColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> pcl::getRandomColor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em> = <code>0.2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em> = <code>2.8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcb3b1113c4cbc0af51c6542b2eb9101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb3b1113c4cbc0af51c6542b2eb9101">&#9670;&nbsp;</a></span>getRejectedQueryIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getRejectedQueryIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">pcl::Correspondences</a> &amp;&#160;</td>
          <td class="paramname"><em>correspondences_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a5f8e904e5c6f763188a410832f96ac00">pcl::Correspondences</a> &amp;&#160;</td>
          <td class="paramname"><em>correspondences_after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>presorting_required</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the query points of correspondences that are present in one correspondence vector but not in the other, e.g., to compare correspondences before and after rejection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">correspondences_before</td><td>Vector of correspondences before rejection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">correspondences_after</td><td>Vector of correspondences after rejection </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Query point indices of correspondences that have been rejected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">presorting_required</td><td>Enable/disable internal sorting of vectors. By default (true), vectors are internally sorted before determining their difference. If the order of correspondences in <em>correspondences_after</em> is not different (has not been changed) from the order in <b>correspondences_before</b> this pre-processing step can be disabled in order to gain efficiency. In order to disable pre-sorting set <em>presorting_required</em> to false. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="correspondence__rejection_8h_source.html#l00118">pcl::registration::CorrespondenceRejector::getRejectedQueryIndices()</a>.</p>

</div>
</div>
<a id="af09b8b74e8f5988cbef7b8eb60d0fcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09b8b74e8f5988cbef7b8eb60d0fcfb">&#9670;&nbsp;</a></span>getTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::getTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2time_8h_source.html#l00188">188</a> of file <a class="el" href="common_2time_8h_source.html">time.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="time__cpu_8h_source.html#l00127">pcl::cuda::ScopeTimeCPU::ScopeTimeCPU()</a>, and <a class="el" href="time__cpu_8h_source.html#l00132">pcl::cuda::ScopeTimeCPU::~ScopeTimeCPU()</a>.</p>

</div>
</div>
<a id="aab2f0e4ca5bc914138112691e0632b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2f0e4ca5bc914138112691e0632b49">&#9670;&nbsp;</a></span>getTransformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTransformation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yaw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3d &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00333">333</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aa8678bc9ac51ff4a0dc27cd543b6ac84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8678bc9ac51ff4a0dc27cd543b6ac84">&#9670;&nbsp;</a></span>getTransformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTransformation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yaw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00326">326</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ad5de15e37a0ff9f56f2cd9e942f44cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5de15e37a0ff9f56f2cd9e942f44cd6">&#9670;&nbsp;</a></span>getTranslationAndEulerAngles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTranslationAndEulerAngles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3d &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00304">304</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a8f85a8959dbec57e64840ee80c20f816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f85a8959dbec57e64840ee80c20f816">&#9670;&nbsp;</a></span>getTranslationAndEulerAngles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTranslationAndEulerAngles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00296">296</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a4ffcf78b18f7bf6e262782ff7c8050b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffcf78b18f7bf6e262782ff7c8050b4">&#9670;&nbsp;</a></span>interpolatePointIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> int pcl::interpolatePointIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485">InterpolationType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the right index according to the interpolation type. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this is adapted from OpenCV </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the index of point to interpolate </td></tr>
    <tr><td class="paramname">length</td><td>the top/bottom row or left/right column index </td></tr>
    <tr><td class="paramname">type</td><td>the requested interpolation </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpcl_1_1_bad_argument_exception.html" title="An exception that is thrown when the arguments number or type is wrong/unhandled.">pcl::BadArgumentException</a></td><td>if type is unknown </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00342">copyPointCloud()</a>.</p>

</div>
</div>
<a id="a2adb775f2d234f57c4e7c1209eb95a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adb775f2d234f57c4e7c1209eb95a1d">&#9670;&nbsp;</a></span>isFinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if the 3D components of a point are all finite param[in] pt point to be tested return true if finite, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00055">55</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree__pointcloud__adjacency_8hpp_source.html#l00157">pcl::octree::OctreePointCloudAdjacency&lt; PointT, LeafContainerT, BranchContainerT &gt;::addPointIdx()</a>, <a class="el" href="octree__pointcloud__adjacency_8hpp_source.html#l00067">pcl::octree::OctreePointCloudAdjacency&lt; PointT, LeafContainerT, BranchContainerT &gt;::addPointsFromInputCloud()</a>, <a class="el" href="octree__pointcloud_8hpp_source.html#l00078">pcl::octree::OctreePointCloud&lt; PointT, OctreeContainerPointIndex, OctreeContainerEmpty, OctreeBase&lt; OctreeContainerPointIndex, OctreeContainerEmpty &gt; &gt;::addPointsFromInputCloud()</a>, <a class="el" href="pcl__visualizer_8hpp_source.html#l01618">pcl::visualization::PCLVisualizer::addPolygonMesh()</a>, <a class="el" href="organized__pointcloud__compression_8hpp_source.html#l00402">pcl::io::OrganizedPointCloudCompression&lt; PointT &gt;::analyzeOrganizedCloud()</a>, <a class="el" href="median__filter_8hpp_source.html#l00047">pcl::MedianFilter&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="crop__box_8hpp_source.html#l00049">pcl::CropBox&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="local__maximum_8hpp_source.html#l00072">pcl::LocalMaximum&lt; PointT &gt;::applyFilterIndices()</a>, <a class="el" href="model__outlier__removal_8hpp_source.html#l00146">pcl::ModelOutlierRemoval&lt; PointT &gt;::applyFilterIndices()</a>, <a class="el" href="octree__search_8hpp_source.html#l00134">pcl::octree::OctreePointCloudSearch&lt; PointT, pcl::octree::OctreeContainerPointIndices, pcl::octree::OctreeContainerEmpty &gt;::approxNearestSearch()</a>, <a class="el" href="keypoints_2include_2pcl_2keypoints_2brisk__2d_8h_source.html#l00158">pcl::BriskKeypoint2D&lt; PointInT, PointOutT, IntensityT &gt;::bilinearInterpolation()</a>, <a class="el" href="pyramid_8hpp_source.html#l00098">pcl::filters::Pyramid&lt; PointT &gt;::compute()</a>, <a class="el" href="centroid_8hpp_source.html#l00056">compute3DCentroid()</a>, <a class="el" href="grabcut__segmentation_8hpp_source.html#l00386">pcl::GrabCut&lt; PointT &gt;::computeBetaNonOrganized()</a>, <a class="el" href="centroid_8hpp_source.html#l00881">computeCentroid()</a>, <a class="el" href="centroid_8hpp_source.html#l00180">computeCovarianceMatrix()</a>, <a class="el" href="intensity__gradient_8hpp_source.html#l00143">pcl::IntensityGradientEstimation&lt; PointInT, PointNT, PointOutT, IntensitySelectorT &gt;::computeFeature()</a>, <a class="el" href="moment__invariants_8hpp_source.html#l00116">pcl::MomentInvariantsEstimation&lt; PointInT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="principal__curvatures_8hpp_source.html#l00115">pcl::PrincipalCurvaturesEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="shot__omp_8hpp_source.html#l00140">pcl::SHOTEstimationOMP&lt; PointInT, PointNT, PointOutT, PointRFT &gt;::computeFeature()</a>, <a class="el" href="usc_8hpp_source.html#l00225">pcl::UniqueShapeContext&lt; PointInT, PointOutT, PointRFT &gt;::computeFeature()</a>, <a class="el" href="boundary_8hpp_source.html#l00116">pcl::BoundaryEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="3dsc_8hpp_source.html#l00249">pcl::ShapeContext3DEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="pfh_8hpp_source.html#l00166">pcl::PFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="fpfh_8hpp_source.html#l00237">pcl::FPFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="shot__omp_8hpp_source.html#l00223">pcl::SHOTColorEstimationOMP&lt; PointInT, PointNT, PointOutT, PointRFT &gt;::computeFeature()</a>, <a class="el" href="shot_8hpp_source.html#l00762">pcl::SHOTEstimation&lt; PointInT, PointNT, pcl::SHOT352, pcl::ReferenceFrame &gt;::computeFeature()</a>, <a class="el" href="shot_8hpp_source.html#l00828">pcl::SHOTColorEstimation&lt; PointInT, PointNT, pcl::SHOT1344, pcl::ReferenceFrame &gt;::computeFeature()</a>, <a class="el" href="normal__3d_8hpp_source.html#l00048">pcl::NormalEstimation&lt; PointInT, PointNT &gt;::computeFeature()</a>, <a class="el" href="centroid_8hpp_source.html#l00485">computeMeanAndCovarianceMatrix()</a>, <a class="el" href="flare_8hpp_source.html#l00110">pcl::FLARELocalReferenceFrameEstimation&lt; PointInT, PointNT, PointOutT, SignedDistanceT &gt;::computePointLRF()</a>, <a class="el" href="pfh_8hpp_source.html#l00060">pcl::PFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePointPFHSignature()</a>, <a class="el" href="organized__pointcloud__conversion_8h_source.html#l00093">pcl::io::OrganizedConversion&lt; PointT, false &gt;::convert()</a>, <a class="el" href="organized__pointcloud__conversion_8h_source.html#l00276">pcl::io::OrganizedConversion&lt; PointT, true &gt;::convert()</a>, <a class="el" href="convolution__3d_8hpp_source.html#l00230">pcl::filters::Convolution3D&lt; PointIn, PointOut, KernelT &gt;::convolve()</a>, <a class="el" href="harris__6d_8hpp_source.html#l00143">pcl::HarrisKeypoint6D&lt; PointInT, PointOutT, NormalT &gt;::detectKeypoints()</a>, <a class="el" href="harris__2d_8hpp_source.html#l00177">pcl::HarrisKeypoint2D&lt; PointInT, PointOutT, IntensityT &gt;::detectKeypoints()</a>, <a class="el" href="trajkovic__3d_8hpp_source.html#l00098">pcl::TrajkovicKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::detectKeypoints()</a>, <a class="el" href="harris__3d_8hpp_source.html#l00241">pcl::HarrisKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::detectKeypoints()</a>, <a class="el" href="susan_8hpp_source.html#l00303">pcl::SUSANKeypoint&lt; PointInT, PointOutT, NormalT, IntensityT &gt;::detectKeypoints()</a>, <a class="el" href="keypoints_2include_2pcl_2keypoints_2impl_2brisk__2d_8hpp_source.html#l00069">pcl::BriskKeypoint2D&lt; PointInT, PointOutT, IntensityT &gt;::detectKeypoints()</a>, <a class="el" href="iss__3d_8hpp_source.html#l00292">pcl::ISSKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::detectKeypoints()</a>, <a class="el" href="correspondence__estimation__organized__projection_8hpp_source.html#l00078">pcl::registration::CorrespondenceEstimationOrganizedProjection&lt; PointSource, PointTarget, Scalar &gt;::determineCorrespondences()</a>, <a class="el" href="range__image_8hpp_source.html#l00233">pcl::RangeImage::doZBuffer()</a>, <a class="el" href="point__cloud__image__extractors_8hpp_source.html#l00051">pcl::io::PointCloudImageExtractor&lt; PointT &gt;::extract()</a>, <a class="el" href="point__cloud__image__extractors_8hpp_source.html#l00139">pcl::io::PointCloudImageExtractorFromLabelField&lt; PointT &gt;::extractImpl()</a>, <a class="el" href="region__growing_8hpp_source.html#l00343">pcl::RegionGrowing&lt; PointT, pcl::Normal &gt;::findPointNeighbours()</a>, <a class="el" href="features_2include_2pcl_2features_2normal__3d_8h_source.html#l00204">flipNormalTowardsNormalsMean()</a>, <a class="el" href="octree__pointcloud__adjacency_8hpp_source.html#l00122">pcl::octree::OctreePointCloudAdjacency&lt; PointT, LeafContainerT, BranchContainerT &gt;::genOctreeKeyforPoint()</a>, <a class="el" href="iss__3d_8hpp_source.html#l00105">pcl::ISSKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::getBoundaryPoints()</a>, <a class="el" href="point__cloud__color__handlers_8hpp_source.html#l00524">pcl::visualization::PointCloudColorHandlerLabelField&lt; PointT &gt;::getColor()</a>, <a class="el" href="segment__differences_8hpp_source.html#l00048">getPointCloudDifference()</a>, <a class="el" href="organized__fast__mesh_8h_source.html#l00438">pcl::OrganizedFastMesh&lt; PointInT &gt;::isValidQuad()</a>, <a class="el" href="organized__fast__mesh_8h_source.html#l00409">pcl::OrganizedFastMesh&lt; PointInT &gt;::isValidTriangle()</a>, <a class="el" href="brute__force_8hpp_source.html#l00054">pcl::search::BruteForce&lt; PointT &gt;::nearestKSearch()</a>, <a class="el" href="octree__search_8hpp_source.html#l00082">pcl::octree::OctreePointCloudSearch&lt; PointT, pcl::octree::OctreeContainerPointIndices, pcl::octree::OctreeContainerEmpty &gt;::nearestKSearch()</a>, <a class="el" href="organized_8hpp_source.html#l00117">pcl::search::OrganizedNeighbor&lt; PointT &gt;::nearestKSearch()</a>, <a class="el" href="convolution__3d_8hpp_source.html#l00105">pcl::filters::GaussianKernel&lt; PointInT, PointOutT &gt;::operator()()</a>, <a class="el" href="convolution__3d_8hpp_source.html#l00134">pcl::filters::GaussianKernelRGB&lt; PointInT, PointOutT &gt;::operator()()</a>, <a class="el" href="organized__fast__mesh_8hpp_source.html#l00048">pcl::OrganizedFastMesh&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="vtk__lib__io_8hpp_source.html#l00396">pcl::io::pointCloudTovtkStructuredGrid()</a>, <a class="el" href="brute__force_8hpp_source.html#l00334">pcl::search::BruteForce&lt; PointT &gt;::radiusSearch()</a>, <a class="el" href="organized_8hpp_source.html#l00050">pcl::search::OrganizedNeighbor&lt; PointT &gt;::radiusSearch()</a>, <a class="el" href="octree__search_8hpp_source.html#l00162">pcl::octree::OctreePointCloudSearch&lt; PointT, pcl::octree::OctreeContainerPointIndices, pcl::octree::OctreeContainerEmpty &gt;::radiusSearch()</a>, <a class="el" href="filter_8hpp_source.html#l00099">removeNaNNormalsFromPointCloud()</a>, <a class="el" href="harris__2d_8hpp_source.html#l00304">pcl::HarrisKeypoint2D&lt; PointInT, PointOutT, IntensityT &gt;::responseHarris()</a>, <a class="el" href="harris__3d_8hpp_source.html#l00321">pcl::HarrisKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::responseHarris()</a>, <a class="el" href="harris__2d_8hpp_source.html#l00396">pcl::HarrisKeypoint2D&lt; PointInT, PointOutT, IntensityT &gt;::responseLowe()</a>, <a class="el" href="harris__3d_8hpp_source.html#l00402">pcl::HarrisKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::responseLowe()</a>, <a class="el" href="harris__2d_8hpp_source.html#l00350">pcl::HarrisKeypoint2D&lt; PointInT, PointOutT, IntensityT &gt;::responseNoble()</a>, <a class="el" href="harris__3d_8hpp_source.html#l00362">pcl::HarrisKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::responseNoble()</a>, <a class="el" href="harris__6d_8hpp_source.html#l00268">pcl::HarrisKeypoint6D&lt; PointInT, PointOutT, NormalT &gt;::responseTomasi()</a>, <a class="el" href="harris__2d_8hpp_source.html#l00442">pcl::HarrisKeypoint2D&lt; PointInT, PointOutT, IntensityT &gt;::responseTomasi()</a>, <a class="el" href="harris__3d_8hpp_source.html#l00460">pcl::HarrisKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::responseTomasi()</a>, <a class="el" href="octree__pointcloud__occupancy_8h_source.html#l00121">pcl::octree::OctreePointCloudOccupancy&lt; PointT, LeafContainerT, BranchContainerT &gt;::setOccupiedVoxelsAtPointsFromCloud()</a>, <a class="el" href="pcl__visualizer_8hpp_source.html#l01539">pcl::visualization::PCLVisualizer::updatePointCloud()</a>, <a class="el" href="pcl__visualizer_8hpp_source.html#l01789">pcl::visualization::PCLVisualizer::updatePolygonMesh()</a>, and <a class="el" href="octree__search_8hpp_source.html#l00050">pcl::octree::OctreePointCloudSearch&lt; PointT, pcl::octree::OctreeContainerPointIndices, pcl::octree::OctreeContainerEmpty &gt;::voxelSearch()</a>.</p>

</div>
</div>
<a id="a6109e92464c36a97c430673de3051e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6109e92464c36a97c430673de3051e42">&#9670;&nbsp;</a></span>isFinite&lt; pcl::Axis &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_axis.html">pcl::Axis</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_axis.html">pcl::Axis</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00068">68</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a68686bc9f758b0e536106c09e42f7ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68686bc9f758b0e536106c09e42f7ab2">&#9670;&nbsp;</a></span>isFinite&lt; pcl::BorderDescription &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_border_description.html">pcl::BorderDescription</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_border_description.html">pcl::BorderDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00070">70</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a206b8c7c106c4d9d7e917761f35df9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206b8c7c106c4d9d7e917761f35df9c5">&#9670;&nbsp;</a></span>isFinite&lt; pcl::Boundary &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_boundary.html">pcl::Boundary</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_boundary.html">pcl::Boundary</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00071">71</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a3de9a778c79fd01e22547a031a56740a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de9a778c79fd01e22547a031a56740a">&#9670;&nbsp;</a></span>isFinite&lt; pcl::BRISKSignature512 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_b_r_i_s_k_signature512.html">pcl::BRISKSignature512</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_b_r_i_s_k_signature512.html">pcl::BRISKSignature512</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00069">69</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="ab813ac49dfae6d8e63ad62f28c9a0494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab813ac49dfae6d8e63ad62f28c9a0494">&#9670;&nbsp;</a></span>isFinite&lt; pcl::ESFSignature640 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_e_s_f_signature640.html">pcl::ESFSignature640</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_e_s_f_signature640.html">pcl::ESFSignature640</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00072">72</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a020eefa3852acf44161d192426a6931a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020eefa3852acf44161d192426a6931a">&#9670;&nbsp;</a></span>isFinite&lt; pcl::FPFHSignature33 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_f_p_f_h_signature33.html">pcl::FPFHSignature33</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_f_p_f_h_signature33.html">pcl::FPFHSignature33</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00073">73</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a553636c8ec38aaac63a5f7413ee94edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553636c8ec38aaac63a5f7413ee94edc">&#9670;&nbsp;</a></span>isFinite&lt; pcl::Intensity &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_intensity.html">pcl::Intensity</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_intensity.html">pcl::Intensity</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00074">74</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a8b0d0c04fa6120c091744698b409af27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0d0c04fa6120c091744698b409af27">&#9670;&nbsp;</a></span>isFinite&lt; pcl::IntensityGradient &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_intensity_gradient.html">pcl::IntensityGradient</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_intensity_gradient.html">pcl::IntensityGradient</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00075">75</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="aababd240de792e41b9dbeff10f3f77d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aababd240de792e41b9dbeff10f3f77d7">&#9670;&nbsp;</a></span>isFinite&lt; pcl::Label &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_label.html">pcl::Label</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_label.html">pcl::Label</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00076">76</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a28eaa01a82e41dabf54825ee6e89634e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28eaa01a82e41dabf54825ee6e89634e">&#9670;&nbsp;</a></span>isFinite&lt; pcl::MomentInvariants &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_moment_invariants.html">pcl::MomentInvariants</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_moment_invariants.html">pcl::MomentInvariants</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00077">77</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a0fb1a21ad498163af58a167ba5e642a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb1a21ad498163af58a167ba5e642a5">&#9670;&nbsp;</a></span>isFinite&lt; pcl::Normal &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_normal.html">pcl::Normal</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_normal.html">pcl::Normal</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00102">102</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a4e61f396c39343c2d5bad73aad0d4ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e61f396c39343c2d5bad73aad0d4ba8">&#9670;&nbsp;</a></span>isFinite&lt; pcl::NormalBasedSignature12 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_normal_based_signature12.html">pcl::NormalBasedSignature12</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_normal_based_signature12.html">pcl::NormalBasedSignature12</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00078">78</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a1b143169967583a7d4ab3cf6ce47002a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b143169967583a7d4ab3cf6ce47002a">&#9670;&nbsp;</a></span>isFinite&lt; pcl::PFHRGBSignature250 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_p_f_h_r_g_b_signature250.html">pcl::PFHRGBSignature250</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_f_h_r_g_b_signature250.html">pcl::PFHRGBSignature250</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00079">79</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a7238f6a28e8867df6173d1cc4abc6fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7238f6a28e8867df6173d1cc4abc6fff">&#9670;&nbsp;</a></span>isFinite&lt; pcl::PFHSignature125 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_p_f_h_signature125.html">pcl::PFHSignature125</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_f_h_signature125.html">pcl::PFHSignature125</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00080">80</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="aecdc544044cf19ed4232e20f2155cdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdc544044cf19ed4232e20f2155cdcc">&#9670;&nbsp;</a></span>isFinite&lt; pcl::PointXY &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_point_x_y.html">pcl::PointXY</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y.html">pcl::PointXY</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00095">95</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

<p class="reference">References <a class="el" href="point__types_8hpp_source.html#l00746">pcl::PointXY::x</a>, and <a class="el" href="point__types_8hpp_source.html#l00747">pcl::PointXY::y</a>.</p>

</div>
</div>
<a id="a05d1bd954e61a6bb139d7103309c8ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d1bd954e61a6bb139d7103309c8ec2">&#9670;&nbsp;</a></span>isFinite&lt; pcl::PPFRGBSignature &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_p_p_f_r_g_b_signature.html">pcl::PPFRGBSignature</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_p_f_r_g_b_signature.html">pcl::PPFRGBSignature</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00081">81</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="afc686eef9a0e685d22f2bfd3e0ef3316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc686eef9a0e685d22f2bfd3e0ef3316">&#9670;&nbsp;</a></span>isFinite&lt; pcl::PPFSignature &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_p_p_f_signature.html">pcl::PPFSignature</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_p_f_signature.html">pcl::PPFSignature</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00082">82</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a5302304032aa948f9aaede456dd97803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5302304032aa948f9aaede456dd97803">&#9670;&nbsp;</a></span>isFinite&lt; pcl::PrincipalCurvatures &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_principal_curvatures.html">pcl::PrincipalCurvatures</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_principal_curvatures.html">pcl::PrincipalCurvatures</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00083">83</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a412254387bbfda50c4f9529fbedd0681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412254387bbfda50c4f9529fbedd0681">&#9670;&nbsp;</a></span>isFinite&lt; pcl::PrincipalRadiiRSD &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_principal_radii_r_s_d.html">pcl::PrincipalRadiiRSD</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_principal_radii_r_s_d.html">pcl::PrincipalRadiiRSD</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00084">84</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a2de4643e7ad834118b6f442fea09d7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de4643e7ad834118b6f442fea09d7dd">&#9670;&nbsp;</a></span>isFinite&lt; pcl::ReferenceFrame &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_reference_frame.html">pcl::ReferenceFrame</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_reference_frame.html">pcl::ReferenceFrame</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00086">86</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="af741156132ea869caf8e3abcae0bef79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af741156132ea869caf8e3abcae0bef79">&#9670;&nbsp;</a></span>isFinite&lt; pcl::RGB &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">pcl::RGB</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_r_g_b.html">pcl::RGB</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00085">85</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a725293aecc4839d0b143cf8b746f8cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725293aecc4839d0b143cf8b746f8cc0">&#9670;&nbsp;</a></span>isFinite&lt; pcl::ShapeContext1980 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_shape_context1980.html">pcl::ShapeContext1980</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_shape_context1980.html">pcl::ShapeContext1980</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00089">89</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a41cad31cd72f1528a92232ebdf5972db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cad31cd72f1528a92232ebdf5972db">&#9670;&nbsp;</a></span>isFinite&lt; pcl::SHOT1344 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_s_h_o_t1344.html">pcl::SHOT1344</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_s_h_o_t1344.html">pcl::SHOT1344</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00087">87</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="aa3bd3800e7cf0c93aade46b89a878259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bd3800e7cf0c93aade46b89a878259">&#9670;&nbsp;</a></span>isFinite&lt; pcl::SHOT352 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_s_h_o_t352.html">pcl::SHOT352</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_s_h_o_t352.html">pcl::SHOT352</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00088">88</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a57267afe0572573812cf800186b456d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57267afe0572573812cf800186b456d4">&#9670;&nbsp;</a></span>isFinite&lt; pcl::UniqueShapeContext1960 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_unique_shape_context1960.html">pcl::UniqueShapeContext1960</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_unique_shape_context1960.html">pcl::UniqueShapeContext1960</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00090">90</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="ac8988331282d31b4ee08d45613208836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8988331282d31b4ee08d45613208836">&#9670;&nbsp;</a></span>isFinite&lt; pcl::VFHSignature308 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacepcl.html#a2adb775f2d234f57c4e7c1209eb95a1d">pcl::isFinite</a>&lt; <a class="el" href="structpcl_1_1_v_f_h_signature308.html">pcl::VFHSignature308</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_v_f_h_signature308.html">pcl::VFHSignature308</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00091">91</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="ab6edf907fde79bd98e96c15424f74dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6edf907fde79bd98e96c15424f74dfe">&#9670;&nbsp;</a></span>isNormalFinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , traits::HasNoNormal&lt; PointT &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pcl::isNormalFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00121">121</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a6cd17db3d296f3f15e66344e37eb9032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd17db3d296f3f15e66344e37eb9032">&#9670;&nbsp;</a></span>isNormalFinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , traits::HasNormal&lt; PointT &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isNormalFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00140">140</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="ab1e28fae1c62a5cd3ba7b741f75d3e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e28fae1c62a5cd3ba7b741f75d3e4b">&#9670;&nbsp;</a></span>isSamePointType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point1T , typename Point2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isSamePointType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two given point types are the same or not. </p>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00372">372</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="a4239e936efbf42ad0e5da571863b5b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4239e936efbf42ad0e5da571863b5b56">&#9670;&nbsp;</a></span>isValueFinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral&lt;Type&gt;::value, bool&gt; pcl::isValueFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00318">318</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

</div>
</div>
<a id="a0e5e574e0b62d33b5eef0b8a3513841b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5e574e0b62d33b5eef0b8a3513841b">&#9670;&nbsp;</a></span>isValueFinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point&lt;Type&gt;::value, bool&gt; pcl::isValueFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>point_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>field_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fields_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a given value of type Type (uchar, char, uint, int, float, double, ...) is finite or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the cloud that contains the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_index</td><td>the index of the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_size</td><td>the size of the point in the cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_idx</td><td>the index of the dimension/field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields_count</td><td>the current fields count</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value is finite, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00305">305</a> of file <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html">file_io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>.</p>

</div>
</div>
<a id="a9b31aaaf53decaf828a4b05ce9c6f908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b31aaaf53decaf828a4b05ce9c6f908">&#9670;&nbsp;</a></span>isXYFinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , traits::HasNoXY&lt; PointT &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pcl::isXYFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00109">109</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a2c61f301e3be16c5cc1c423ad7041eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c61f301e3be16c5cc1c423ad7041eaf">&#9670;&nbsp;</a></span>isXYFinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , traits::HasXY&lt; PointT &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isXYFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00128">128</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="af0863d8e9957d47a89538a631122efd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0863d8e9957d47a89538a631122efd9">&#9670;&nbsp;</a></span>isXYZFinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , traits::HasNoXYZ&lt; PointT &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool pcl::isXYZFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00115">115</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="ad2af6706fa91836eaa079a9b1a857a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2af6706fa91836eaa079a9b1a857a50">&#9670;&nbsp;</a></span>isXYZFinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , traits::HasXYZ&lt; PointT &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isXYZFinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__tests_8h_source.html#l00134">134</a> of file <a class="el" href="point__tests_8h_source.html">point_tests.h</a>.</p>

</div>
</div>
<a id="a2bf72a3e909eaac4e666bc4ef0f835f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf72a3e909eaac4e666bc4ef0f835f8">&#9670;&nbsp;</a></span>lzfCompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> unsigned int pcl::lzfCompress </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>in_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>out_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress in_len bytes stored at the memory block starting at <em>in_data</em> and write the result to <em>out_data</em>, up to a maximum length of <em>out_len</em> bytes using Marc Lehmann's LZF algorithm. </p>
<p>If the output buffer is not large enough or any error occurs return 0, otherwise return the number of bytes used, which might be considerably more than in_len (but less than 104% of the original size), so it makes sense to always use out_len == in_len - 1), to ensure <em>some</em> compression, and store the data uncompressed otherwise (with a flag, of course.</p>
<dl class="section note"><dt>Note</dt><dd>The buffers must not be overlapping.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_data</td><td>the input uncompressed buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_len</td><td>the length of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>the output buffer where the compressed result will be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_len</td><td>the length of the output buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="pcd__io_8hpp_source.html#l00241">pcl::PCDWriter::writeBinaryCompressed()</a>.</p>

</div>
</div>
<a id="ae90a8f0773d828ec6a82d88c575aa783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90a8f0773d828ec6a82d88c575aa783">&#9670;&nbsp;</a></span>lzfDecompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> unsigned int pcl::lzfDecompress </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>in_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>out_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompress data compressed with the <em>lzfCompress</em> function and stored at location <em>in_data</em> and length <em>in_len</em>. </p>
<p>The result will be stored at <em>out_data</em> up to a maximum of <em>out_len</em> characters.</p>
<p>If the output buffer is not large enough to hold the decompressed data, a 0 is returned and errno is set to E2BIG. Otherwise the number of decompressed bytes (i.e. the original length of the data) is returned.</p>
<p>If an error in the compressed data is detected, a zero is returned and errno is set to EINVAL.</p>
<p>This function is very fast, about as fast as a copying loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_data</td><td>the input compressed buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_len</td><td>the length of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>the output buffer (must be resized to <em>out_len</em>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_len</td><td>the length of the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf0472aa62fb36ea477ef66c191c8626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0472aa62fb36ea477ef66c191c8626">&#9670;&nbsp;</a></span>make_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt; pcl::make_shared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pcl::shared_ptr compliant with type T's allocation policy. </p>
<p>std::allocate_shared or std::make_shared will be invoked in case T has or doesn't have a custom allocator, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>In MSVC &lt; 1915 (before version 15.8) alignment was incorrectly set at most at alignof(max_align_t). This bug was fixed in said version and is acknowledged by defining _ENABLE_EXTENDED_ALIGNED_STORAGE. See #3752.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structpcl_1_1has__custom__allocator.html" title="Tests at compile time if type T has a custom allocator.">pcl::has_custom_allocator</a>, <a class="el" href="group__common.html#ga35846236568f16ca7fa07d958966e12c" title="Macro to signal a class requires a custom allocator.">PCL_MAKE_ALIGNED_OPERATOR_NEW</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object to create a pcl::shared_ptr of </td></tr>
    <tr><td class="paramname">Args</td><td>Types for the arguments to <a class="el" href="namespacepcl.html#abf0472aa62fb36ea477ef66c191c8626" title="Returns a pcl::shared_ptr compliant with type T&#39;s allocation policy.">pcl::make_shared</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>List of arguments with which an instance of T will be constructed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcl::shared_ptr of an instance of type T </dd></dl>

</div>
</div>
<a id="a87ec5383674604eedd381f0c379b04f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ec5383674604eedd381f0c379b04f5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_axis.html">Axis</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e32b0632e12d5a051cb8b04ea5f5ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e32b0632e12d5a051cb8b04ea5f5ca0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/68]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_bivariate_polynomial_t.html">BivariatePolynomialT</a>&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bivariate__polynomial_8hpp_source.html#l00240">240</a> of file <a class="el" href="bivariate__polynomial_8hpp_source.html">bivariate_polynomial.hpp</a>.</p>

<p class="reference">References <a class="el" href="bivariate__polynomial_8h_source.html#l00117">pcl::BivariatePolynomialT&lt; real &gt;::degree</a>, and <a class="el" href="bivariate__polynomial_8h_source.html#l00118">pcl::BivariatePolynomialT&lt; real &gt;::parameters</a>.</p>

</div>
</div>
<a id="a5b1153a607ce169857125edae09cfe39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1153a607ce169857125edae09cfe39">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_border_description.html">BorderDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ee8aad293f74d3742a25238a786c2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee8aad293f74d3742a25238a786c2e9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_boundary.html">Boundary</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0225d96d6b8de7b63f878ccbe58c1e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0225d96d6b8de7b63f878ccbe58c1e82">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_b_r_i_s_k_signature512.html">BRISKSignature512</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83830868a12eca592bd12b5b9d62f9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83830868a12eca592bd12b5b9d62f9e2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overloaded &lt;&lt; operator </p>

</div>
</div>
<a id="ae13addefb957e51551de773268c65c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13addefb957e51551de773268c65c82">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_c_p_p_f_signature.html">CPPFSignature</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dc7a0ea4cd99f38691a573b989f5540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc7a0ea4cd99f38691a573b989f5540">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_e_s_f_signature640.html">ESFSignature640</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3de48790dd4f9e19c9a1550fb848ea3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de48790dd4f9e19c9a1550fb848ea3d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_f_p_f_h_signature33.html">FPFHSignature33</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaebc412871f2707e575fa34ce572572a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebc412871f2707e575fa34ce572572a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_g_a_s_d_signature512.html">GASDSignature512</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01fab9179c9352d802406f948da4951b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fab9179c9352d802406f948da4951b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_g_a_s_d_signature7992.html">GASDSignature7992</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa18dfb13fd6d95ba40ccad228917d1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18dfb13fd6d95ba40ccad228917d1b2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_g_a_s_d_signature984.html">GASDSignature984</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af20aa5d2c41247323461c041a257f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20aa5d2c41247323461c041a257f1bc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_g_f_p_f_h_signature16.html">GFPFHSignature16</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf291c3601778128223fda6010b6e910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf291c3601778128223fda6010b6e910">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_gradient_x_y.html">GradientXY</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="recognition_2include_2pcl_2recognition_2point__types_8h_source.html#l00072">72</a> of file <a class="el" href="recognition_2include_2pcl_2recognition_2point__types_8h_source.html">point_types.h</a>.</p>

<p class="reference">References <a class="el" href="recognition_2include_2pcl_2recognition_2point__types_8h_source.html#l00061">pcl::GradientXY::magnitude</a>, <a class="el" href="recognition_2include_2pcl_2recognition_2point__types_8h_source.html#l00058">pcl::GradientXY::x</a>, and <a class="el" href="recognition_2include_2pcl_2recognition_2point__types_8h_source.html#l00059">pcl::GradientXY::y</a>.</p>

</div>
</div>
<a id="a90501d20b65f614f006f508b852e5770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90501d20b65f614f006f508b852e5770">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_g_r_s_d_signature21.html">GRSDSignature21</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4827eb3b63ef3565d88791ff9d674eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4827eb3b63ef3565d88791ff9d674eb5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/68]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_histogram.html">Histogram</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types_8hpp_source.html#l01826">1826</a> of file <a class="el" href="point__types_8hpp_source.html">point_types.hpp</a>.</p>

<p class="reference">References <a class="el" href="point__types_8hpp_source.html#l01679">pcl::Histogram&lt; N &gt;::histogram</a>.</p>

</div>
</div>
<a id="aeec9af0fa6d2045038d97086d2564b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec9af0fa6d2045038d97086d2564b04">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[17/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_intensity.html">Intensity</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61bc5840d2339ab463518c23d2eec429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bc5840d2339ab463518c23d2eec429">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[18/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_intensity32u.html">Intensity32u</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2821e799172bdcc306b9efd1f759b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2821e799172bdcc306b9efd1f759b63">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[19/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_intensity8u.html">Intensity8u</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac837bb01edfb9daaec3f6c6459662445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac837bb01edfb9daaec3f6c6459662445">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[20/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_intensity_gradient.html">IntensityGradient</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cf0dccceb5499828fdeb277ec86ee24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf0dccceb5499828fdeb277ec86ee24">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[21/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_interest_point.html">InterestPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fcc1cb564b3460bc9f09a0ff4fb0dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcc1cb564b3460bc9f09a0ff4fb0dc9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[22/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_label.html">Label</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e8528949adf7d108f67295784ea8f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8528949adf7d108f67295784ea8f4c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[23/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_moment_invariants.html">MomentInvariants</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45fe4f8c4719b2ffbc7b617333767f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fe4f8c4719b2ffbc7b617333767f46">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[24/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_narf36.html">Narf36</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7c5f8626f928698f5b3a8967f0b046a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c5f8626f928698f5b3a8967f0b046a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[25/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_normal.html">Normal</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4534a2c1bd0618b111647e999e77df33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4534a2c1bd0618b111647e999e77df33">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[26/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_normal_based_signature12.html">NormalBasedSignature12</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d52efa0d7cbf23909bd816bb0a1c666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d52efa0d7cbf23909bd816bb0a1c666">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[27/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_f_h_r_g_b_signature250.html">PFHRGBSignature250</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a105b339fcb7ac0a6adc12d4d7d8b6054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105b339fcb7ac0a6adc12d4d7d8b6054">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[28/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_f_h_signature125.html">PFHSignature125</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72338648bb90c152d9877996101dc59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72338648bb90c152d9877996101dc59e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[29/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_d_e_m.html">PointDEM</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a412c39716aa2a36ff6ab9ade75c169c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412c39716aa2a36ff6ab9ade75c169c4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[30/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_normal.html">PointNormal</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c99ce77bc64a87b38980b612e31c921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c99ce77bc64a87b38980b612e31c921">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[31/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_surfel.html">PointSurfel</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad38e7946d98cae3c778e06ecbaa4df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad38e7946d98cae3c778e06ecbaa4df9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[32/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_u_v.html">PointUV</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ad2d3d0146b30ce1ea5d3d816caec10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad2d3d0146b30ce1ea5d3d816caec10">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[33/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6ce409883a619f6e9b4bfb3ce61d0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ce409883a619f6e9b4bfb3ce61d0c7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[34/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_scale.html">PointWithScale</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa69fd139cdf30136859e5c44171ce84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa69fd139cdf30136859e5c44171ce84">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[35/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_viewpoint.html">PointWithViewpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d15602f8e84118e21dc97048232d5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d15602f8e84118e21dc97048232d5c6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[36/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y.html">PointXY</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a259fa5168292d2f0a5bbfee6208304a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259fa5168292d2f0a5bbfee6208304a4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[37/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z.html">PointXYZ</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a194bce1cd392f2839fdf417016be09f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194bce1cd392f2839fdf417016be09f1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[38/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a502d6cf6fd2b60cbed256dfa64574eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502d6cf6fd2b60cbed256dfa64574eb4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[39/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_i.html">PointXYZI</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23eb640f2481ebea8e9b2c9428ea213f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23eb640f2481ebea8e9b2c9428ea213f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[40/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_i_normal.html">PointXYZINormal</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc0503cf66eb447c6a1d6f460f3c5265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0503cf66eb447c6a1d6f460f3c5265">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[41/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_l.html">PointXYZL</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06bd0eda0fca53206e567da9048be531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bd0eda0fca53206e567da9048be531">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[42/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_l_normal.html">PointXYZLNormal</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90abb02fce3fae16f4f6812fba2027a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90abb02fce3fae16f4f6812fba2027a1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[43/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae032ca18d8a2d681bb9c6f61dc47722a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae032ca18d8a2d681bb9c6f61dc47722a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[44/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d43ea244ae0faf522aebc5559673fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d43ea244ae0faf522aebc5559673fa8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[45/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_l.html">PointXYZRGBL</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a509826a38db4aeebcf04422c06dda97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509826a38db4aeebcf04422c06dda97a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[46/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_normal.html">PointXYZRGBNormal</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc8cfa2a02fbd9dac7f8122dcf6e2bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8cfa2a02fbd9dac7f8122dcf6e2bb7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[47/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_p_f_r_g_b_signature.html">PPFRGBSignature</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63c118315e1092054d743db6c859d40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c118315e1092054d743db6c859d40a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[48/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_p_f_signature.html">PPFSignature</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2458afa4cdfef33ff38dace1ad221e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2458afa4cdfef33ff38dace1ad221e73">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[49/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_principal_curvatures.html">PrincipalCurvatures</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab08c0deb092684b90e6bf986bd77e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab08c0deb092684b90e6bf986bd77e4f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[50/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_principal_radii_r_s_d.html">PrincipalRadiiRSD</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e0fa7ba4f8d3ff01a3e4332f96d6b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0fa7ba4f8d3ff01a3e4332f96d6b85">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[51/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>/ingroup range_image </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00815">815</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00357">pcl::RangeImage::getAngularResolutionX()</a>, <a class="el" href="range__image_8h_source.html#l00361">pcl::RangeImage::getAngularResolutionY()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="pcl__macros_8h_source.html#l00235">RAD2DEG</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00424">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00422">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="a4d909a2e60dc70d67db592dbe67a7cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d909a2e60dc70d67db592dbe67a7cc8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[52/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_range_image_border_extractor_1_1_parameters.html">RangeImageBorderExtractor::Parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image__border__extractor_8hpp_source.html#l00060">60</a> of file <a class="el" href="range__image__border__extractor_8hpp_source.html">range_image_border_extractor.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image__border__extractor_8h_source.html#l00095">pcl::RangeImageBorderExtractor::Parameters::minimum_border_probability</a>, <a class="el" href="range__image__border__extractor_8h_source.html#l00094">pcl::RangeImageBorderExtractor::Parameters::pixel_radius_border_direction</a>, <a class="el" href="range__image__border__extractor_8h_source.html#l00092">pcl::RangeImageBorderExtractor::Parameters::pixel_radius_borders</a>, <a class="el" href="range__image__border__extractor_8h_source.html#l00093">pcl::RangeImageBorderExtractor::Parameters::pixel_radius_plane_extraction</a>, <a class="el" href="range__image__border__extractor_8h_source.html#l00096">pcl::RangeImageBorderExtractor::Parameters::pixel_radius_principal_curvature</a>, <a class="el" href="pcl__macros_8h_source.html#l00280">PVARC</a>, and <a class="el" href="pcl__macros_8h_source.html#l00276">PVARN</a>.</p>

</div>
</div>
<a id="a19343463a3278d1d0e3db79c4e018aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19343463a3278d1d0e3db79c4e018aaa">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[53/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_reference_frame.html">ReferenceFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab125cc601b291e5d99552aafce17a53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab125cc601b291e5d99552aafce17a53e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[54/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6ae936041311537e8a56dec6159ced9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ae936041311537e8a56dec6159ced9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[55/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_shape_context1980.html">ShapeContext1980</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d41b561831d49b78d04200ee37d3002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d41b561831d49b78d04200ee37d3002">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[56/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_s_h_o_t1344.html">SHOT1344</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b039494767b268e50f0a1bb2976fa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b039494767b268e50f0a1bb2976fa48">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[57/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_s_h_o_t352.html">SHOT352</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d952d1be42065f1810999eccc365ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d952d1be42065f1810999eccc365ddf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[58/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_unique_shape_context1960.html">UniqueShapeContext1960</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1608e058a8bc248efa6f5220e655cff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1608e058a8bc248efa6f5220e655cff7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[59/68]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_v_f_h_signature308.html">VFHSignature308</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bc69cba7bca0412b28149e727ce56be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc69cba7bca0412b28149e727ce56be">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[60/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_header.html">PCLHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_header_8h_source.html#l00029">29</a> of file <a class="el" href="_p_c_l_header_8h_source.html">PCLHeader.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_header_8h_source.html#l00020">pcl::PCLHeader::frame_id</a>, <a class="el" href="_p_c_l_header_8h_source.html#l00013">pcl::PCLHeader::seq</a>, and <a class="el" href="_p_c_l_header_8h_source.html#l00018">pcl::PCLHeader::stamp</a>.</p>

</div>
</div>
<a id="aadf1fb9037c2eca16a673118288a876f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf1fb9037c2eca16a673118288a876f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[61/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="structpcl_1_1_model_coefficients.html">pcl::ModelCoefficients</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_model_coefficients_8h_source.html#l00030">30</a> of file <a class="el" href="_model_coefficients_8h_source.html">ModelCoefficients.h</a>.</p>

</div>
</div>
<a id="af6f264d661418058c6ff558ccb6d3cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f264d661418058c6ff558ccb6d3cb4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[62/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_image_8h_source.html#l00031">31</a> of file <a class="el" href="_p_c_l_image_8h_source.html">PCLImage.h</a>.</p>

</div>
</div>
<a id="a308f9f5919e442b1b4b084b0fdcc4a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308f9f5919e442b1b4b084b0fdcc4a05">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[63/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00092">92</a> of file <a class="el" href="_p_c_l_point_cloud2_8h_source.html">PCLPointCloud2.h</a>.</p>

</div>
</div>
<a id="ab74d14f268f3e1f29df2503dac6c3ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74d14f268f3e1f29df2503dac6c3ac4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[64/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_point_field_8h_source.html#l00036">36</a> of file <a class="el" href="_p_c_l_point_field_8h_source.html">PCLPointField.h</a>.</p>

</div>
</div>
<a id="abfc72bf72c8fb262df806d469cf72a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc72bf72c8fb262df806d469cf72a05">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[65/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_point_indices_8h_source.html#l00029">29</a> of file <a class="el" href="_point_indices_8h_source.html">PointIndices.h</a>.</p>

</div>
</div>
<a id="a9f1aabda7f7d9292915b26e52bae7f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1aabda7f7d9292915b26e52bae7f5d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[66/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_polygon_mesh_8h_source.html#l00104">104</a> of file <a class="el" href="_polygon_mesh_8h_source.html">PolygonMesh.h</a>.</p>

</div>
</div>
<a id="a31f82c5c83fe221b70f6793cd8649a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f82c5c83fe221b70f6793cd8649a0f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[67/68]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_vertices_8h_source.html#l00031">31</a> of file <a class="el" href="_vertices_8h_source.html">Vertices.h</a>.</p>

</div>
</div>
<a id="a9af8b9bfb52f728a1ea55a8a4603f3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af8b9bfb52f728a1ea55a8a4603f3ac">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[68/68]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; pcl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00653">653</a> of file <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html">point_cloud.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00424">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00422">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="abe79fa3e470b2634599cd18aae729fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe79fa3e470b2634599cd18aae729fe3">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_header.html">PCLHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_header.html">PCLHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_p_c_l_header_8h_source.html#l00037">37</a> of file <a class="el" href="_p_c_l_header_8h_source.html">PCLHeader.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_header_8h_source.html#l00020">pcl::PCLHeader::frame_id</a>, <a class="el" href="_p_c_l_header_8h_source.html#l00013">pcl::PCLHeader::seq</a>, and <a class="el" href="_p_c_l_header_8h_source.html#l00018">pcl::PCLHeader::stamp</a>.</p>

<p class="reference">Referenced by <a class="el" href="cuda_2common_2include_2pcl_2cuda_2point__types_8h_source.html#l00118">pcl::cuda::__align__()</a>.</p>

</div>
</div>
<a id="a96f34b2d4af408c1e4c13414ee32451f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f34b2d4af408c1e4c13414ee32451f">&#9670;&nbsp;</a></span>planeWithPlaneIntersection() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::planeWithPlaneIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angular_tolerance</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the line of intersection of two non-parallel planes using lagrange multipliers. </p>
<dl class="section note"><dt>Note</dt><dd>Described in: "Intersection of Two Planes, John Krumm, Microsoft Research, Redmond, WA, USA" </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_a</td><td>coefficients of plane A and plane B in the form ax + by + cz + d = 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_b</td><td>coefficients of line where line.tail&lt;3&gt;() = direction vector and line.head&lt;3&gt;() the point on the line clossest to (0, 0, 0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">line</td><td>the intersected line to be filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angular_tolerance</td><td>tolerance in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeded/planes aren't parallel </dd></dl>

<p class="definition">Definition at line <a class="el" href="intersections_8hpp_source.html#l00079">79</a> of file <a class="el" href="intersections_8hpp_source.html">intersections.hpp</a>.</p>

</div>
</div>
<a id="a425e0506b2af1892e706a2375b9fd0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425e0506b2af1892e706a2375b9fd0bc">&#9670;&nbsp;</a></span>planeWithPlaneIntersection() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::planeWithPlaneIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angular_tolerance</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the line of intersection of two non-parallel planes using lagrange multipliers. </p>
<dl class="section note"><dt>Note</dt><dd>Described in: "Intersection of Two Planes, John Krumm, Microsoft Research, Redmond, WA, USA" </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_a</td><td>coefficients of plane A and plane B in the form ax + by + cz + d = 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_b</td><td>coefficients of line where line.tail&lt;3&gt;() = direction vector and line.head&lt;3&gt;() the point on the line clossest to (0, 0, 0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">line</td><td>the intersected line to be filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angular_tolerance</td><td>tolerance in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeded/planes aren't parallel </dd></dl>

<p class="definition">Definition at line <a class="el" href="intersections_8hpp_source.html#l00079">79</a> of file <a class="el" href="intersections_8hpp_source.html">intersections.hpp</a>.</p>

</div>
</div>
<a id="a6646a946951d9293cee2500342f8ab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6646a946951d9293cee2500342f8ab08">&#9670;&nbsp;</a></span>planeWithPlaneIntersection() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::planeWithPlaneIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>plane_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>plane_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angular_tolerance</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intersections_8h_source.html#l00105">105</a> of file <a class="el" href="intersections_8h_source.html">intersections.h</a>.</p>

</div>
</div>
<a id="abc420a405fdf57c19edd9e91d240269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc420a405fdf57c19edd9e91d240269b">&#9670;&nbsp;</a></span>planeWithPlaneIntersection() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::planeWithPlaneIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>plane_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>plane_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angular_tolerance</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intersections_8h_source.html#l00096">96</a> of file <a class="el" href="intersections_8h_source.html">intersections.h</a>.</p>

</div>
</div>
<a id="abbe8ed3ea926b449a3936b3d2eba3693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe8ed3ea926b449a3936b3d2eba3693">&#9670;&nbsp;</a></span>PointCloudDepthAndRGBtoXYZRGBA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointCloudDepthAndRGBtoXYZRGBA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_intensity.html">Intensity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>focal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert registered Depth image and <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> image to PointCloudXYZRGBA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>the input depth image as intensity points in float </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>the input <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focal</td><td>the focal length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output pointcloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00358">358</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00284">pcl::PointCloud&lt; PointT &gt;::at()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="a28dd2e3220f2c19ff79b9665fd90b94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dd2e3220f2c19ff79b9665fd90b94e">&#9670;&nbsp;</a></span>PointCloudRGBtoI() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointCloudRGBtoI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_intensity.html">Intensity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud to an <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a> point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00248">248</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="point__types__conversion_8h_source.html#l00070">PointRGBtoI()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="a0c7dd592ee87bfcb46f923a5e1465922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7dd592ee87bfcb46f923a5e1465922">&#9670;&nbsp;</a></span>PointCloudRGBtoI() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointCloudRGBtoI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_intensity32u.html">Intensity32u</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud to an <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a> point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00284">284</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="point__types__conversion_8h_source.html#l00070">PointRGBtoI()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="aaea9b6d24e68456c7827fcade6f32e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea9b6d24e68456c7827fcade6f32e39">&#9670;&nbsp;</a></span>PointCloudRGBtoI() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointCloudRGBtoI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_intensity8u.html">Intensity8u</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud to an <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a> point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00266">266</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="point__types__conversion_8h_source.html#l00070">PointRGBtoI()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="a4c3f94312acc1926da5f1ab7174e9b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3f94312acc1926da5f1ab7174e9b79">&#9670;&nbsp;</a></span>PointCloudXYZRGBAtoXYZHSV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointCloudXYZRGBAtoXYZHSV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a XYZRGB point cloud to a XYZHSV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input XYZRGB point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output XYZHSV point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00320">320</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="point__types__conversion_8h_source.html#l00143">PointXYZRGBAtoXYZHSV()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="aeb9b69a70749ba22828986131fb9b2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9b69a70749ba22828986131fb9b2d9">&#9670;&nbsp;</a></span>PointCloudXYZRGBtoXYZHSV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointCloudXYZRGBtoXYZHSV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a XYZRGB point cloud to a XYZHSV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input XYZRGB point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output XYZHSV point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00302">302</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="point__types__conversion_8h_source.html#l00105">PointXYZRGBtoXYZHSV()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="af55e56a236bab4680054f866be7396c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55e56a236bab4680054f866be7396c2">&#9670;&nbsp;</a></span>PointCloudXYZRGBtoXYZI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointCloudXYZRGBtoXYZI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_i.html">PointXYZI</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a XYZRGB point cloud to a XYZI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input XYZRGB point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output XYZI point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00338">338</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="point__types__conversion_8h_source.html#l00058">PointXYZRGBtoXYZI()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ab8711ab975e8f5ee58602540bab56c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8711ab975e8f5ee58602540bab56c63">&#9670;&nbsp;</a></span>PointRGBtoI() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointRGBtoI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_intensity.html">Intensity</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point type to a I. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a> point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00070">70</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="point__types__conversion_8h_source.html#l00248">PointCloudRGBtoI()</a>.</p>

</div>
</div>
<a id="a3428719f9ea8012a746c56929fd3d331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3428719f9ea8012a746c56929fd3d331">&#9670;&nbsp;</a></span>PointRGBtoI() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointRGBtoI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_intensity32u.html">Intensity32u</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point type to a I. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a> point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00093">93</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

</div>
</div>
<a id="adb0c42f809f6b1a1a74460b4e7e29284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0c42f809f6b1a1a74460b4e7e29284">&#9670;&nbsp;</a></span>PointRGBtoI() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointRGBtoI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_r_g_b.html">RGB</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_intensity8u.html">Intensity8u</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point type to a I. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output <a class="el" href="structpcl_1_1_intensity.html" title="A point structure representing the grayscale intensity in single-channel images.">Intensity</a> point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00081">81</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

</div>
</div>
<a id="a688582cb4b66085025fb42e354ac37fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688582cb4b66085025fb42e354ac37fa">&#9670;&nbsp;</a></span>PointXYZHSVtoXYZRGB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointXYZHSVtoXYZRGB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00180">180</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="point__types_8hpp_source.html#l00700">pcl::_PointXYZHSV::h</a>, <a class="el" href="point__types_8hpp_source.html#l00701">pcl::_PointXYZHSV::s</a>, and <a class="el" href="point__types_8hpp_source.html#l00702">pcl::_PointXYZHSV::v</a>.</p>

</div>
</div>
<a id="a73954cca0b970cb4aae7db33a568998a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73954cca0b970cb4aae7db33a568998a">&#9670;&nbsp;</a></span>PointXYZRGBAtoXYZHSV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointXYZRGBAtoXYZHSV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">PointXYZRGBA</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a XYZRGBA point type to a XYZHSV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input XYZRGBA point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output XYZHSV point </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>include the A parameter but how? </dd></dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00143">143</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="point__types_8hpp_source.html#l00700">pcl::_PointXYZHSV::h</a>, <a class="el" href="point__types_8hpp_source.html#l00701">pcl::_PointXYZHSV::s</a>, and <a class="el" href="point__types_8hpp_source.html#l00702">pcl::_PointXYZHSV::v</a>.</p>

<p class="reference">Referenced by <a class="el" href="point__types__conversion_8h_source.html#l00320">PointCloudXYZRGBAtoXYZHSV()</a>.</p>

</div>
</div>
<a id="a535c726cf92e7201f369715f9eef5902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535c726cf92e7201f369715f9eef5902">&#9670;&nbsp;</a></span>PointXYZRGBtoXYZHSV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointXYZRGBtoXYZHSV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_h_s_v.html">PointXYZHSV</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a XYZRGB point type to a XYZHSV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input XYZRGB point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output XYZHSV point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00105">105</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="point__types_8hpp_source.html#l00700">pcl::_PointXYZHSV::h</a>, <a class="el" href="point__types_8hpp_source.html#l00701">pcl::_PointXYZHSV::s</a>, and <a class="el" href="point__types_8hpp_source.html#l00702">pcl::_PointXYZHSV::v</a>.</p>

<p class="reference">Referenced by <a class="el" href="point__types__conversion_8h_source.html#l00302">PointCloudXYZRGBtoXYZHSV()</a>, and <a class="el" href="seeded__hue__segmentation_8hpp_source.html#l00046">seededHueSegmentation()</a>.</p>

</div>
</div>
<a id="ae7d33a86f7112fc2695d5644a299e6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d33a86f7112fc2695d5644a299e6bd">&#9670;&nbsp;</a></span>PointXYZRGBtoXYZI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::PointXYZRGBtoXYZI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointXYZRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_i.html">PointXYZI</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a XYZRGB point type to a XYZI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the input XYZRGB point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the output XYZI point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__types__conversion_8h_source.html#l00058">58</a> of file <a class="el" href="point__types__conversion_8h_source.html">point_types_conversion.h</a>.</p>

<p class="reference">References <a class="el" href="point__types_8hpp_source.html#l00456">pcl::_PointXYZI::intensity</a>.</p>

<p class="reference">Referenced by <a class="el" href="point__types__conversion_8h_source.html#l00338">PointCloudXYZRGBtoXYZI()</a>.</p>

</div>
</div>
<a id="a23810514c001fdc966f3db72456ee128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23810514c001fdc966f3db72456ee128">&#9670;&nbsp;</a></span>projectPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::projectPoint </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>model_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project a point on a planar model given by a set of normalized coefficients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the input point to project </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_coefficients</td><td>the coefficients of the plane (a, b, c, d) that satisfy ax+by+cz+d=0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>the resultant projected point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sample__consensus_2include_2pcl_2sample__consensus_2sac__model__plane_8h_source.html#l00055">55</a> of file <a class="el" href="sample__consensus_2include_2pcl_2sample__consensus_2sac__model__plane_8h_source.html">sac_model_plane.h</a>.</p>

</div>
</div>
<a id="a11183c5f2385e531fb9f4d323d629c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11183c5f2385e531fb9f4d323d629c39">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading data from a stream. </p>

<p class="definition">Definition at line <a class="el" href="region__xy_8h_source.html#l00046">46</a> of file <a class="el" href="region__xy_8h_source.html">region_xy.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="dense__quantized__multi__mod__template_8h_source.html#l00063">pcl::DenseQuantizedSingleModTemplate::deserialize()</a>, <a class="el" href="sparse__quantized__multi__mod__template_8h_source.html#l00096">pcl::QuantizedMultiModFeature::deserialize()</a>, <a class="el" href="dense__quantized__multi__mod__template_8h_source.html#l00098">pcl::DenseQuantizedMultiModTemplate::deserialize()</a>, <a class="el" href="region__xy_8h_source.html#l00109">pcl::RegionXY::deserialize()</a>, <a class="el" href="sparse__quantized__multi__mod__template_8h_source.html#l00137">pcl::SparseQuantizedMultiModTemplate::deserialize()</a>, <a class="el" href="region__xy_8h_source.html#l00053">read()</a>, <a class="el" href="vector_8hpp_source.html#l00249">pcl::poisson::Vector&lt; T &gt;::read()</a>, <a class="el" href="sparse__matrix_8hpp_source.html#l00126">pcl::poisson::SparseMatrix&lt; T &gt;::read()</a>, <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00123">pcl::FileReader::read()</a>, <a class="el" href="ifs__io_8h_source.html#l00124">pcl::IFSReader::read()</a>, <a class="el" href="ply__io_8h_source.html#l00184">pcl::PLYReader::read()</a>, <a class="el" href="obj__io_8h_source.html#l00232">pcl::OBJReader::read()</a>, and <a class="el" href="pcd__io_8h_source.html#l00276">pcl::PCDReader::read()</a>.</p>

</div>
</div>
<a id="a0d824ba34337b87d2c56385523965543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d824ba34337b87d2c56385523965543">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading data arrays from a stream. </p>

<p class="definition">Definition at line <a class="el" href="region__xy_8h_source.html#l00053">53</a> of file <a class="el" href="region__xy_8h_source.html">region_xy.h</a>.</p>

<p class="reference">References <a class="el" href="region__xy_8h_source.html#l00046">read()</a>.</p>

</div>
</div>
<a id="a0d10806d2fbd7a668419758e64a49b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10806d2fbd7a668419758e64a49b04">&#9670;&nbsp;</a></span>setFieldValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename ValT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::setFieldValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>field_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValT &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value at a specified field in a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pt</td><td>the point to set the value to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_offset</td><td>the offset of the field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to set </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00227">227</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a4e51fd3658ed051b4f6cc0c0340bde2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e51fd3658ed051b4f6cc0c0340bde2c">&#9670;&nbsp;</a></span>squaredEuclideanDistance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float pcl::squaredEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1segmentation_1_1grabcut_1_1_color.html">pcl::segmentation::grabcut::Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1segmentation_1_1grabcut_1_1_color.html">pcl::segmentation::grabcut::Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grabcut__segmentation_8hpp_source.html#l00050">50</a> of file <a class="el" href="grabcut__segmentation_8hpp_source.html">grabcut_segmentation.hpp</a>.</p>

<p class="reference">References <a class="el" href="grabcut__segmentation_8h_source.html#l00186">pcl::segmentation::grabcut::Color::b</a>, <a class="el" href="grabcut__segmentation_8h_source.html#l00186">pcl::segmentation::grabcut::Color::g</a>, and <a class="el" href="grabcut__segmentation_8h_source.html#l00186">pcl::segmentation::grabcut::Color::r</a>.</p>

</div>
</div>
<a id="a28ecc173df18d9175dee9f4dd042390b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ecc173df18d9175dee9f4dd042390b">&#9670;&nbsp;</a></span>squaredEuclideanDistance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType1 , typename PointType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::squaredEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">const PointType1 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointType2 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the squared euclidean distance between the two given points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>the second point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00179">179</a> of file <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html">distances.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="pyramid_8hpp_source.html#l00098">pcl::filters::Pyramid&lt; PointT &gt;::compute()</a>, <a class="el" href="grabcut__segmentation_8hpp_source.html#l00386">pcl::GrabCut&lt; PointT &gt;::computeBetaNonOrganized()</a>, <a class="el" href="grabcut__segmentation_8hpp_source.html#l00425">pcl::GrabCut&lt; PointT &gt;::computeBetaOrganized()</a>, <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00201">euclideanDistance()</a>, <a class="el" href="range__image_8hpp_source.html#l00842">pcl::RangeImage::getEuclideanDistanceSquared()</a>, <a class="el" href="range__image_8hpp_source.html#l00620">pcl::RangeImage::getImpactAngle()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00070">pcl::RangeImageBorderExtractor::getNeighborDistanceChangeScore()</a>, <a class="el" href="range__image_8hpp_source.html#l01052">pcl::RangeImage::getSquaredDistanceOfNthNeighbor()</a>, <a class="el" href="range__image_8hpp_source.html#l00965">pcl::RangeImage::getSurfaceInformation()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00767">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, pcl::Normal, float &gt;::linkMatchWithBase()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00341">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, pcl::Normal, float &gt;::selectBase()</a>, <a class="el" href="surfel__smoothing_8hpp_source.html#l00082">pcl::SurfelSmoothing&lt; PointT, PointNT &gt;::smoothCloudIteration()</a>, and <a class="el" href="ia__fpcs_8hpp_source.html#l00819">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, pcl::Normal, float &gt;::validateMatch()</a>.</p>

</div>
</div>
<a id="acce728864fe6aa3af8783cb0a963a4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce728864fe6aa3af8783cb0a963a4b1">&#9670;&nbsp;</a></span>squaredEuclideanDistance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::squaredEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y.html">PointXY</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y.html">PointXY</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the squared euclidean distance between the two given points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>the second point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00190">190</a> of file <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html">distances.h</a>.</p>

<p class="reference">References <a class="el" href="point__types_8hpp_source.html#l00746">pcl::PointXY::x</a>, and <a class="el" href="point__types_8hpp_source.html#l00747">pcl::PointXY::y</a>.</p>

</div>
</div>
<a id="a2602bbf77a4278ada7b16d88fd35d7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2602bbf77a4278ada7b16d88fd35d7b3">&#9670;&nbsp;</a></span>threePlanesIntersection() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::threePlanesIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersection_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>determinant_tolerance</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the point of intersection of three non-parallel planes by solving the equations. </p>
<dl class="section note"><dt>Note</dt><dd>If using nearly parallel planes you can lower the determinant_tolerance value. This can lead to inconsistent results. If the three planes intersects in a line the point will be anywhere on the line. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_a</td><td>are the coefficients of the first plane in the form ax + by + cz + d = 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_b</td><td>are the coefficients of the second plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_c</td><td>are the coefficients of the third plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">determinant_tolerance</td><td>is a limit to determine whether planes are parallel or not </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection_point</td><td>the three coordinates x, y, z of the intersection point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeded/planes aren't parallel </dd></dl>

<p class="definition">Definition at line <a class="el" href="intersections_8hpp_source.html#l00127">127</a> of file <a class="el" href="intersections_8hpp_source.html">intersections.hpp</a>.</p>

</div>
</div>
<a id="ac2056989ddf42f3c88d85b4d0e5c79a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2056989ddf42f3c88d85b4d0e5c79a7">&#9670;&nbsp;</a></span>threePlanesIntersection() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::threePlanesIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersection_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>determinant_tolerance</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the point of intersection of three non-parallel planes by solving the equations. </p>
<dl class="section note"><dt>Note</dt><dd>If using nearly parallel planes you can lower the determinant_tolerance value. This can lead to inconsistent results. If the three planes intersects in a line the point will be anywhere on the line. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_a</td><td>are the coefficients of the first plane in the form ax + by + cz + d = 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_b</td><td>are the coefficients of the second plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_c</td><td>are the coefficients of the third plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">determinant_tolerance</td><td>is a limit to determine whether planes are parallel or not </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection_point</td><td>the three coordinates x, y, z of the intersection point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeded/planes aren't parallel </dd></dl>

<p class="definition">Definition at line <a class="el" href="intersections_8hpp_source.html#l00127">127</a> of file <a class="el" href="intersections_8hpp_source.html">intersections.hpp</a>.</p>

</div>
</div>
<a id="a64550b12c7a235265268291080372169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64550b12c7a235265268291080372169">&#9670;&nbsp;</a></span>threePlanesIntersection() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::threePlanesIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>plane_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>plane_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>plane_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>intersection_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>determinant_tolerance</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intersections_8h_source.html#l00144">144</a> of file <a class="el" href="intersections_8h_source.html">intersections.h</a>.</p>

</div>
</div>
<a id="aecefc6e2d9503d55e2433ef05006a7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecefc6e2d9503d55e2433ef05006a7c7">&#9670;&nbsp;</a></span>threePlanesIntersection() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::threePlanesIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>plane_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>plane_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>plane_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>intersection_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>determinant_tolerance</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intersections_8h_source.html#l00133">133</a> of file <a class="el" href="intersections_8h_source.html">intersections.h</a>.</p>

</div>
</div>
<a id="acac1ad597aa12ea57af7b3095abf30f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac1ad597aa12ea57af7b3095abf30f7">&#9670;&nbsp;</a></span>toPCLPointCloud2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CloudT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::toPCLPointCloud2 </td>
          <td>(</td>
          <td class="paramtype">const CloudT &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> fields of a <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> into <a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>the resultant <a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> CloudT cloud type, CloudT should be akin to pcl::PointCloud&lt;pcl::PointXYZRGBA&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>will throw std::runtime_error if there is a problem </dd></dl>

<p class="definition">Definition at line <a class="el" href="conversions_8h_source.html#l00282">282</a> of file <a class="el" href="conversions_8h_source.html">conversions.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_image_8h_source.html#l00022">pcl::PCLImage::data</a>, <a class="el" href="_p_c_l_image_8h_source.html#l00017">pcl::PCLImage::encoding</a>, <a class="el" href="_p_c_l_image_8h_source.html#l00015">pcl::PCLImage::height</a>, <a class="el" href="_p_c_l_image_8h_source.html#l00020">pcl::PCLImage::step</a>, and <a class="el" href="_p_c_l_image_8h_source.html#l00016">pcl::PCLImage::width</a>.</p>

</div>
</div>
<a id="ad27d2fbd536cc9ea7cf83412ce71db08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27d2fbd536cc9ea7cf83412ce71db08">&#9670;&nbsp;</a></span>toPCLPointCloud2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::toPCLPointCloud2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> fields of a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> msg into <a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramname">msg</td><td>the resultant <a class="el" href="structpcl_1_1_p_c_l_image.html">pcl::PCLImage</a> will throw std::runtime_error if there is a problem </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_8h_source.html#l00315">315</a> of file <a class="el" href="conversions_8h_source.html">conversions.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_image_8h_source.html#l00022">pcl::PCLImage::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>, <a class="el" href="_p_c_l_image_8h_source.html#l00017">pcl::PCLImage::encoding</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>, <a class="el" href="_p_c_l_image_8h_source.html#l00015">pcl::PCLImage::height</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00019">pcl::PCLPointCloud2::height</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00026">pcl::PCLPointCloud2::point_step</a>, <a class="el" href="_p_c_l_image_8h_source.html#l00020">pcl::PCLImage::step</a>, <a class="el" href="_p_c_l_image_8h_source.html#l00016">pcl::PCLImage::width</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00020">pcl::PCLPointCloud2::width</a>.</p>

</div>
</div>
<a id="a71ae5cefc55b6418e1389136c8e8ee96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ae5cefc55b6418e1389136c8e8ee96">&#9670;&nbsp;</a></span>toPCLPointCloud2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::toPCLPointCloud2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a pcl::PointCloud&lt;T&gt; object to a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary data blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input pcl::PointCloud&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>the resultant <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> binary blob </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>msg.is_bigendian = ?; </dd></dl>

<p class="definition">Definition at line <a class="el" href="conversions_8h_source.html#l00241">241</a> of file <a class="el" href="conversions_8h_source.html">conversions.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00029">pcl::PCLPointCloud2::data</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00022">pcl::PCLPointCloud2::fields</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00017">pcl::PCLPointCloud2::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00019">pcl::PCLPointCloud2::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00031">pcl::PCLPointCloud2::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00026">pcl::PCLPointCloud2::point_step</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00027">pcl::PCLPointCloud2::row_step</a>, <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00020">pcl::PCLPointCloud2::width</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="joint__icp_8hpp_source.html#l00051">pcl::JointIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::computeTransformation()</a>, <a class="el" href="icp_8hpp_source.html#l00121">pcl::IterativeClosestPoint&lt; PointSource, PointTarget &gt;::computeTransformation()</a>, <a class="el" href="standalone__marching__cubes_8hpp_source.html#l00218">pcl::gpu::kinfuLS::StandaloneMarchingCubes&lt; PointT &gt;::convertTrianglesToMesh()</a>, <a class="el" href="standalone__marching__cubes_8hpp_source.html#l00094">pcl::gpu::kinfuLS::StandaloneMarchingCubes&lt; PointT &gt;::getMeshesFromTSDFVector()</a>, <a class="el" href="poisson_8hpp_source.html#l00152">pcl::Poisson&lt; PointNT &gt;::performReconstruction()</a>, <a class="el" href="concave__hull_8hpp_source.html#l00590">pcl::ConcaveHull&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="grid__projection_8hpp_source.html#l00723">pcl::GridProjection&lt; PointNT &gt;::performReconstruction()</a>, <a class="el" href="convex__hull_8hpp_source.html#l00459">pcl::ConvexHull&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="marching__cubes_8hpp_source.html#l00208">pcl::MarchingCubes&lt; PointNT &gt;::performReconstruction()</a>, <a class="el" href="reconstruction_8hpp_source.html#l00050">pcl::SurfaceReconstruction&lt; PointNT &gt;::reconstruct()</a>, <a class="el" href="reconstruction_8hpp_source.html#l00130">pcl::MeshConstruction&lt; PointInT &gt;::reconstruct()</a>, <a class="el" href="mesh__conversion_8h_source.html#l00057">pcl::geometry::toFaceVertexMesh()</a>, <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00208">pcl::FileWriter::write()</a>, and <a class="el" href="ply__io_8h_source.html#l00694">pcl::PLYWriter::write()</a>.</p>

</div>
</div>
<a id="a2cc8393db8572b2e75f7dc880315d04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc8393db8572b2e75f7dc880315d04c">&#9670;&nbsp;</a></span>transformBetween2CoordinateSystems() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::transformBetween2CoordinateSystems </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>from_line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>from_line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>to_line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>to_line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Transform&lt; double, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00695">695</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a040e5a468379787b82aa58540cda0a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040e5a468379787b82aa58540cda0a8e">&#9670;&nbsp;</a></span>transformBetween2CoordinateSystems() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::transformBetween2CoordinateSystems </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>from_line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>from_line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>to_line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>to_line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Transform&lt; float, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00705">705</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a71ec11d4f29c5c8a5b6220c0838a294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ec11d4f29c5c8a5b6220c0838a294f">&#9670;&nbsp;</a></span>transformBetween2CoordinateSystems() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::transformBetween2CoordinateSystems </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>from_line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>from_line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>to_line_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td>
          <td class="paramname"><em>to_line_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the transformation between two coordinate systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_line_x</td><td>X axis from the origin coordinate system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_line_y</td><td>Y axis from the origin coordinate system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_line_x</td><td>X axis from the destination coordinate system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_line_y</td><td>Y axis from the destination coordinate system </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transformation</td><td>the transformation matrix to fill </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if transformation was filled, false otherwise.</dd></dl>
<p>Line must be filled in this form:<br  />
line[0-2] = Coordinate system origin coordinates <br  />
line[3-5] = Direction vector (norm doesn't matter) </p>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00854">854</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00788">checkCoordinateSystem()</a>.</p>

</div>
</div>
<a id="a76fd28edbb46c951a2ed1da38c32ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fd28edbb46c951a2ed1da38c32ec86">&#9670;&nbsp;</a></span>transformLine() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::transformLine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a line using an affine matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">line_in</td><td>the line to be transformed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">line_out</td><td>the transformed line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transformation</td><td>the transformation matrix</td></tr>
  </table>
  </dd>
</dl>
<p>Lines must be filled in this form:<br  />
line[0-2] = Origin coordinates of the vector<br  />
line[3-5] = Direction vector</p>
<dl class="section note"><dt>Note</dt><dd>Can be used with <code>line_in</code> = <code>line_out</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00736">736</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00423">transformPoint()</a>, and <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00456">transformVector()</a>.</p>

</div>
</div>
<a id="a2fd0ac90e227ddbac62b981045f7ee76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd0ac90e227ddbac62b981045f7ee76">&#9670;&nbsp;</a></span>transformLine() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::transformLine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>line_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>line_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3d &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00504">504</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a997d49a6f1c11be29bf3db6a7ad1c93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997d49a6f1c11be29bf3db6a7ad1c93b">&#9670;&nbsp;</a></span>transformLine() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::transformLine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>line_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>line_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00496">496</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a667af5d4074fc5bf917549b1ecc28ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667af5d4074fc5bf917549b1ecc28ea6">&#9670;&nbsp;</a></span>transformPlane() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPlane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; double, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00526">526</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a51632e4157f725102a3ae373981eab8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51632e4157f725102a3ae373981eab8c">&#9670;&nbsp;</a></span>transformPlane() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPlane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; float, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; float, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00534">534</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a350ec0c9c7e7fbac1581dc01db77d5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350ec0c9c7e7fbac1581dc01db77d5e6">&#9670;&nbsp;</a></span>transformPlane() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPlane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform plane vectors using an affine matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_in</td><td>the plane coefficients to be transformed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plane_out</td><td>the transformed plane coefficients to fill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transformation</td><td>the transformation matrix</td></tr>
  </table>
  </dd>
</dl>
<p>The plane vectors are filled in the form ax+by+cz+d=0 Can be used with non Hessian form planes coefficients Can be used with <code>plane_in</code> = <code>plane_out</code> </p>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00758">758</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00775">transformPlane()</a>.</p>

</div>
</div>
<a id="ab41234b4e47f34a90944122bc441ebda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41234b4e47f34a90944122bc441ebda">&#9670;&nbsp;</a></span>transformPlane() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a>&#160;</td>
          <td class="paramname"><em>plane_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a>&#160;</td>
          <td class="paramname"><em>plane_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; double, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00557">557</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a8a18cf3648dc9cc2d0889d1616c4ca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18cf3648dc9cc2d0889d1616c4ca8f">&#9670;&nbsp;</a></span>transformPlane() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a>&#160;</td>
          <td class="paramname"><em>plane_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a>&#160;</td>
          <td class="paramname"><em>plane_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; float, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00565">565</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a08ce9e89d1fd409e8e2217da8d3b3c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ce9e89d1fd409e8e2217da8d3b3c8a">&#9670;&nbsp;</a></span>transformPlane() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a>&#160;</td>
          <td class="paramname"><em>plane_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_model_coefficients.html#a216734124e133bb3e171ab7bf5935dcd">pcl::ModelCoefficients::Ptr</a>&#160;</td>
          <td class="paramname"><em>plane_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform plane vectors using an affine matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_in</td><td>the plane coefficients to be transformed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plane_out</td><td>the transformed plane coefficients to fill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transformation</td><td>the transformation matrix</td></tr>
  </table>
  </dd>
</dl>
<p>The plane vectors are filled in the form ax+by+cz+d=0 Can be used with non Hessian form planes coefficients Can be used with <code>plane_in</code> = <code>plane_out</code> </p><dl class="section warning"><dt>Warning</dt><dd><a class="el" href="structpcl_1_1_model_coefficients.html">ModelCoefficients</a> stores floats only ! </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00775">775</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00758">transformPlane()</a>.</p>

</div>
</div>
<a id="a5a5b5b7345fac388db975e1eb5577628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5b5b7345fac388db975e1eb5577628">&#9670;&nbsp;</a></span>transformPoint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a point using an affine matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_in</td><td>the vector to be transformed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point_out</td><td>the transformed vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transformation</td><td>the transformation matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used with <code>point_in</code> = <code>point_out</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00423">423</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00736">transformLine()</a>.</p>

</div>
</div>
<a id="a78eee91f5fe85181edebfcdf871109cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78eee91f5fe85181edebfcdf871109cb">&#9670;&nbsp;</a></span>transformPoint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>point_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>point_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3d &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00441">441</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aeacbba9c2228c2dc21aa4aa3e2fb5b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacbba9c2228c2dc21aa4aa3e2fb5b03">&#9670;&nbsp;</a></span>transformPoint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00433">433</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a6eebb98525a1ce95bdf822c892e9f897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eebb98525a1ce95bdf822c892e9f897">&#9670;&nbsp;</a></span>transformPoint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> pcl::transformPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00456">456</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a6a3230afc385ffd571b5697cbcb1772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3230afc385ffd571b5697cbcb1772d">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00091">91</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a861030ddf3bd17ed84672785fc9c4472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861030ddf3bd17ed84672785fc9c4472">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00258">258</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a98254c7dd344ae3907cc5ab149ecd046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98254c7dd344ae3907cc5ab149ecd046">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00120">120</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="aaef7fc8ea3f5d9784d15586eec0d5c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef7fc8ea3f5d9784d15586eec0d5c77">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00287">287</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a1ab6dcd277c78349b0e2fbc93c685589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab6dcd277c78349b0e2fbc93c685589">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00066">66</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="aefbe4956d1c8fb785a97df6708d57c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbe4956d1c8fb785a97df6708d57c56">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00229">229</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="aad58c0696cdc30b705ab4dac46fa4898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad58c0696cdc30b705ab4dac46fa4898">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternionf &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00409">409</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="afae7b7ff14e3fc9919d117bffa0398ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae7b7ff14e3fc9919d117bffa0398ad">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00170">170</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a4b7674476fbb6b9b66c00883721a18e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7674476fbb6b9b66c00883721a18e0">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00350">350</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="ab3eede6083fd2722d5b1f3d241c3d126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3eede6083fd2722d5b1f3d241c3d126">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z, normal_x, normal_y, normal_z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00360">360</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="transforms_8hpp_source.html#l00091">pcl::detail::Transformer&lt; Scalar &gt;::se3()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00424">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00422">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="transforms_8hpp_source.html#l00079">pcl::detail::Transformer&lt; Scalar &gt;::so3()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="a7d49d40760b5f64b82295e7d50e67f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d49d40760b5f64b82295e7d50e67f66">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00200">200</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a310b1980cf614a10ed3be69930267431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310b1980cf614a10ed3be69930267431">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00383">383</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a2010514a42ccb4cb04eb47d5920de6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2010514a42ccb4cb04eb47d5920de6e5">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z, normal_x, normal_y, normal_z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00189">189</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

<p class="reference">References <a class="el" href="_point_indices_8h_source.html#l00023">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="a747aa1efb26bb28eb16a5a8495167f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747aa1efb26bb28eb16a5a8495167f59">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00145">145</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a9c6c26cfe6720871853f991ba2013fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6c26cfe6720871853f991ba2013fdf">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00318">318</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a41bb12134125eaf406cc32e1939f4c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bb12134125eaf406cc32e1939f4c60">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z, normal_x, normal_y, normal_z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used with cloud_in equal to cloud_out </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00312">312</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="transforms_8hpp_source.html#l00091">pcl::detail::Transformer&lt; Scalar &gt;::se3()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00424">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00422">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="transforms_8hpp_source.html#l00079">pcl::detail::Transformer&lt; Scalar &gt;::so3()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="icp_8hpp_source.html#l00294">pcl::IterativeClosestPointWithNormals&lt; PointSource, PointTarget, Scalar &gt;::transformCloud()</a>, and <a class="el" href="transforms_8hpp_source.html#l00425">transformPointCloudWithNormals()</a>.</p>

</div>
</div>
<a id="a0190c799174d6565db2994f9b4f0898d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0190c799174d6565db2994f9b4f0898d">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternionf &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00436">436</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="aadb382fa277fd5e69472ec3c878e6692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb382fa277fd5e69472ec3c878e6692">&#9670;&nbsp;</a></span>transformPointWithNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> pcl::transformPointWithNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html#l00473">473</a> of file <a class="el" href="common_2include_2pcl_2common_2transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="a63a9da67d327b4940e73e18fd2970775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a9da67d327b4940e73e18fd2970775">&#9670;&nbsp;</a></span>transformVector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a vector using an affine matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vector_in</td><td>the vector to be transformed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vector_out</td><td>the transformed vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transformation</td><td>the transformation matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used with <code>vector_in</code> = <code>vector_out</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00456">456</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00736">transformLine()</a>.</p>

</div>
</div>
<a id="ade2183a5dca6c3c71d150d44bf7a042f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2183a5dca6c3c71d150d44bf7a042f">&#9670;&nbsp;</a></span>transformVector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vector_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vector_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3d &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00472">472</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ae310fc96b4f9e6829d99c6a873ac4b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae310fc96b4f9e6829d99c6a873ac4b10">&#9670;&nbsp;</a></span>transformVector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vector_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vector_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00464">464</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a65861ea96a34a05b42fea5ada648c8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65861ea96a34a05b42fea5ada648c8bf">&#9670;&nbsp;</a></span>umeyama()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::internal::umeyama_transform_matrix_type&lt; Derived, OtherDerived &gt;::type pcl::umeyama </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_scaling</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the transformation between two point sets. </p>
<p>The algorithm is based on: "Least-squares estimation of transformation parameters between two point patterns", Shinji Umeyama, PAMI 1991, DOI: 10.1109/34.88573</p>
<p>It estimates parameters <img class="formulaInl" alt="$ c, \mathbf{R}, $" src="form_2.png"/> and <img class="formulaInl" alt="$ \mathbf{t} $" src="form_3.png"/> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \frac{1}{n} \sum_{i=1}^n \vert\vert y_i - (c\mathbf{R}x_i + \mathbf{t}) \vert\vert_2^2 \end{align*}" src="form_4.png"/>
</p>
<p> is minimized.</p>
<p>The algorithm is based on the analysis of the covariance matrix <img class="formulaInl" alt="$ \Sigma_{\mathbf{x}\mathbf{y}} \in \mathbb{R}^{d \times d} $" src="form_5.png"/> of the input point sets <img class="formulaInl" alt="$ \mathbf{x} $" src="form_6.png"/> and <img class="formulaInl" alt="$ \mathbf{y} $" src="form_7.png"/> where <img class="formulaInl" alt="$d$" src="form_8.png"/> is corresponding to the dimension (which is typically small). The analysis is involving the SVD having a complexity of <img class="formulaInl" alt="$O(d^3)$" src="form_9.png"/> though the actual computational effort lies in the covariance matrix computation which has an asymptotic lower bound of <img class="formulaInl" alt="$O(dm)$" src="form_10.png"/> when the input point sets have dimension <img class="formulaInl" alt="$d \times m$" src="form_11.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source points <img class="formulaInl" alt="$ \mathbf{x} = \left( x_1, \hdots, x_n \right) $" src="form_12.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Destination points <img class="formulaInl" alt="$ \mathbf{y} = \left( y_1, \hdots, y_n \right) $" src="form_13.png"/>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_scaling</td><td>Sets <img class="formulaInl" alt="$ c=1 $" src="form_14.png"/> when <code>false</code> is passed. (default: false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The homogeneous transformation <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} T = \begin{bmatrix} c\mathbf{R} &amp; \mathbf{t} \\ \mathbf{0} &amp; 1 \end{bmatrix} \end{align*}" src="form_15.png"/>
</p>
 minimizing the resudiual above. This transformation is always returned as an Eigen::Matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00660">660</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="transformation__estimation__svd_8hpp_source.html#l00125">pcl::registration::TransformationEstimationSVD&lt; PointT, PointT, Scalar &gt;::estimateRigidTransformation()</a>, and <a class="el" href="sac__model__registration_8hpp_source.html#l00276">pcl::SampleConsensusModelRegistration&lt; PointT &gt;::estimateRigidTransformationSVD()</a>.</p>

</div>
</div>
<a id="a3a8ed85949c0e5ee02fac957cd7b3196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8ed85949c0e5ee02fac957cd7b3196">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing data arrays to a stream. </p>

<p class="definition">Definition at line <a class="el" href="region__xy_8h_source.html#l00070">70</a> of file <a class="el" href="region__xy_8h_source.html">region_xy.h</a>.</p>

<p class="reference">References <a class="el" href="region__xy_8h_source.html#l00063">write()</a>.</p>

</div>
</div>
<a id="abc72ecd1c10de3620edb3e5a419d77d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc72ecd1c10de3620edb3e5a419d77d5">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing data to a stream. </p>

<p class="definition">Definition at line <a class="el" href="region__xy_8h_source.html#l00063">63</a> of file <a class="el" href="region__xy_8h_source.html">region_xy.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="dense__quantized__multi__mod__template_8h_source.html#l00052">pcl::DenseQuantizedSingleModTemplate::serialize()</a>, <a class="el" href="sparse__quantized__multi__mod__template_8h_source.html#l00085">pcl::QuantizedMultiModFeature::serialize()</a>, <a class="el" href="dense__quantized__multi__mod__template_8h_source.html#l00085">pcl::DenseQuantizedMultiModTemplate::serialize()</a>, <a class="el" href="region__xy_8h_source.html#l00098">pcl::RegionXY::serialize()</a>, <a class="el" href="sparse__quantized__multi__mod__template_8h_source.html#l00122">pcl::SparseQuantizedMultiModTemplate::serialize()</a>, <a class="el" href="region__xy_8h_source.html#l00070">write()</a>, <a class="el" href="vector_8hpp_source.html#l00258">pcl::poisson::Vector&lt; T &gt;::write()</a>, <a class="el" href="sparse__matrix_8hpp_source.html#l00117">pcl::poisson::SparseMatrix&lt; T &gt;::write()</a>, <a class="el" href="ifs__io_8h_source.html#l00172">pcl::IFSWriter::write()</a>, <a class="el" href="io_2include_2pcl_2io_2file__io_8h_source.html#l00193">pcl::FileWriter::write()</a>, <a class="el" href="lzf__image__io_8h_source.html#l00415">pcl::io::LZFImageWriter::write()</a>, <a class="el" href="pcd__io_8h_source.html#l00478">pcl::PCDWriter::write()</a>, and <a class="el" href="ply__io_8h_source.html#l00676">pcl::PLYWriter::write()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af46e561a1ed94889f2d0b343293087e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46e561a1ed94889f2d0b343293087e5">&#9670;&nbsp;</a></span>edgeTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int pcl::edgeTable[256]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="surface_2include_2pcl_2surface_2marching__cubes_8h_source.html#l00060">60</a> of file <a class="el" href="surface_2include_2pcl_2surface_2marching__cubes_8h_source.html">marching_cubes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="marching__cubes_8hpp_source.html#l00083">pcl::MarchingCubes&lt; PointNT &gt;::createSurface()</a>.</p>

</div>
</div>
<a id="ad42bfadb1ac9576b4390c409f29bbbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42bfadb1ac9576b4390c409f29bbbd1">&#9670;&nbsp;</a></span>I_SHIFT_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int pcl::I_SHIFT_EDGE[3][2]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {0,1}, {1,3}, {1,2}</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00060">60</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="grid__projection_8hpp_source.html#l00175">pcl::GridProjection&lt; PointNT &gt;::createSurfaceForCell()</a>.</p>

</div>
</div>
<a id="aca325832bef94391fd46c45a952081ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca325832bef94391fd46c45a952081ea">&#9670;&nbsp;</a></span>I_SHIFT_EP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int pcl::I_SHIFT_EP[12][2]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {0, 4}, {1, 5}, {2, 6}, {3, 7}, </div>
<div class="line">    {0, 1}, {1, 2}, {2, 3}, {3, 0},</div>
<div class="line">    {4, 5}, {5, 6}, {6, 7}, {7, 4}</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>The 12 edges of a cell. </p>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00050">50</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a84721a0872dda8ea38b5f3fd306c88f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84721a0872dda8ea38b5f3fd306c88f8">&#9670;&nbsp;</a></span>I_SHIFT_PT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int pcl::I_SHIFT_PT[4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0, 4, 5, 7</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00056">56</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="grid__projection_8hpp_source.html#l00175">pcl::GridProjection&lt; PointNT &gt;::createSurfaceForCell()</a>.</p>

</div>
</div>
<a id="abec2d9927927653af6d842971d4a514c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec2d9927927653af6d842971d4a514c">&#9670;&nbsp;</a></span>SAC_LMEDS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static int pcl::SAC_LMEDS = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="method__types_8h_source.html#l00046">46</a> of file <a class="el" href="method__types_8h_source.html">method_types.h</a>.</p>

</div>
</div>
<a id="a952325f9e9d892a2c3f0a47cf10351f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952325f9e9d892a2c3f0a47cf10351f4">&#9670;&nbsp;</a></span>SAC_MLESAC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static int pcl::SAC_MLESAC = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="method__types_8h_source.html#l00050">50</a> of file <a class="el" href="method__types_8h_source.html">method_types.h</a>.</p>

</div>
</div>
<a id="a15196d038687c175f9e80d9288cbc2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15196d038687c175f9e80d9288cbc2a7">&#9670;&nbsp;</a></span>SAC_MSAC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static int pcl::SAC_MSAC = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="method__types_8h_source.html#l00047">47</a> of file <a class="el" href="method__types_8h_source.html">method_types.h</a>.</p>

</div>
</div>
<a id="a829773f124635b23ee974e7e145dd3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829773f124635b23ee974e7e145dd3ea">&#9670;&nbsp;</a></span>SAC_PROSAC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static int pcl::SAC_PROSAC = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="method__types_8h_source.html#l00051">51</a> of file <a class="el" href="method__types_8h_source.html">method_types.h</a>.</p>

</div>
</div>
<a id="af681d81612b8475461f95bb45eb458de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af681d81612b8475461f95bb45eb458de">&#9670;&nbsp;</a></span>SAC_RANSAC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static int pcl::SAC_RANSAC = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="method__types_8h_source.html#l00045">45</a> of file <a class="el" href="method__types_8h_source.html">method_types.h</a>.</p>

</div>
</div>
<a id="aab6bb33f62c5027a735f7195d34660b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6bb33f62c5027a735f7195d34660b9">&#9670;&nbsp;</a></span>SAC_RMSAC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static int pcl::SAC_RMSAC = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="method__types_8h_source.html#l00049">49</a> of file <a class="el" href="method__types_8h_source.html">method_types.h</a>.</p>

</div>
</div>
<a id="a939bbfaac918c8fbc2f5a7bcc17e9c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939bbfaac918c8fbc2f5a7bcc17e9c05">&#9670;&nbsp;</a></span>SAC_RRANSAC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static int pcl::SAC_RRANSAC = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="method__types_8h_source.html#l00048">48</a> of file <a class="el" href="method__types_8h_source.html">method_types.h</a>.</p>

</div>
</div>
<a id="afaf90f2950487a5a98d46da99e58ea04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf90f2950487a5a98d46da99e58ea04">&#9670;&nbsp;</a></span>triTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int pcl::triTable[256][16]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="surface_2include_2pcl_2surface_2marching__cubes_8h_source.html#l00094">94</a> of file <a class="el" href="surface_2include_2pcl_2surface_2marching__cubes_8h_source.html">marching_cubes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="marching__cubes_8hpp_source.html#l00083">pcl::MarchingCubes&lt; PointNT &gt;::createSurface()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacepcl_html_ae716f0bdfbc7ae033006733a42fb6b63"><div class="ttname"><a href="namespacepcl.html#ae716f0bdfbc7ae033006733a42fb6b63">pcl::MsgFieldMap</a></div><div class="ttdeci">std::vector&lt; detail::FieldMapping &gt; MsgFieldMap</div><div class="ttdef"><b>Definition:</b> <a href="common_2include_2pcl_2point__cloud_8h_source.html#l00072">point_cloud.h:72</a></div></div>
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Tue Jun 2 2020 14:11:26</p>
</div> <!-- #footer -->
</body>
</html>
