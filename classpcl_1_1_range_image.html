<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): pcl::RangeImage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.14.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1_range_image-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">pcl::RangeImage Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpcl_1_1_range_image.html" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where...">RangeImage</a> is derived from pcl/PointCloud and provides functionalities with focus on situations where a 3D scene was captured from a specific view point.  
 <a href="classpcl_1_1_range_image.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="range__image_8h_source.html">pcl/range_image/range_image.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for pcl::RangeImage:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classpcl_1_1_range_image__inherit__graph.png" border="0" usemap="#apcl_1_1_range_image_inherit__map" alt="Inheritance graph"/></div>
<map name="apcl_1_1_range_image_inherit__map" id="apcl_1_1_range_image_inherit__map">
<area shape="rect" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where..." alt="" coords="129,185,259,212"/>
<area shape="rect" href="classpcl_1_1_range_image_planar.html" title="RangeImagePlanar is derived from the original range image and differs from it because it&#39;s not a sphe..." alt="" coords="5,261,177,288"/>
<area shape="rect" href="classpcl_1_1_range_image_spherical.html" title="RangeImageSpherical is derived from the original range image and uses a slightly different spherical ..." alt="" coords="201,261,392,288"/>
<area shape="rect" href="classpcl_1_1_point_cloud.html" title=" " alt="" coords="95,95,293,136"/>
<area shape="rect" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points." alt="" coords="99,5,289,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for pcl::RangeImage:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classpcl_1_1_range_image__coll__graph.png" border="0" usemap="#apcl_1_1_range_image_coll__map" alt="Collaboration graph"/></div>
<map name="apcl_1_1_range_image_coll__map" id="apcl_1_1_range_image_coll__map">
<area shape="rect" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where..." alt="" coords="137,380,268,407"/>
<area shape="rect" href="classpcl_1_1_point_cloud.html" title=" " alt="" coords="5,276,203,317"/>
<area shape="rect" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points." alt="" coords="9,187,199,213"/>
<area shape="rect" title=" " alt="" coords="61,5,136,32"/>
<area shape="rect" href="structpcl_1_1_p_c_l_header.html" title=" " alt="" coords="152,96,272,123"/>
<area shape="rect" title=" " alt="" coords="175,5,249,32"/>
<area shape="rect" href="structpcl_1_1_point_with_range.html" title="A point structure representing Euclidean xyz coordinates, padded with an extra range float." alt="" coords="227,283,381,310"/>
<area shape="rect" href="structpcl_1_1___point_with_range.html" title=" " alt="" coords="224,187,384,213"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8b5785b0499f0a70d5c87fceba55992f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> { <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a> = 0
, <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992faa7e6d8ab63f2359fd25c11db114db19c">LASER_FRAME</a> = 1
 }</td></tr>
<tr class="separator:a8b5785b0499f0a70d5c87fceba55992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa810c2aa68b3e77745e1f98775be5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a9aa810c2aa68b3e77745e1f98775be5b">BaseClass</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt;</td></tr>
<tr class="separator:a9aa810c2aa68b3e77745e1f98775be5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba06f02358b2efee4b98e086068ee6b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aba06f02358b2efee4b98e086068ee6b1">VectorOfEigenVector3f</a> = std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt;</td></tr>
<tr class="separator:aba06f02358b2efee4b98e086068ee6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba0be0fa2c5cbd409547860c68ff9e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a3ba0be0fa2c5cbd409547860c68ff9e8">Ptr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &gt;</td></tr>
<tr class="separator:a3ba0be0fa2c5cbd409547860c68ff9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960ddd0ee536453dc9c042fd4a7754a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a960ddd0ee536453dc9c042fd4a7754a1">ConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &gt;</td></tr>
<tr class="separator:a960ddd0ee536453dc9c042fd4a7754a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_point_cloud"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_point_cloud')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; PointWithRange &gt;</a></td></tr>
<tr class="memitem:a113035c40ca7dd7e0a627d06679fe448 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a113035c40ca7dd7e0a627d06679fe448">PointType</a> = <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a></td></tr>
<tr class="separator:a113035c40ca7dd7e0a627d06679fe448 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45b75e3c8487979f6f77e7df55ada43 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab45b75e3c8487979f6f77e7df55ada43">VectorType</a> = std::vector&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &gt;</td></tr>
<tr class="separator:ab45b75e3c8487979f6f77e7df55ada43 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8735a9dd13685e75bb3eeacc8e10195f inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a8735a9dd13685e75bb3eeacc8e10195f">CloudVectorType</a> = std::vector&lt; <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt;, Eigen::aligned_allocator&lt; <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &gt; &gt;</td></tr>
<tr class="separator:a8735a9dd13685e75bb3eeacc8e10195f inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab805ba3b19e952ad19d084a9caa3dc60 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">Ptr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &gt;</td></tr>
<tr class="separator:ab805ba3b19e952ad19d084a9caa3dc60 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70fd81ce582ccabf683dd782ed3f032 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">ConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &gt;</td></tr>
<tr class="separator:af70fd81ce582ccabf683dd782ed3f032 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c062c8598136181bf309724786c9688 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a3c062c8598136181bf309724786c9688">value_type</a> = <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a></td></tr>
<tr class="separator:a3c062c8598136181bf309724786c9688 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659b0790149998f837284c41172c2aa7 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a659b0790149998f837284c41172c2aa7">reference</a> = <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;</td></tr>
<tr class="separator:a659b0790149998f837284c41172c2aa7 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d2232fd5722806001ddbabad6cd24 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aa12d2232fd5722806001ddbabad6cd24">const_reference</a> = const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;</td></tr>
<tr class="separator:aa12d2232fd5722806001ddbabad6cd24 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9664f2985a6013bef9878309548c7d inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#abc9664f2985a6013bef9878309548c7d">difference_type</a> = typename VectorType::difference_type</td></tr>
<tr class="separator:abc9664f2985a6013bef9878309548c7d inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0271fb189501a836a1119d7ee2653f03 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a0271fb189501a836a1119d7ee2653f03">size_type</a> = typename VectorType::size_type</td></tr>
<tr class="separator:a0271fb189501a836a1119d7ee2653f03 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a263d415a6c9cecd3339a747784859b inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> = typename VectorType::iterator</td></tr>
<tr class="separator:a5a263d415a6c9cecd3339a747784859b inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f665129bf87d862bcfbd61e3fe91ecf inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a8f665129bf87d862bcfbd61e3fe91ecf">const_iterator</a> = typename VectorType::const_iterator</td></tr>
<tr class="separator:a8f665129bf87d862bcfbd61e3fe91ecf inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451c7f5b161dae231170c8408f431e79 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a451c7f5b161dae231170c8408f431e79">reverse_iterator</a> = typename VectorType::reverse_iterator</td></tr>
<tr class="separator:a451c7f5b161dae231170c8408f431e79 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf24dc7a2f62f1db9fb55623e243bf1 inherit pub_types_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a9bf24dc7a2f62f1db9fb55623e243bf1">const_reverse_iterator</a> = typename VectorType::const_reverse_iterator</td></tr>
<tr class="separator:a9bf24dc7a2f62f1db9fb55623e243bf1 inherit pub_types_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af18b2d3410fb7799ad4de375b51df035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af18b2d3410fb7799ad4de375b51df035">RangeImage</a> ()</td></tr>
<tr class="memdesc:af18b2d3410fb7799ad4de375b51df035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classpcl_1_1_range_image.html#af18b2d3410fb7799ad4de375b51df035">More...</a><br /></td></tr>
<tr class="separator:af18b2d3410fb7799ad4de375b51df035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274fcd95e5f7c8da5f4f5ecf151bad40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a274fcd95e5f7c8da5f4f5ecf151bad40">~RangeImage</a> ()</td></tr>
<tr class="memdesc:a274fcd95e5f7c8da5f4f5ecf151bad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classpcl_1_1_range_image.html#a274fcd95e5f7c8da5f4f5ecf151bad40">More...</a><br /></td></tr>
<tr class="separator:a274fcd95e5f7c8da5f4f5ecf151bad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f898747aa6a52e484d65babc2600a23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_range_image.html#a3ba0be0fa2c5cbd409547860c68ff9e8">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a7f898747aa6a52e484d65babc2600a23">makeShared</a> ()</td></tr>
<tr class="memdesc:a7f898747aa6a52e484d65babc2600a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a boost shared pointer of a copy of this.  <a href="classpcl_1_1_range_image.html#a7f898747aa6a52e484d65babc2600a23">More...</a><br /></td></tr>
<tr class="separator:a7f898747aa6a52e484d65babc2600a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd539d95dd7bbbd1d67db12e9be275b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#acd539d95dd7bbbd1d67db12e9be275b0">reset</a> ()</td></tr>
<tr class="memdesc:acd539d95dd7bbbd1d67db12e9be275b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all values to an empty range image.  <a href="classpcl_1_1_range_image.html#acd539d95dd7bbbd1d67db12e9be275b0">More...</a><br /></td></tr>
<tr class="separator:acd539d95dd7bbbd1d67db12e9be275b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f6a143de2d73a0ad9fea6c527a2efb"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:a82f6a143de2d73a0ad9fea6c527a2efb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a82f6a143de2d73a0ad9fea6c527a2efb">createFromPointCloud</a> (const PointCloudType &amp;point_cloud, float angular_resolution=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(0.5f), float max_angle_width=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f), float max_angle_height=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(180.0f), const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:a82f6a143de2d73a0ad9fea6c527a2efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud.  <a href="classpcl_1_1_range_image.html#a82f6a143de2d73a0ad9fea6c527a2efb">More...</a><br /></td></tr>
<tr class="separator:a82f6a143de2d73a0ad9fea6c527a2efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a8a2def6dde7446b9fc456f7992aa9"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:ae3a8a2def6dde7446b9fc456f7992aa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae3a8a2def6dde7446b9fc456f7992aa9">createFromPointCloud</a> (const PointCloudType &amp;point_cloud, float angular_resolution_x=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(0.5f), float angular_resolution_y=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(0.5f), float max_angle_width=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f), float max_angle_height=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(180.0f), const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:ae3a8a2def6dde7446b9fc456f7992aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud.  <a href="classpcl_1_1_range_image.html#ae3a8a2def6dde7446b9fc456f7992aa9">More...</a><br /></td></tr>
<tr class="separator:ae3a8a2def6dde7446b9fc456f7992aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb553405d9b1df2b10b08c98c052250"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:afbb553405d9b1df2b10b08c98c052250"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#afbb553405d9b1df2b10b08c98c052250">createFromPointCloudWithKnownSize</a> (const PointCloudType &amp;point_cloud, float angular_resolution, const Eigen::Vector3f &amp;point_cloud_center, float point_cloud_radius, const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:afbb553405d9b1df2b10b08c98c052250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation.  <a href="classpcl_1_1_range_image.html#afbb553405d9b1df2b10b08c98c052250">More...</a><br /></td></tr>
<tr class="separator:afbb553405d9b1df2b10b08c98c052250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52b84843090cf756a37c596b5e772d2"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:ac52b84843090cf756a37c596b5e772d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac52b84843090cf756a37c596b5e772d2">createFromPointCloudWithKnownSize</a> (const PointCloudType &amp;point_cloud, float angular_resolution_x, float angular_resolution_y, const Eigen::Vector3f &amp;point_cloud_center, float point_cloud_radius, const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:ac52b84843090cf756a37c596b5e772d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation.  <a href="classpcl_1_1_range_image.html#ac52b84843090cf756a37c596b5e772d2">More...</a><br /></td></tr>
<tr class="separator:ac52b84843090cf756a37c596b5e772d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb7406e0e57923a7f5d533ea578c0f"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudTypeWithViewpoints &gt; </td></tr>
<tr class="memitem:a91cb7406e0e57923a7f5d533ea578c0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a91cb7406e0e57923a7f5d533ea578c0f">createFromPointCloudWithViewpoints</a> (const PointCloudTypeWithViewpoints &amp;point_cloud, float angular_resolution, float max_angle_width, float max_angle_height, <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:a91cb7406e0e57923a7f5d533ea578c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)).  <a href="classpcl_1_1_range_image.html#a91cb7406e0e57923a7f5d533ea578c0f">More...</a><br /></td></tr>
<tr class="separator:a91cb7406e0e57923a7f5d533ea578c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66de72c9511e694d41bd7a48c043f541"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudTypeWithViewpoints &gt; </td></tr>
<tr class="memitem:a66de72c9511e694d41bd7a48c043f541"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a66de72c9511e694d41bd7a48c043f541">createFromPointCloudWithViewpoints</a> (const PointCloudTypeWithViewpoints &amp;point_cloud, float angular_resolution_x, float angular_resolution_y, float max_angle_width, float max_angle_height, <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float noise_level=0.0f, float min_range=0.0f, int border_size=0)</td></tr>
<tr class="memdesc:a66de72c9511e694d41bd7a48c043f541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)).  <a href="classpcl_1_1_range_image.html#a66de72c9511e694d41bd7a48c043f541">More...</a><br /></td></tr>
<tr class="separator:a66de72c9511e694d41bd7a48c043f541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb318d3d6f1cf6aace8d2ed10ed7fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a46cb318d3d6f1cf6aace8d2ed10ed7fa">createEmpty</a> (float angular_resolution, const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float angle_width=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f), float angle_height=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(180.0f))</td></tr>
<tr class="memdesc:a46cb318d3d6f1cf6aace8d2ed10ed7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty depth image (filled with unobserved points)  <a href="classpcl_1_1_range_image.html#a46cb318d3d6f1cf6aace8d2ed10ed7fa">More...</a><br /></td></tr>
<tr class="separator:a46cb318d3d6f1cf6aace8d2ed10ed7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9ecf76f97e99ede5b71bb7da6c1715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#afa9ecf76f97e99ede5b71bb7da6c1715">createEmpty</a> (float angular_resolution_x, float angular_resolution_y, const Eigen::Affine3f &amp;sensor_pose=Eigen::Affine3f::Identity(), <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a> coordinate_frame=<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a>, float angle_width=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f), float angle_height=<a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(180.0f))</td></tr>
<tr class="memdesc:afa9ecf76f97e99ede5b71bb7da6c1715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty depth image (filled with unobserved points)  <a href="classpcl_1_1_range_image.html#afa9ecf76f97e99ede5b71bb7da6c1715">More...</a><br /></td></tr>
<tr class="separator:afa9ecf76f97e99ede5b71bb7da6c1715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56655a55b4c83c7ce301ca0f020759b4"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:a56655a55b4c83c7ce301ca0f020759b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a56655a55b4c83c7ce301ca0f020759b4">doZBuffer</a> (const PointCloudType &amp;point_cloud, float noise_level, float min_range, int &amp;top, int &amp;right, int &amp;bottom, int &amp;left)</td></tr>
<tr class="memdesc:a56655a55b4c83c7ce301ca0f020759b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate the given point cloud into the current range image using a z-buffer.  <a href="classpcl_1_1_range_image.html#a56655a55b4c83c7ce301ca0f020759b4">More...</a><br /></td></tr>
<tr class="separator:a56655a55b4c83c7ce301ca0f020759b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3ceb66679ccc84587eef5c29a16386"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudType &gt; </td></tr>
<tr class="memitem:a6c3ceb66679ccc84587eef5c29a16386"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6c3ceb66679ccc84587eef5c29a16386">integrateFarRanges</a> (const PointCloudType &amp;far_ranges)</td></tr>
<tr class="memdesc:a6c3ceb66679ccc84587eef5c29a16386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates the given far range measurements into the range image.  <a href="classpcl_1_1_range_image.html#a6c3ceb66679ccc84587eef5c29a16386">More...</a><br /></td></tr>
<tr class="separator:a6c3ceb66679ccc84587eef5c29a16386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f223d93080e9ce32122f90a265f7c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a20f223d93080e9ce32122f90a265f7c4">cropImage</a> (int border_size=0, int top=-1, int right=-1, int bottom=-1, int left=-1)</td></tr>
<tr class="memdesc:a20f223d93080e9ce32122f90a265f7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cut the range image to the minimal size so that it still contains all actual range readings.  <a href="classpcl_1_1_range_image.html#a20f223d93080e9ce32122f90a265f7c4">More...</a><br /></td></tr>
<tr class="separator:a20f223d93080e9ce32122f90a265f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab124a58f66b1d9a5d0f433c8474ef2b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ab124a58f66b1d9a5d0f433c8474ef2b4">getRangesArray</a> () const</td></tr>
<tr class="memdesc:ab124a58f66b1d9a5d0f433c8474ef2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the range values in one float array of size width*height.  <a href="classpcl_1_1_range_image.html#ab124a58f66b1d9a5d0f433c8474ef2b4">More...</a><br /></td></tr>
<tr class="separator:ab124a58f66b1d9a5d0f433c8474ef2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac503c8e060a6f6b1cae1c1fa87fa6e33"><td class="memItemLeft" align="right" valign="top">const Eigen::Affine3f &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac503c8e060a6f6b1cae1c1fa87fa6e33">getTransformationToRangeImageSystem</a> () const</td></tr>
<tr class="memdesc:ac503c8e060a6f6b1cae1c1fa87fa6e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the transformation from the world system into the range image system (the sensor coordinate frame)  <a href="classpcl_1_1_range_image.html#ac503c8e060a6f6b1cae1c1fa87fa6e33">More...</a><br /></td></tr>
<tr class="separator:ac503c8e060a6f6b1cae1c1fa87fa6e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0419b66dd9e76fbc6d568049abfad3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ab0419b66dd9e76fbc6d568049abfad3c">setTransformationToRangeImageSystem</a> (const Eigen::Affine3f &amp;to_range_image_system)</td></tr>
<tr class="memdesc:ab0419b66dd9e76fbc6d568049abfad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the transformation from the range image system (the sensor coordinate frame) into the world system.  <a href="classpcl_1_1_range_image.html#ab0419b66dd9e76fbc6d568049abfad3c">More...</a><br /></td></tr>
<tr class="separator:ab0419b66dd9e76fbc6d568049abfad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdff6ffbb3bfec294637225b5fb82956"><td class="memItemLeft" align="right" valign="top">const Eigen::Affine3f &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#afdff6ffbb3bfec294637225b5fb82956">getTransformationToWorldSystem</a> () const</td></tr>
<tr class="memdesc:afdff6ffbb3bfec294637225b5fb82956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the transformation from the range image system (the sensor coordinate frame) into the world system.  <a href="classpcl_1_1_range_image.html#afdff6ffbb3bfec294637225b5fb82956">More...</a><br /></td></tr>
<tr class="separator:afdff6ffbb3bfec294637225b5fb82956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc3548b0b33e90cead2c1ecfce14c34"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6fc3548b0b33e90cead2c1ecfce14c34">getAngularResolution</a> () const</td></tr>
<tr class="memdesc:a6fc3548b0b33e90cead2c1ecfce14c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the angular resolution of the range image in x direction in radians per pixel.  <a href="classpcl_1_1_range_image.html#a6fc3548b0b33e90cead2c1ecfce14c34">More...</a><br /></td></tr>
<tr class="separator:a6fc3548b0b33e90cead2c1ecfce14c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6522dbfac4997c15bd24b0b9b3e9d4dd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6522dbfac4997c15bd24b0b9b3e9d4dd">getAngularResolutionX</a> () const</td></tr>
<tr class="memdesc:a6522dbfac4997c15bd24b0b9b3e9d4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the angular resolution of the range image in x direction in radians per pixel.  <a href="classpcl_1_1_range_image.html#a6522dbfac4997c15bd24b0b9b3e9d4dd">More...</a><br /></td></tr>
<tr class="separator:a6522dbfac4997c15bd24b0b9b3e9d4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4891c9812652efe513b9ff060490364"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af4891c9812652efe513b9ff060490364">getAngularResolutionY</a> () const</td></tr>
<tr class="memdesc:af4891c9812652efe513b9ff060490364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the angular resolution of the range image in y direction in radians per pixel.  <a href="classpcl_1_1_range_image.html#af4891c9812652efe513b9ff060490364">More...</a><br /></td></tr>
<tr class="separator:af4891c9812652efe513b9ff060490364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c0b0f74510988357a56fdc48d18f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a41c0b0f74510988357a56fdc48d18f93">getAngularResolution</a> (float &amp;angular_resolution_x, float &amp;angular_resolution_y) const</td></tr>
<tr class="memdesc:a41c0b0f74510988357a56fdc48d18f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the angular resolution of the range image in x and y direction (in radians).  <a href="classpcl_1_1_range_image.html#a41c0b0f74510988357a56fdc48d18f93">More...</a><br /></td></tr>
<tr class="separator:a41c0b0f74510988357a56fdc48d18f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2720450161caef9a2992b0ac943ab2b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2720450161caef9a2992b0ac943ab2b7">setAngularResolution</a> (float angular_resolution)</td></tr>
<tr class="memdesc:a2720450161caef9a2992b0ac943ab2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the angular resolution of the range image.  <a href="classpcl_1_1_range_image.html#a2720450161caef9a2992b0ac943ab2b7">More...</a><br /></td></tr>
<tr class="separator:a2720450161caef9a2992b0ac943ab2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74583440e4ef4b611b7d2b638c6da28e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a74583440e4ef4b611b7d2b638c6da28e">setAngularResolution</a> (float angular_resolution_x, float angular_resolution_y)</td></tr>
<tr class="memdesc:a74583440e4ef4b611b7d2b638c6da28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the angular resolution of the range image.  <a href="classpcl_1_1_range_image.html#a74583440e4ef4b611b7d2b638c6da28e">More...</a><br /></td></tr>
<tr class="separator:a74583440e4ef4b611b7d2b638c6da28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52164736793c99cc9fc48dedee615e45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a52164736793c99cc9fc48dedee615e45">getPoint</a> (int image_x, int image_y) const</td></tr>
<tr class="memdesc:a52164736793c99cc9fc48dedee615e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 3D point with range at the given image position.  <a href="classpcl_1_1_range_image.html#a52164736793c99cc9fc48dedee615e45">More...</a><br /></td></tr>
<tr class="separator:a52164736793c99cc9fc48dedee615e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb229f49ccf885517e905373372b00be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#adb229f49ccf885517e905373372b00be">getPoint</a> (int image_x, int image_y)</td></tr>
<tr class="memdesc:adb229f49ccf885517e905373372b00be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const-version of getPoint.  <a href="classpcl_1_1_range_image.html#adb229f49ccf885517e905373372b00be">More...</a><br /></td></tr>
<tr class="separator:adb229f49ccf885517e905373372b00be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0168934416e10ded1eb34d57123b8d37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0168934416e10ded1eb34d57123b8d37">getPoint</a> (float image_x, float image_y) const</td></tr>
<tr class="memdesc:a0168934416e10ded1eb34d57123b8d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 3d point with range at the given image position.  <a href="classpcl_1_1_range_image.html#a0168934416e10ded1eb34d57123b8d37">More...</a><br /></td></tr>
<tr class="separator:a0168934416e10ded1eb34d57123b8d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa403d6ee9c3d76a50b268204acab27ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa403d6ee9c3d76a50b268204acab27ff">getPoint</a> (float image_x, float image_y)</td></tr>
<tr class="memdesc:aa403d6ee9c3d76a50b268204acab27ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const-version of the above.  <a href="classpcl_1_1_range_image.html#aa403d6ee9c3d76a50b268204acab27ff">More...</a><br /></td></tr>
<tr class="separator:aa403d6ee9c3d76a50b268204acab27ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587663a5b4123f4c423c9e38a9b36d41"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a587663a5b4123f4c423c9e38a9b36d41">getPointNoCheck</a> (int image_x, int image_y) const</td></tr>
<tr class="memdesc:a587663a5b4123f4c423c9e38a9b36d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 3D point with range at the given image position.  <a href="classpcl_1_1_range_image.html#a587663a5b4123f4c423c9e38a9b36d41">More...</a><br /></td></tr>
<tr class="separator:a587663a5b4123f4c423c9e38a9b36d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bfd00007940d0043b8f1df43663d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a45bfd00007940d0043b8f1df43663d07">getPointNoCheck</a> (int image_x, int image_y)</td></tr>
<tr class="memdesc:a45bfd00007940d0043b8f1df43663d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const-version of getPointNoCheck.  <a href="classpcl_1_1_range_image.html#a45bfd00007940d0043b8f1df43663d07">More...</a><br /></td></tr>
<tr class="separator:a45bfd00007940d0043b8f1df43663d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a8dbb8cc328029a928b3cff4225d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a35a8dbb8cc328029a928b3cff4225d5b">getPoint</a> (int image_x, int image_y, Eigen::Vector3f &amp;point) const</td></tr>
<tr class="memdesc:a35a8dbb8cc328029a928b3cff4225d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a35a8dbb8cc328029a928b3cff4225d5b">More...</a><br /></td></tr>
<tr class="separator:a35a8dbb8cc328029a928b3cff4225d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e520479cc8f66e5ddd7f594649b25f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa7e520479cc8f66e5ddd7f594649b25f">getPoint</a> (int index, Eigen::Vector3f &amp;point) const</td></tr>
<tr class="memdesc:aa7e520479cc8f66e5ddd7f594649b25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#aa7e520479cc8f66e5ddd7f594649b25f">More...</a><br /></td></tr>
<tr class="separator:aa7e520479cc8f66e5ddd7f594649b25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63716da3dad788cd23b64e9dc67b1791"><td class="memItemLeft" align="right" valign="top">const Eigen::Map&lt; const Eigen::Vector3f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a63716da3dad788cd23b64e9dc67b1791">getEigenVector3f</a> (int x, int y) const</td></tr>
<tr class="memdesc:a63716da3dad788cd23b64e9dc67b1791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a63716da3dad788cd23b64e9dc67b1791">More...</a><br /></td></tr>
<tr class="separator:a63716da3dad788cd23b64e9dc67b1791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3ee4df50d138b9f9b4ba34306c1071"><td class="memItemLeft" align="right" valign="top">const Eigen::Map&lt; const Eigen::Vector3f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aab3ee4df50d138b9f9b4ba34306c1071">getEigenVector3f</a> (int index) const</td></tr>
<tr class="memdesc:aab3ee4df50d138b9f9b4ba34306c1071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#aab3ee4df50d138b9f9b4ba34306c1071">More...</a><br /></td></tr>
<tr class="separator:aab3ee4df50d138b9f9b4ba34306c1071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467a03da34e4ffd323ae0f080ac85570"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a467a03da34e4ffd323ae0f080ac85570">getPoint</a> (int index) const</td></tr>
<tr class="memdesc:a467a03da34e4ffd323ae0f080ac85570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 3d point with range at the given index (whereas index=y*width+x)  <a href="classpcl_1_1_range_image.html#a467a03da34e4ffd323ae0f080ac85570">More...</a><br /></td></tr>
<tr class="separator:a467a03da34e4ffd323ae0f080ac85570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acc16b4b5fb7071175bada62a5b75d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1acc16b4b5fb7071175bada62a5b75d0">calculate3DPoint</a> (float image_x, float image_y, float range, <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point) const</td></tr>
<tr class="memdesc:a1acc16b4b5fb7071175bada62a5b75d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 3D point according to the given image point and range.  <a href="classpcl_1_1_range_image.html#a1acc16b4b5fb7071175bada62a5b75d0">More...</a><br /></td></tr>
<tr class="separator:a1acc16b4b5fb7071175bada62a5b75d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f969bd0149b7848f0f26b44bb88035c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0f969bd0149b7848f0f26b44bb88035c">calculate3DPoint</a> (float image_x, float image_y, <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point) const</td></tr>
<tr class="memdesc:a0f969bd0149b7848f0f26b44bb88035c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 3D point according to the given image point and the range value at the closest pixel.  <a href="classpcl_1_1_range_image.html#a0f969bd0149b7848f0f26b44bb88035c">More...</a><br /></td></tr>
<tr class="separator:a0f969bd0149b7848f0f26b44bb88035c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e97e7487ac21a77075b5f8b64ca205"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa9e97e7487ac21a77075b5f8b64ca205">calculate3DPoint</a> (float image_x, float image_y, float range, Eigen::Vector3f &amp;point) const</td></tr>
<tr class="memdesc:aa9e97e7487ac21a77075b5f8b64ca205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 3D point according to the given image point and range.  <a href="classpcl_1_1_range_image.html#aa9e97e7487ac21a77075b5f8b64ca205">More...</a><br /></td></tr>
<tr class="separator:aa9e97e7487ac21a77075b5f8b64ca205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb77866cf4ee5d2a619f4f8cc62cc9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#abbb77866cf4ee5d2a619f4f8cc62cc9b">calculate3DPoint</a> (float image_x, float image_y, Eigen::Vector3f &amp;point) const</td></tr>
<tr class="memdesc:abbb77866cf4ee5d2a619f4f8cc62cc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 3D point according to the given image point and the range value at the closest pixel.  <a href="classpcl_1_1_range_image.html#abbb77866cf4ee5d2a619f4f8cc62cc9b">More...</a><br /></td></tr>
<tr class="separator:abbb77866cf4ee5d2a619f4f8cc62cc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d6ccfef80c3788102327df618a3fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a08d6ccfef80c3788102327df618a3fbf">recalculate3DPointPositions</a> ()</td></tr>
<tr class="memdesc:a08d6ccfef80c3788102327df618a3fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate all 3D point positions according to their pixel position and range.  <a href="classpcl_1_1_range_image.html#a08d6ccfef80c3788102327df618a3fbf">More...</a><br /></td></tr>
<tr class="separator:a08d6ccfef80c3788102327df618a3fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a53bfc9f4a3365ee8e62513ae37eb5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a7a53bfc9f4a3365ee8e62513ae37eb5c">getImagePoint</a> (const Eigen::Vector3f &amp;point, float &amp;image_x, float &amp;image_y, float &amp;range) const</td></tr>
<tr class="memdesc:a7a53bfc9f4a3365ee8e62513ae37eb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imagePoint from 3D point in world coordinates.  <a href="classpcl_1_1_range_image.html#a7a53bfc9f4a3365ee8e62513ae37eb5c">More...</a><br /></td></tr>
<tr class="separator:a7a53bfc9f4a3365ee8e62513ae37eb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9295b795c8f52a90eb3af983612fea8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a9295b795c8f52a90eb3af983612fea8a">getImagePoint</a> (const Eigen::Vector3f &amp;point, int &amp;image_x, int &amp;image_y, float &amp;range) const</td></tr>
<tr class="memdesc:a9295b795c8f52a90eb3af983612fea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a9295b795c8f52a90eb3af983612fea8a">More...</a><br /></td></tr>
<tr class="separator:a9295b795c8f52a90eb3af983612fea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9b678a491ddefc1109494157e0aa83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8b9b678a491ddefc1109494157e0aa83">getImagePoint</a> (const Eigen::Vector3f &amp;point, float &amp;image_x, float &amp;image_y) const</td></tr>
<tr class="memdesc:a8b9b678a491ddefc1109494157e0aa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a8b9b678a491ddefc1109494157e0aa83">More...</a><br /></td></tr>
<tr class="separator:a8b9b678a491ddefc1109494157e0aa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7ef90b9c78876a492fd16701d6578e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aac7ef90b9c78876a492fd16701d6578e">getImagePoint</a> (const Eigen::Vector3f &amp;point, int &amp;image_x, int &amp;image_y) const</td></tr>
<tr class="memdesc:aac7ef90b9c78876a492fd16701d6578e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#aac7ef90b9c78876a492fd16701d6578e">More...</a><br /></td></tr>
<tr class="separator:aac7ef90b9c78876a492fd16701d6578e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c81c4b4ffd68fc5742167d15f6af87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a09c81c4b4ffd68fc5742167d15f6af87">getImagePoint</a> (float x, float y, float z, float &amp;image_x, float &amp;image_y, float &amp;range) const</td></tr>
<tr class="memdesc:a09c81c4b4ffd68fc5742167d15f6af87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a09c81c4b4ffd68fc5742167d15f6af87">More...</a><br /></td></tr>
<tr class="separator:a09c81c4b4ffd68fc5742167d15f6af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8123412373a87d5030ee5f8a9b3ba3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a8123412373a87d5030ee5f8a9b3ba3e4">getImagePoint</a> (float x, float y, float z, float &amp;image_x, float &amp;image_y) const</td></tr>
<tr class="memdesc:a8123412373a87d5030ee5f8a9b3ba3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a8123412373a87d5030ee5f8a9b3ba3e4">More...</a><br /></td></tr>
<tr class="separator:a8123412373a87d5030ee5f8a9b3ba3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0bfce9adcf8161feec7c59f75082c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2ba0bfce9adcf8161feec7c59f75082c">getImagePoint</a> (float x, float y, float z, int &amp;image_x, int &amp;image_y) const</td></tr>
<tr class="memdesc:a2ba0bfce9adcf8161feec7c59f75082c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a2ba0bfce9adcf8161feec7c59f75082c">More...</a><br /></td></tr>
<tr class="separator:a2ba0bfce9adcf8161feec7c59f75082c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e63aa0e7dc143f4a4a15611edcede70"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a3e63aa0e7dc143f4a4a15611edcede70">checkPoint</a> (const Eigen::Vector3f &amp;point, <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point_in_image) const</td></tr>
<tr class="memdesc:a3e63aa0e7dc143f4a4a15611edcede70"><td class="mdescLeft">&#160;</td><td class="mdescRight">point_in_image will be the point in the image at the position the given point would be.  <a href="classpcl_1_1_range_image.html#a3e63aa0e7dc143f4a4a15611edcede70">More...</a><br /></td></tr>
<tr class="separator:a3e63aa0e7dc143f4a4a15611edcede70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea43fc18a9695437879d4b3b3860a9ae"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aea43fc18a9695437879d4b3b3860a9ae">getRangeDifference</a> (const Eigen::Vector3f &amp;point) const</td></tr>
<tr class="memdesc:aea43fc18a9695437879d4b3b3860a9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference in range between the given point and the range of the point in the image at the position the given point would be.  <a href="classpcl_1_1_range_image.html#aea43fc18a9695437879d4b3b3860a9ae">More...</a><br /></td></tr>
<tr class="separator:aea43fc18a9695437879d4b3b3860a9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd931443541e194f1c53d5f7b1c43e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#adfd931443541e194f1c53d5f7b1c43e6">getImagePointFromAngles</a> (float angle_x, float angle_y, float &amp;image_x, float &amp;image_y) const</td></tr>
<tr class="memdesc:adfd931443541e194f1c53d5f7b1c43e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image point corresponding to the given angles.  <a href="classpcl_1_1_range_image.html#adfd931443541e194f1c53d5f7b1c43e6">More...</a><br /></td></tr>
<tr class="separator:adfd931443541e194f1c53d5f7b1c43e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2388ab60ff312e9034df5e67f899ea97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2388ab60ff312e9034df5e67f899ea97">getAnglesFromImagePoint</a> (float image_x, float image_y, float &amp;angle_x, float &amp;angle_y) const</td></tr>
<tr class="memdesc:a2388ab60ff312e9034df5e67f899ea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angles corresponding to the given image point.  <a href="classpcl_1_1_range_image.html#a2388ab60ff312e9034df5e67f899ea97">More...</a><br /></td></tr>
<tr class="separator:a2388ab60ff312e9034df5e67f899ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86174b766aa77898e0d49ef11f4613b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a86174b766aa77898e0d49ef11f4613b1">real2DToInt2D</a> (float x, float y, int &amp;xInt, int &amp;yInt) const</td></tr>
<tr class="memdesc:a86174b766aa77898e0d49ef11f4613b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an image point in float values to an image point in int values.  <a href="classpcl_1_1_range_image.html#a86174b766aa77898e0d49ef11f4613b1">More...</a><br /></td></tr>
<tr class="separator:a86174b766aa77898e0d49ef11f4613b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824a6bb27b43a174da775a656b81a483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a824a6bb27b43a174da775a656b81a483">isInImage</a> (int x, int y) const</td></tr>
<tr class="memdesc:a824a6bb27b43a174da775a656b81a483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is inside of the image.  <a href="classpcl_1_1_range_image.html#a824a6bb27b43a174da775a656b81a483">More...</a><br /></td></tr>
<tr class="separator:a824a6bb27b43a174da775a656b81a483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2372989721c3c119bb5d4b5ebd9b59c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2372989721c3c119bb5d4b5ebd9b59c3">isValid</a> (int x, int y) const</td></tr>
<tr class="memdesc:a2372989721c3c119bb5d4b5ebd9b59c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is inside of the image and has a finite range.  <a href="classpcl_1_1_range_image.html#a2372989721c3c119bb5d4b5ebd9b59c3">More...</a><br /></td></tr>
<tr class="separator:a2372989721c3c119bb5d4b5ebd9b59c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad353c062c9b17adda3797bf970b9934b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ad353c062c9b17adda3797bf970b9934b">isValid</a> (int index) const</td></tr>
<tr class="memdesc:ad353c062c9b17adda3797bf970b9934b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point has a finite range.  <a href="classpcl_1_1_range_image.html#ad353c062c9b17adda3797bf970b9934b">More...</a><br /></td></tr>
<tr class="separator:ad353c062c9b17adda3797bf970b9934b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e51885e151759d815ec1b1b72ea4ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a75e51885e151759d815ec1b1b72ea4ff">isObserved</a> (int x, int y) const</td></tr>
<tr class="memdesc:a75e51885e151759d815ec1b1b72ea4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is inside of the image and has either a finite range or a max reading (range=INFINITY)  <a href="classpcl_1_1_range_image.html#a75e51885e151759d815ec1b1b72ea4ff">More...</a><br /></td></tr>
<tr class="separator:a75e51885e151759d815ec1b1b72ea4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771ab2f1ee2952a319da20301b27ab3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a771ab2f1ee2952a319da20301b27ab3b">isMaxRange</a> (int x, int y) const</td></tr>
<tr class="memdesc:a771ab2f1ee2952a319da20301b27ab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is a max range (range=INFINITY) - please check isInImage or isObserved first!  <a href="classpcl_1_1_range_image.html#a771ab2f1ee2952a319da20301b27ab3b">More...</a><br /></td></tr>
<tr class="separator:a771ab2f1ee2952a319da20301b27ab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb21e9a192704802adabd6693f00e397"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aeb21e9a192704802adabd6693f00e397">getNormal</a> (int x, int y, int radius, Eigen::Vector3f &amp;normal, int step_size=1) const</td></tr>
<tr class="memdesc:aeb21e9a192704802adabd6693f00e397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the normal of an image point using the neighbors with a maximum pixel distance of radius.  <a href="classpcl_1_1_range_image.html#aeb21e9a192704802adabd6693f00e397">More...</a><br /></td></tr>
<tr class="separator:aeb21e9a192704802adabd6693f00e397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb0781e43e55cff62851019ffac47ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#accb0781e43e55cff62851019ffac47ce">getNormalForClosestNeighbors</a> (int x, int y, int radius, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point, int no_of_nearest_neighbors, Eigen::Vector3f &amp;normal, int step_size=1) const</td></tr>
<tr class="memdesc:accb0781e43e55cff62851019ffac47ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but only the no_of_nearest_neighbors points closest to the given point are considered.  <a href="classpcl_1_1_range_image.html#accb0781e43e55cff62851019ffac47ce">More...</a><br /></td></tr>
<tr class="separator:accb0781e43e55cff62851019ffac47ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e583b912d095111ad61232ca2e8705e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a3e583b912d095111ad61232ca2e8705e">getNormalForClosestNeighbors</a> (int x, int y, int radius, const Eigen::Vector3f &amp;point, int no_of_nearest_neighbors, Eigen::Vector3f &amp;normal, Eigen::Vector3f *point_on_plane=nullptr, int step_size=1) const</td></tr>
<tr class="memdesc:a3e583b912d095111ad61232ca2e8705e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a3e583b912d095111ad61232ca2e8705e">More...</a><br /></td></tr>
<tr class="separator:a3e583b912d095111ad61232ca2e8705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb82433197f15970647793c6271fe9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a5cb82433197f15970647793c6271fe9a">getNormalForClosestNeighbors</a> (int x, int y, Eigen::Vector3f &amp;normal, int radius=2) const</td></tr>
<tr class="memdesc:a5cb82433197f15970647793c6271fe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, using default values.  <a href="classpcl_1_1_range_image.html#a5cb82433197f15970647793c6271fe9a">More...</a><br /></td></tr>
<tr class="separator:a5cb82433197f15970647793c6271fe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44f7eb7c10f57ca223fed1e1267ac51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa44f7eb7c10f57ca223fed1e1267ac51">getSurfaceInformation</a> (int x, int y, int radius, const Eigen::Vector3f &amp;point, int no_of_closest_neighbors, int step_size, float &amp;max_closest_neighbor_distance_squared, Eigen::Vector3f &amp;normal, Eigen::Vector3f &amp;mean, Eigen::Vector3f &amp;eigen_values, Eigen::Vector3f *normal_all_neighbors=nullptr, Eigen::Vector3f *mean_all_neighbors=nullptr, Eigen::Vector3f *eigen_values_all_neighbors=nullptr) const</td></tr>
<tr class="memdesc:aa44f7eb7c10f57ca223fed1e1267ac51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but extracts some more data and can also return the extracted information for all neighbors in radius if normal_all_neighbors is not NULL.  <a href="classpcl_1_1_range_image.html#aa44f7eb7c10f57ca223fed1e1267ac51">More...</a><br /></td></tr>
<tr class="separator:aa44f7eb7c10f57ca223fed1e1267ac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae259a9342238404e8dbb3ff938470ce2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae259a9342238404e8dbb3ff938470ce2">getSquaredDistanceOfNthNeighbor</a> (int x, int y, int radius, int n, int step_size) const</td></tr>
<tr class="separator:ae259a9342238404e8dbb3ff938470ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b87fa04fd32ec986f1af9149bd46841"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6b87fa04fd32ec986f1af9149bd46841">getImpactAngle</a> (const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point1, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point2) const</td></tr>
<tr class="memdesc:a6b87fa04fd32ec986f1af9149bd46841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the impact angle based on the sensor position and the two given points - will return -INFINITY if one of the points is unobserved.  <a href="classpcl_1_1_range_image.html#a6b87fa04fd32ec986f1af9149bd46841">More...</a><br /></td></tr>
<tr class="separator:a6b87fa04fd32ec986f1af9149bd46841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6210710d430006d4c4ca93b6f8023da"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa6210710d430006d4c4ca93b6f8023da">getImpactAngle</a> (int x1, int y1, int x2, int y2) const</td></tr>
<tr class="memdesc:aa6210710d430006d4c4ca93b6f8023da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#aa6210710d430006d4c4ca93b6f8023da">More...</a><br /></td></tr>
<tr class="separator:aa6210710d430006d4c4ca93b6f8023da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca716a0e6b2aba846bdb4079275f6d9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1ca716a0e6b2aba846bdb4079275f6d9">getImpactAngleBasedOnLocalNormal</a> (int x, int y, int radius) const</td></tr>
<tr class="memdesc:a1ca716a0e6b2aba846bdb4079275f6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a local normal (with a heuristic not to include background points) and calculate the impact angle based on this.  <a href="classpcl_1_1_range_image.html#a1ca716a0e6b2aba846bdb4079275f6d9">More...</a><br /></td></tr>
<tr class="separator:a1ca716a0e6b2aba846bdb4079275f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd52c29445543d03e40f0d75c8120c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aecd52c29445543d03e40f0d75c8120c0">getImpactAngleImageBasedOnLocalNormals</a> (int radius) const</td></tr>
<tr class="memdesc:aecd52c29445543d03e40f0d75c8120c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the above function for every point in the image.  <a href="classpcl_1_1_range_image.html#aecd52c29445543d03e40f0d75c8120c0">More...</a><br /></td></tr>
<tr class="separator:aecd52c29445543d03e40f0d75c8120c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6d4bb74fa5134a6c21823dfdcdb13e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a5b6d4bb74fa5134a6c21823dfdcdb13e">getNormalBasedAcutenessValue</a> (int x, int y, int radius) const</td></tr>
<tr class="memdesc:a5b6d4bb74fa5134a6c21823dfdcdb13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) This uses getImpactAngleBasedOnLocalNormal Will return -INFINITY if no normal could be calculated.  <a href="classpcl_1_1_range_image.html#a5b6d4bb74fa5134a6c21823dfdcdb13e">More...</a><br /></td></tr>
<tr class="separator:a5b6d4bb74fa5134a6c21823dfdcdb13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2290765b8ccd5608ffa4967dc282395a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2290765b8ccd5608ffa4967dc282395a">getAcutenessValue</a> (const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point1, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point2) const</td></tr>
<tr class="memdesc:a2290765b8ccd5608ffa4967dc282395a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) will return -INFINITY if one of the points is unobserved.  <a href="classpcl_1_1_range_image.html#a2290765b8ccd5608ffa4967dc282395a">More...</a><br /></td></tr>
<tr class="separator:a2290765b8ccd5608ffa4967dc282395a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428803af781c88a43cf0c9b251d081bf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a428803af781c88a43cf0c9b251d081bf">getAcutenessValue</a> (int x1, int y1, int x2, int y2) const</td></tr>
<tr class="memdesc:a428803af781c88a43cf0c9b251d081bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above.  <a href="classpcl_1_1_range_image.html#a428803af781c88a43cf0c9b251d081bf">More...</a><br /></td></tr>
<tr class="separator:a428803af781c88a43cf0c9b251d081bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56821ed68e8701450b4725ed9c6fd7a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a56821ed68e8701450b4725ed9c6fd7a0">getAcutenessValueImages</a> (int pixel_distance, float *&amp;acuteness_value_image_x, float *&amp;acuteness_value_image_y) const</td></tr>
<tr class="memdesc:a56821ed68e8701450b4725ed9c6fd7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate getAcutenessValue for every point.  <a href="classpcl_1_1_range_image.html#a56821ed68e8701450b4725ed9c6fd7a0">More...</a><br /></td></tr>
<tr class="separator:a56821ed68e8701450b4725ed9c6fd7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b744103dab2ba2a9ada137aa75887f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a16b744103dab2ba2a9ada137aa75887f">getSurfaceChange</a> (int x, int y, int radius) const</td></tr>
<tr class="memdesc:a16b744103dab2ba2a9ada137aa75887f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates, how much the surface changes at a point.  <a href="classpcl_1_1_range_image.html#a16b744103dab2ba2a9ada137aa75887f">More...</a><br /></td></tr>
<tr class="separator:a16b744103dab2ba2a9ada137aa75887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b27f51c94a493a2c98c96a6acf3f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a23b27f51c94a493a2c98c96a6acf3f11">getSurfaceChangeImage</a> (int radius) const</td></tr>
<tr class="memdesc:a23b27f51c94a493a2c98c96a6acf3f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the above function for every point in the image.  <a href="classpcl_1_1_range_image.html#a23b27f51c94a493a2c98c96a6acf3f11">More...</a><br /></td></tr>
<tr class="separator:a23b27f51c94a493a2c98c96a6acf3f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd94afe865f6cd46cfbc64f45bb1d03e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#afd94afe865f6cd46cfbc64f45bb1d03e">getSurfaceAngleChange</a> (int x, int y, int radius, float &amp;angle_change_x, float &amp;angle_change_y) const</td></tr>
<tr class="memdesc:afd94afe865f6cd46cfbc64f45bb1d03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates, how much the surface changes at a point.  <a href="classpcl_1_1_range_image.html#afd94afe865f6cd46cfbc64f45bb1d03e">More...</a><br /></td></tr>
<tr class="separator:afd94afe865f6cd46cfbc64f45bb1d03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0501e4697fe05327423b4e247baa3528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0501e4697fe05327423b4e247baa3528">getSurfaceAngleChangeImages</a> (int radius, float *&amp;angle_change_image_x, float *&amp;angle_change_image_y) const</td></tr>
<tr class="memdesc:a0501e4697fe05327423b4e247baa3528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the above function for every point in the image.  <a href="classpcl_1_1_range_image.html#a0501e4697fe05327423b4e247baa3528">More...</a><br /></td></tr>
<tr class="separator:a0501e4697fe05327423b4e247baa3528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a22e10be8bfcedf9297d1e1badef1c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac6a22e10be8bfcedf9297d1e1badef1c">getCurvature</a> (int x, int y, int radius, int step_size) const</td></tr>
<tr class="memdesc:ac6a22e10be8bfcedf9297d1e1badef1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the curvature in a point using pca.  <a href="classpcl_1_1_range_image.html#ac6a22e10be8bfcedf9297d1e1badef1c">More...</a><br /></td></tr>
<tr class="separator:ac6a22e10be8bfcedf9297d1e1badef1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942d6b253c5df68008614af6dfed323a"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a942d6b253c5df68008614af6dfed323a">getSensorPos</a> () const</td></tr>
<tr class="memdesc:a942d6b253c5df68008614af6dfed323a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sensor position.  <a href="classpcl_1_1_range_image.html#a942d6b253c5df68008614af6dfed323a">More...</a><br /></td></tr>
<tr class="separator:a942d6b253c5df68008614af6dfed323a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f7d854c4f15ab0ab2193cc726c353f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ad4f7d854c4f15ab0ab2193cc726c353f">setUnseenToMaxRange</a> ()</td></tr>
<tr class="memdesc:ad4f7d854c4f15ab0ab2193cc726c353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all -INFINITY values to INFINITY.  <a href="classpcl_1_1_range_image.html#ad4f7d854c4f15ab0ab2193cc726c353f">More...</a><br /></td></tr>
<tr class="separator:ad4f7d854c4f15ab0ab2193cc726c353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e2db660717d67a19f5cdb39937c00a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a25e2db660717d67a19f5cdb39937c00a">getImageOffsetX</a> () const</td></tr>
<tr class="memdesc:a25e2db660717d67a19f5cdb39937c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for image_offset_x_.  <a href="classpcl_1_1_range_image.html#a25e2db660717d67a19f5cdb39937c00a">More...</a><br /></td></tr>
<tr class="separator:a25e2db660717d67a19f5cdb39937c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c06aa5693077ab6db7ec5c691dc677"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a42c06aa5693077ab6db7ec5c691dc677">getImageOffsetY</a> () const</td></tr>
<tr class="memdesc:a42c06aa5693077ab6db7ec5c691dc677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for image_offset_y_.  <a href="classpcl_1_1_range_image.html#a42c06aa5693077ab6db7ec5c691dc677">More...</a><br /></td></tr>
<tr class="separator:a42c06aa5693077ab6db7ec5c691dc677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a922e6a1170b1494ee21859087b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a962a922e6a1170b1494ee21859087b4e">setImageOffsets</a> (int offset_x, int offset_y)</td></tr>
<tr class="memdesc:a962a922e6a1170b1494ee21859087b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for image offsets.  <a href="classpcl_1_1_range_image.html#a962a922e6a1170b1494ee21859087b4e">More...</a><br /></td></tr>
<tr class="separator:a962a922e6a1170b1494ee21859087b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f4985713cf3f17ac8f8c69c0201729"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a33f4985713cf3f17ac8f8c69c0201729">getSubImage</a> (int sub_image_image_offset_x, int sub_image_image_offset_y, int sub_image_width, int sub_image_height, int combine_pixels, <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;sub_image) const</td></tr>
<tr class="memdesc:a33f4985713cf3f17ac8f8c69c0201729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sub part of the complete image as a new range image.  <a href="classpcl_1_1_range_image.html#a33f4985713cf3f17ac8f8c69c0201729">More...</a><br /></td></tr>
<tr class="separator:a33f4985713cf3f17ac8f8c69c0201729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39a4eac61ba75bb9f2913a1ff3ec84d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ab39a4eac61ba75bb9f2913a1ff3ec84d">getHalfImage</a> (<a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;half_image) const</td></tr>
<tr class="memdesc:ab39a4eac61ba75bb9f2913a1ff3ec84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range image with half the resolution.  <a href="classpcl_1_1_range_image.html#ab39a4eac61ba75bb9f2913a1ff3ec84d">More...</a><br /></td></tr>
<tr class="separator:ab39a4eac61ba75bb9f2913a1ff3ec84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b475eb983cd9edaea5d97c6d098a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a83b475eb983cd9edaea5d97c6d098a7c">getMinMaxRanges</a> (float &amp;min_range, float &amp;max_range) const</td></tr>
<tr class="memdesc:a83b475eb983cd9edaea5d97c6d098a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum range in the image.  <a href="classpcl_1_1_range_image.html#a83b475eb983cd9edaea5d97c6d098a7c">More...</a><br /></td></tr>
<tr class="separator:a83b475eb983cd9edaea5d97c6d098a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37582520baf6b317bbb81e85c95cc602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a37582520baf6b317bbb81e85c95cc602">change3dPointsToLocalCoordinateFrame</a> ()</td></tr>
<tr class="memdesc:a37582520baf6b317bbb81e85c95cc602"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensor pose to 0 and transforms all point positions to this local coordinate frame.  <a href="classpcl_1_1_range_image.html#a37582520baf6b317bbb81e85c95cc602">More...</a><br /></td></tr>
<tr class="separator:a37582520baf6b317bbb81e85c95cc602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225cab091b80ff23a3c7b0d7291dead2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a225cab091b80ff23a3c7b0d7291dead2">getInterpolatedSurfaceProjection</a> (const Eigen::Affine3f &amp;pose, int pixel_size, float world_size) const</td></tr>
<tr class="memdesc:a225cab091b80ff23a3c7b0d7291dead2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a range patch as the z values of the coordinate frame given by pose.  <a href="classpcl_1_1_range_image.html#a225cab091b80ff23a3c7b0d7291dead2">More...</a><br /></td></tr>
<tr class="separator:a225cab091b80ff23a3c7b0d7291dead2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accadf69890d534cfcb0f9d65c60feaac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#accadf69890d534cfcb0f9d65c60feaac">getInterpolatedSurfaceProjection</a> (const Eigen::Vector3f &amp;point, int pixel_size, float world_size) const</td></tr>
<tr class="memdesc:accadf69890d534cfcb0f9d65c60feaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but using the local coordinate frame defined by point and the viewing direction.  <a href="classpcl_1_1_range_image.html#accadf69890d534cfcb0f9d65c60feaac">More...</a><br /></td></tr>
<tr class="separator:accadf69890d534cfcb0f9d65c60feaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646c58459dc6780f114039d296d88d4"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6646c58459dc6780f114039d296d88d4">getTransformationToViewerCoordinateFrame</a> (const Eigen::Vector3f &amp;point) const</td></tr>
<tr class="memdesc:a6646c58459dc6780f114039d296d88d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local coordinate frame with 0,0,0 in point, upright and Z as the viewing direction.  <a href="classpcl_1_1_range_image.html#a6646c58459dc6780f114039d296d88d4">More...</a><br /></td></tr>
<tr class="separator:a6646c58459dc6780f114039d296d88d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f79a45cb9beea2cca3a6f17a16d44b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a4f79a45cb9beea2cca3a6f17a16d44b7">getTransformationToViewerCoordinateFrame</a> (const Eigen::Vector3f &amp;point, Eigen::Affine3f &amp;transformation) const</td></tr>
<tr class="memdesc:a4f79a45cb9beea2cca3a6f17a16d44b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, using a reference for the retrurn value.  <a href="classpcl_1_1_range_image.html#a4f79a45cb9beea2cca3a6f17a16d44b7">More...</a><br /></td></tr>
<tr class="separator:a4f79a45cb9beea2cca3a6f17a16d44b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38c579faf678914119d4190b0068ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ab38c579faf678914119d4190b0068ab6">getRotationToViewerCoordinateFrame</a> (const Eigen::Vector3f &amp;point, Eigen::Affine3f &amp;transformation) const</td></tr>
<tr class="memdesc:ab38c579faf678914119d4190b0068ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but only returning the rotation.  <a href="classpcl_1_1_range_image.html#ab38c579faf678914119d4190b0068ab6">More...</a><br /></td></tr>
<tr class="separator:ab38c579faf678914119d4190b0068ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee070d08d3e3688e24f8ebffc9b6436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a0ee070d08d3e3688e24f8ebffc9b6436">getNormalBasedUprightTransformation</a> (const Eigen::Vector3f &amp;point, float max_dist, Eigen::Affine3f &amp;transformation) const</td></tr>
<tr class="memdesc:a0ee070d08d3e3688e24f8ebffc9b6436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a local coordinate frame at the given point based on the normal.  <a href="classpcl_1_1_range_image.html#a0ee070d08d3e3688e24f8ebffc9b6436">More...</a><br /></td></tr>
<tr class="separator:a0ee070d08d3e3688e24f8ebffc9b6436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e02f341db8f43860b2cb83824a2123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a03e02f341db8f43860b2cb83824a2123">getIntegralImage</a> (float *&amp;integral_image, int *&amp;valid_points_num_image) const</td></tr>
<tr class="memdesc:a03e02f341db8f43860b2cb83824a2123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integral image of the range values (used for fast blur operations).  <a href="classpcl_1_1_range_image.html#a03e02f341db8f43860b2cb83824a2123">More...</a><br /></td></tr>
<tr class="separator:a03e02f341db8f43860b2cb83824a2123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1037c5597389ad0f981c91f820b392a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1037c5597389ad0f981c91f820b392a9">getBlurredImageUsingIntegralImage</a> (int blur_radius, float *integral_image, int *valid_points_num_image, <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;range_image) const</td></tr>
<tr class="memdesc:a1037c5597389ad0f981c91f820b392a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a blurred version of the range image using box filters on the provided integral image.  <a href="classpcl_1_1_range_image.html#a1037c5597389ad0f981c91f820b392a9">More...</a><br /></td></tr>
<tr class="separator:a1037c5597389ad0f981c91f820b392a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b238256cffb27a526bf89e857e5602"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a29b238256cffb27a526bf89e857e5602">getBlurredImage</a> (int blur_radius, <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;range_image) const</td></tr>
<tr class="memdesc:a29b238256cffb27a526bf89e857e5602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a blurred version of the range image using box filters.  <a href="classpcl_1_1_range_image.html#a29b238256cffb27a526bf89e857e5602">More...</a><br /></td></tr>
<tr class="separator:a29b238256cffb27a526bf89e857e5602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9270139a4ebc5b01e91262bba72c1cf5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a9270139a4ebc5b01e91262bba72c1cf5">getEuclideanDistanceSquared</a> (int x1, int y1, int x2, int y2) const</td></tr>
<tr class="memdesc:a9270139a4ebc5b01e91262bba72c1cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the squared euclidean distance between the two image points.  <a href="classpcl_1_1_range_image.html#a9270139a4ebc5b01e91262bba72c1cf5">More...</a><br /></td></tr>
<tr class="separator:a9270139a4ebc5b01e91262bba72c1cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d702bb8f446bb382040e5872b6dbfb1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a4d702bb8f446bb382040e5872b6dbfb1">getAverageEuclideanDistance</a> (int x, int y, int offset_x, int offset_y, int max_steps) const</td></tr>
<tr class="memdesc:a4d702bb8f446bb382040e5872b6dbfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doing the above for some steps in the given direction and averaging.  <a href="classpcl_1_1_range_image.html#a4d702bb8f446bb382040e5872b6dbfb1">More...</a><br /></td></tr>
<tr class="separator:a4d702bb8f446bb382040e5872b6dbfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e94ffae804608d0a7d2762cddd6fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a42e94ffae804608d0a7d2762cddd6fd2">getRangeImageWithSmoothedSurface</a> (int radius, <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;smoothed_range_image) const</td></tr>
<tr class="memdesc:a42e94ffae804608d0a7d2762cddd6fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project all points on the local plane approximation, thereby smoothing the surface of the scan.  <a href="classpcl_1_1_range_image.html#a42e94ffae804608d0a7d2762cddd6fd2">More...</a><br /></td></tr>
<tr class="separator:a42e94ffae804608d0a7d2762cddd6fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397d6c6b38906e98ab89b817c4191247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a397d6c6b38906e98ab89b817c4191247">get1dPointAverage</a> (int x, int y, int delta_x, int delta_y, int no_of_points, <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;average_point) const</td></tr>
<tr class="memdesc:a397d6c6b38906e98ab89b817c4191247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the average 3D position of the no_of_points points described by the start point x,y in the direction delta.  <a href="classpcl_1_1_range_image.html#a397d6c6b38906e98ab89b817c4191247">More...</a><br /></td></tr>
<tr class="separator:a397d6c6b38906e98ab89b817c4191247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd0bcec3d51c70ac205bbfc75dd8c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#addd0bcec3d51c70ac205bbfc75dd8c18">getOverlap</a> (const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;other_range_image, const Eigen::Affine3f &amp;relative_transformation, int search_radius, float max_distance, int pixel_step=1) const</td></tr>
<tr class="memdesc:addd0bcec3d51c70ac205bbfc75dd8c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the overlap of two range images given the relative transformation (from the given image to *this)  <a href="classpcl_1_1_range_image.html#addd0bcec3d51c70ac205bbfc75dd8c18">More...</a><br /></td></tr>
<tr class="separator:addd0bcec3d51c70ac205bbfc75dd8c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37bc4a8aab3d63ee7c9ef9428239f00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ad37bc4a8aab3d63ee7c9ef9428239f00">getViewingDirection</a> (int x, int y, Eigen::Vector3f &amp;viewing_direction) const</td></tr>
<tr class="memdesc:ad37bc4a8aab3d63ee7c9ef9428239f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewing direction for the given point.  <a href="classpcl_1_1_range_image.html#ad37bc4a8aab3d63ee7c9ef9428239f00">More...</a><br /></td></tr>
<tr class="separator:ad37bc4a8aab3d63ee7c9ef9428239f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dfa3c681a50aebc74ae6830767a831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a32dfa3c681a50aebc74ae6830767a831">getViewingDirection</a> (const Eigen::Vector3f &amp;point, Eigen::Vector3f &amp;viewing_direction) const</td></tr>
<tr class="memdesc:a32dfa3c681a50aebc74ae6830767a831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewing direction for the given point.  <a href="classpcl_1_1_range_image.html#a32dfa3c681a50aebc74ae6830767a831">More...</a><br /></td></tr>
<tr class="separator:a32dfa3c681a50aebc74ae6830767a831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bca09c1eb8be12975c47cb6d6233ca5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a7bca09c1eb8be12975c47cb6d6233ca5">getNew</a> () const</td></tr>
<tr class="memdesc:a7bca09c1eb8be12975c47cb6d6233ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a newly created Range image.  <a href="classpcl_1_1_range_image.html#a7bca09c1eb8be12975c47cb6d6233ca5">More...</a><br /></td></tr>
<tr class="separator:a7bca09c1eb8be12975c47cb6d6233ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454c9018fc001c85e9d8df6900ceb0f6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a454c9018fc001c85e9d8df6900ceb0f6">copyTo</a> (<a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;other) const</td></tr>
<tr class="memdesc:a454c9018fc001c85e9d8df6900ceb0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy other to *this.  <a href="classpcl_1_1_range_image.html#a454c9018fc001c85e9d8df6900ceb0f6">More...</a><br /></td></tr>
<tr class="separator:a454c9018fc001c85e9d8df6900ceb0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_point_cloud"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_point_cloud')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; PointWithRange &gt;</a></td></tr>
<tr class="memitem:a827dc5d5c287df03ce7ae106fece588c inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a827dc5d5c287df03ce7ae106fece588c">PointCloud</a> ()=default</td></tr>
<tr class="memdesc:a827dc5d5c287df03ce7ae106fece588c inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classpcl_1_1_point_cloud.html#a827dc5d5c287df03ce7ae106fece588c">More...</a><br /></td></tr>
<tr class="separator:a827dc5d5c287df03ce7ae106fece588c inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810a6a220de5bce04c22a8d6632fa490 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a810a6a220de5bce04c22a8d6632fa490">PointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &amp;pc, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices)</td></tr>
<tr class="memdesc:a810a6a220de5bce04c22a8d6632fa490 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from point cloud subset.  <a href="classpcl_1_1_point_cloud.html#a810a6a220de5bce04c22a8d6632fa490">More...</a><br /></td></tr>
<tr class="separator:a810a6a220de5bce04c22a8d6632fa490 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f9808c10574cf7ff8d1b5bdcb0f4a2 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a34f9808c10574cf7ff8d1b5bdcb0f4a2">PointCloud</a> (std::uint32_t width_, std::uint32_t height_, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;value_=<a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a>())</td></tr>
<tr class="memdesc:a34f9808c10574cf7ff8d1b5bdcb0f4a2 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate constructor from point cloud subset.  <a href="classpcl_1_1_point_cloud.html#a34f9808c10574cf7ff8d1b5bdcb0f4a2">More...</a><br /></td></tr>
<tr class="separator:a34f9808c10574cf7ff8d1b5bdcb0f4a2 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335a1cf1c305cc563f9ebeb2a61f994b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a335a1cf1c305cc563f9ebeb2a61f994b">operator+=</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a> &amp;rhs)</td></tr>
<tr class="memdesc:a335a1cf1c305cc563f9ebeb2a61f994b inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point cloud to the current cloud.  <a href="classpcl_1_1_point_cloud.html#a335a1cf1c305cc563f9ebeb2a61f994b">More...</a><br /></td></tr>
<tr class="separator:a335a1cf1c305cc563f9ebeb2a61f994b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430e4cb8d38c4a7f581199e03a88a779 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a430e4cb8d38c4a7f581199e03a88a779">operator+</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a> &amp;rhs)</td></tr>
<tr class="memdesc:a430e4cb8d38c4a7f581199e03a88a779 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point cloud to another cloud.  <a href="classpcl_1_1_point_cloud.html#a430e4cb8d38c4a7f581199e03a88a779">More...</a><br /></td></tr>
<tr class="separator:a430e4cb8d38c4a7f581199e03a88a779 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1155fe4ba5cdc7e83cb72159a4ea02dc inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a1155fe4ba5cdc7e83cb72159a4ea02dc">at</a> (int column, int row) const</td></tr>
<tr class="memdesc:a1155fe4ba5cdc7e83cb72159a4ea02dc inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the point given by the (column, row) coordinates.  <a href="classpcl_1_1_point_cloud.html#a1155fe4ba5cdc7e83cb72159a4ea02dc">More...</a><br /></td></tr>
<tr class="separator:a1155fe4ba5cdc7e83cb72159a4ea02dc inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930c2d1f3d8682ca228873ce1c5cc7c4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a930c2d1f3d8682ca228873ce1c5cc7c4">at</a> (int column, int row)</td></tr>
<tr class="memdesc:a930c2d1f3d8682ca228873ce1c5cc7c4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the point given by the (column, row) coordinates.  <a href="classpcl_1_1_point_cloud.html#a930c2d1f3d8682ca228873ce1c5cc7c4">More...</a><br /></td></tr>
<tr class="separator:a930c2d1f3d8682ca228873ce1c5cc7c4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a5ee1f334013d9413e11457e695e41 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a47a5ee1f334013d9413e11457e695e41">at</a> (std::size_t n) const</td></tr>
<tr class="separator:a47a5ee1f334013d9413e11457e695e41 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6e0eeeced9f72e3d65196b56945ffe inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a3a6e0eeeced9f72e3d65196b56945ffe">at</a> (std::size_t n)</td></tr>
<tr class="separator:a3a6e0eeeced9f72e3d65196b56945ffe inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4061110abf7f3761e6702c3d26397da inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab4061110abf7f3761e6702c3d26397da">operator()</a> (std::size_t column, std::size_t row) const</td></tr>
<tr class="memdesc:ab4061110abf7f3761e6702c3d26397da inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the point given by the (column, row) coordinates.  <a href="classpcl_1_1_point_cloud.html#ab4061110abf7f3761e6702c3d26397da">More...</a><br /></td></tr>
<tr class="separator:ab4061110abf7f3761e6702c3d26397da inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0466c2a757298f353339f75c367d79 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a6a0466c2a757298f353339f75c367d79">operator()</a> (std::size_t column, std::size_t row)</td></tr>
<tr class="memdesc:a6a0466c2a757298f353339f75c367d79 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the point given by the (column, row) coordinates.  <a href="classpcl_1_1_point_cloud.html#a6a0466c2a757298f353339f75c367d79">More...</a><br /></td></tr>
<tr class="separator:a6a0466c2a757298f353339f75c367d79 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914dbcef25abdb46f32991ac112002e7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a914dbcef25abdb46f32991ac112002e7">isOrganized</a> () const</td></tr>
<tr class="memdesc:a914dbcef25abdb46f32991ac112002e7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a dataset is organized (e.g., arranged in a structured grid).  <a href="classpcl_1_1_point_cloud.html#a914dbcef25abdb46f32991ac112002e7">More...</a><br /></td></tr>
<tr class="separator:a914dbcef25abdb46f32991ac112002e7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9486898ac363e8206829da7c01ea62d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">Eigen::Map&lt; Eigen::MatrixXf, Eigen::Aligned, Eigen::OuterStride&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab9486898ac363e8206829da7c01ea62d">getMatrixXfMap</a> (int dim, int stride, int offset)</td></tr>
<tr class="memdesc:ab9486898ac363e8206829da7c01ea62d inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf (assumes float values) mapped to the specified dimensions of the PointCloud.  <a href="classpcl_1_1_point_cloud.html#ab9486898ac363e8206829da7c01ea62d">More...</a><br /></td></tr>
<tr class="separator:ab9486898ac363e8206829da7c01ea62d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb96c26772eca605280d622efe35995 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const Eigen::Map&lt; const Eigen::MatrixXf, Eigen::Aligned, Eigen::OuterStride&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a0fb96c26772eca605280d622efe35995">getMatrixXfMap</a> (int dim, int stride, int offset) const</td></tr>
<tr class="memdesc:a0fb96c26772eca605280d622efe35995 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf (assumes float values) mapped to the specified dimensions of the PointCloud.  <a href="classpcl_1_1_point_cloud.html#a0fb96c26772eca605280d622efe35995">More...</a><br /></td></tr>
<tr class="separator:a0fb96c26772eca605280d622efe35995 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dc0edddaa502394241e777cf6721f2 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">Eigen::Map&lt; Eigen::MatrixXf, Eigen::Aligned, Eigen::OuterStride&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a33dc0edddaa502394241e777cf6721f2">getMatrixXfMap</a> ()</td></tr>
<tr class="separator:a33dc0edddaa502394241e777cf6721f2 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f6eac70c5fa9b370834f64377c546d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const Eigen::Map&lt; const Eigen::MatrixXf, Eigen::Aligned, Eigen::OuterStride&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ad5f6eac70c5fa9b370834f64377c546d">getMatrixXfMap</a> () const</td></tr>
<tr class="separator:ad5f6eac70c5fa9b370834f64377c546d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03bb625caff9989dda162c1a4200baf inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ad03bb625caff9989dda162c1a4200baf">begin</a> () noexcept</td></tr>
<tr class="separator:ad03bb625caff9989dda162c1a4200baf inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aad777b644c1cdcbf50296d7e9b5ca8 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a8f665129bf87d862bcfbd61e3fe91ecf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a1aad777b644c1cdcbf50296d7e9b5ca8">begin</a> () const noexcept</td></tr>
<tr class="separator:a1aad777b644c1cdcbf50296d7e9b5ca8 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907a15bd2319bec9c1c93a7009c8cfd1 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a907a15bd2319bec9c1c93a7009c8cfd1">end</a> () noexcept</td></tr>
<tr class="separator:a907a15bd2319bec9c1c93a7009c8cfd1 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a36f40543b5ed4fc7e1f3fedd323d6 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a8f665129bf87d862bcfbd61e3fe91ecf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ac6a36f40543b5ed4fc7e1f3fedd323d6">end</a> () const noexcept</td></tr>
<tr class="separator:ac6a36f40543b5ed4fc7e1f3fedd323d6 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d55a476ea1f914dd05358f05ffb94d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a8f665129bf87d862bcfbd61e3fe91ecf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a09d55a476ea1f914dd05358f05ffb94d">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a09d55a476ea1f914dd05358f05ffb94d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3830550c0a4b37087dd70c4c265488 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a8f665129bf87d862bcfbd61e3fe91ecf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a1e3830550c0a4b37087dd70c4c265488">cend</a> () const noexcept</td></tr>
<tr class="separator:a1e3830550c0a4b37087dd70c4c265488 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18743b0063f36acb5b30dd914846fbb7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a451c7f5b161dae231170c8408f431e79">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a18743b0063f36acb5b30dd914846fbb7">rbegin</a> () noexcept</td></tr>
<tr class="separator:a18743b0063f36acb5b30dd914846fbb7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccc094edd51016399ffac2a68dc6e17 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a9bf24dc7a2f62f1db9fb55623e243bf1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#adccc094edd51016399ffac2a68dc6e17">rbegin</a> () const noexcept</td></tr>
<tr class="separator:adccc094edd51016399ffac2a68dc6e17 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e170fb43f21d0906261ea193fb738b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a451c7f5b161dae231170c8408f431e79">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#af2e170fb43f21d0906261ea193fb738b">rend</a> () noexcept</td></tr>
<tr class="separator:af2e170fb43f21d0906261ea193fb738b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a833ed28b82e19e789955da4faa91a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a9bf24dc7a2f62f1db9fb55623e243bf1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a07a833ed28b82e19e789955da4faa91a">rend</a> () const noexcept</td></tr>
<tr class="separator:a07a833ed28b82e19e789955da4faa91a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc2461bcf057365249e0271ca87836b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a9bf24dc7a2f62f1db9fb55623e243bf1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a3bc2461bcf057365249e0271ca87836b">crbegin</a> () const noexcept</td></tr>
<tr class="separator:a3bc2461bcf057365249e0271ca87836b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a602bcc677728560fec7671aad9fbdc inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a9bf24dc7a2f62f1db9fb55623e243bf1">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a2a602bcc677728560fec7671aad9fbdc">crend</a> () const noexcept</td></tr>
<tr class="separator:a2a602bcc677728560fec7671aad9fbdc inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fc6f30bae069ca325b80f60757276e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aa3fc6f30bae069ca325b80f60757276e">size</a> () const</td></tr>
<tr class="separator:aa3fc6f30bae069ca325b80f60757276e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23c437751d8449ccd9fda9b0a473c4e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ac23c437751d8449ccd9fda9b0a473c4e">max_size</a> () const noexcept</td></tr>
<tr class="separator:ac23c437751d8449ccd9fda9b0a473c4e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d68c32d71772ac16943d65e87deb98 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab2d68c32d71772ac16943d65e87deb98">reserve</a> (std::size_t n)</td></tr>
<tr class="separator:ab2d68c32d71772ac16943d65e87deb98 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1626420d44e28b5ab22bdc2f1fc6c7ff inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a1626420d44e28b5ab22bdc2f1fc6c7ff">empty</a> () const</td></tr>
<tr class="separator:a1626420d44e28b5ab22bdc2f1fc6c7ff inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ea96f88e94451f4fd7522d5237474e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a02ea96f88e94451f4fd7522d5237474e">data</a> () noexcept</td></tr>
<tr class="separator:a02ea96f88e94451f4fd7522d5237474e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd841515594abf38b743c76b088e6734 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#afd841515594abf38b743c76b088e6734">data</a> () const noexcept</td></tr>
<tr class="separator:afd841515594abf38b743c76b088e6734 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552575b03243c7f5d95bb03c59842238 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a552575b03243c7f5d95bb03c59842238">resize</a> (std::size_t count)</td></tr>
<tr class="memdesc:a552575b03243c7f5d95bb03c59842238 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain <code>count</code> elements.  <a href="classpcl_1_1_point_cloud.html#a552575b03243c7f5d95bb03c59842238">More...</a><br /></td></tr>
<tr class="separator:a552575b03243c7f5d95bb03c59842238 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a0de19c29af92d1ba70b509a256e5a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a09a0de19c29af92d1ba70b509a256e5a">resize</a> (<a class="el" href="namespacepcl.html#a1b98b7f9535916d9dffec6d425d2eed9">uindex_t</a> new_width, <a class="el" href="namespacepcl.html#a1b98b7f9535916d9dffec6d425d2eed9">uindex_t</a> new_height)</td></tr>
<tr class="memdesc:a09a0de19c29af92d1ba70b509a256e5a inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain <code>new_width * new_height</code> elements.  <a href="classpcl_1_1_point_cloud.html#a09a0de19c29af92d1ba70b509a256e5a">More...</a><br /></td></tr>
<tr class="separator:a09a0de19c29af92d1ba70b509a256e5a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d32bd327ffede23a9ef04fc853f29d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a35d32bd327ffede23a9ef04fc853f29d">resize</a> (<a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> count, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;value)</td></tr>
<tr class="memdesc:a35d32bd327ffede23a9ef04fc853f29d inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classpcl_1_1_point_cloud.html#a35d32bd327ffede23a9ef04fc853f29d">More...</a><br /></td></tr>
<tr class="separator:a35d32bd327ffede23a9ef04fc853f29d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978165fe6667ba14ed0995366d05052c inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a978165fe6667ba14ed0995366d05052c">resize</a> (<a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> new_width, <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> new_height, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;value)</td></tr>
<tr class="memdesc:a978165fe6667ba14ed0995366d05052c inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="classpcl_1_1_point_cloud.html#a978165fe6667ba14ed0995366d05052c">More...</a><br /></td></tr>
<tr class="separator:a978165fe6667ba14ed0995366d05052c inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2630bae5a9bf001bcadfa69c2831ab0a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a2630bae5a9bf001bcadfa69c2831ab0a">operator[]</a> (std::size_t n) const</td></tr>
<tr class="separator:a2630bae5a9bf001bcadfa69c2831ab0a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbbb3749be776301025d308b07436f9 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a0cbbb3749be776301025d308b07436f9">operator[]</a> (std::size_t n)</td></tr>
<tr class="separator:a0cbbb3749be776301025d308b07436f9 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb4170da773993d46db2e760d74736d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a4eb4170da773993d46db2e760d74736d">front</a> () const</td></tr>
<tr class="separator:a4eb4170da773993d46db2e760d74736d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157e45c8c8bb7b028b315e3a1548cc85 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a157e45c8c8bb7b028b315e3a1548cc85">front</a> ()</td></tr>
<tr class="separator:a157e45c8c8bb7b028b315e3a1548cc85 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6381d79fcde03c65cdddb8abf610ae46 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a6381d79fcde03c65cdddb8abf610ae46">back</a> () const</td></tr>
<tr class="separator:a6381d79fcde03c65cdddb8abf610ae46 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a3d18a47ea5ef7ea379fac42f7575a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a21a3d18a47ea5ef7ea379fac42f7575a">back</a> ()</td></tr>
<tr class="separator:a21a3d18a47ea5ef7ea379fac42f7575a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1392d4d379c4ad616d32f2ddabe2669 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ad1392d4d379c4ad616d32f2ddabe2669">assign</a> (<a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> count, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;value)</td></tr>
<tr class="memdesc:ad1392d4d379c4ad616d32f2ddabe2669 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the points with <code>count</code> copies of <code>value</code>  <a href="classpcl_1_1_point_cloud.html#ad1392d4d379c4ad616d32f2ddabe2669">More...</a><br /></td></tr>
<tr class="separator:ad1392d4d379c4ad616d32f2ddabe2669 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cc1fb81be813d45dcda878c9a43d44 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ae7cc1fb81be813d45dcda878c9a43d44">assign</a> (<a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> new_width, <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> new_height, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;value)</td></tr>
<tr class="memdesc:ae7cc1fb81be813d45dcda878c9a43d44 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the points with <code>new_width * new_height</code> copies of <code>value</code>  <a href="classpcl_1_1_point_cloud.html#ae7cc1fb81be813d45dcda878c9a43d44">More...</a><br /></td></tr>
<tr class="separator:ae7cc1fb81be813d45dcda878c9a43d44 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea087ba09ba530dcdc695603fec0481 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a8ea087ba09ba530dcdc695603fec0481">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a8ea087ba09ba530dcdc695603fec0481 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the points with copies of those in the range <code>[first, last)</code>  <a href="classpcl_1_1_point_cloud.html#a8ea087ba09ba530dcdc695603fec0481">More...</a><br /></td></tr>
<tr class="separator:a8ea087ba09ba530dcdc695603fec0481 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568f6def0da4101cdf002450e97bbfed inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a568f6def0da4101cdf002450e97bbfed">assign</a> (InputIterator first, InputIterator last, <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> new_width)</td></tr>
<tr class="memdesc:a568f6def0da4101cdf002450e97bbfed inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the points with copies of those in the range <code>[first, last)</code>  <a href="classpcl_1_1_point_cloud.html#a568f6def0da4101cdf002450e97bbfed">More...</a><br /></td></tr>
<tr class="separator:a568f6def0da4101cdf002450e97bbfed inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c2ea8956c5d274df8dc6f7cfe22785 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a72c2ea8956c5d274df8dc6f7cfe22785">assign</a> (std::initializer_list&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; ilist)</td></tr>
<tr class="memdesc:a72c2ea8956c5d274df8dc6f7cfe22785 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the points with the elements from the initializer list <code>ilist</code>  <a href="classpcl_1_1_point_cloud.html#a72c2ea8956c5d274df8dc6f7cfe22785">More...</a><br /></td></tr>
<tr class="separator:a72c2ea8956c5d274df8dc6f7cfe22785 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab40a980803206183436c7535f2f59af inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aab40a980803206183436c7535f2f59af">assign</a> (std::initializer_list&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; ilist, <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> new_width)</td></tr>
<tr class="memdesc:aab40a980803206183436c7535f2f59af inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the points with the elements from the initializer list <code>ilist</code>  <a href="classpcl_1_1_point_cloud.html#aab40a980803206183436c7535f2f59af">More...</a><br /></td></tr>
<tr class="separator:aab40a980803206183436c7535f2f59af inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4d7abee110e47d90635eb042488bb4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a0b4d7abee110e47d90635eb042488bb4">push_back</a> (const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;pt)</td></tr>
<tr class="memdesc:a0b4d7abee110e47d90635eb042488bb4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud, at the end of the container.  <a href="classpcl_1_1_point_cloud.html#a0b4d7abee110e47d90635eb042488bb4">More...</a><br /></td></tr>
<tr class="separator:a0b4d7abee110e47d90635eb042488bb4 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6270ef2fbbaa127f0af8645dfa2be586 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a6270ef2fbbaa127f0af8645dfa2be586">transient_push_back</a> (const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;pt)</td></tr>
<tr class="memdesc:a6270ef2fbbaa127f0af8645dfa2be586 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud, at the end of the container.  <a href="classpcl_1_1_point_cloud.html#a6270ef2fbbaa127f0af8645dfa2be586">More...</a><br /></td></tr>
<tr class="separator:a6270ef2fbbaa127f0af8645dfa2be586 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c6b2deef3b70d309fbf4513000e85d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a659b0790149998f837284c41172c2aa7">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a73c6b2deef3b70d309fbf4513000e85d">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a73c6b2deef3b70d309fbf4513000e85d inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new point in the cloud, at the end of the container.  <a href="classpcl_1_1_point_cloud.html#a73c6b2deef3b70d309fbf4513000e85d">More...</a><br /></td></tr>
<tr class="separator:a73c6b2deef3b70d309fbf4513000e85d inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b591c143dd6d869eaa179bdac23826c inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a659b0790149998f837284c41172c2aa7">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a0b591c143dd6d869eaa179bdac23826c">transient_emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a0b591c143dd6d869eaa179bdac23826c inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new point in the cloud, at the end of the container.  <a href="classpcl_1_1_point_cloud.html#a0b591c143dd6d869eaa179bdac23826c">More...</a><br /></td></tr>
<tr class="separator:a0b591c143dd6d869eaa179bdac23826c inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75387c07a2d24ee943eb71ab1c00e4a7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a75387c07a2d24ee943eb71ab1c00e4a7">insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;pt)</td></tr>
<tr class="memdesc:a75387c07a2d24ee943eb71ab1c00e4a7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud, given an iterator.  <a href="classpcl_1_1_point_cloud.html#a75387c07a2d24ee943eb71ab1c00e4a7">More...</a><br /></td></tr>
<tr class="separator:a75387c07a2d24ee943eb71ab1c00e4a7 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c2892860c2c0caf349ada9f4f0690a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a26c2892860c2c0caf349ada9f4f0690a">insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position, std::size_t n, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;pt)</td></tr>
<tr class="memdesc:a26c2892860c2c0caf349ada9f4f0690a inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud N times, given an iterator.  <a href="classpcl_1_1_point_cloud.html#a26c2892860c2c0caf349ada9f4f0690a">More...</a><br /></td></tr>
<tr class="separator:a26c2892860c2c0caf349ada9f4f0690a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cccb494b2875101b528a8919c738f9b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a3cccb494b2875101b528a8919c738f9b">insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a3cccb494b2875101b528a8919c738f9b inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new range of points in the cloud, at a certain position.  <a href="classpcl_1_1_point_cloud.html#a3cccb494b2875101b528a8919c738f9b">More...</a><br /></td></tr>
<tr class="separator:a3cccb494b2875101b528a8919c738f9b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1b4ade6ac50d278a0e952f42bfd8c3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aea1b4ade6ac50d278a0e952f42bfd8c3">transient_insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;pt)</td></tr>
<tr class="memdesc:aea1b4ade6ac50d278a0e952f42bfd8c3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud, given an iterator.  <a href="classpcl_1_1_point_cloud.html#aea1b4ade6ac50d278a0e952f42bfd8c3">More...</a><br /></td></tr>
<tr class="separator:aea1b4ade6ac50d278a0e952f42bfd8c3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d57b306764b0b59eca9cc0466c365a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a26d57b306764b0b59eca9cc0466c365a">transient_insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position, std::size_t n, const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;pt)</td></tr>
<tr class="memdesc:a26d57b306764b0b59eca9cc0466c365a inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new point in the cloud N times, given an iterator.  <a href="classpcl_1_1_point_cloud.html#a26d57b306764b0b59eca9cc0466c365a">More...</a><br /></td></tr>
<tr class="separator:a26d57b306764b0b59eca9cc0466c365a inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a98e42fd659610b6bd8624f73382aff inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a9a98e42fd659610b6bd8624f73382aff">transient_insert</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a9a98e42fd659610b6bd8624f73382aff inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new range of points in the cloud, at a certain position.  <a href="classpcl_1_1_point_cloud.html#a9a98e42fd659610b6bd8624f73382aff">More...</a><br /></td></tr>
<tr class="separator:a9a98e42fd659610b6bd8624f73382aff inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce40296ecfd6900af3afe6758ace0cd inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a8ce40296ecfd6900af3afe6758ace0cd">emplace</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a8ce40296ecfd6900af3afe6758ace0cd inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new point in the cloud, given an iterator.  <a href="classpcl_1_1_point_cloud.html#a8ce40296ecfd6900af3afe6758ace0cd">More...</a><br /></td></tr>
<tr class="separator:a8ce40296ecfd6900af3afe6758ace0cd inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedee4c14db3d5a9bb5a218020f6e34c1 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aedee4c14db3d5a9bb5a218020f6e34c1">transient_emplace</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aedee4c14db3d5a9bb5a218020f6e34c1 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new point in the cloud, given an iterator.  <a href="classpcl_1_1_point_cloud.html#aedee4c14db3d5a9bb5a218020f6e34c1">More...</a><br /></td></tr>
<tr class="separator:aedee4c14db3d5a9bb5a218020f6e34c1 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06463926e7cbe52ed3c024c7bc7565d3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a06463926e7cbe52ed3c024c7bc7565d3">erase</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position)</td></tr>
<tr class="memdesc:a06463926e7cbe52ed3c024c7bc7565d3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a point in the cloud.  <a href="classpcl_1_1_point_cloud.html#a06463926e7cbe52ed3c024c7bc7565d3">More...</a><br /></td></tr>
<tr class="separator:a06463926e7cbe52ed3c024c7bc7565d3 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2901a922dac074254160e1e11912d2c5 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a2901a922dac074254160e1e11912d2c5">erase</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> first, <a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> last)</td></tr>
<tr class="memdesc:a2901a922dac074254160e1e11912d2c5 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a set of points given by a (first, last) iterator pair.  <a href="classpcl_1_1_point_cloud.html#a2901a922dac074254160e1e11912d2c5">More...</a><br /></td></tr>
<tr class="separator:a2901a922dac074254160e1e11912d2c5 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51393e25f013a4c2ca8a99a91fc7309c inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a51393e25f013a4c2ca8a99a91fc7309c">transient_erase</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> position)</td></tr>
<tr class="memdesc:a51393e25f013a4c2ca8a99a91fc7309c inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a point in the cloud.  <a href="classpcl_1_1_point_cloud.html#a51393e25f013a4c2ca8a99a91fc7309c">More...</a><br /></td></tr>
<tr class="separator:a51393e25f013a4c2ca8a99a91fc7309c inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41808523a136b52f1b2ef2b7301faa3b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a41808523a136b52f1b2ef2b7301faa3b">transient_erase</a> (<a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> first, <a class="el" href="classpcl_1_1_point_cloud.html#a5a263d415a6c9cecd3339a747784859b">iterator</a> last)</td></tr>
<tr class="memdesc:a41808523a136b52f1b2ef2b7301faa3b inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a set of points given by a (first, last) iterator pair.  <a href="classpcl_1_1_point_cloud.html#a41808523a136b52f1b2ef2b7301faa3b">More...</a><br /></td></tr>
<tr class="separator:a41808523a136b52f1b2ef2b7301faa3b inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a0b63e9c8442286b08336f8385a9ea inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#ab4a0b63e9c8442286b08336f8385a9ea">swap</a> (<a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab4a0b63e9c8442286b08336f8385a9ea inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap a point cloud with another cloud.  <a href="classpcl_1_1_point_cloud.html#ab4a0b63e9c8442286b08336f8385a9ea">More...</a><br /></td></tr>
<tr class="separator:ab4a0b63e9c8442286b08336f8385a9ea inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963c0da7320055c79e5af0df4f6ad224 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a963c0da7320055c79e5af0df4f6ad224">clear</a> ()</td></tr>
<tr class="memdesc:a963c0da7320055c79e5af0df4f6ad224 inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all points in a cloud and sets the width and height to 0.  <a href="classpcl_1_1_point_cloud.html#a963c0da7320055c79e5af0df4f6ad224">More...</a><br /></td></tr>
<tr class="separator:a963c0da7320055c79e5af0df4f6ad224 inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebbbb9c522a94cf245dd3968b50ed5e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#afebbbb9c522a94cf245dd3968b50ed5e">makeShared</a> () const</td></tr>
<tr class="memdesc:afebbbb9c522a94cf245dd3968b50ed5e inherit pub_methods_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the cloud to the heap and return a smart pointer Note that deep copy is performed, so avoid using this function on non-empty clouds.  <a href="classpcl_1_1_point_cloud.html#afebbbb9c522a94cf245dd3968b50ed5e">More...</a><br /></td></tr>
<tr class="separator:afebbbb9c522a94cf245dd3968b50ed5e inherit pub_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac504743608967dcd142dc4249b82ea5a"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac504743608967dcd142dc4249b82ea5a">getMaxAngleSize</a> (const Eigen::Affine3f &amp;viewer_pose, const Eigen::Vector3f &amp;center, float radius)</td></tr>
<tr class="memdesc:ac504743608967dcd142dc4249b82ea5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a certain area when seen from the given pose.  <a href="classpcl_1_1_range_image.html#ac504743608967dcd142dc4249b82ea5a">More...</a><br /></td></tr>
<tr class="separator:ac504743608967dcd142dc4249b82ea5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3b75077a96415e431b90f53a249773"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a2e3b75077a96415e431b90f53a249773">getEigenVector3f</a> (const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;point)</td></tr>
<tr class="memdesc:a2e3b75077a96415e431b90f53a249773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Eigen::Vector3f from <a class="el" href="structpcl_1_1_point_with_range.html" title="A point structure representing Euclidean xyz coordinates, padded with an extra range float.">PointWithRange</a>.  <a href="classpcl_1_1_range_image.html#a2e3b75077a96415e431b90f53a249773">More...</a><br /></td></tr>
<tr class="separator:a2e3b75077a96415e431b90f53a249773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c0908bfbe060fdb517728fe56b2c55"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#af5c0908bfbe060fdb517728fe56b2c55">getCoordinateFrameTransformation</a> (<a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a> coordinate_frame, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:af5c0908bfbe060fdb517728fe56b2c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation that transforms the given coordinate frame into CAMERA_FRAME.  <a href="classpcl_1_1_range_image.html#af5c0908bfbe060fdb517728fe56b2c55">More...</a><br /></td></tr>
<tr class="separator:af5c0908bfbe060fdb517728fe56b2c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c425d518d92def18300cd029ae1855"><td class="memTemplParams" colspan="2">template&lt;typename PointCloudTypeWithViewpoints &gt; </td></tr>
<tr class="memitem:a49c425d518d92def18300cd029ae1855"><td class="memTemplItemLeft" align="right" valign="top">static Eigen::Vector3f&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a49c425d518d92def18300cd029ae1855">getAverageViewPoint</a> (const PointCloudTypeWithViewpoints &amp;point_cloud)</td></tr>
<tr class="memdesc:a49c425d518d92def18300cd029ae1855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average viewpoint of a point cloud where each point carries viewpoint information as vp_x, vp_y, vp_z.  <a href="classpcl_1_1_range_image.html#a49c425d518d92def18300cd029ae1855">More...</a><br /></td></tr>
<tr class="separator:a49c425d518d92def18300cd029ae1855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e39ee2587a56fbdda651c27cc7898e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a75e39ee2587a56fbdda651c27cc7898e">extractFarRanges</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;point_cloud_data, <a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_viewpoint.html">PointWithViewpoint</a> &gt; &amp;far_ranges)</td></tr>
<tr class="memdesc:a75e39ee2587a56fbdda651c27cc7898e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the provided data includes far ranges and add them to far_ranges.  <a href="classpcl_1_1_range_image.html#a75e39ee2587a56fbdda651c27cc7898e">More...</a><br /></td></tr>
<tr class="separator:a75e39ee2587a56fbdda651c27cc7898e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classpcl_1_1_point_cloud"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpcl_1_1_point_cloud')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; PointWithRange &gt;</a></td></tr>
<tr class="memitem:af029c33f2907e4b9bd4d7bc719afce2a inherit pub_static_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#af029c33f2907e4b9bd4d7bc719afce2a">concatenate</a> (<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &amp;cloud1, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &amp;cloud2)</td></tr>
<tr class="separator:af029c33f2907e4b9bd4d7bc719afce2a inherit pub_static_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd03c68e99f7857d1f7f9ce991e9fd4 inherit pub_static_methods_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a8dd03c68e99f7857d1f7f9ce991e9fd4">concatenate</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &amp;cloud1, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &amp;cloud2, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &amp;cloud_out)</td></tr>
<tr class="separator:a8dd03c68e99f7857d1f7f9ce991e9fd4 inherit pub_static_methods_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a34fe4f6701548e2514ae45099309cac4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a34fe4f6701548e2514ae45099309cac4">max_no_of_threads</a></td></tr>
<tr class="memdesc:a34fe4f6701548e2514ae45099309cac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of openmp threads that can be used in this class.  <a href="classpcl_1_1_range_image.html#a34fe4f6701548e2514ae45099309cac4">More...</a><br /></td></tr>
<tr class="separator:a34fe4f6701548e2514ae45099309cac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd552e2971d69843fdec72413823f57"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1bd552e2971d69843fdec72413823f57">debug</a></td></tr>
<tr class="memdesc:a1bd552e2971d69843fdec72413823f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just for...  <a href="classpcl_1_1_range_image.html#a1bd552e2971d69843fdec72413823f57">More...</a><br /></td></tr>
<tr class="separator:a1bd552e2971d69843fdec72413823f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ae74c34594e1417fb702d92ff51f2b495"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ae74c34594e1417fb702d92ff51f2b495">createLookupTables</a> ()</td></tr>
<tr class="memdesc:ae74c34594e1417fb702d92ff51f2b495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create lookup tables for trigonometric functions.  <a href="classpcl_1_1_range_image.html#ae74c34594e1417fb702d92ff51f2b495">More...</a><br /></td></tr>
<tr class="separator:ae74c34594e1417fb702d92ff51f2b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb20514cdc04674448a5e5c6cb373bc"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a6cb20514cdc04674448a5e5c6cb373bc">asinLookUp</a> (float value)</td></tr>
<tr class="memdesc:a6cb20514cdc04674448a5e5c6cb373bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the asin lookup table.  <a href="classpcl_1_1_range_image.html#a6cb20514cdc04674448a5e5c6cb373bc">More...</a><br /></td></tr>
<tr class="separator:a6cb20514cdc04674448a5e5c6cb373bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17835570c515cca3ba1ecd0f132bf013"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a17835570c515cca3ba1ecd0f132bf013">atan2LookUp</a> (float y, float x)</td></tr>
<tr class="memdesc:a17835570c515cca3ba1ecd0f132bf013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the std::atan2 lookup table.  <a href="classpcl_1_1_range_image.html#a17835570c515cca3ba1ecd0f132bf013">More...</a><br /></td></tr>
<tr class="separator:a17835570c515cca3ba1ecd0f132bf013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ab1f1088b1c8d111dfe02139882ded"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a29ab1f1088b1c8d111dfe02139882ded">cosLookUp</a> (float value)</td></tr>
<tr class="memdesc:a29ab1f1088b1c8d111dfe02139882ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the cos lookup table.  <a href="classpcl_1_1_range_image.html#a29ab1f1088b1c8d111dfe02139882ded">More...</a><br /></td></tr>
<tr class="separator:a29ab1f1088b1c8d111dfe02139882ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ada8177479f0e95999a66294db4c0c3eb"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ada8177479f0e95999a66294db4c0c3eb">to_range_image_system_</a></td></tr>
<tr class="memdesc:ada8177479f0e95999a66294db4c0c3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of to_world_system_.  <a href="classpcl_1_1_range_image.html#ada8177479f0e95999a66294db4c0c3eb">More...</a><br /></td></tr>
<tr class="separator:ada8177479f0e95999a66294db4c0c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c36f147403c0f64e1c3a386b30e229"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a31c36f147403c0f64e1c3a386b30e229">to_world_system_</a></td></tr>
<tr class="memdesc:a31c36f147403c0f64e1c3a386b30e229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of to_range_image_system_.  <a href="classpcl_1_1_range_image.html#a31c36f147403c0f64e1c3a386b30e229">More...</a><br /></td></tr>
<tr class="separator:a31c36f147403c0f64e1c3a386b30e229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbfb655cdfeb5d8ace1ac841a52a524"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#abdbfb655cdfeb5d8ace1ac841a52a524">angular_resolution_x_</a> {0.0f}</td></tr>
<tr class="memdesc:abdbfb655cdfeb5d8ace1ac841a52a524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular resolution of the range image in x direction in radians per pixel.  <a href="classpcl_1_1_range_image.html#abdbfb655cdfeb5d8ace1ac841a52a524">More...</a><br /></td></tr>
<tr class="separator:abdbfb655cdfeb5d8ace1ac841a52a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9471a00ecde65c754227e155cc234942"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a9471a00ecde65c754227e155cc234942">angular_resolution_y_</a> {0.0f}</td></tr>
<tr class="memdesc:a9471a00ecde65c754227e155cc234942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular resolution of the range image in y direction in radians per pixel.  <a href="classpcl_1_1_range_image.html#a9471a00ecde65c754227e155cc234942">More...</a><br /></td></tr>
<tr class="separator:a9471a00ecde65c754227e155cc234942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb1466576e6c2d08e3065b67da0b250"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#adbb1466576e6c2d08e3065b67da0b250">angular_resolution_x_reciprocal_</a> {0.0f}</td></tr>
<tr class="memdesc:adbb1466576e6c2d08e3065b67da0b250"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0/angular_resolution_x_ - provided for better performance of multiplication compared to division  <a href="classpcl_1_1_range_image.html#adbb1466576e6c2d08e3065b67da0b250">More...</a><br /></td></tr>
<tr class="separator:adbb1466576e6c2d08e3065b67da0b250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843659230146a43690ee4d4fb53fcc92"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a843659230146a43690ee4d4fb53fcc92">angular_resolution_y_reciprocal_</a> {0.0f}</td></tr>
<tr class="memdesc:a843659230146a43690ee4d4fb53fcc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0/angular_resolution_y_ - provided for better performance of multiplication compared to division  <a href="classpcl_1_1_range_image.html#a843659230146a43690ee4d4fb53fcc92">More...</a><br /></td></tr>
<tr class="separator:a843659230146a43690ee4d4fb53fcc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01b76b2e83df5967984084e7558c2d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac01b76b2e83df5967984084e7558c2d5">image_offset_x_</a> {0}</td></tr>
<tr class="separator:ac01b76b2e83df5967984084e7558c2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1518af9f1c9eb6ac259be92824842e23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a1518af9f1c9eb6ac259be92824842e23">image_offset_y_</a> {0}</td></tr>
<tr class="memdesc:a1518af9f1c9eb6ac259be92824842e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of the top left corner of the range image compared to an image of full size (360x180 degrees)  <a href="classpcl_1_1_range_image.html#a1518af9f1c9eb6ac259be92824842e23">More...</a><br /></td></tr>
<tr class="separator:a1518af9f1c9eb6ac259be92824842e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bf019906a3256038561354d6b95885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a51bf019906a3256038561354d6b95885">unobserved_point</a></td></tr>
<tr class="memdesc:a51bf019906a3256038561354d6b95885"><td class="mdescLeft">&#160;</td><td class="mdescRight">This point is used to be able to return a reference to a non-existing point.  <a href="classpcl_1_1_range_image.html#a51bf019906a3256038561354d6b95885">More...</a><br /></td></tr>
<tr class="separator:a51bf019906a3256038561354d6b95885"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ac8b2b871a3ac8f1d2bfd900d1b527561"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#ac8b2b871a3ac8f1d2bfd900d1b527561">lookup_table_size</a></td></tr>
<tr class="separator:ac8b2b871a3ac8f1d2bfd900d1b527561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c5323cee871dcb71da6888b9cf4b5b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#aa1c5323cee871dcb71da6888b9cf4b5b">asin_lookup_table</a></td></tr>
<tr class="separator:aa1c5323cee871dcb71da6888b9cf4b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ce0726f5ec931ab3a0e0dde61daac1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a99ce0726f5ec931ab3a0e0dde61daac1">atan_lookup_table</a></td></tr>
<tr class="separator:a99ce0726f5ec931ab3a0e0dde61daac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7092794afdcc1a97613646e8054fa441"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image.html#a7092794afdcc1a97613646e8054fa441">cos_lookup_table</a></td></tr>
<tr class="separator:a7092794afdcc1a97613646e8054fa441"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classpcl_1_1_point_cloud"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classpcl_1_1_point_cloud')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt; PointWithRange &gt;</a></td></tr>
<tr class="memitem:a82e0be055a617e5e74102ed62712b352 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_p_c_l_header.html">pcl::PCLHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a82e0be055a617e5e74102ed62712b352">header</a></td></tr>
<tr class="memdesc:a82e0be055a617e5e74102ed62712b352 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point cloud header.  <a href="classpcl_1_1_point_cloud.html#a82e0be055a617e5e74102ed62712b352">More...</a><br /></td></tr>
<tr class="separator:a82e0be055a617e5e74102ed62712b352 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16a62638198313b9c093127c492c884 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a>, Eigen::aligned_allocator&lt; <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#af16a62638198313b9c093127c492c884">points</a></td></tr>
<tr class="memdesc:af16a62638198313b9c093127c492c884 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point data.  <a href="classpcl_1_1_point_cloud.html#af16a62638198313b9c093127c492c884">More...</a><br /></td></tr>
<tr class="separator:af16a62638198313b9c093127c492c884 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644dc7161c2e3f23bc4d36d36c58e7b4 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a644dc7161c2e3f23bc4d36d36c58e7b4">width</a></td></tr>
<tr class="memdesc:a644dc7161c2e3f23bc4d36d36c58e7b4 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point cloud width (if organized as an image-structure).  <a href="classpcl_1_1_point_cloud.html#a644dc7161c2e3f23bc4d36d36c58e7b4">More...</a><br /></td></tr>
<tr class="separator:a644dc7161c2e3f23bc4d36d36c58e7b4 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917b6eb0ef204836c56a2334ddd703fe inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a917b6eb0ef204836c56a2334ddd703fe">height</a></td></tr>
<tr class="memdesc:a917b6eb0ef204836c56a2334ddd703fe inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point cloud height (if organized as an image-structure).  <a href="classpcl_1_1_point_cloud.html#a917b6eb0ef204836c56a2334ddd703fe">More...</a><br /></td></tr>
<tr class="separator:a917b6eb0ef204836c56a2334ddd703fe inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca88d8ebf6f4f35acbc31cdfb38aa94 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a3ca88d8ebf6f4f35acbc31cdfb38aa94">is_dense</a></td></tr>
<tr class="memdesc:a3ca88d8ebf6f4f35acbc31cdfb38aa94 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if no points are invalid (e.g., have NaN or Inf values in any of their floating point fields).  <a href="classpcl_1_1_point_cloud.html#a3ca88d8ebf6f4f35acbc31cdfb38aa94">More...</a><br /></td></tr>
<tr class="separator:a3ca88d8ebf6f4f35acbc31cdfb38aa94 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7c2cd4b0d1c7f0fbc096276b5e2230 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#aad7c2cd4b0d1c7f0fbc096276b5e2230">sensor_origin_</a></td></tr>
<tr class="memdesc:aad7c2cd4b0d1c7f0fbc096276b5e2230 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor acquisition pose (origin/translation).  <a href="classpcl_1_1_point_cloud.html#aad7c2cd4b0d1c7f0fbc096276b5e2230">More...</a><br /></td></tr>
<tr class="separator:aad7c2cd4b0d1c7f0fbc096276b5e2230 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de17e88bdf15e1c4fd1bcc6b85b1941 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memItemLeft" align="right" valign="top">Eigen::Quaternionf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_point_cloud.html#a5de17e88bdf15e1c4fd1bcc6b85b1941">sensor_orientation_</a></td></tr>
<tr class="memdesc:a5de17e88bdf15e1c4fd1bcc6b85b1941 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor acquisition pose (rotation).  <a href="classpcl_1_1_point_cloud.html#a5de17e88bdf15e1c4fd1bcc6b85b1941">More...</a><br /></td></tr>
<tr class="separator:a5de17e88bdf15e1c4fd1bcc6b85b1941 inherit pub_attribs_classpcl_1_1_point_cloud"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpcl_1_1_range_image.html" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where...">RangeImage</a> is derived from pcl/PointCloud and provides functionalities with focus on situations where a 3D scene was captured from a specific view point. </p>
<dl class="section author"><dt>Author</dt><dd>Bastian Steder </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00054">54</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9aa810c2aa68b3e77745e1f98775be5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa810c2aa68b3e77745e1f98775be5b">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_range_image.html#a9aa810c2aa68b3e77745e1f98775be5b">pcl::RangeImage::BaseClass</a> =  <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;<a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00058">58</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a id="a960ddd0ee536453dc9c042fd4a7754a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960ddd0ee536453dc9c042fd4a7754a1">&#9670;&nbsp;</a></span>ConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_range_image.html#a960ddd0ee536453dc9c042fd4a7754a1">pcl::RangeImage::ConstPtr</a> =  shared_ptr&lt;const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00061">61</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a id="a3ba0be0fa2c5cbd409547860c68ff9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba0be0fa2c5cbd409547860c68ff9e8">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_range_image.html#a3ba0be0fa2c5cbd409547860c68ff9e8">pcl::RangeImage::Ptr</a> =  shared_ptr&lt;<a class="el" href="classpcl_1_1_range_image.html">RangeImage</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00060">60</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a id="aba06f02358b2efee4b98e086068ee6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba06f02358b2efee4b98e086068ee6b1">&#9670;&nbsp;</a></span>VectorOfEigenVector3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_range_image.html#aba06f02358b2efee4b98e086068ee6b1">pcl::RangeImage::VectorOfEigenVector3f</a> =  std::vector&lt;Eigen::Vector3f, Eigen::aligned_allocator&lt;Eigen::Vector3f&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00059">59</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8b5785b0499f0a70d5c87fceba55992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5785b0499f0a70d5c87fceba55992f">&#9670;&nbsp;</a></span>CoordinateFrame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">pcl::RangeImage::CoordinateFrame</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf"></a>CAMERA_FRAME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b5785b0499f0a70d5c87fceba55992faa7e6d8ab63f2359fd25c11db114db19c"></a>LASER_FRAME&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00063">63</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af18b2d3410fb7799ad4de375b51df035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18b2d3410fb7799ad4de375b51df035">&#9670;&nbsp;</a></span>RangeImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> pcl::RangeImage::RangeImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

<p class="reference">Referenced by <a class="el" href="range__image_8h_source.html#l00749">getNew()</a>.</p>

</div>
</div>
<a id="a274fcd95e5f7c8da5f4f5ecf151bad40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274fcd95e5f7c8da5f4f5ecf151bad40">&#9670;&nbsp;</a></span>~RangeImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> pcl::RangeImage::~RangeImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6cb20514cdc04674448a5e5c6cb373bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb20514cdc04674448a5e5c6cb373bc">&#9670;&nbsp;</a></span>asinLookUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::asinLookUp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the asin lookup table. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00054">54</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00786">asin_lookup_table</a>, <a class="el" href="range__image_8h_source.html#l00785">lookup_table_size</a>, and <a class="el" href="pcl__macros_8h_source.html#l00254">pcl_lrintf</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, and <a class="el" href="range__image__spherical_8hpp_source.html#l00060">pcl::RangeImageSpherical::getImagePoint()</a>.</p>

</div>
</div>
<a id="a17835570c515cca3ba1ecd0f132bf013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17835570c515cca3ba1ecd0f132bf013">&#9670;&nbsp;</a></span>atan2LookUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::atan2LookUp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the std::atan2 lookup table. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00064">64</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00787">atan_lookup_table</a>, <a class="el" href="range__image_8h_source.html#l00785">lookup_table_size</a>, <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>, and <a class="el" href="pcl__macros_8h_source.html#l00254">pcl_lrintf</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, and <a class="el" href="range__image__spherical_8hpp_source.html#l00060">pcl::RangeImageSpherical::getImagePoint()</a>.</p>

</div>
</div>
<a id="abbb77866cf4ee5d2a619f4f8cc62cc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb77866cf4ee5d2a619f4f8cc62cc9b">&#9670;&nbsp;</a></span>calculate3DPoint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::calculate3DPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 3D point according to the given image point and the range value at the closest pixel. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00584">584</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00592">calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, and <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a id="aa9e97e7487ac21a77075b5f8b64ca205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e97e7487ac21a77075b5f8b64ca205">&#9670;&nbsp;</a></span>calculate3DPoint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::calculate3DPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 3D point according to the given image point and range. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#ac897815d91a94243d6c50a7b47c50abd">pcl::RangeImagePlanar</a>, and <a class="el" href="classpcl_1_1_range_image_spherical.html#a43849e7a155b8af09e0355fe77e65266">pcl::RangeImageSpherical</a>.</p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00571">571</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00609">getAnglesFromImagePoint()</a>, and <a class="el" href="range__image_8h_source.html#l00769">to_world_system_</a>.</p>

</div>
</div>
<a id="a1acc16b4b5fb7071175bada62a5b75d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acc16b4b5fb7071175bada62a5b75d0">&#9670;&nbsp;</a></span>calculate3DPoint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::calculate3DPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 3D point according to the given image point and range. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00592">592</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00584">calculate3DPoint()</a>, and <a class="el" href="range__image__border__extractor_8hpp_source.html#l00120">pcl::RangeImageBorderExtractor::get3dDirection()</a>.</p>

</div>
</div>
<a id="a0f969bd0149b7848f0f26b44bb88035c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f969bd0149b7848f0f26b44bb88035c">&#9670;&nbsp;</a></span>calculate3DPoint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::calculate3DPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 3D point according to the given image point and the range value at the closest pixel. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00601">601</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00592">calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, and <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a id="a37582520baf6b317bbb81e85c95cc602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37582520baf6b317bbb81e85c95cc602">&#9670;&nbsp;</a></span>change3dPointsToLocalCoordinateFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::change3dPointsToLocalCoordinateFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensor pose to 0 and transforms all point positions to this local coordinate frame. </p>

</div>
</div>
<a id="a3e63aa0e7dc143f4a4a15611edcede70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e63aa0e7dc143f4a4a15611edcede70">&#9670;&nbsp;</a></span>checkPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::checkPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point_in_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>point_in_image will be the point in the image at the position the given point would be. </p>
<p>Returns the range of the given point. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00401">401</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>, and <a class="el" href="range__image_8h_source.html#l00778">unobserved_point</a>.</p>

</div>
</div>
<a id="a454c9018fc001c85e9d8df6900ceb0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454c9018fc001c85e9d8df6900ceb0f6">&#9670;&nbsp;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy other to *this. </p>
<p>Necessary for use in virtual functions that need to copy derived <a class="el" href="classpcl_1_1_range_image.html" title="RangeImage is derived from pcl/PointCloud and provides functionalities with focus on situations where...">RangeImage</a> classes (like <a class="el" href="classpcl_1_1_range_image_planar.html" title="RangeImagePlanar is derived from the original range image and differs from it because it&#39;s not a sphe...">RangeImagePlanar</a>) </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#a6eb0cd99d5062b11ccd54b4274340c0c">pcl::RangeImagePlanar</a>.</p>

</div>
</div>
<a id="a29ab1f1088b1c8d111dfe02139882ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ab1f1088b1c8d111dfe02139882ded">&#9670;&nbsp;</a></span>cosLookUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::cosLookUp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the cos lookup table. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00090">90</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00788">cos_lookup_table</a>, <a class="el" href="range__image_8h_source.html#l00785">lookup_table_size</a>, <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>, and <a class="el" href="pcl__macros_8h_source.html#l00254">pcl_lrintf</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00592">pcl::RangeImagePlanar::calculate3DPoint()</a>.</p>

</div>
</div>
<a id="a46cb318d3d6f1cf6aace8d2ed10ed7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cb318d3d6f1cf6aace8d2ed10ed7fa">&#9670;&nbsp;</a></span>createEmpty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createEmpty </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_width</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_height</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(180.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty depth image (filled with unobserved points) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angular_resolution</td><td>the angle (in radians) between each sample in the depth image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor (defaults to 2*pi (360deg)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor (defaults to pi (180deg)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa9ecf76f97e99ede5b71bb7da6c1715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9ecf76f97e99ede5b71bb7da6c1715">&#9670;&nbsp;</a></span>createEmpty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createEmpty </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_width</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(360.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_height</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>(180.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty depth image (filled with unobserved points) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">angular_resolution_x</td><td>the angular difference (in radians) between the individual pixels in the image in the x-direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">angular_resolution_y</td><td>the angular difference (in radians) between the individual pixels in the image in the y-direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor (defaults to 2*pi (360deg)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor (defaults to pi (180deg)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82f6a143de2d73a0ad9fea6c527a2efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f6a143de2d73a0ad9fea6c527a2efb">&#9670;&nbsp;</a></span>createFromPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloud </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(0.5f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_width</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(360.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_height</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(180.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution</td><td>the angular difference (in radians) between the individual pixels in the image </td></tr>
    <tr><td class="paramname">max_angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor </td></tr>
    <tr><td class="paramname">max_angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor </td></tr>
    <tr><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0). Set to <code>std::numeric_limits&lt;int&gt;::min()</code> to turn cropping off. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00098">98</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, and <a class="el" href="range__image_8hpp_source.html#l00224">createFromPointCloudWithViewpoints()</a>.</p>

</div>
</div>
<a id="ae3a8a2def6dde7446b9fc456f7992aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a8a2def6dde7446b9fc456f7992aa9">&#9670;&nbsp;</a></span>createFromPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloud </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(0.5f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(0.5f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_width</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(360.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_height</em> = <code><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a>&#160;(180.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution_x</td><td>the angular difference (in radians) between the individual pixels in the image in the x-direction </td></tr>
    <tr><td class="paramname">angular_resolution_y</td><td>the angular difference (in radians) between the individual pixels in the image in the y-direction </td></tr>
    <tr><td class="paramname">max_angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor </td></tr>
    <tr><td class="paramname">max_angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor </td></tr>
    <tr><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0). Set to <code>std::numeric_limits&lt;int&gt;::min()</code> to turn cropping off. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00109">109</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_y_reciprocal_</a>, <a class="el" href="classpcl_1_1_range_image.html#a20f223d93080e9ce32122f90a265f7c4">cropImage()</a>, <a class="el" href="angles_8hpp_source.html#l00067">pcl::deg2rad()</a>, <a class="el" href="range__image_8hpp_source.html#l00238">doZBuffer()</a>, <a class="el" href="classpcl_1_1_range_image.html#af5c0908bfbe060fdb517728fe56b2c55">getCoordinateFrameTransformation()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointWithRange &gt;::height</a>, <a class="el" href="range__image_8h_source.html#l00776">image_offset_x_</a>, <a class="el" href="range__image_8h_source.html#l00776">image_offset_y_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointWithRange &gt;::is_dense</a>, <a class="el" href="pcl__macros_8h_source.html#l00253">pcl_lrint</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, <a class="el" href="classpcl_1_1_range_image.html#a08d6ccfef80c3788102327df618a3fbf">recalculate3DPointPositions()</a>, <a class="el" href="range__image_8hpp_source.html#l01195">setAngularResolution()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointWithRange &gt;::size()</a>, <a class="el" href="range__image_8h_source.html#l00768">to_range_image_system_</a>, <a class="el" href="range__image_8h_source.html#l00769">to_world_system_</a>, <a class="el" href="range__image_8h_source.html#l00778">unobserved_point</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

</div>
</div>
<a id="afbb553405d9b1df2b10b08c98c052250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb553405d9b1df2b10b08c98c052250">&#9670;&nbsp;</a></span>createFromPointCloudWithKnownSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloudWithKnownSize </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_cloud_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>point_cloud_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution</td><td>the angle (in radians) between each sample in the depth image </td></tr>
    <tr><td class="paramname">point_cloud_center</td><td>the center of bounding sphere </td></tr>
    <tr><td class="paramname">point_cloud_radius</td><td>the radius of the bounding sphere </td></tr>
    <tr><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0). Set to <code>std::numeric_limits&lt;int&gt;::min()</code> to turn cropping off. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00148">148</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

</div>
</div>
<a id="ac52b84843090cf756a37c596b5e772d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52b84843090cf756a37c596b5e772d2">&#9670;&nbsp;</a></span>createFromPointCloudWithKnownSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloudWithKnownSize </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point_cloud_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>point_cloud_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>sensor_pose</em> = <code>Eigen::Affine3f::Identity&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud, getting a hint about the size of the scene for faster calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution_x</td><td>the angular difference (in radians) between the individual pixels in the image in the x-direction </td></tr>
    <tr><td class="paramname">angular_resolution_y</td><td>the angular difference (in radians) between the individual pixels in the image in the y-direction </td></tr>
    <tr><td class="paramname">point_cloud_center</td><td>the center of bounding sphere </td></tr>
    <tr><td class="paramname">point_cloud_radius</td><td>the radius of the bounding sphere </td></tr>
    <tr><td class="paramname">sensor_pose</td><td>an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () ) </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0). Set to <code>std::numeric_limits&lt;int&gt;::min()</code> to turn cropping off. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00159">159</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_y_reciprocal_</a>, <a class="el" href="range__image_8hpp_source.html#l00098">createFromPointCloud()</a>, <a class="el" href="classpcl_1_1_range_image.html#a20f223d93080e9ce32122f90a265f7c4">cropImage()</a>, <a class="el" href="angles_8hpp_source.html#l00067">pcl::deg2rad()</a>, <a class="el" href="range__image_8hpp_source.html#l00238">doZBuffer()</a>, <a class="el" href="classpcl_1_1_range_image.html#af5c0908bfbe060fdb517728fe56b2c55">getCoordinateFrameTransformation()</a>, <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00795">getMaxAngleSize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointWithRange &gt;::height</a>, <a class="el" href="range__image_8h_source.html#l00776">image_offset_x_</a>, <a class="el" href="range__image_8h_source.html#l00776">image_offset_y_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointWithRange &gt;::is_dense</a>, <a class="el" href="pcl__macros_8h_source.html#l00253">pcl_lrint</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, <a class="el" href="classpcl_1_1_range_image.html#a08d6ccfef80c3788102327df618a3fbf">recalculate3DPointPositions()</a>, <a class="el" href="range__image_8hpp_source.html#l01195">setAngularResolution()</a>, <a class="el" href="range__image_8h_source.html#l00768">to_range_image_system_</a>, <a class="el" href="range__image_8h_source.html#l00769">to_world_system_</a>, <a class="el" href="range__image_8h_source.html#l00778">unobserved_point</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

</div>
</div>
<a id="a91cb7406e0e57923a7f5d533ea578c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb7406e0e57923a7f5d533ea578c0f">&#9670;&nbsp;</a></span>createFromPointCloudWithViewpoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudTypeWithViewpoints &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloudWithViewpoints </td>
          <td>(</td>
          <td class="paramtype">const PointCloudTypeWithViewpoints &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution</td><td>the angle (in radians) between each sample in the depth image </td></tr>
    <tr><td class="paramname">max_angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor </td></tr>
    <tr><td class="paramname">max_angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0). Set to <code>std::numeric_limits&lt;int&gt;::min()</code> to turn cropping off. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If wrong_coordinate_system is true, the sensor pose will be rotated to change from a coordinate frame with x to the front, y to the left and z to the top to the coordinate frame we use here (x to the right, y to the bottom and z to the front) </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00211">211</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

</div>
</div>
<a id="a66de72c9511e694d41bd7a48c043f541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66de72c9511e694d41bd7a48c043f541">&#9670;&nbsp;</a></span>createFromPointCloudWithViewpoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudTypeWithViewpoints &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::createFromPointCloudWithViewpoints </td>
          <td>(</td>
          <td class="paramtype">const PointCloudTypeWithViewpoints &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_angle_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em> = <code><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992facc23a9ec8c5fe7011f1168b87ec945bf">CAMERA_FRAME</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the depth image from a point cloud, using the average viewpoint of the points (vp_x,vp_y,vp_z in the point type) in the point cloud as sensor pose (assuming a rotation of (0,0,0)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">angular_resolution_x</td><td>the angular difference (in radians) between the individual pixels in the image in the x-direction </td></tr>
    <tr><td class="paramname">angular_resolution_y</td><td>the angular difference (in radians) between the individual pixels in the image in the y-direction </td></tr>
    <tr><td class="paramname">max_angle_width</td><td>an angle (in radians) defining the horizontal bounds of the sensor </td></tr>
    <tr><td class="paramname">max_angle_height</td><td>an angle (in radians) defining the vertical bounds of the sensor </td></tr>
    <tr><td class="paramname">coordinate_frame</td><td>the coordinate frame (defaults to CAMERA_FRAME) </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range (defaults to 0) </td></tr>
    <tr><td class="paramname">border_size</td><td>the border size (defaults to 0). Set to <code>std::numeric_limits&lt;int&gt;::min()</code> to turn cropping off. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If wrong_coordinate_system is true, the sensor pose will be rotated to change from a coordinate frame with x to the front, y to the left and z to the top to the coordinate frame we use here (x to the right, y to the bottom and z to the front) </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00224">224</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00098">createFromPointCloud()</a>, and <a class="el" href="range__image_8hpp_source.html#l01133">getAverageViewPoint()</a>.</p>

</div>
</div>
<a id="ae74c34594e1417fb702d92ff51f2b495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74c34594e1417fb702d92ff51f2b495">&#9670;&nbsp;</a></span>createLookupTables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pcl::RangeImage::createLookupTables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create lookup tables for trigonometric functions. </p>

</div>
</div>
<a id="a20f223d93080e9ce32122f90a265f7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f223d93080e9ce32122f90a265f7c4">&#9670;&nbsp;</a></span>cropImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::cropImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottom</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cut the range image to the minimal size so that it still contains all actual range readings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">border_size</td><td>allows increase from the minimal size by the specified number of pixels (defaults to 0) </td></tr>
    <tr><td class="paramname">top</td><td>if positive, this value overrides the position of the top edge (defaults to -1) </td></tr>
    <tr><td class="paramname">right</td><td>if positive, this value overrides the position of the right edge (defaults to -1) </td></tr>
    <tr><td class="paramname">bottom</td><td>if positive, this value overrides the position of the bottom edge (defaults to -1) </td></tr>
    <tr><td class="paramname">left</td><td>if positive, this value overrides the position of the left edge (defaults to -1) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, and <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a id="a56655a55b4c83c7ce301ca0f020759b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56655a55b4c83c7ce301ca0f020759b4">&#9670;&nbsp;</a></span>doZBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::doZBuffer </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>noise_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate the given point cloud into the current range image using a z-buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">noise_level</td><td>- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell. </td></tr>
    <tr><td class="paramname">min_range</td><td>the minimum visible range </td></tr>
    <tr><td class="paramname">top</td><td>returns the minimum y pixel position in the image where a point was added </td></tr>
    <tr><td class="paramname">right</td><td>returns the maximum x pixel position in the image where a point was added </td></tr>
    <tr><td class="paramname">bottom</td><td>returns the maximum y pixel position in the image where a point was added </td></tr>
    <tr><td class="paramname">left</td><td>returns the minimum x pixel position in the image where a point was added </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00238">238</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointWithRange &gt;::height</a>, <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>, <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>, <a class="el" href="pcl__macros_8h_source.html#l00253">pcl_lrint</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, <a class="el" href="range__image_8hpp_source.html#l00442">real2DToInt2D()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointWithRange &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, and <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a id="a75e39ee2587a56fbdda651c27cc7898e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e39ee2587a56fbdda651c27cc7898e">&#9670;&nbsp;</a></span>extractFarRanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::extractFarRanges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>point_cloud_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_with_viewpoint.html">PointWithViewpoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>far_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the provided data includes far ranges and add them to far_ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud_data</td><td>a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> message containing the input cloud </td></tr>
    <tr><td class="paramname">far_ranges</td><td>the resulting cloud containing those points with far ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a397d6c6b38906e98ab89b817c4191247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397d6c6b38906e98ab89b817c4191247">&#9670;&nbsp;</a></span>get1dPointAverage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::get1dPointAverage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_of_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>average_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the average 3D position of the no_of_points points described by the start point x,y in the direction delta. </p>
<p>Returns a max range point (range=INFINITY) if the first point is max range and an unobserved point (range=-INFINITY) if non of the points is observed. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00809">809</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00495">getPointNoCheck()</a>, <a class="el" href="range__image_8hpp_source.html#l00457">isValid()</a>, <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>, and <a class="el" href="range__image_8h_source.html#l00778">unobserved_point</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00070">pcl::RangeImageBorderExtractor::getNeighborDistanceChangeScore()</a>.</p>

</div>
</div>
<a id="a2290765b8ccd5608ffa4967dc282395a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2290765b8ccd5608ffa4967dc282395a">&#9670;&nbsp;</a></span>getAcutenessValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAcutenessValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) will return -INFINITY if one of the points is unobserved. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00659">659</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00627">getImpactAngle()</a>, and <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00674">getAcutenessValue()</a>.</p>

</div>
</div>
<a id="a428803af781c88a43cf0c9b251d081bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428803af781c88a43cf0c9b251d081bf">&#9670;&nbsp;</a></span>getAcutenessValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAcutenessValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00674">674</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00659">getAcutenessValue()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>.</p>

</div>
</div>
<a id="a56821ed68e8701450b4725ed9c6fd7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56821ed68e8701450b4725ed9c6fd7a0">&#9670;&nbsp;</a></span>getAcutenessValueImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::getAcutenessValueImages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixel_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>acuteness_value_image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>acuteness_value_image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate getAcutenessValue for every point. </p>

</div>
</div>
<a id="a2388ab60ff312e9034df5e67f899ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2388ab60ff312e9034df5e67f899ea97">&#9670;&nbsp;</a></span>getAnglesFromImagePoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getAnglesFromImagePoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angle_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angle_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the angles corresponding to the given image point. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00609">609</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00770">angular_resolution_x_</a>, <a class="el" href="range__image_8h_source.html#l00771">angular_resolution_y_</a>, <a class="el" href="range__image_8h_source.html#l00776">image_offset_x_</a>, <a class="el" href="range__image_8h_source.html#l00776">image_offset_y_</a>, and <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00571">calculate3DPoint()</a>.</p>

</div>
</div>
<a id="a6fc3548b0b33e90cead2c1ecfce14c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc3548b0b33e90cead2c1ecfce14c34">&#9670;&nbsp;</a></span>getAngularResolution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAngularResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the angular resolution of the range image in x direction in radians per pixel. </p>
<p>Provided for downwards compatibility </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00352">352</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00770">angular_resolution_x_</a>.</p>

</div>
</div>
<a id="a41c0b0f74510988357a56fdc48d18f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c0b0f74510988357a56fdc48d18f93">&#9670;&nbsp;</a></span>getAngularResolution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getAngularResolution </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the angular resolution of the range image in x and y direction (in radians). </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01221">1221</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00770">angular_resolution_x_</a>, and <a class="el" href="range__image_8h_source.html#l00771">angular_resolution_y_</a>.</p>

</div>
</div>
<a id="a6522dbfac4997c15bd24b0b9b3e9d4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6522dbfac4997c15bd24b0b9b3e9d4dd">&#9670;&nbsp;</a></span>getAngularResolutionX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAngularResolutionX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the angular resolution of the range image in x direction in radians per pixel. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00356">356</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00770">angular_resolution_x_</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8h_source.html#l00814">pcl::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="af4891c9812652efe513b9ff060490364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4891c9812652efe513b9ff060490364">&#9670;&nbsp;</a></span>getAngularResolutionY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAngularResolutionY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the angular resolution of the range image in y direction in radians per pixel. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00360">360</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00771">angular_resolution_y_</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8h_source.html#l00814">pcl::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a4d702bb8f446bb382040e5872b6dbfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d702bb8f446bb382040e5872b6dbfb1">&#9670;&nbsp;</a></span>getAverageEuclideanDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getAverageEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Doing the above for some steps in the given direction and averaging. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00864">864</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00849">getEuclideanDistanceSquared()</a>.</p>

</div>
</div>
<a id="a49c425d518d92def18300cd029ae1855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c425d518d92def18300cd029ae1855">&#9670;&nbsp;</a></span>getAverageViewPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudTypeWithViewpoints &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f pcl::RangeImage::getAverageViewPoint </td>
          <td>(</td>
          <td class="paramtype">const PointCloudTypeWithViewpoints &amp;&#160;</td>
          <td class="paramname"><em>point_cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the average viewpoint of a point cloud where each point carries viewpoint information as vp_x, vp_y, vp_z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_cloud</td><td>the input point cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average viewpoint (as an Eigen::Vector3f) </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01133">1133</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00224">createFromPointCloudWithViewpoints()</a>.</p>

</div>
</div>
<a id="a29b238256cffb27a526bf89e857e5602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b238256cffb27a526bf89e857e5602">&#9670;&nbsp;</a></span>getBlurredImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::getBlurredImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blur_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>range_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a blurred version of the range image using box filters. </p>

</div>
</div>
<a id="a1037c5597389ad0f981c91f820b392a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1037c5597389ad0f981c91f820b392a9">&#9670;&nbsp;</a></span>getBlurredImageUsingIntegralImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::getBlurredImageUsingIntegralImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blur_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>integral_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>valid_points_num_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>range_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a blurred version of the range image using box filters on the provided integral image. </p>

</div>
</div>
<a id="af5c0908bfbe060fdb517728fe56b2c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c0908bfbe060fdb517728fe56b2c55">&#9670;&nbsp;</a></span>getCoordinateFrameTransformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::getCoordinateFrameTransformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html#a8b5785b0499f0a70d5c87fceba55992f">RangeImage::CoordinateFrame</a>&#160;</td>
          <td class="paramname"><em>coordinate_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the transformation that transforms the given coordinate frame into CAMERA_FRAME. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinate_frame</td><td>the input coordinate frame </td></tr>
    <tr><td class="paramname">transformation</td><td>the resulting transformation that warps <em>coordinate_frame</em> into CAMERA_FRAME </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, and <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a id="ac6a22e10be8bfcedf9297d1e1badef1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a22e10be8bfcedf9297d1e1badef1c">&#9670;&nbsp;</a></span>getCurvature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getCurvature </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the curvature in a point using pca. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01108">1108</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="vector__average_8hpp_source.html#l00063">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, <a class="el" href="vector__average_8hpp_source.html#l00084">pcl::VectorAverage&lt; real, dimension &gt;::doPCA()</a>, <a class="el" href="vector__average_8h_source.html#l00083">pcl::VectorAverage&lt; real, dimension &gt;::getNoOfSamples()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>, and <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a id="a2e3b75077a96415e431b90f53a249773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3b75077a96415e431b90f53a249773">&#9670;&nbsp;</a></span>getEigenVector3f() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f pcl::RangeImage::getEigenVector3f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Eigen::Vector3f from <a class="el" href="structpcl_1_1_point_with_range.html" title="A point structure representing Euclidean xyz coordinates, padded with an extra range float.">PointWithRange</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the input point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an Eigen::Vector3f representation of the input point </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00802">802</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00891">getImpactAngleBasedOnLocalNormal()</a>.</p>

</div>
</div>
<a id="aab3ee4df50d138b9f9b4ba34306c1071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3ee4df50d138b9f9b4ba34306c1071">&#9670;&nbsp;</a></span>getEigenVector3f() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Map&lt; const Eigen::Vector3f &gt; pcl::RangeImage::getEigenVector3f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00564">564</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>.</p>

</div>
</div>
<a id="a63716da3dad788cd23b64e9dc67b1791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63716da3dad788cd23b64e9dc67b1791">&#9670;&nbsp;</a></span>getEigenVector3f() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Map&lt; const Eigen::Vector3f &gt; pcl::RangeImage::getEigenVector3f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00557">557</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>.</p>

</div>
</div>
<a id="a9270139a4ebc5b01e91262bba72c1cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9270139a4ebc5b01e91262bba72c1cf5">&#9670;&nbsp;</a></span>getEuclideanDistanceSquared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getEuclideanDistanceSquared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the squared euclidean distance between the two image points. </p>
<p>Returns -INFINITY if one of the points was not observed </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00849">849</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00471">isObserved()</a>, <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00182">pcl::squaredEuclideanDistance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00864">getAverageEuclideanDistance()</a>.</p>

</div>
</div>
<a id="ab39a4eac61ba75bb9f2913a1ff3ec84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39a4eac61ba75bb9f2913a1ff3ec84d">&#9670;&nbsp;</a></span>getHalfImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcl::RangeImage::getHalfImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>half_image</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range image with half the resolution. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#a08d9e7838a64e2d041f73597f205fd35">pcl::RangeImagePlanar</a>.</p>

</div>
</div>
<a id="a25e2db660717d67a19f5cdb39937c00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e2db660717d67a19f5cdb39937c00a">&#9670;&nbsp;</a></span>getImageOffsetX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::getImageOffsetX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for image_offset_x_. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00630">630</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00776">image_offset_x_</a>.</p>

</div>
</div>
<a id="a42c06aa5693077ab6db7ec5c691dc677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c06aa5693077ab6db7ec5c691dc677">&#9670;&nbsp;</a></span>getImageOffsetY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::getImageOffsetY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for image_offset_y_. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00633">633</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00776">image_offset_y_</a>.</p>

</div>
</div>
<a id="a8b9b678a491ddefc1109494157e0aa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9b678a491ddefc1109494157e0aa83">&#9670;&nbsp;</a></span>getImagePoint() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00384">384</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>.</p>

</div>
</div>
<a id="a7a53bfc9f4a3365ee8e62513ae37eb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a53bfc9f4a3365ee8e62513ae37eb5c">&#9670;&nbsp;</a></span>getImagePoint() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get imagePoint from 3D point in world coordinates. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#acc9341cdb5d210534ea69dd0ad1bcbcf">pcl::RangeImagePlanar</a>, and <a class="el" href="classpcl_1_1_range_image_spherical.html#ac3d6279042ea8f5da9ea0efd8221a749">pcl::RangeImageSpherical</a>.</p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00357">357</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00054">asinLookUp()</a>, <a class="el" href="range__image_8hpp_source.html#l00064">atan2LookUp()</a>, <a class="el" href="range__image_8hpp_source.html#l00434">getImagePointFromAngles()</a>, and <a class="el" href="range__image_8h_source.html#l00768">to_range_image_system_</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00401">checkPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00238">doZBuffer()</a>, <a class="el" href="range__image_8hpp_source.html#l00332">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00415">getRangeDifference()</a>, and <a class="el" href="range__image_8hpp_source.html#l01229">integrateFarRanges()</a>.</p>

</div>
</div>
<a id="aac7ef90b9c78876a492fd16701d6578e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7ef90b9c78876a492fd16701d6578e">&#9670;&nbsp;</a></span>getImagePoint() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00392">392</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00442">real2DToInt2D()</a>.</p>

</div>
</div>
<a id="a9295b795c8f52a90eb3af983612fea8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9295b795c8f52a90eb3af983612fea8a">&#9670;&nbsp;</a></span>getImagePoint() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00376">376</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00442">real2DToInt2D()</a>.</p>

</div>
</div>
<a id="a8123412373a87d5030ee5f8a9b3ba3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8123412373a87d5030ee5f8a9b3ba3e4">&#9670;&nbsp;</a></span>getImagePoint() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00340">340</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>.</p>

</div>
</div>
<a id="a09c81c4b4ffd68fc5742167d15f6af87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c81c4b4ffd68fc5742167d15f6af87">&#9670;&nbsp;</a></span>getImagePoint() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00332">332</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>.</p>

</div>
</div>
<a id="a2ba0bfce9adcf8161feec7c59f75082c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba0bfce9adcf8161feec7c59f75082c">&#9670;&nbsp;</a></span>getImagePoint() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00348">348</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00442">real2DToInt2D()</a>.</p>

</div>
</div>
<a id="adfd931443541e194f1c53d5f7b1c43e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd931443541e194f1c53d5f7b1c43e6">&#9670;&nbsp;</a></span>getImagePointFromAngles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getImagePointFromAngles </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the image point corresponding to the given angles. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00434">434</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>.</p>

</div>
</div>
<a id="a6b87fa04fd32ec986f1af9149bd46841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b87fa04fd32ec986f1af9149bd46841">&#9670;&nbsp;</a></span>getImpactAngle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getImpactAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the impact angle based on the sensor position and the two given points - will return -INFINITY if one of the points is unobserved. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00627">627</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>, <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00182">pcl::squaredEuclideanDistance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00659">getAcutenessValue()</a>, and <a class="el" href="range__image_8hpp_source.html#l00618">getImpactAngle()</a>.</p>

</div>
</div>
<a id="aa6210710d430006d4c4ca93b6f8023da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6210710d430006d4c4ca93b6f8023da">&#9670;&nbsp;</a></span>getImpactAngle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getImpactAngle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00618">618</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00627">getImpactAngle()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>.</p>

</div>
</div>
<a id="a1ca716a0e6b2aba846bdb4079275f6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca716a0e6b2aba846bdb4079275f6d9">&#9670;&nbsp;</a></span>getImpactAngleBasedOnLocalNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getImpactAngleBasedOnLocalNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a local normal (with a heuristic not to include background points) and calculate the impact angle based on this. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00891">891</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="angles_8hpp_source.html#l00067">pcl::deg2rad()</a>, <a class="el" href="range__image_8hpp_source.html#l00802">getEigenVector3f()</a>, <a class="el" href="range__image_8hpp_source.html#l00944">getNormalForClosestNeighbors()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00683">getSensorPos()</a>, and <a class="el" href="range__image_8hpp_source.html#l00457">isValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00932">getNormalBasedAcutenessValue()</a>.</p>

</div>
</div>
<a id="aecd52c29445543d03e40f0d75c8120c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd52c29445543d03e40f0d75c8120c0">&#9670;&nbsp;</a></span>getImpactAngleImageBasedOnLocalNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float* pcl::RangeImage::getImpactAngleImageBasedOnLocalNormals </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the above function for every point in the image. </p>

</div>
</div>
<a id="a03e02f341db8f43860b2cb83824a2123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e02f341db8f43860b2cb83824a2123">&#9670;&nbsp;</a></span>getIntegralImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::getIntegralImage </td>
          <td>(</td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>integral_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>valid_points_num_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the integral image of the range values (used for fast blur operations). </p>
<p>You are responsible for deleting it after usage! </p>

</div>
</div>
<a id="a225cab091b80ff23a3c7b0d7291dead2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225cab091b80ff23a3c7b0d7291dead2">&#9670;&nbsp;</a></span>getInterpolatedSurfaceProjection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float* pcl::RangeImage::getInterpolatedSurfaceProjection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>world_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a range patch as the z values of the coordinate frame given by pose. </p>
<p>The patch will have size pixel_size x pixel_size and each pixel covers world_size/pixel_size meters in the world You are responsible for deleting the structure afterwards! </p>

</div>
</div>
<a id="accadf69890d534cfcb0f9d65c60feaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accadf69890d534cfcb0f9d65c60feaac">&#9670;&nbsp;</a></span>getInterpolatedSurfaceProjection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float* pcl::RangeImage::getInterpolatedSurfaceProjection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>world_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but using the local coordinate frame defined by point and the viewing direction. </p>

</div>
</div>
<a id="ac504743608967dcd142dc4249b82ea5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac504743608967dcd142dc4249b82ea5a">&#9670;&nbsp;</a></span>getMaxAngleSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getMaxAngleSize </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>viewer_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a certain area when seen from the given pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewer_pose</td><td>an affine matrix defining the pose of the viewer </td></tr>
    <tr><td class="paramname">center</td><td>the center of the area </td></tr>
    <tr><td class="paramname">radius</td><td>the radius of the area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the area as viewed according to <em>viewer_pose</em> </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00795">795</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a id="a83b475eb983cd9edaea5d97c6d098a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b475eb983cd9edaea5d97c6d098a7c">&#9670;&nbsp;</a></span>getMinMaxRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::getMinMaxRanges </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>min_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>max_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum and maximum range in the image. </p>

</div>
</div>
<a id="a7bca09c1eb8be12975c47cb6d6233ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bca09c1eb8be12975c47cb6d6233ca5">&#9670;&nbsp;</a></span>getNew()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a>* pcl::RangeImage::getNew </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a newly created Range image. </p>
<p>Can be reimplemented in derived classes like <a class="el" href="classpcl_1_1_range_image_planar.html" title="RangeImagePlanar is derived from the original range image and differs from it because it&#39;s not a sphe...">RangeImagePlanar</a> to return an image of the same type. </p>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#a3d641496a2a90649d32419a2f3d00726">pcl::RangeImagePlanar</a>, and <a class="el" href="classpcl_1_1_range_image_spherical.html#acb6dc5877e1e91d773392a346778b0bc">pcl::RangeImageSpherical</a>.</p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00749">749</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="classpcl_1_1_range_image.html#af18b2d3410fb7799ad4de375b51df035">RangeImage()</a>.</p>

</div>
</div>
<a id="aeb21e9a192704802adabd6693f00e397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb21e9a192704802adabd6693f00e397">&#9670;&nbsp;</a></span>getNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the normal of an image point using the neighbors with a maximum pixel distance of radius. </p>
<p>step_size determines how many pixels are used. 1 means all, 2 only every second, etc.. Returns false if it was unable to calculate a normal. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00906">906</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="vector__average_8hpp_source.html#l00063">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, <a class="el" href="vector__average_8hpp_source.html#l00084">pcl::VectorAverage&lt; real, dimension &gt;::doPCA()</a>, <a class="el" href="vector__average_8h_source.html#l00071">pcl::VectorAverage&lt; real, dimension &gt;::getMean()</a>, <a class="el" href="vector__average_8h_source.html#l00083">pcl::VectorAverage&lt; real, dimension &gt;::getNoOfSamples()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00683">getSensorPos()</a>, <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>, and <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a id="a5b6d4bb74fa5134a6c21823dfdcdb13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6d4bb74fa5134a6c21823dfdcdb13e">&#9670;&nbsp;</a></span>getNormalBasedAcutenessValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getNormalBasedAcutenessValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a score [0,1] that tells how acute the impact angle is (1.0f - getImpactAngle/90deg) This uses getImpactAngleBasedOnLocalNormal Will return -INFINITY if no normal could be calculated. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00932">932</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00891">getImpactAngleBasedOnLocalNormal()</a>, and <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>.</p>

</div>
</div>
<a id="a0ee070d08d3e3688e24f8ebffc9b6436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee070d08d3e3688e24f8ebffc9b6436">&#9670;&nbsp;</a></span>getNormalBasedUprightTransformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::RangeImage::getNormalBasedUprightTransformation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a local coordinate frame at the given point based on the normal. </p>

</div>
</div>
<a id="a5cb82433197f15970647793c6271fe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb82433197f15970647793c6271fe9a">&#9670;&nbsp;</a></span>getNormalForClosestNeighbors() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getNormalForClosestNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, using default values. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00952">952</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00944">getNormalForClosestNeighbors()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00457">isValid()</a>.</p>

</div>
</div>
<a id="a3e583b912d095111ad61232ca2e8705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e583b912d095111ad61232ca2e8705e">&#9670;&nbsp;</a></span>getNormalForClosestNeighbors() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getNormalForClosestNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_of_nearest_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f *&#160;</td>
          <td class="paramname"><em>point_on_plane</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01089">1089</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00972">getSurfaceInformation()</a>.</p>

</div>
</div>
<a id="accb0781e43e55cff62851019ffac47ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb0781e43e55cff62851019ffac47ce">&#9670;&nbsp;</a></span>getNormalForClosestNeighbors() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getNormalForClosestNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_of_nearest_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, but only the no_of_nearest_neighbors points closest to the given point are considered. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00944">944</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00891">getImpactAngleBasedOnLocalNormal()</a>, and <a class="el" href="range__image_8hpp_source.html#l00952">getNormalForClosestNeighbors()</a>.</p>

</div>
</div>
<a id="addd0bcec3d51c70ac205bbfc75dd8c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd0bcec3d51c70ac205bbfc75dd8c18">&#9670;&nbsp;</a></span>getOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float pcl::RangeImage::getOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>other_range_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>relative_transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixel_step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the overlap of two range images given the relative transformation (from the given image to *this) </p>

</div>
</div>
<a id="aa403d6ee9c3d76a50b268204acab27ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa403d6ee9c3d76a50b268204acab27ff">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-const-version of the above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00533">533</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00442">real2DToInt2D()</a>.</p>

</div>
</div>
<a id="a0168934416e10ded1eb34d57123b8d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0168934416e10ded1eb34d57123b8d37">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 3d point with range at the given image position. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00524">524</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00442">real2DToInt2D()</a>.</p>

</div>
</div>
<a id="adb229f49ccf885517e905373372b00be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb229f49ccf885517e905373372b00be">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-const-version of getPoint. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00509">509</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

</div>
</div>
<a id="a52164736793c99cc9fc48dedee615e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52164736793c99cc9fc48dedee615e45">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 3D point with range at the given image position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_x</td><td>the x coordinate </td></tr>
    <tr><td class="paramname">image_y</td><td>the y coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the point at the specified location (returns unobserved_point if outside of the image bounds) </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00486">486</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, <a class="el" href="range__image_8h_source.html#l00778">unobserved_point</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00584">calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00401">checkPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00809">get1dPointAverage()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00120">pcl::RangeImageBorderExtractor::get3dDirection()</a>, <a class="el" href="range__image_8hpp_source.html#l00674">getAcutenessValue()</a>, <a class="el" href="range__image_8hpp_source.html#l01108">getCurvature()</a>, <a class="el" href="range__image_8hpp_source.html#l00557">getEigenVector3f()</a>, <a class="el" href="range__image_8hpp_source.html#l00849">getEuclideanDistanceSquared()</a>, <a class="el" href="range__image_8hpp_source.html#l00376">pcl::RangeImagePlanar::getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00618">getImpactAngle()</a>, <a class="el" href="range__image_8hpp_source.html#l00891">getImpactAngleBasedOnLocalNormal()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00070">pcl::RangeImageBorderExtractor::getNeighborDistanceChangeScore()</a>, <a class="el" href="range__image_8hpp_source.html#l00906">getNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l00952">getNormalForClosestNeighbors()</a>, <a class="el" href="range__image_8hpp_source.html#l00524">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00415">getRangeDifference()</a>, <a class="el" href="range__image_8hpp_source.html#l01059">getSquaredDistanceOfNthNeighbor()</a>, <a class="el" href="range__image_8hpp_source.html#l00690">getSurfaceAngleChange()</a>, <a class="el" href="range__image_8hpp_source.html#l00972">getSurfaceInformation()</a>, <a class="el" href="range__image_8hpp_source.html#l01153">getViewingDirection()</a>, <a class="el" href="range__image_8hpp_source.html#l01229">integrateFarRanges()</a>, and <a class="el" href="range__image_8hpp_source.html#l00478">isMaxRange()</a>.</p>

</div>
</div>
<a id="a35a8dbb8cc328029a928b3cff4225d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a8dbb8cc328029a928b3cff4225d5b">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00542">542</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>.</p>

</div>
</div>
<a id="a467a03da34e4ffd323ae0f080ac85570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467a03da34e4ffd323ae0f080ac85570">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 3d point with range at the given index (whereas index=y*width+x) </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00517">517</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointWithRange &gt;::points</a>.</p>

</div>
</div>
<a id="aa7e520479cc8f66e5ddd7f594649b25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e520479cc8f66e5ddd7f594649b25f">&#9670;&nbsp;</a></span>getPoint() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00550">550</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>.</p>

</div>
</div>
<a id="a45bfd00007940d0043b8f1df43663d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bfd00007940d0043b8f1df43663d07">&#9670;&nbsp;</a></span>getPointNoCheck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPointNoCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-const-version of getPointNoCheck. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00502">502</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

</div>
</div>
<a id="a587663a5b4123f4c423c9e38a9b36d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587663a5b4123f4c423c9e38a9b36d41">&#9670;&nbsp;</a></span>getPointNoCheck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> &amp; pcl::RangeImage::getPointNoCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 3D point with range at the given image position. </p>
<p>This method performs no error checking to make sure the specified image position is inside of the image! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_x</td><td>the x coordinate </td></tr>
    <tr><td class="paramname">image_y</td><td>the y coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the point at the specified location (program may fail if the location is outside of the image bounds) </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00495">495</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointWithRange &gt;::points</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00809">get1dPointAverage()</a>, and <a class="el" href="range__image_8hpp_source.html#l01059">getSquaredDistanceOfNthNeighbor()</a>.</p>

</div>
</div>
<a id="aea43fc18a9695437879d4b3b3860a9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea43fc18a9695437879d4b3b3860a9ae">&#9670;&nbsp;</a></span>getRangeDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getRangeDifference </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the difference in range between the given point and the range of the point in the image at the position the given point would be. </p>
<p>(Return value is point_in_image.range-given_point.range) </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00415">415</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>, and <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a id="a42e94ffae804608d0a7d2762cddd6fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e94ffae804608d0a7d2762cddd6fd2">&#9670;&nbsp;</a></span>getRangeImageWithSmoothedSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::getRangeImageWithSmoothedSurface </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>smoothed_range_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project all points on the local plane approximation, thereby smoothing the surface of the scan. </p>

</div>
</div>
<a id="ab124a58f66b1d9a5d0f433c8474ef2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab124a58f66b1d9a5d0f433c8474ef2b4">&#9670;&nbsp;</a></span>getRangesArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float* pcl::RangeImage::getRangesArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the range values in one float array of size width*height. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new float array containing the range values </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method allocates a new float array; the caller is responsible for freeing this memory. </dd></dl>

</div>
</div>
<a id="ab38c579faf678914119d4190b0068ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38c579faf678914119d4190b0068ab6">&#9670;&nbsp;</a></span>getRotationToViewerCoordinateFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getRotationToViewerCoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, but only returning the rotation. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01187">1187</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00683">getSensorPos()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00564">pcl::getTransformationFromTwoUnitVectors()</a>.</p>

</div>
</div>
<a id="a942d6b253c5df68008614af6dfed323a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942d6b253c5df68008614af6dfed323a">&#9670;&nbsp;</a></span>getSensorPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector3f pcl::RangeImage::getSensorPos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sensor position. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00683">683</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00769">to_world_system_</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00120">pcl::RangeImageBorderExtractor::get3dDirection()</a>, <a class="el" href="range__image_8hpp_source.html#l00891">getImpactAngleBasedOnLocalNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l00906">getNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l01187">getRotationToViewerCoordinateFrame()</a>, <a class="el" href="range__image_8hpp_source.html#l00972">getSurfaceInformation()</a>, <a class="el" href="range__image_8hpp_source.html#l01179">getTransformationToViewerCoordinateFrame()</a>, and <a class="el" href="range__image_8hpp_source.html#l01153">getViewingDirection()</a>.</p>

</div>
</div>
<a id="ae259a9342238404e8dbb3ff938470ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae259a9342238404e8dbb3ff938470ce2">&#9670;&nbsp;</a></span>getSquaredDistanceOfNthNeighbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::getSquaredDistanceOfNthNeighbor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01059">1059</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00495">getPointNoCheck()</a>, <a class="el" href="range__image_8hpp_source.html#l00457">isValid()</a>, <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00182">pcl::squaredEuclideanDistance()</a>.</p>

</div>
</div>
<a id="a33f4985713cf3f17ac8f8c69c0201729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f4985713cf3f17ac8f8c69c0201729">&#9670;&nbsp;</a></span>getSubImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcl::RangeImage::getSubImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sub_image_image_offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sub_image_image_offset_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sub_image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sub_image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>combine_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_range_image.html">RangeImage</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a sub part of the complete image as a new range image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub_image_image_offset_x</td><td>- The x coordinate of the top left pixel of the sub image. This is always according to absolute 0,0 meaning -180,-90 and it is already in the system of the new image, so the actual pixel used in the original image is combine_pixels* (image_offset_x-image_offset_x_) </td></tr>
    <tr><td class="paramname">sub_image_image_offset_y</td><td>- Same as image_offset_x for the y coordinate </td></tr>
    <tr><td class="paramname">sub_image_width</td><td>- width of the new image </td></tr>
    <tr><td class="paramname">sub_image_height</td><td>- height of the new image </td></tr>
    <tr><td class="paramname">combine_pixels</td><td>- shrinking factor, meaning the new angular resolution is combine_pixels times the old one </td></tr>
    <tr><td class="paramname">sub_image</td><td>- the output image </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classpcl_1_1_range_image_planar.html#a46bcbab49438968be9c743987b408b86">pcl::RangeImagePlanar</a>.</p>

</div>
</div>
<a id="afd94afe865f6cd46cfbc64f45bb1d03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd94afe865f6cd46cfbc64f45bb1d03e">&#9670;&nbsp;</a></span>getSurfaceAngleChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getSurfaceAngleChange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angle_change_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>angle_change_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates, how much the surface changes at a point. </p>
<p>Returns an angle [0.0f, PI] for x and y direction. A return value of -INFINITY means that a point was unobserved. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00690">690</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l01170">getTransformationToViewerCoordinateFrame()</a>, <a class="el" href="range__image_8hpp_source.html#l00478">isMaxRange()</a>, <a class="el" href="range__image_8hpp_source.html#l00471">isObserved()</a>, and <a class="el" href="range__image_8hpp_source.html#l00457">isValid()</a>.</p>

</div>
</div>
<a id="a0501e4697fe05327423b4e247baa3528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0501e4697fe05327423b4e247baa3528">&#9670;&nbsp;</a></span>getSurfaceAngleChangeImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::getSurfaceAngleChangeImages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>angle_change_image_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&amp;&#160;</td>
          <td class="paramname"><em>angle_change_image_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the above function for every point in the image. </p>

</div>
</div>
<a id="a16b744103dab2ba2a9ada137aa75887f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b744103dab2ba2a9ada137aa75887f">&#9670;&nbsp;</a></span>getSurfaceChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float pcl::RangeImage::getSurfaceChange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates, how much the surface changes at a point. </p>
<p>Pi meaning a flat surface and 0.0f would be a needle point Calculates, how much the surface changes at a point. 1 meaning a 90deg angle and 0 a flat surface </p>

</div>
</div>
<a id="a23b27f51c94a493a2c98c96a6acf3f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b27f51c94a493a2c98c96a6acf3f11">&#9670;&nbsp;</a></span>getSurfaceChangeImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> float* pcl::RangeImage::getSurfaceChangeImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the above function for every point in the image. </p>

</div>
</div>
<a id="aa44f7eb7c10f57ca223fed1e1267ac51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44f7eb7c10f57ca223fed1e1267ac51">&#9670;&nbsp;</a></span>getSurfaceInformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getSurfaceInformation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_of_closest_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>max_closest_neighbor_distance_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>eigen_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f *&#160;</td>
          <td class="paramname"><em>normal_all_neighbors</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f *&#160;</td>
          <td class="paramname"><em>mean_all_neighbors</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f *&#160;</td>
          <td class="paramname"><em>eigen_values_all_neighbors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above but extracts some more data and can also return the extracted information for all neighbors in radius if normal_all_neighbors is not NULL. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00972">972</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="vector__average_8hpp_source.html#l00063">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>, <a class="el" href="vector__average_8hpp_source.html#l00084">pcl::VectorAverage&lt; real, dimension &gt;::doPCA()</a>, <a class="el" href="vector__average_8h_source.html#l00071">pcl::VectorAverage&lt; real, dimension &gt;::getMean()</a>, <a class="el" href="vector__average_8h_source.html#l00083">pcl::VectorAverage&lt; real, dimension &gt;::getNoOfSamples()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00683">getSensorPos()</a>, <a class="el" href="range__image_8hpp_source.html#l00457">isValid()</a>, and <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00182">pcl::squaredEuclideanDistance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l01089">getNormalForClosestNeighbors()</a>.</p>

</div>
</div>
<a id="ac503c8e060a6f6b1cae1c1fa87fa6e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac503c8e060a6f6b1cae1c1fa87fa6e33">&#9670;&nbsp;</a></span>getTransformationToRangeImageSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Affine3f&amp; pcl::RangeImage::getTransformationToRangeImageSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the transformation from the world system into the range image system (the sensor coordinate frame) </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00337">337</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00768">to_range_image_system_</a>.</p>

</div>
</div>
<a id="a6646c58459dc6780f114039d296d88d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6646c58459dc6780f114039d296d88d4">&#9670;&nbsp;</a></span>getTransformationToViewerCoordinateFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::RangeImage::getTransformationToViewerCoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local coordinate frame with 0,0,0 in point, upright and Z as the viewing direction. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01170">1170</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00690">getSurfaceAngleChange()</a>.</p>

</div>
</div>
<a id="a4f79a45cb9beea2cca3a6f17a16d44b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f79a45cb9beea2cca3a6f17a16d44b7">&#9670;&nbsp;</a></span>getTransformationToViewerCoordinateFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getTransformationToViewerCoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, using a reference for the retrurn value. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01179">1179</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00683">getSensorPos()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00583">pcl::getTransformationFromTwoUnitVectorsAndOrigin()</a>.</p>

</div>
</div>
<a id="afdff6ffbb3bfec294637225b5fb82956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdff6ffbb3bfec294637225b5fb82956">&#9670;&nbsp;</a></span>getTransformationToWorldSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Affine3f&amp; pcl::RangeImage::getTransformationToWorldSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the transformation from the range image system (the sensor coordinate frame) into the world system. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00347">347</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00769">to_world_system_</a>.</p>

</div>
</div>
<a id="a32dfa3c681a50aebc74ae6830767a831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dfa3c681a50aebc74ae6830767a831">&#9670;&nbsp;</a></span>getViewingDirection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::getViewingDirection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>viewing_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the viewing direction for the given point. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01163">1163</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00683">getSensorPos()</a>.</p>

</div>
</div>
<a id="ad37bc4a8aab3d63ee7c9ef9428239f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37bc4a8aab3d63ee7c9ef9428239f00">&#9670;&nbsp;</a></span>getViewingDirection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::getViewingDirection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>viewing_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the viewing direction for the given point. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01153">1153</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00683">getSensorPos()</a>, and <a class="el" href="range__image_8hpp_source.html#l00457">isValid()</a>.</p>

</div>
</div>
<a id="a6c3ceb66679ccc84587eef5c29a16386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3ceb66679ccc84587eef5c29a16386">&#9670;&nbsp;</a></span>integrateFarRanges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointCloudType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::integrateFarRanges </td>
          <td>(</td>
          <td class="paramtype">const PointCloudType &amp;&#160;</td>
          <td class="paramname"><em>far_ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates the given far range measurements into the range image. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01229">1229</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00450">isInImage()</a>, <a class="el" href="pcl__macros_8h_source.html#l00253">pcl_lrint</a>, and <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>.</p>

</div>
</div>
<a id="a824a6bb27b43a174da775a656b81a483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824a6bb27b43a174da775a656b81a483">&#9670;&nbsp;</a></span>isInImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isInImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is inside of the image. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00450">450</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointWithRange &gt;::height</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointWithRange &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00180">pcl::RangeImageBorderExtractor::changeScoreAccordingToShadowBorderValue()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00289">pcl::RangeImageBorderExtractor::checkIfMaximum()</a>, <a class="el" href="range__image_8hpp_source.html#l00401">checkPoint()</a>, <a class="el" href="range__image__border__extractor_8hpp_source.html#l00258">pcl::RangeImageBorderExtractor::checkPotentialBorder()</a>, <a class="el" href="range__image_8hpp_source.html#l00238">doZBuffer()</a>, <a class="el" href="range__image_8hpp_source.html#l00674">getAcutenessValue()</a>, <a class="el" href="range__image_8hpp_source.html#l01108">getCurvature()</a>, <a class="el" href="range__image_8hpp_source.html#l00376">pcl::RangeImagePlanar::getImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00618">getImpactAngle()</a>, <a class="el" href="range__image_8hpp_source.html#l00906">getNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00415">getRangeDifference()</a>, <a class="el" href="range__image_8hpp_source.html#l01229">integrateFarRanges()</a>, and <a class="el" href="range__image__border__extractor_8hpp_source.html#l00226">pcl::RangeImageBorderExtractor::updatedScoreAccordingToNeighborValues()</a>.</p>

</div>
</div>
<a id="a771ab2f1ee2952a319da20301b27ab3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771ab2f1ee2952a319da20301b27ab3b">&#9670;&nbsp;</a></span>isMaxRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isMaxRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is a max range (range=INFINITY) - please check isInImage or isObserved first! </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00478">478</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>, and <a class="el" href="point__types_8hpp_source.html#l01046">pcl::_PointWithRange::range</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00180">pcl::RangeImageBorderExtractor::changeScoreAccordingToShadowBorderValue()</a>, and <a class="el" href="range__image_8hpp_source.html#l00690">getSurfaceAngleChange()</a>.</p>

</div>
</div>
<a id="a75e51885e151759d815ec1b1b72ea4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e51885e151759d815ec1b1b72ea4ff">&#9670;&nbsp;</a></span>isObserved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isObserved </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is inside of the image and has either a finite range or a max reading (range=INFINITY) </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00471">471</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00849">getEuclideanDistanceSquared()</a>, and <a class="el" href="range__image_8hpp_source.html#l00690">getSurfaceAngleChange()</a>.</p>

</div>
</div>
<a id="ad353c062c9b17adda3797bf970b9934b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad353c062c9b17adda3797bf970b9934b">&#9670;&nbsp;</a></span>isValid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point has a finite range. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00464">464</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

</div>
</div>
<a id="a2372989721c3c119bb5d4b5ebd9b59c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2372989721c3c119bb5d4b5ebd9b59c3">&#9670;&nbsp;</a></span>isValid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::isValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is inside of the image and has a finite range. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00457">457</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image__border__extractor_8hpp_source.html#l00312">pcl::RangeImageBorderExtractor::calculateMainPrincipalCurvature()</a>, <a class="el" href="range__image_8hpp_source.html#l00809">get1dPointAverage()</a>, <a class="el" href="range__image_8hpp_source.html#l00891">getImpactAngleBasedOnLocalNormal()</a>, <a class="el" href="range__image_8hpp_source.html#l00952">getNormalForClosestNeighbors()</a>, <a class="el" href="range__image_8hpp_source.html#l01059">getSquaredDistanceOfNthNeighbor()</a>, <a class="el" href="range__image_8hpp_source.html#l00690">getSurfaceAngleChange()</a>, <a class="el" href="range__image_8hpp_source.html#l00972">getSurfaceInformation()</a>, and <a class="el" href="range__image_8hpp_source.html#l01153">getViewingDirection()</a>.</p>

</div>
</div>
<a id="a7f898747aa6a52e484d65babc2600a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f898747aa6a52e484d65babc2600a23">&#9670;&nbsp;</a></span>makeShared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_range_image.html#a3ba0be0fa2c5cbd409547860c68ff9e8">Ptr</a> pcl::RangeImage::makeShared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a boost shared pointer of a copy of this. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00124">124</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a id="a86174b766aa77898e0d49ef11f4613b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86174b766aa77898e0d49ef11f4613b1">&#9670;&nbsp;</a></span>real2DToInt2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::real2DToInt2D </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>xInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>yInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms an image point in float values to an image point in int values. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l00442">442</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00238">doZBuffer()</a>, <a class="el" href="range__image_8hpp_source.html#l00348">getImagePoint()</a>, and <a class="el" href="range__image_8hpp_source.html#l00524">getPoint()</a>.</p>

</div>
</div>
<a id="a08d6ccfef80c3788102327df618a3fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d6ccfef80c3788102327df618a3fbf">&#9670;&nbsp;</a></span>recalculate3DPointPositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::recalculate3DPointPositions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate all 3D point positions according to their pixel position and range. </p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, and <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a id="acd539d95dd7bbbd1d67db12e9be275b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd539d95dd7bbbd1d67db12e9be275b0">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all values to an empty range image. </p>

</div>
</div>
<a id="a2720450161caef9a2992b0ac943ab2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2720450161caef9a2992b0ac943ab2b7">&#9670;&nbsp;</a></span>setAngularResolution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::setAngularResolution </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the angular resolution of the range image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angular_resolution</td><td>the new angular resolution in x and y direction (in radians per pixel) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01195">1195</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00770">angular_resolution_x_</a>, <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00771">angular_resolution_y_</a>, and <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_y_reciprocal_</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, and <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>.</p>

</div>
</div>
<a id="a74583440e4ef4b611b7d2b638c6da28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74583440e4ef4b611b7d2b638c6da28e">&#9670;&nbsp;</a></span>setAngularResolution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::setAngularResolution </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angular_resolution_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the angular resolution of the range image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angular_resolution_x</td><td>the new angular resolution in x direction (in radians per pixel) </td></tr>
    <tr><td class="paramname">angular_resolution_y</td><td>the new angular resolution in y direction (in radians per pixel) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01203">1203</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00770">angular_resolution_x_</a>, <a class="el" href="range__image_8h_source.html#l00772">angular_resolution_x_reciprocal_</a>, <a class="el" href="range__image_8h_source.html#l00771">angular_resolution_y_</a>, and <a class="el" href="range__image_8h_source.html#l00774">angular_resolution_y_reciprocal_</a>.</p>

</div>
</div>
<a id="a962a922e6a1170b1494ee21859087b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a922e6a1170b1494ee21859087b4e">&#9670;&nbsp;</a></span>setImageOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::setImageOffsets </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for image offsets. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00637">637</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00776">image_offset_x_</a>, and <a class="el" href="range__image_8h_source.html#l00776">image_offset_y_</a>.</p>

</div>
</div>
<a id="ab0419b66dd9e76fbc6d568049abfad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0419b66dd9e76fbc6d568049abfad3c">&#9670;&nbsp;</a></span>setTransformationToRangeImageSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::RangeImage::setTransformationToRangeImageSystem </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>to_range_image_system</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for the transformation from the range image system (the sensor coordinate frame) into the world system. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8hpp_source.html#l01213">1213</a> of file <a class="el" href="range__image_8hpp_source.html">range_image.hpp</a>.</p>

<p class="reference">References <a class="el" href="range__image_8h_source.html#l00768">to_range_image_system_</a>, and <a class="el" href="range__image_8h_source.html#l00769">to_world_system_</a>.</p>

</div>
</div>
<a id="ad4f7d854c4f15ab0ab2193cc726c353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f7d854c4f15ab0ab2193cc726c353f">&#9670;&nbsp;</a></span>setUnseenToMaxRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::RangeImage::setUnseenToMaxRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all -INFINITY values to INFINITY. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abdbfb655cdfeb5d8ace1ac841a52a524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbfb655cdfeb5d8ace1ac841a52a524">&#9670;&nbsp;</a></span>angular_resolution_x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::angular_resolution_x_ {0.0f}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Angular resolution of the range image in x direction in radians per pixel. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00770">770</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00609">getAnglesFromImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00070">pcl::RangeImageSpherical::getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l01221">getAngularResolution()</a>, <a class="el" href="range__image_8h_source.html#l00356">getAngularResolutionX()</a>, and <a class="el" href="range__image_8hpp_source.html#l01195">setAngularResolution()</a>.</p>

</div>
</div>
<a id="adbb1466576e6c2d08e3065b67da0b250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb1466576e6c2d08e3065b67da0b250">&#9670;&nbsp;</a></span>angular_resolution_x_reciprocal_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::angular_resolution_x_reciprocal_ {0.0f}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1.0/angular_resolution_x_ - provided for better performance of multiplication compared to division </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00772">772</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00592">pcl::RangeImagePlanar::calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00077">pcl::RangeImageSpherical::getImagePointFromAngles()</a>, and <a class="el" href="range__image_8hpp_source.html#l01195">setAngularResolution()</a>.</p>

</div>
</div>
<a id="a9471a00ecde65c754227e155cc234942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9471a00ecde65c754227e155cc234942">&#9670;&nbsp;</a></span>angular_resolution_y_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::angular_resolution_y_ {0.0f}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Angular resolution of the range image in y direction in radians per pixel. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00771">771</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00609">getAnglesFromImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00070">pcl::RangeImageSpherical::getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8hpp_source.html#l01221">getAngularResolution()</a>, <a class="el" href="range__image_8h_source.html#l00360">getAngularResolutionY()</a>, and <a class="el" href="range__image_8hpp_source.html#l01195">setAngularResolution()</a>.</p>

</div>
</div>
<a id="a843659230146a43690ee4d4fb53fcc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843659230146a43690ee4d4fb53fcc92">&#9670;&nbsp;</a></span>angular_resolution_y_reciprocal_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::RangeImage::angular_resolution_y_reciprocal_ {0.0f}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1.0/angular_resolution_y_ - provided for better performance of multiplication compared to division </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00774">774</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00592">pcl::RangeImagePlanar::calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00077">pcl::RangeImageSpherical::getImagePointFromAngles()</a>, and <a class="el" href="range__image_8hpp_source.html#l01195">setAngularResolution()</a>.</p>

</div>
</div>
<a id="aa1c5323cee871dcb71da6888b9cf4b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c5323cee871dcb71da6888b9cf4b5b">&#9670;&nbsp;</a></span>asin_lookup_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::vector&lt;float&gt; pcl::RangeImage::asin_lookup_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00786">786</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00054">asinLookUp()</a>.</p>

</div>
</div>
<a id="a99ce0726f5ec931ab3a0e0dde61daac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ce0726f5ec931ab3a0e0dde61daac1">&#9670;&nbsp;</a></span>atan_lookup_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::vector&lt;float&gt; pcl::RangeImage::atan_lookup_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00787">787</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00064">atan2LookUp()</a>.</p>

</div>
</div>
<a id="a7092794afdcc1a97613646e8054fa441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7092794afdcc1a97613646e8054fa441">&#9670;&nbsp;</a></span>cos_lookup_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> std::vector&lt;float&gt; pcl::RangeImage::cos_lookup_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00788">788</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00090">cosLookUp()</a>.</p>

</div>
</div>
<a id="a1bd552e2971d69843fdec72413823f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd552e2971d69843fdec72413823f57">&#9670;&nbsp;</a></span>debug</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::RangeImage::debug</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just for... </p>
<p>well... debugging purposes. :-) </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00764">764</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a id="ac01b76b2e83df5967984084e7558c2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01b76b2e83df5967984084e7558c2d5">&#9670;&nbsp;</a></span>image_offset_x_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::image_offset_x_ {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00776">776</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00592">pcl::RangeImagePlanar::calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00609">getAnglesFromImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00070">pcl::RangeImageSpherical::getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8h_source.html#l00630">getImageOffsetX()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00105">pcl::RangeImagePlanar::getImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00077">pcl::RangeImageSpherical::getImagePointFromAngles()</a>, and <a class="el" href="range__image_8h_source.html#l00637">setImageOffsets()</a>.</p>

</div>
</div>
<a id="a1518af9f1c9eb6ac259be92824842e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1518af9f1c9eb6ac259be92824842e23">&#9670;&nbsp;</a></span>image_offset_y_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::image_offset_y_ {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Position of the top left corner of the range image compared to an image of full size (360x180 degrees) </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00776">776</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00592">pcl::RangeImagePlanar::calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00609">getAnglesFromImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00070">pcl::RangeImageSpherical::getAnglesFromImagePoint()</a>, <a class="el" href="range__image_8h_source.html#l00633">getImageOffsetY()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00105">pcl::RangeImagePlanar::getImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00077">pcl::RangeImageSpherical::getImagePointFromAngles()</a>, and <a class="el" href="range__image_8h_source.html#l00637">setImageOffsets()</a>.</p>

</div>
</div>
<a id="ac8b2b871a3ac8f1d2bfd900d1b527561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b2b871a3ac8f1d2bfd900d1b527561">&#9670;&nbsp;</a></span>lookup_table_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> const int pcl::RangeImage::lookup_table_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00785">785</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00054">asinLookUp()</a>, <a class="el" href="range__image_8hpp_source.html#l00064">atan2LookUp()</a>, and <a class="el" href="range__image_8hpp_source.html#l00090">cosLookUp()</a>.</p>

</div>
</div>
<a id="a34fe4f6701548e2514ae45099309cac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fe4f6701548e2514ae45099309cac4">&#9670;&nbsp;</a></span>max_no_of_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::RangeImage::max_no_of_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of openmp threads that can be used in this class. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00078">78</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

</div>
</div>
<a id="ada8177479f0e95999a66294db4c0c3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8177479f0e95999a66294db4c0c3eb">&#9670;&nbsp;</a></span>to_range_image_system_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::RangeImage::to_range_image_system_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of to_world_system_. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00768">768</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00357">getImagePoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00060">pcl::RangeImageSpherical::getImagePoint()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00105">pcl::RangeImagePlanar::getImagePoint()</a>, <a class="el" href="range__image_8h_source.html#l00337">getTransformationToRangeImageSystem()</a>, and <a class="el" href="range__image_8hpp_source.html#l01213">setTransformationToRangeImageSystem()</a>.</p>

</div>
</div>
<a id="a31c36f147403c0f64e1c3a386b30e229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c36f147403c0f64e1c3a386b30e229">&#9670;&nbsp;</a></span>to_world_system_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::RangeImage::to_world_system_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of to_range_image_system_. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00769">769</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00571">calculate3DPoint()</a>, <a class="el" href="range__image__spherical_8hpp_source.html#l00048">pcl::RangeImageSpherical::calculate3DPoint()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00092">pcl::RangeImagePlanar::calculate3DPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00683">getSensorPos()</a>, <a class="el" href="range__image_8h_source.html#l00347">getTransformationToWorldSystem()</a>, and <a class="el" href="range__image_8hpp_source.html#l01213">setTransformationToRangeImageSystem()</a>.</p>

</div>
</div>
<a id="a51bf019906a3256038561354d6b95885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bf019906a3256038561354d6b95885">&#9670;&nbsp;</a></span>unobserved_point</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_with_range.html">PointWithRange</a> pcl::RangeImage::unobserved_point</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This point is used to be able to return a reference to a non-existing point. </p>

<p class="definition">Definition at line <a class="el" href="range__image_8h_source.html#l00778">778</a> of file <a class="el" href="range__image_8h_source.html">range_image.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00401">checkPoint()</a>, <a class="el" href="range__image_8hpp_source.html#l00109">createFromPointCloud()</a>, <a class="el" href="range__image__planar_8hpp_source.html#l00050">pcl::RangeImagePlanar::createFromPointCloudWithFixedSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00809">get1dPointAverage()</a>, and <a class="el" href="range__image_8hpp_source.html#l00486">getPoint()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>pcl/range_image/<a class="el" href="range__image_8h_source.html">range_image.h</a></li>
<li>pcl/range_image/impl/<a class="el" href="range__image_8hpp_source.html">range_image.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Wed Oct 23 2024 10:17:09</p>
</div> <!-- #footer -->
</body>
</html>
