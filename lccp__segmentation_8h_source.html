<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): pcl/segmentation/lccp_segmentation.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.14.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_864cadfcf76019fd9a0a836ee881d655.html">pcl</a></li><li class="navelem"><a class="el" href="dir_75b522e316e1b3af642e1cdb6b6108b7.html">segmentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">lccp_segmentation.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> * Software License Agreement (BSD License)</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> *  Point Cloud Library (PCL) - www.pointclouds.org</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> *  Copyright (c) 2014-, Open Perception, Inc.</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"> *  All rights reserved.</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"> *  Redistribution and use in source and binary forms, with or without</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"> *  modification, are permitted provided that the following conditions</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment"> *  are met:</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"> *   * Redistributions of source code must retain the above copyright</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> *     notice, this list of conditions and the following disclaimer.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"> *   * Redistributions in binary form must reproduce the above</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> *     copyright notice, this list of conditions and the following</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> *     disclaimer in the documentation and/or other materials provided</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> *     with the distribution.</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> *   * Neither the name of the copyright holder(s) nor the names of its</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> *     contributors may be used to endorse or promote products derived</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> *     from this software without specific prior written permission.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment"> *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment"> *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment"> *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment"> *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment"> *  POSSIBILITY OF SUCH DAMAGE.</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#pragma once</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="common_2include_2pcl_2point__types_8h.html">pcl/point_types.h</a>&gt;</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#include &lt;pcl/point_cloud.h&gt;</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &lt;pcl/segmentation/supervoxel_clustering.h&gt;</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#define PCL_INSTANTIATE_LCCPSegmentation(T) template class PCL_EXPORTS pcl::LCCPSegmentation&lt;T&gt;;</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; </div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacepcl.html">pcl</a></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{<span class="comment"></span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">  /** \brief A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connected supervoxels separated by concave borders.</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">   *  \note If you use this in a scientific work please cite the following paper:</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">   *  S. C. Stein, M. Schoeler, J. Papon, F. Woergoetter</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">   *  Object Partitioning using Local Convexity</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">   *  In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR) 2014</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">   *  \author Simon Christoph Stein and Markus Schoeler (mschoeler@gwdg.de)</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">   *  \ingroup segmentation</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>T&gt;</div>
<div class="line"><a name="l00057"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html">   57</a></span>&#160;  <span class="keyword">class </span><a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html">LCCPSegmentation</a></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  {<span class="comment"></span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">    /** \brief Edge Properties stored in the adjacency graph.*/</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keyword">struct </span>EdgeProperties</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">      /** \brief Describes the difference of normals of the two supervoxels being connected*/</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;      <span class="keywordtype">float</span> normal_difference{0.0f};</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">      /** \brief Describes if a connection is convex or concave*/</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <span class="keywordtype">bool</span> is_convex{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">      /** \brief Describes if a connection is valid for the segment growing. Usually convex connections are and concave connection are not. Due to k-concavity a convex connection can be invalidated*/</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      <span class="keywordtype">bool</span> is_valid{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">      /** \brief Additional member used for the CPC algorithm. If edge has already induced a cut, it should be ignored for further cutting.*/</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;      <span class="keywordtype">bool</span> used_for_cutting{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160; </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;      EdgeProperties () = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    };</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160; </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160; </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      <span class="comment">// Adjacency list with nodes holding labels (std::uint32_t) and edges holding EdgeProperties.</span></div>
<div class="line"><a name="l00080"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a401a63e8901a4cdbe6808aa3f8946042">   80</a></span>&#160;      <span class="keyword">using</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a401a63e8901a4cdbe6808aa3f8946042">SupervoxelAdjacencyList</a> = boost::adjacency_list&lt;boost::setS, boost::setS, boost::undirectedS, std::uint32_t, EdgeProperties&gt;;</div>
<div class="line"><a name="l00081"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a3603ba360aff996d79c9bc623092a372">   81</a></span>&#160;      <span class="keyword">using</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a3603ba360aff996d79c9bc623092a372">VertexIterator</a> = <span class="keyword">typename</span> boost::graph_traits&lt;SupervoxelAdjacencyList&gt;::vertex_iterator;</div>
<div class="line"><a name="l00082"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#ab86afb355a46703d2849acaa47461109">   82</a></span>&#160;      <span class="keyword">using</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ab86afb355a46703d2849acaa47461109">AdjacencyIterator</a> = <span class="keyword">typename</span> boost::graph_traits&lt;SupervoxelAdjacencyList&gt;::adjacency_iterator;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160; </div>
<div class="line"><a name="l00084"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#ae9c4ea671386a2f3ea8e09b66d2a95fa">   84</a></span>&#160;      <span class="keyword">using</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ae9c4ea671386a2f3ea8e09b66d2a95fa">VertexID</a> = <span class="keyword">typename</span> boost::graph_traits&lt;SupervoxelAdjacencyList&gt;::vertex_descriptor;</div>
<div class="line"><a name="l00085"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a3b3ed9b6259ec52919206bdb35045902">   85</a></span>&#160;      <span class="keyword">using</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a3b3ed9b6259ec52919206bdb35045902">EdgeIterator</a> = <span class="keyword">typename</span> boost::graph_traits&lt;SupervoxelAdjacencyList&gt;::edge_iterator;</div>
<div class="line"><a name="l00086"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#aa81772587e9e8d3efd3045c6ed5bf05d">   86</a></span>&#160;      <span class="keyword">using</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aa81772587e9e8d3efd3045c6ed5bf05d">OutEdgeIterator</a> = <span class="keyword">typename</span> boost::graph_traits&lt;SupervoxelAdjacencyList&gt;::out_edge_iterator;</div>
<div class="line"><a name="l00087"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#ae717455468ca24b826b69077e04eb1f0">   87</a></span>&#160;      <span class="keyword">using</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ae717455468ca24b826b69077e04eb1f0">EdgeID</a> = <span class="keyword">typename</span> boost::graph_traits&lt;SupervoxelAdjacencyList&gt;::edge_descriptor;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160; </div>
<div class="line"><a name="l00089"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a4a207f7776e9e9b11e47d5b29ca0c5ec">   89</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a4a207f7776e9e9b11e47d5b29ca0c5ec">LCCPSegmentation</a> ();</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      <span class="keyword">virtual</span></div>
<div class="line"><a name="l00091"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a0590d2f40d8786a8d2f807a51bbefc28">   91</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a0590d2f40d8786a8d2f807a51bbefc28">~LCCPSegmentation</a> ();</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">      /** \brief Reset internal memory.  */</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#af5a6ac69bde329584570506c7c78b9af">reset</a> ();</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160; </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">      /** \brief Set the supervoxel clusters as well as the adjacency graph for the segmentation.Those parameters are generated by using the \ref SupervoxelClustering class. To retrieve the output use the \ref segment method.</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">       *  \param[in] supervoxel_clusters_arg Map of &lt; supervoxel labels, supervoxels &gt;</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">       *  \param[in] label_adjacency_arg The graph defining the supervoxel adjacency relations</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">       *  \note Implicitly calls \ref reset */</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00103"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a755ac30b385774437a946526475244ab">  103</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a755ac30b385774437a946526475244ab">setInputSupervoxels</a> (<span class="keyword">const</span> std::map&lt;std::uint32_t, <span class="keyword">typename</span> <a class="code" href="classpcl_1_1_supervoxel.html#a47183e1bf16da4c9c6173ded72ca264e">pcl::Supervoxel&lt;PointT&gt;::Ptr</a>&gt; &amp;supervoxel_clusters_arg,</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                           <span class="keyword">const</span> std::multimap&lt;std::uint32_t, std::uint32_t&gt; &amp;label_adjacency_arg)</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="comment">// Initialization</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a81ad3e06748b022bdf909a29d863677a">prepareSegmentation</a> (supervoxel_clusters_arg, label_adjacency_arg);  <span class="comment">// after this, sv_adjacency_list_ can be used to access adjacency list</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a0ebcf3b12da8ec8ff9029a4bc77292b6">supervoxels_set_</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      }</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">      /** \brief Merge supervoxels using local convexity. The input parameters are generated by using the \ref SupervoxelClustering class. To retrieve the output use the \ref relabelCloud method.</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">       *  \note There are three ways to retrieve the segmentation afterwards: \ref relabelCloud, \ref getSegmentToSupervoxelMap and \ref getSupervoxelToSegmentMap. */</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a8ef6896e6fabc91e26f7f9dfff757753">segment</a> ();</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">      /** \brief Relabels cloud with supervoxel labels with the computed segment labels. labeled_cloud_arg should be created using SupervoxelClustering::getLabeledCloud.</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">       *  \param[in,out] labeled_cloud_arg Cloud to relabel  */</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a73b148531688cdb949bb9185e6ada8e9">relabelCloud</a> (<a class="code" href="classpcl_1_1_point_cloud.html">pcl::PointCloud&lt;pcl::PointXYZL&gt;</a> &amp;labeled_cloud_arg);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">      /** \brief Get map&lt;SegmentID, std::set&lt;SuperVoxel IDs&gt; &gt;</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">       *  \param[out] segment_supervoxel_map_arg The output container. On error the map is empty. */</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00124"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a93b6050ab422da465548a17cca765d30">  124</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a93b6050ab422da465548a17cca765d30">getSegmentToSupervoxelMap</a> (std::map&lt;std::uint32_t, std::set&lt;std::uint32_t&gt; &gt;&amp; segment_supervoxel_map_arg)<span class="keyword"> const</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a428e19cb5f6711c7d2e20f31472a876a">grouping_data_valid_</a>)</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;          segment_supervoxel_map_arg = <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a0d190b75aef48962c8c1117f19b4ba99">seg_label_to_sv_list_map_</a>;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;          PCL_WARN (<span class="stringliteral">&quot;[pcl::LCCPSegmentation::getSegmentMap] WARNING: Call function segment first. Nothing has been done. \n&quot;</span>);</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;          segment_supervoxel_map_arg = std::map&lt;std::uint32_t, std::set&lt;std::uint32_t&gt; &gt; ();</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        }</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;      }</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">      /** \brief Get map&lt;Supervoxel_ID, Segment_ID&gt;</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment">       *  \param[out] supervoxel_segment_map_arg The output container. On error the map is empty. */</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00140"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#ae6714a1dccf80c17024890c2e627a489">  140</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ae6714a1dccf80c17024890c2e627a489">getSupervoxelToSegmentMap</a> (std::map&lt;std::uint32_t, std::uint32_t&gt;&amp; supervoxel_segment_map_arg)<span class="keyword"> const</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a428e19cb5f6711c7d2e20f31472a876a">grouping_data_valid_</a>)</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        {</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;          supervoxel_segment_map_arg = <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a1025cd710a6ed3a71afa92960ebd8d59">sv_label_to_seg_label_map_</a>;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        }</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;          PCL_WARN (<span class="stringliteral">&quot;[pcl::LCCPSegmentation::getSegmentMap] WARNING: Call function segment first. Nothing has been done. \n&quot;</span>);</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;          supervoxel_segment_map_arg = std::map&lt;std::uint32_t, std::uint32_t&gt; ();</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        }</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;      }</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">      /** \brief Get map &lt;SegmentID, std::set&lt;Neighboring SegmentIDs&gt; &gt;</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">       * \param[out] segment_adjacency_map_arg map &lt; SegmentID, std::set&lt; Neighboring SegmentIDs&gt; &gt;. On error the map is empty.  */</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00156"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a71a218e67e668b713e58ed7c62303fb8">  156</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a71a218e67e668b713e58ed7c62303fb8">getSegmentAdjacencyMap</a> (std::map&lt;std::uint32_t, std::set&lt;std::uint32_t&gt; &gt;&amp; segment_adjacency_map_arg)</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a428e19cb5f6711c7d2e20f31472a876a">grouping_data_valid_</a>)</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;          <span class="keywordflow">if</span> (<a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#afbf311d016bdf56dc583f156e65f0284">seg_label_to_neighbor_set_map_</a>.empty ())</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a6a3d6ce5b725f4ba8989654bcb94c1e5">computeSegmentAdjacency</a> ();</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;          segment_adjacency_map_arg = <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#afbf311d016bdf56dc583f156e65f0284">seg_label_to_neighbor_set_map_</a>;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        }</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;          PCL_WARN (<span class="stringliteral">&quot;[pcl::LCCPSegmentation::getSegmentAdjacencyMap] WARNING: Call function segment first. Nothing has been done. \n&quot;</span>);</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;          segment_adjacency_map_arg = std::map&lt;std::uint32_t, std::set&lt;std::uint32_t&gt; &gt; ();</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;      }</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">      /** \brief Get normal threshold</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment">       *  \return The concavity tolerance angle in [deg] that is currently set */</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">float</span></div>
<div class="line"><a name="l00174"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#ac4d9e71e46c6be921687146b33e9deed">  174</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ac4d9e71e46c6be921687146b33e9deed">getConcavityToleranceThreshold</a> ()<span class="keyword"> const</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <span class="keywordflow">return</span> (<a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a90f2ad90bee047f31f2c9ad4f3b0c158">concavity_tolerance_threshold_</a>);</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      }</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">      /** \brief Get the supervoxel adjacency graph with classified edges (boost::adjacency_list).</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">       * \param[out] adjacency_list_arg The supervoxel adjacency list with classified (convex/concave) edges. On error the list is empty.  */</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00182"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#aed49f8015934b23055f2d307a8ee9f01">  182</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aed49f8015934b23055f2d307a8ee9f01">getSVAdjacencyList</a> (<a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a401a63e8901a4cdbe6808aa3f8946042">SupervoxelAdjacencyList</a>&amp; adjacency_list_arg)<span class="keyword"> const</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a428e19cb5f6711c7d2e20f31472a876a">grouping_data_valid_</a>)</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;          adjacency_list_arg = <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#adff367bb7eab2ec652da194f36ad2ab4">sv_adjacency_list_</a>;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        }</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        {</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;          PCL_WARN (<span class="stringliteral">&quot;[pcl::LCCPSegmentation::getSVAdjacencyList] WARNING: Call function segment first. Nothing has been done. \n&quot;</span>);</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;          adjacency_list_arg = <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a401a63e8901a4cdbe6808aa3f8946042">pcl::LCCPSegmentation&lt;PointT&gt;::SupervoxelAdjacencyList</a> ();</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        }</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;      }</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">      /** \brief Set normal threshold</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">       *  \param[in] concavity_tolerance_threshold_arg the concavity tolerance angle in [deg] to set */</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00198"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#abc2b7be596c2785fb8664922bbca7177">  198</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#abc2b7be596c2785fb8664922bbca7177">setConcavityToleranceThreshold</a> (<span class="keywordtype">float</span> concavity_tolerance_threshold_arg)</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a90f2ad90bee047f31f2c9ad4f3b0c158">concavity_tolerance_threshold_</a> = concavity_tolerance_threshold_arg;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      }</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment">      /** \brief Determines if a smoothness check is done during segmentation, trying to invalidate edges of non-smooth connected edges (steps). Two supervoxels are unsmooth if their plane-to-plane distance DIST &gt; (expected_distance + smoothness_threshold_*voxel_resolution_). For parallel supervoxels, the expected_distance is zero.</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">       *  \param[in] use_smoothness_check_arg Determines if the smoothness check is used</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">       *  \param[in] voxel_res_arg The voxel resolution used for the supervoxels that are segmented</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">       *  \param[in] seed_res_arg The seed resolution used for the supervoxels that are segmented</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment">       *  \param[in] smoothness_threshold_arg Threshold (/fudging factor) for smoothness constraint according to the above formula. */</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00209"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a391f12ac00e266066391bbff3fd1d823">  209</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a391f12ac00e266066391bbff3fd1d823">setSmoothnessCheck</a> (<span class="keywordtype">bool</span> use_smoothness_check_arg,</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                          <span class="keywordtype">float</span> voxel_res_arg,</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                          <span class="keywordtype">float</span> seed_res_arg,</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                          <span class="keywordtype">float</span> smoothness_threshold_arg = 0.1)</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a6c58a7748116a2fa0e9d820ffadb718a">use_smoothness_check_</a> = use_smoothness_check_arg;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a0998d8eabad97e8dbc57973b28d4b389">voxel_resolution_</a> = voxel_res_arg;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aa9f7011e99af9d3849937ff5370c2e11">seed_resolution_</a> = seed_res_arg;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aa4b03eeae0ef4422a5e49b41455a098d">smoothness_threshold_</a> = smoothness_threshold_arg;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      }</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">      /** \brief Determines if we want to use the sanity criterion to invalidate singular connected patches</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">       *  \param[in] use_sanity_criterion_arg Determines if the sanity check is performed */</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00223"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#afcbcd533f01655310bec5f17c5213c65">  223</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#afcbcd533f01655310bec5f17c5213c65">setSanityCheck</a> (<span class="keyword">const</span> <span class="keywordtype">bool</span> use_sanity_criterion_arg)</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a728844e11f8848c7400d7875bae92800">use_sanity_check_</a> = use_sanity_criterion_arg;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">      /** \brief Set the value used for k convexity. For k&gt;0 convex connections between p_i and p_j require k common neighbors of these patches that have a convex connection to both.</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">       *  \param[in] k_factor_arg factor used for extended convexity check */</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00231"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a483d45c2b60b2cc9c0a2c9a5bc936f0e">  231</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a483d45c2b60b2cc9c0a2c9a5bc936f0e">setKFactor</a> (<span class="keyword">const</span> std::uint32_t k_factor_arg)</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      {</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a5e53389944e55b1b8f181fcfeabeac92">k_factor_</a> = k_factor_arg;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;      }</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">      /** \brief Set the value \ref min_segment_size_ used in \ref mergeSmallSegments</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">       *  \param[in] min_segment_size_arg Segments smaller than this size will be merged */</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line"><a name="l00239"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a31d402379c6ae8e5292c6145b68359f2">  239</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a31d402379c6ae8e5292c6145b68359f2">setMinSegmentSize</a> (<span class="keyword">const</span> std::uint32_t min_segment_size_arg)</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;      {</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aad4e51ac94e66333271b6f0966d490ca">min_segment_size_</a> = min_segment_size_arg;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;      }</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160; </div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">      /** \brief Segments smaller than \ref min_segment_size_ are merged to the label of largest neighbor */</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a7f0ada4d9a4918d9dbb9e33e32b23d46">mergeSmallSegments</a> ();</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">      /** \brief Compute the adjacency of the segments */</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a6a3d6ce5b725f4ba8989654bcb94c1e5">computeSegmentAdjacency</a> ();</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">      /** \brief Is called within \ref setInputSupervoxels mainly to reserve required memory.</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">       *  \param[in] supervoxel_clusters_arg map of &lt; supervoxel labels, supervoxels &gt;</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">       *  \param[in] label_adjacency_arg The graph defining the supervoxel adjacency relations */</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a81ad3e06748b022bdf909a29d863677a">prepareSegmentation</a> (<span class="keyword">const</span> std::map&lt;std::uint32_t, <span class="keyword">typename</span> <a class="code" href="classpcl_1_1_supervoxel.html#a47183e1bf16da4c9c6173ded72ca264e">pcl::Supervoxel&lt;PointT&gt;::Ptr</a>&gt; &amp;supervoxel_clusters_arg,</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                           <span class="keyword">const</span> std::multimap&lt;std::uint32_t, std::uint32_t&gt; &amp;label_adjacency_arg);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160; </div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">      /** Perform depth search on the graph and recursively group all supervoxels with convex connections</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment">       *  \note The vertices in the supervoxel adjacency list are the supervoxel centroids */</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ad1a810ce20594b9a9309c29f089f0d18">doGrouping</a> ();</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">      /** \brief Assigns neighbors of the query point to the same group as the query point. Recursive part of \ref doGrouping. Grouping is done by a depth-search of nodes in the adjacency-graph.</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">       *  \param[in] queryPointID ID of point whose neighbors will be considered for grouping</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">       *  \param[in] group_label ID of the group/segment the queried point belongs to  */</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a4a492a4362ba841361155407ef78c00e">recursiveSegmentGrowing</a> (<span class="keyword">const</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ae9c4ea671386a2f3ea8e09b66d2a95fa">VertexID</a>  &amp;queryPointID,</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_label);</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">      /** \brief Calculates convexity of edges and saves this to the adjacency graph.</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">       *  \param[in,out] adjacency_list_arg The supervoxel adjacency list*/</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a64ade0e74f07da2c8100a1a9d5d46e00">calculateConvexConnections</a> (<a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a401a63e8901a4cdbe6808aa3f8946042">SupervoxelAdjacencyList</a>&amp; adjacency_list_arg);</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">      /** \brief Connections are only convex if this is true for at least k_arg common neighbors of the two patches. Call \ref setKFactor before \ref segment to use this.</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">       *  \param[in] k_arg Factor used for extended convexity check */</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      <span class="keywordtype">void</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ad918a280410d18af75bad10b3134e5ab">applyKconvexity</a> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_arg);</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment">      /** \brief Returns true if the connection between source and target is convex.</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">       *  \param[in] source_label_arg Label of one supervoxel connected to the edge that should be checked</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment">       *  \param[in] target_label_arg Label of the other supervoxel connected to the edge that should be checked</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">       *  \param[out] normal_angle The angle between source and target</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment">       *  \return True if connection is convex */</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      <span class="keywordtype">bool</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#ac0ae97b40df2e37a2386b459bcfe83f7">connIsConvex</a> (<span class="keyword">const</span> std::uint32_t source_label_arg,</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                    <span class="keyword">const</span> std::uint32_t target_label_arg,</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                    <span class="keywordtype">float</span> &amp;normal_angle);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment">      ///  *** Parameters *** ///</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">      /** \brief Normal Threshold in degrees [0,180] used for merging */</span></div>
<div class="line"><a name="l00297"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a90f2ad90bee047f31f2c9ad4f3b0c158">  297</a></span>&#160;      <span class="keywordtype">float</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a90f2ad90bee047f31f2c9ad4f3b0c158">concavity_tolerance_threshold_</a>{10};</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment">      /** \brief Marks if valid grouping data (\ref sv_adjacency_list_, \ref sv_label_to_seg_label_map_, \ref processed_) is available */</span></div>
<div class="line"><a name="l00300"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a428e19cb5f6711c7d2e20f31472a876a">  300</a></span>&#160;      <span class="keywordtype">bool</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a428e19cb5f6711c7d2e20f31472a876a">grouping_data_valid_</a>{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment">      /** \brief Marks if supervoxels have been set by calling \ref setInputSupervoxels */</span></div>
<div class="line"><a name="l00303"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a0ebcf3b12da8ec8ff9029a4bc77292b6">  303</a></span>&#160;      <span class="keywordtype">bool</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a0ebcf3b12da8ec8ff9029a4bc77292b6">supervoxels_set_</a>{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="comment">      /** \brief Determines if the smoothness check is used during segmentation*/</span></div>
<div class="line"><a name="l00306"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a6c58a7748116a2fa0e9d820ffadb718a">  306</a></span>&#160;      <span class="keywordtype">bool</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a6c58a7748116a2fa0e9d820ffadb718a">use_smoothness_check_</a>{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">      /** \brief Two supervoxels are unsmooth if their plane-to-plane distance DIST &gt;  (expected_distance + smoothness_threshold_*voxel_resolution_). For parallel supervoxels, the expected_distance is zero. */</span></div>
<div class="line"><a name="l00309"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#aa4b03eeae0ef4422a5e49b41455a098d">  309</a></span>&#160;      <span class="keywordtype">float</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aa4b03eeae0ef4422a5e49b41455a098d">smoothness_threshold_</a>{0.1};</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment">      /** \brief Determines if we use the sanity check which tries to find and invalidate singular connected patches*/</span></div>
<div class="line"><a name="l00312"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a728844e11f8848c7400d7875bae92800">  312</a></span>&#160;      <span class="keywordtype">bool</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a728844e11f8848c7400d7875bae92800">use_sanity_check_</a>{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment">      /** \brief Seed resolution of the supervoxels (used only for smoothness check) */</span></div>
<div class="line"><a name="l00315"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#aa9f7011e99af9d3849937ff5370c2e11">  315</a></span>&#160;      <span class="keywordtype">float</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aa9f7011e99af9d3849937ff5370c2e11">seed_resolution_</a>{0.0f};</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment">      /** \brief Voxel resolution used to build the supervoxels (used only for smoothness check)*/</span></div>
<div class="line"><a name="l00318"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a0998d8eabad97e8dbc57973b28d4b389">  318</a></span>&#160;      <span class="keywordtype">float</span> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a0998d8eabad97e8dbc57973b28d4b389">voxel_resolution_</a>{0.0f};</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment">      /** \brief Factor used for k-convexity */</span></div>
<div class="line"><a name="l00321"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a5e53389944e55b1b8f181fcfeabeac92">  321</a></span>&#160;      std::uint32_t <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a5e53389944e55b1b8f181fcfeabeac92">k_factor_</a>{0};</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment">      /** \brief Minimum segment size */</span></div>
<div class="line"><a name="l00324"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#aad4e51ac94e66333271b6f0966d490ca">  324</a></span>&#160;      std::uint32_t <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aad4e51ac94e66333271b6f0966d490ca">min_segment_size_</a>{0};</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">      /** \brief Stores which supervoxel labels were already visited during recursive grouping.</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">       *  \note processed_[sv_Label] = false (default)/true (already processed) */</span></div>
<div class="line"><a name="l00328"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#aafd14e2d17cd2748149262e73b206cfc">  328</a></span>&#160;      std::map&lt;std::uint32_t, bool&gt; <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#aafd14e2d17cd2748149262e73b206cfc">processed_</a>;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">      /** \brief Adjacency graph with the supervoxel labels as nodes and edges between adjacent supervoxels */</span></div>
<div class="line"><a name="l00331"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#adff367bb7eab2ec652da194f36ad2ab4">  331</a></span>&#160;      <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a401a63e8901a4cdbe6808aa3f8946042">SupervoxelAdjacencyList</a> <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#adff367bb7eab2ec652da194f36ad2ab4">sv_adjacency_list_</a>;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">      /** \brief map from the supervoxel labels to the supervoxel objects  */</span></div>
<div class="line"><a name="l00334"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#af96ee6363b605f3a745442ac6cb50c66">  334</a></span>&#160;      std::map&lt;std::uint32_t, typename pcl::Supervoxel&lt;PointT&gt;::Ptr&gt; <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#af96ee6363b605f3a745442ac6cb50c66">sv_label_to_supervoxel_map_</a>;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment">      /** \brief Storing relation between original SuperVoxel Labels and new segmantion labels.</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment">       *  \note sv_label_to_seg_label_map_[old_labelID] = new_labelID */</span></div>
<div class="line"><a name="l00338"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a1025cd710a6ed3a71afa92960ebd8d59">  338</a></span>&#160;      std::map&lt;std::uint32_t, std::uint32_t&gt; <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a1025cd710a6ed3a71afa92960ebd8d59">sv_label_to_seg_label_map_</a>;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment">      /** \brief map Segment Label to a set of Supervoxel Labels */</span></div>
<div class="line"><a name="l00341"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#a0d190b75aef48962c8c1117f19b4ba99">  341</a></span>&#160;      std::map&lt;std::uint32_t, std::set&lt;std::uint32_t&gt; &gt; <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#a0d190b75aef48962c8c1117f19b4ba99">seg_label_to_sv_list_map_</a>;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment">      /** \brief map &lt; SegmentID, std::set&lt; Neighboring segment labels&gt; &gt; */</span></div>
<div class="line"><a name="l00344"></a><span class="lineno"><a class="line" href="classpcl_1_1_l_c_c_p_segmentation.html#afbf311d016bdf56dc583f156e65f0284">  344</a></span>&#160;      std::map&lt;std::uint32_t, std::set&lt;std::uint32_t&gt; &gt; <a class="code" href="classpcl_1_1_l_c_c_p_segmentation.html#afbf311d016bdf56dc583f156e65f0284">seg_label_to_neighbor_set_map_</a>;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160; </div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  };</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;}</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160; </div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="preprocessor">#ifdef PCL_NO_PRECOMPILE</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="preprocessor">#include &lt;pcl/segmentation/impl/lccp_segmentation.hpp&gt;</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html">pcl::LCCPSegmentation</a></div><div class="ttdoc">A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connect...</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00057">lccp_segmentation.h:58</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a0590d2f40d8786a8d2f807a51bbefc28"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a0590d2f40d8786a8d2f807a51bbefc28">pcl::LCCPSegmentation::~LCCPSegmentation</a></div><div class="ttdeci">virtual ~LCCPSegmentation()</div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a0998d8eabad97e8dbc57973b28d4b389"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a0998d8eabad97e8dbc57973b28d4b389">pcl::LCCPSegmentation::voxel_resolution_</a></div><div class="ttdeci">float voxel_resolution_</div><div class="ttdoc">Voxel resolution used to build the supervoxels (used only for smoothness check)</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00318">lccp_segmentation.h:318</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a0d190b75aef48962c8c1117f19b4ba99"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a0d190b75aef48962c8c1117f19b4ba99">pcl::LCCPSegmentation::seg_label_to_sv_list_map_</a></div><div class="ttdeci">std::map&lt; std::uint32_t, std::set&lt; std::uint32_t &gt; &gt; seg_label_to_sv_list_map_</div><div class="ttdoc">map Segment Label to a set of Supervoxel Labels</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00341">lccp_segmentation.h:341</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a0ebcf3b12da8ec8ff9029a4bc77292b6"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a0ebcf3b12da8ec8ff9029a4bc77292b6">pcl::LCCPSegmentation::supervoxels_set_</a></div><div class="ttdeci">bool supervoxels_set_</div><div class="ttdoc">Marks if supervoxels have been set by calling setInputSupervoxels.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00303">lccp_segmentation.h:303</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a1025cd710a6ed3a71afa92960ebd8d59"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a1025cd710a6ed3a71afa92960ebd8d59">pcl::LCCPSegmentation::sv_label_to_seg_label_map_</a></div><div class="ttdeci">std::map&lt; std::uint32_t, std::uint32_t &gt; sv_label_to_seg_label_map_</div><div class="ttdoc">Storing relation between original SuperVoxel Labels and new segmantion labels.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00338">lccp_segmentation.h:338</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a31d402379c6ae8e5292c6145b68359f2"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a31d402379c6ae8e5292c6145b68359f2">pcl::LCCPSegmentation::setMinSegmentSize</a></div><div class="ttdeci">void setMinSegmentSize(const std::uint32_t min_segment_size_arg)</div><div class="ttdoc">Set the value min_segment_size_ used in mergeSmallSegments.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00239">lccp_segmentation.h:239</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a3603ba360aff996d79c9bc623092a372"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a3603ba360aff996d79c9bc623092a372">pcl::LCCPSegmentation::VertexIterator</a></div><div class="ttdeci">typename boost::graph_traits&lt; SupervoxelAdjacencyList &gt;::vertex_iterator VertexIterator</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00081">lccp_segmentation.h:81</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a391f12ac00e266066391bbff3fd1d823"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a391f12ac00e266066391bbff3fd1d823">pcl::LCCPSegmentation::setSmoothnessCheck</a></div><div class="ttdeci">void setSmoothnessCheck(bool use_smoothness_check_arg, float voxel_res_arg, float seed_res_arg, float smoothness_threshold_arg=0.1)</div><div class="ttdoc">Determines if a smoothness check is done during segmentation, trying to invalidate edges of non-smoot...</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00209">lccp_segmentation.h:209</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a3b3ed9b6259ec52919206bdb35045902"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a3b3ed9b6259ec52919206bdb35045902">pcl::LCCPSegmentation::EdgeIterator</a></div><div class="ttdeci">typename boost::graph_traits&lt; SupervoxelAdjacencyList &gt;::edge_iterator EdgeIterator</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00085">lccp_segmentation.h:85</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a401a63e8901a4cdbe6808aa3f8946042"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a401a63e8901a4cdbe6808aa3f8946042">pcl::LCCPSegmentation::SupervoxelAdjacencyList</a></div><div class="ttdeci">boost::adjacency_list&lt; boost::setS, boost::setS, boost::undirectedS, std::uint32_t, EdgeProperties &gt; SupervoxelAdjacencyList</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00080">lccp_segmentation.h:80</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a428e19cb5f6711c7d2e20f31472a876a"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a428e19cb5f6711c7d2e20f31472a876a">pcl::LCCPSegmentation::grouping_data_valid_</a></div><div class="ttdeci">bool grouping_data_valid_</div><div class="ttdoc">Marks if valid grouping data (sv_adjacency_list_, sv_label_to_seg_label_map_, processed_) is availabl...</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00300">lccp_segmentation.h:300</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a483d45c2b60b2cc9c0a2c9a5bc936f0e"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a483d45c2b60b2cc9c0a2c9a5bc936f0e">pcl::LCCPSegmentation::setKFactor</a></div><div class="ttdeci">void setKFactor(const std::uint32_t k_factor_arg)</div><div class="ttdoc">Set the value used for k convexity.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00231">lccp_segmentation.h:231</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a4a207f7776e9e9b11e47d5b29ca0c5ec"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a4a207f7776e9e9b11e47d5b29ca0c5ec">pcl::LCCPSegmentation::LCCPSegmentation</a></div><div class="ttdeci">LCCPSegmentation()</div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a4a492a4362ba841361155407ef78c00e"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a4a492a4362ba841361155407ef78c00e">pcl::LCCPSegmentation::recursiveSegmentGrowing</a></div><div class="ttdeci">void recursiveSegmentGrowing(const VertexID &amp;queryPointID, const unsigned int group_label)</div><div class="ttdoc">Assigns neighbors of the query point to the same group as the query point.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00309">lccp_segmentation.hpp:309</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a5e53389944e55b1b8f181fcfeabeac92"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a5e53389944e55b1b8f181fcfeabeac92">pcl::LCCPSegmentation::k_factor_</a></div><div class="ttdeci">std::uint32_t k_factor_</div><div class="ttdoc">Factor used for k-convexity.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00321">lccp_segmentation.h:321</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a64ade0e74f07da2c8100a1a9d5d46e00"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a64ade0e74f07da2c8100a1a9d5d46e00">pcl::LCCPSegmentation::calculateConvexConnections</a></div><div class="ttdeci">void calculateConvexConnections(SupervoxelAdjacencyList &amp;adjacency_list_arg)</div><div class="ttdoc">Calculates convexity of edges and saves this to the adjacency graph.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00396">lccp_segmentation.hpp:396</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a6a3d6ce5b725f4ba8989654bcb94c1e5"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a6a3d6ce5b725f4ba8989654bcb94c1e5">pcl::LCCPSegmentation::computeSegmentAdjacency</a></div><div class="ttdeci">void computeSegmentAdjacency()</div><div class="ttdoc">Compute the adjacency of the segments.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00123">lccp_segmentation.hpp:123</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a6c58a7748116a2fa0e9d820ffadb718a"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a6c58a7748116a2fa0e9d820ffadb718a">pcl::LCCPSegmentation::use_smoothness_check_</a></div><div class="ttdeci">bool use_smoothness_check_</div><div class="ttdoc">Determines if the smoothness check is used during segmentation.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00306">lccp_segmentation.h:306</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a71a218e67e668b713e58ed7c62303fb8"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a71a218e67e668b713e58ed7c62303fb8">pcl::LCCPSegmentation::getSegmentAdjacencyMap</a></div><div class="ttdeci">void getSegmentAdjacencyMap(std::map&lt; std::uint32_t, std::set&lt; std::uint32_t &gt; &gt; &amp;segment_adjacency_map_arg)</div><div class="ttdoc">Get map &lt;SegmentID, std::set&lt;Neighboring SegmentIDs&gt; &gt;</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00156">lccp_segmentation.h:156</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a728844e11f8848c7400d7875bae92800"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a728844e11f8848c7400d7875bae92800">pcl::LCCPSegmentation::use_sanity_check_</a></div><div class="ttdeci">bool use_sanity_check_</div><div class="ttdoc">Determines if we use the sanity check which tries to find and invalidate singular connected patches.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00312">lccp_segmentation.h:312</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a73b148531688cdb949bb9185e6ada8e9"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a73b148531688cdb949bb9185e6ada8e9">pcl::LCCPSegmentation::relabelCloud</a></div><div class="ttdeci">void relabelCloud(pcl::PointCloud&lt; pcl::PointXYZL &gt; &amp;labeled_cloud_arg)</div><div class="ttdoc">Relabels cloud with supervoxel labels with the computed segment labels.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00098">lccp_segmentation.hpp:98</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a755ac30b385774437a946526475244ab"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a755ac30b385774437a946526475244ab">pcl::LCCPSegmentation::setInputSupervoxels</a></div><div class="ttdeci">void setInputSupervoxels(const std::map&lt; std::uint32_t, typename pcl::Supervoxel&lt; PointT &gt;::Ptr &gt; &amp;supervoxel_clusters_arg, const std::multimap&lt; std::uint32_t, std::uint32_t &gt; &amp;label_adjacency_arg)</div><div class="ttdoc">Set the supervoxel clusters as well as the adjacency graph for the segmentation.Those parameters are ...</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00103">lccp_segmentation.h:103</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a7f0ada4d9a4918d9dbb9e33e32b23d46"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a7f0ada4d9a4918d9dbb9e33e32b23d46">pcl::LCCPSegmentation::mergeSmallSegments</a></div><div class="ttdeci">void mergeSmallSegments()</div><div class="ttdoc">Segments smaller than min_segment_size_ are merged to the label of largest neighbor.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00154">lccp_segmentation.hpp:154</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a81ad3e06748b022bdf909a29d863677a"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a81ad3e06748b022bdf909a29d863677a">pcl::LCCPSegmentation::prepareSegmentation</a></div><div class="ttdeci">void prepareSegmentation(const std::map&lt; std::uint32_t, typename pcl::Supervoxel&lt; PointT &gt;::Ptr &gt; &amp;supervoxel_clusters_arg, const std::multimap&lt; std::uint32_t, std::uint32_t &gt; &amp;label_adjacency_arg)</div><div class="ttdoc">Is called within setInputSupervoxels mainly to reserve required memory.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00228">lccp_segmentation.hpp:228</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a8ef6896e6fabc91e26f7f9dfff757753"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a8ef6896e6fabc91e26f7f9dfff757753">pcl::LCCPSegmentation::segment</a></div><div class="ttdeci">void segment()</div><div class="ttdoc">Merge supervoxels using local convexity.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00073">lccp_segmentation.hpp:73</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a90f2ad90bee047f31f2c9ad4f3b0c158"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a90f2ad90bee047f31f2c9ad4f3b0c158">pcl::LCCPSegmentation::concavity_tolerance_threshold_</a></div><div class="ttdeci">float concavity_tolerance_threshold_</div><div class="ttdoc">*** Parameters *** ///</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00297">lccp_segmentation.h:297</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_a93b6050ab422da465548a17cca765d30"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#a93b6050ab422da465548a17cca765d30">pcl::LCCPSegmentation::getSegmentToSupervoxelMap</a></div><div class="ttdeci">void getSegmentToSupervoxelMap(std::map&lt; std::uint32_t, std::set&lt; std::uint32_t &gt; &gt; &amp;segment_supervoxel_map_arg) const</div><div class="ttdoc">Get map&lt;SegmentID, std::set&lt;SuperVoxel IDs&gt; &gt;</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00124">lccp_segmentation.h:124</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_aa4b03eeae0ef4422a5e49b41455a098d"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#aa4b03eeae0ef4422a5e49b41455a098d">pcl::LCCPSegmentation::smoothness_threshold_</a></div><div class="ttdeci">float smoothness_threshold_</div><div class="ttdoc">Two supervoxels are unsmooth if their plane-to-plane distance DIST &gt; (expected_distance + smoothness_...</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00309">lccp_segmentation.h:309</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_aa81772587e9e8d3efd3045c6ed5bf05d"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#aa81772587e9e8d3efd3045c6ed5bf05d">pcl::LCCPSegmentation::OutEdgeIterator</a></div><div class="ttdeci">typename boost::graph_traits&lt; SupervoxelAdjacencyList &gt;::out_edge_iterator OutEdgeIterator</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00086">lccp_segmentation.h:86</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_aa9f7011e99af9d3849937ff5370c2e11"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#aa9f7011e99af9d3849937ff5370c2e11">pcl::LCCPSegmentation::seed_resolution_</a></div><div class="ttdeci">float seed_resolution_</div><div class="ttdoc">Seed resolution of the supervoxels (used only for smoothness check)</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00315">lccp_segmentation.h:315</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_aad4e51ac94e66333271b6f0966d490ca"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#aad4e51ac94e66333271b6f0966d490ca">pcl::LCCPSegmentation::min_segment_size_</a></div><div class="ttdeci">std::uint32_t min_segment_size_</div><div class="ttdoc">Minimum segment size.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00324">lccp_segmentation.h:324</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_aafd14e2d17cd2748149262e73b206cfc"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#aafd14e2d17cd2748149262e73b206cfc">pcl::LCCPSegmentation::processed_</a></div><div class="ttdeci">std::map&lt; std::uint32_t, bool &gt; processed_</div><div class="ttdoc">Stores which supervoxel labels were already visited during recursive grouping.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00328">lccp_segmentation.h:328</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_ab86afb355a46703d2849acaa47461109"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#ab86afb355a46703d2849acaa47461109">pcl::LCCPSegmentation::AdjacencyIterator</a></div><div class="ttdeci">typename boost::graph_traits&lt; SupervoxelAdjacencyList &gt;::adjacency_iterator AdjacencyIterator</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00082">lccp_segmentation.h:82</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_abc2b7be596c2785fb8664922bbca7177"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#abc2b7be596c2785fb8664922bbca7177">pcl::LCCPSegmentation::setConcavityToleranceThreshold</a></div><div class="ttdeci">void setConcavityToleranceThreshold(float concavity_tolerance_threshold_arg)</div><div class="ttdoc">Set normal threshold.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00198">lccp_segmentation.h:198</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_ac0ae97b40df2e37a2386b459bcfe83f7"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#ac0ae97b40df2e37a2386b459bcfe83f7">pcl::LCCPSegmentation::connIsConvex</a></div><div class="ttdeci">bool connIsConvex(const std::uint32_t source_label_arg, const std::uint32_t target_label_arg, float &amp;normal_angle)</div><div class="ttdoc">Returns true if the connection between source and target is convex.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00416">lccp_segmentation.hpp:416</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_ac4d9e71e46c6be921687146b33e9deed"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#ac4d9e71e46c6be921687146b33e9deed">pcl::LCCPSegmentation::getConcavityToleranceThreshold</a></div><div class="ttdeci">float getConcavityToleranceThreshold() const</div><div class="ttdoc">Get normal threshold.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00174">lccp_segmentation.h:174</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_ad1a810ce20594b9a9309c29f089f0d18"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#ad1a810ce20594b9a9309c29f089f0d18">pcl::LCCPSegmentation::doGrouping</a></div><div class="ttdeci">void doGrouping()</div><div class="ttdoc">Perform depth search on the graph and recursively group all supervoxels with convex connections.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00278">lccp_segmentation.hpp:278</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_ad918a280410d18af75bad10b3134e5ab"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#ad918a280410d18af75bad10b3134e5ab">pcl::LCCPSegmentation::applyKconvexity</a></div><div class="ttdeci">void applyKconvexity(const unsigned int k_arg)</div><div class="ttdoc">Connections are only convex if this is true for at least k_arg common neighbors of the two patches.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00339">lccp_segmentation.hpp:339</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_adff367bb7eab2ec652da194f36ad2ab4"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#adff367bb7eab2ec652da194f36ad2ab4">pcl::LCCPSegmentation::sv_adjacency_list_</a></div><div class="ttdeci">SupervoxelAdjacencyList sv_adjacency_list_</div><div class="ttdoc">Adjacency graph with the supervoxel labels as nodes and edges between adjacent supervoxels.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00331">lccp_segmentation.h:331</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_ae6714a1dccf80c17024890c2e627a489"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#ae6714a1dccf80c17024890c2e627a489">pcl::LCCPSegmentation::getSupervoxelToSegmentMap</a></div><div class="ttdeci">void getSupervoxelToSegmentMap(std::map&lt; std::uint32_t, std::uint32_t &gt; &amp;supervoxel_segment_map_arg) const</div><div class="ttdoc">Get map&lt;Supervoxel_ID, Segment_ID&gt;</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00140">lccp_segmentation.h:140</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_ae717455468ca24b826b69077e04eb1f0"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#ae717455468ca24b826b69077e04eb1f0">pcl::LCCPSegmentation::EdgeID</a></div><div class="ttdeci">typename boost::graph_traits&lt; SupervoxelAdjacencyList &gt;::edge_descriptor EdgeID</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00087">lccp_segmentation.h:87</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_ae9c4ea671386a2f3ea8e09b66d2a95fa"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#ae9c4ea671386a2f3ea8e09b66d2a95fa">pcl::LCCPSegmentation::VertexID</a></div><div class="ttdeci">typename boost::graph_traits&lt; SupervoxelAdjacencyList &gt;::vertex_descriptor VertexID</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00084">lccp_segmentation.h:84</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_aed49f8015934b23055f2d307a8ee9f01"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#aed49f8015934b23055f2d307a8ee9f01">pcl::LCCPSegmentation::getSVAdjacencyList</a></div><div class="ttdeci">void getSVAdjacencyList(SupervoxelAdjacencyList &amp;adjacency_list_arg) const</div><div class="ttdoc">Get the supervoxel adjacency graph with classified edges (boost::adjacency_list).</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00182">lccp_segmentation.h:182</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_af5a6ac69bde329584570506c7c78b9af"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#af5a6ac69bde329584570506c7c78b9af">pcl::LCCPSegmentation::reset</a></div><div class="ttdeci">void reset()</div><div class="ttdoc">Reset internal memory.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8hpp_source.html#l00060">lccp_segmentation.hpp:60</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_af96ee6363b605f3a745442ac6cb50c66"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#af96ee6363b605f3a745442ac6cb50c66">pcl::LCCPSegmentation::sv_label_to_supervoxel_map_</a></div><div class="ttdeci">std::map&lt; std::uint32_t, typename pcl::Supervoxel&lt; PointT &gt;::Ptr &gt; sv_label_to_supervoxel_map_</div><div class="ttdoc">map from the supervoxel labels to the supervoxel objects</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00334">lccp_segmentation.h:334</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_afbf311d016bdf56dc583f156e65f0284"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#afbf311d016bdf56dc583f156e65f0284">pcl::LCCPSegmentation::seg_label_to_neighbor_set_map_</a></div><div class="ttdeci">std::map&lt; std::uint32_t, std::set&lt; std::uint32_t &gt; &gt; seg_label_to_neighbor_set_map_</div><div class="ttdoc">map &lt; SegmentID, std::set&lt; Neighboring segment labels&gt; &gt;</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00344">lccp_segmentation.h:344</a></div></div>
<div class="ttc" id="aclasspcl_1_1_l_c_c_p_segmentation_html_afcbcd533f01655310bec5f17c5213c65"><div class="ttname"><a href="classpcl_1_1_l_c_c_p_segmentation.html#afcbcd533f01655310bec5f17c5213c65">pcl::LCCPSegmentation::setSanityCheck</a></div><div class="ttdeci">void setSanityCheck(const bool use_sanity_criterion_arg)</div><div class="ttdoc">Determines if we want to use the sanity criterion to invalidate singular connected patches.</div><div class="ttdef"><b>Definition:</b> <a href="lccp__segmentation_8h_source.html#l00223">lccp_segmentation.h:223</a></div></div>
<div class="ttc" id="aclasspcl_1_1_point_cloud_html"><div class="ttname"><a href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a></div><div class="ttdoc">PointCloud represents the base class in PCL for storing collections of 3D points.</div><div class="ttdef"><b>Definition:</b> <a href="common_2include_2pcl_2point__cloud_8h_source.html#l00172">point_cloud.h:173</a></div></div>
<div class="ttc" id="aclasspcl_1_1_supervoxel_html_a47183e1bf16da4c9c6173ded72ca264e"><div class="ttname"><a href="classpcl_1_1_supervoxel.html#a47183e1bf16da4c9c6173ded72ca264e">pcl::Supervoxel::Ptr</a></div><div class="ttdeci">shared_ptr&lt; Supervoxel&lt; PointT &gt; &gt; Ptr</div><div class="ttdef"><b>Definition:</b> <a href="supervoxel__clustering_8h_source.html#l00075">supervoxel_clustering.h:75</a></div></div>
<div class="ttc" id="acommon_2include_2pcl_2point__types_8h_html"><div class="ttname"><a href="common_2include_2pcl_2point__types_8h.html">point_types.h</a></div><div class="ttdoc">Defines all the PCL implemented PointT point type structures.</div></div>
<div class="ttc" id="anamespacepcl_html"><div class="ttname"><a href="namespacepcl.html">pcl</a></div><div class="ttdef"><b>Definition:</b> <a href="2d_2include_2pcl_22d_2convolution_8h_source.html#l00046">convolution.h:46</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Wed Oct 23 2024 10:17:00</p>
</div> <!-- #footer -->
</body>
</html>
