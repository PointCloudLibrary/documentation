<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): Module common</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.14.1-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Module common</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="secCommonPresentation"></a>
Overview</h1>
<p>The <b>pcl_common</b> library contains the common data structures and methods used by the majority of PCL libraries. The core data structures include the PointCloud class and a multitude of point types that are used to represent points, surface normals, RGB color values, feature descriptors, etc. It also contains numerous functions for computing distances/norms, means and covariances, angular conversions, geometric transformations, and more.</p>
<h1><a class="anchor" id="secCommonRequirements"></a>
Requirements</h1>
<ul>
<li>none </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_bivariate_polynomial_t.html">pcl::BivariatePolynomialT&lt; real &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a bivariate polynomial and provides some functionality for it.  <a href="classpcl_1_1_bivariate_polynomial_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_centroid_point.html">pcl::CentroidPoint&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic class that computes the centroid of points fed to it.  <a href="classpcl_1_1_centroid_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_nd_concatenate_functor.html">pcl::NdConcatenateFunctor&lt; PointInT, PointOutT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor structure for concatenate.  <a href="structpcl_1_1_nd_concatenate_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature_histogram.html">pcl::FeatureHistogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for histograms for computing mean and variance of some floats.  <a href="classpcl_1_1_feature_histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_gaussian_kernel.html">pcl::GaussianKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classpcl_1_1_gaussian_kernel.html" title="Class GaussianKernel assembles all the method for computing, convolving, smoothing,...">GaussianKernel</a> assembles all the method for computing, convolving, smoothing, gradients computing an image using a gaussian kernel.  <a href="classpcl_1_1_gaussian_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_a.html">pcl::PCA&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Principal Component analysis (<a class="el" href="classpcl_1_1_p_c_a.html" title="Principal Component analysis (PCA) class.">PCA</a>) class.  <a href="classpcl_1_1_p_c_a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_piecewise_linear_function.html">pcl::PiecewiseLinearFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides functionalities to efficiently return values for piecewise linear function.  <a href="classpcl_1_1_piecewise_linear_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_polynomial_calculations_t.html">pcl::PolynomialCalculationsT&lt; real &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides some functionality for polynomials, like finding roots or approximating bivariate polynomials.  <a href="classpcl_1_1_polynomial_calculations_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_poses_from_matches.html">pcl::PosesFromMatches</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate 3D transformation based on point correspondences  <a href="classpcl_1_1_poses_from_matches.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_stop_watch.html">pcl::StopWatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple stopwatch.  <a href="classpcl_1_1_stop_watch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_scope_time.html">pcl::ScopeTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to measure the time spent in a scope.  <a href="classpcl_1_1_scope_time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_event_frequency.html">pcl::EventFrequency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to measure frequency of a certain event.  <a href="classpcl_1_1_event_frequency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_time_trigger.html">pcl::TimeTrigger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer class that invokes registered callback methods periodically.  <a href="classpcl_1_1_time_trigger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_transformation_from_correspondences.html">pcl::TransformationFromCorrespondences</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a transformation based on corresponding 3D points.  <a href="classpcl_1_1_transformation_from_correspondences.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_vector_average.html">pcl::VectorAverage&lt; real, dimension &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the weighted average and the covariance matrix.  <a href="classpcl_1_1_vector_average.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_correspondence.html">pcl::Correspondence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpcl_1_1_correspondence.html" title="Correspondence represents a match between two entities (e.g., points, descriptors,...">Correspondence</a> represents a match between two entities (e.g., points, descriptors, etc).  <a href="structpcl_1_1_correspondence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_correspondence3_d.html">pcl::PointCorrespondence3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a (possible) correspondence between two 3D points in two different coordinate frames (e.g.  <a href="structpcl_1_1_point_correspondence3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_correspondence6_d.html">pcl::PointCorrespondence6D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a (possible) correspondence between two points (e.g.  <a href="structpcl_1_1_point_correspondence6_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z.html">pcl::PointXYZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates.  <a href="structpcl_1_1_point_x_y_z.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_intensity.html">pcl::Intensity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the grayscale intensity in single-channel images.  <a href="structpcl_1_1_intensity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_intensity8u.html">pcl::Intensity8u</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the grayscale intensity in single-channel images.  <a href="structpcl_1_1_intensity8u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_intensity32u.html">pcl::Intensity32u</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the grayscale intensity in single-channel images.  <a href="structpcl_1_1_intensity32u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___point_x_y_z_i.html">pcl::_PointXYZI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the intensity value.  <a href="structpcl_1_1___point_x_y_z_i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_a.html">pcl::PointXYZRGBA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the RGBA color.  <a href="structpcl_1_1_point_x_y_z_r_g_b_a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">pcl::PointXYZRGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> color.  <a href="structpcl_1_1_point_x_y_z_r_g_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_l_a_b.html">pcl::PointXYZLAB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the CIELAB color.  <a href="structpcl_1_1_point_x_y_z_l_a_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y.html">pcl::PointXY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D point structure representing Euclidean xy coordinates.  <a href="structpcl_1_1_point_x_y.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_u_v.html">pcl::PointUV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D point structure representing pixel image coordinates.  <a href="structpcl_1_1_point_u_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_interest_point.html">pcl::InterestPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing an interest point with Euclidean xyz coordinates, and an interest value.  <a href="structpcl_1_1_interest_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_normal.html">pcl::Normal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_axis.html">pcl::Axis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing an <a class="el" href="structpcl_1_1_axis.html" title="A point structure representing an Axis using its normal coordinates.">Axis</a> using its normal coordinates.  <a href="structpcl_1_1_axis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_normal.html">pcl::PointNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, together with normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_point_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b_normal.html">pcl::PointXYZRGBNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the <a class="el" href="structpcl_1_1_r_g_b.html" title="A structure representing RGB color information.">RGB</a> color, together with normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_point_x_y_z_r_g_b_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_i_normal.html">pcl::PointXYZINormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, intensity, together with normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_point_x_y_z_i_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_x_y_z_l_normal.html">pcl::PointXYZLNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, a label, together with normal coordinates and the surface curvature estimate.  <a href="structpcl_1_1_point_x_y_z_l_normal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_with_range.html">pcl::PointWithRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, padded with an extra range float.  <a href="structpcl_1_1_point_with_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_with_viewpoint.html">pcl::PointWithViewpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates together with the viewpoint from which it was seen.  <a href="structpcl_1_1_point_with_viewpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_moment_invariants.html">pcl::MomentInvariants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the three moment invariants.  <a href="structpcl_1_1_moment_invariants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_principal_radii_r_s_d.html">pcl::PrincipalRadiiRSD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the minimum and maximum surface radii (in meters) computed using RSD.  <a href="structpcl_1_1_principal_radii_r_s_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_boundary.html">pcl::Boundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing a description of whether a point is lying on a surface boundary or not.  <a href="structpcl_1_1_boundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_principal_curvatures.html">pcl::PrincipalCurvatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the principal curvatures and their magnitudes.  <a href="structpcl_1_1_principal_curvatures.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_f_h_signature125.html">pcl::PFHSignature125</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (PFH).  <a href="structpcl_1_1_p_f_h_signature125.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_f_h_r_g_b_signature250.html">pcl::PFHRGBSignature250</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> with colors (PFHRGB).  <a href="structpcl_1_1_p_f_h_r_g_b_signature250.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_p_f_signature.html">pcl::PPFSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure for storing the Point Pair <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> (PPF) values.  <a href="structpcl_1_1_p_p_f_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_c_p_p_f_signature.html">pcl::CPPFSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure for storing the Point Pair <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> (CPPF) values.  <a href="structpcl_1_1_c_p_p_f_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_p_p_f_r_g_b_signature.html">pcl::PPFRGBSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure for storing the Point Pair Color <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> (PPFRGB) values.  <a href="structpcl_1_1_p_p_f_r_g_b_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_normal_based_signature12.html">pcl::NormalBasedSignature12</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the <a class="el" href="structpcl_1_1_normal.html" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> Based Signature for a feature matrix of 4-by-3.  <a href="structpcl_1_1_normal_based_signature12.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_shape_context1980.html">pcl::ShapeContext1980</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing a Shape Context.  <a href="structpcl_1_1_shape_context1980.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_unique_shape_context1960.html">pcl::UniqueShapeContext1960</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing a Unique Shape Context.  <a href="structpcl_1_1_unique_shape_context1960.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_h_o_t352.html">pcl::SHOT352</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the generic Signature of Histograms of OrienTations (SHOT) - shape only.  <a href="structpcl_1_1_s_h_o_t352.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_s_h_o_t1344.html">pcl::SHOT1344</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the generic Signature of Histograms of OrienTations (SHOT) - shape+color.  <a href="structpcl_1_1_s_h_o_t1344.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1___reference_frame.html">pcl::_ReferenceFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing the Local Reference Frame of a point.  <a href="structpcl_1_1___reference_frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_f_p_f_h_signature33.html">pcl::FPFHSignature33</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Fast Point <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (FPFH).  <a href="structpcl_1_1_f_p_f_h_signature33.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_v_f_h_signature308.html">pcl::VFHSignature308</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Viewpoint <a class="el" href="classpcl_1_1_feature.html" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram.html" title="A point structure representing an N-D histogram.">Histogram</a> (VFH).  <a href="structpcl_1_1_v_f_h_signature308.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_r_s_d_signature21.html">pcl::GRSDSignature21</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Global Radius-based Surface Descriptor (GRSD).  <a href="structpcl_1_1_g_r_s_d_signature21.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_b_r_i_s_k_signature512.html">pcl::BRISKSignature512</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Binary Robust Invariant Scalable Keypoints (BRISK).  <a href="structpcl_1_1_b_r_i_s_k_signature512.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_e_s_f_signature640.html">pcl::ESFSignature640</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Ensemble of Shape Functions (ESF).  <a href="structpcl_1_1_e_s_f_signature640.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_a_s_d_signature512.html">pcl::GASDSignature512</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Globally Aligned Spatial Distribution (GASD) shape descriptor.  <a href="structpcl_1_1_g_a_s_d_signature512.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_a_s_d_signature984.html">pcl::GASDSignature984</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Globally Aligned Spatial Distribution (GASD) shape and color descriptor.  <a href="structpcl_1_1_g_a_s_d_signature984.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_a_s_d_signature7992.html">pcl::GASDSignature7992</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the Globally Aligned Spatial Distribution (GASD) shape and color descriptor.  <a href="structpcl_1_1_g_a_s_d_signature7992.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_g_f_p_f_h_signature16.html">pcl::GFPFHSignature16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the GFPFH descriptor with 16 bins.  <a href="structpcl_1_1_g_f_p_f_h_signature16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_narf36.html">pcl::Narf36</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the <a class="el" href="classpcl_1_1_narf.html" title="NARF (Normal Aligned Radial Features) is a point feature descriptor type for 3D data.">Narf</a> descriptor.  <a href="structpcl_1_1_narf36.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_border_description.html">pcl::BorderDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to store if a point in a range image lies on a border between an obstacle and the background.  <a href="structpcl_1_1_border_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_intensity_gradient.html">pcl::IntensityGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing the intensity gradient of an XYZI point cloud.  <a href="structpcl_1_1_intensity_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_histogram.html">pcl::Histogram&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing an N-D histogram.  <a href="structpcl_1_1_histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_with_scale.html">pcl::PointWithScale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing a 3-D position and scale.  <a href="structpcl_1_1_point_with_scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_surfel.html">pcl::PointSurfel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A surfel, that is, a point structure representing Euclidean xyz coordinates, together with normal coordinates, a RGBA color, a radius, a confidence value and the surface curvature estimate.  <a href="structpcl_1_1_point_surfel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_point_d_e_m.html">pcl::PointDEM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Digital Elevation Map.  <a href="structpcl_1_1_point_d_e_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCL base class.  <a href="classpcl_1_1_p_c_l_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1cuda_1_1_scope_time_c_p_u.html">pcl::cuda::ScopeTimeCPU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to measure the time spent in a scope.  <a href="classpcl_1_1cuda_1_1_scope_time_c_p_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_gradient_x_y.html">pcl::GradientXY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point structure representing Euclidean xyz coordinates, and the intensity value.  <a href="structpcl_1_1_gradient_x_y.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:angles_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="angles_8h.html">angles.h</a></td></tr>
<tr class="memdesc:angles_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define standard C methods to do angle calculations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:centroid_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="centroid_8h.html">centroid.h</a></td></tr>
<tr class="memdesc:centroid_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define methods for centroid estimation and covariance matrix calculus. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:common_2include_2pcl_2common_2common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_2include_2pcl_2common_2common_8h.html">common.h</a></td></tr>
<tr class="memdesc:common_2include_2pcl_2common_2common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define standard C methods and C++ classes that are common to all methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:common_2include_2pcl_2common_2distances_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_2include_2pcl_2common_2distances_8h.html">distances.h</a></td></tr>
<tr class="memdesc:common_2include_2pcl_2common_2distances_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define standard C methods to do distance calculations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:common_2include_2pcl_2common_2file__io_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_2include_2pcl_2common_2file__io_8h.html">file_io.h</a></td></tr>
<tr class="memdesc:common_2include_2pcl_2common_2file__io_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define some helper functions for reading and writing files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:random_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="random_8h.html">random.h</a></td></tr>
<tr class="memdesc:random_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">CloudGenerator class generates a point cloud using some random number generator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:common_2include_2pcl_2common_2geometry_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_2include_2pcl_2common_2geometry_8h.html">geometry.h</a></td></tr>
<tr class="memdesc:common_2include_2pcl_2common_2geometry_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines some geometrical functions and utility functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:intersections_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersections_8h.html">intersections.h</a></td></tr>
<tr class="memdesc:intersections_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define line with line intersection functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:norms_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="norms_8h.html">norms.h</a></td></tr>
<tr class="memdesc:norms_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define standard C methods to calculate different norms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:common_2include_2pcl_2common_2geometry_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_2include_2pcl_2common_2geometry_8h.html">geometry.h</a></td></tr>
<tr class="memdesc:common_2include_2pcl_2common_2geometry_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines some geometrical functions and utility functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:common_2time_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_2time_8h.html">time.h</a></td></tr>
<tr class="memdesc:common_2time_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define methods for measuring time spent in code blocks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:memory_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memory_8h.html">memory.h</a></td></tr>
<tr class="memdesc:memory_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines functions, macros and traits for allocating and using memory. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pcl__macros_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcl__macros_8h.html">pcl_macros.h</a></td></tr>
<tr class="memdesc:pcl__macros_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all the PCL and non-PCL macros used. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:common_2include_2pcl_2point__types_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="common_2include_2pcl_2point__types_8h.html">point_types.h</a></td></tr>
<tr class="memdesc:common_2include_2pcl_2point__types_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all the PCL implemented PointT point type structures. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:types_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html">types.h</a></td></tr>
<tr class="memdesc:types_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines basic non-point types used by PCL. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga35846236568f16ca7fa07d958966e12c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga35846236568f16ca7fa07d958966e12c">PCL_MAKE_ALIGNED_OPERATOR_NEW</a></td></tr>
<tr class="memdesc:ga35846236568f16ca7fa07d958966e12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to signal a class requires a custom allocator.  <a href="group__common.html#ga35846236568f16ca7fa07d958966e12c">More...</a><br /></td></tr>
<tr class="separator:ga35846236568f16ca7fa07d958966e12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6ef917f66c9c9b3cb888aea5013b53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gafd6ef917f66c9c9b3cb888aea5013b53">PCL_FALLTHROUGH</a></td></tr>
<tr class="memdesc:gafd6ef917f66c9c9b3cb888aea5013b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to add a no-op or a fallthrough attribute based on compiler feature.  <a href="group__common.html#gafd6ef917f66c9c9b3cb888aea5013b53">More...</a><br /></td></tr>
<tr class="separator:gafd6ef917f66c9c9b3cb888aea5013b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafb2b6757a09f69abeb6795cc0956acbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gafb2b6757a09f69abeb6795cc0956acbf">pcl::BorderTraits</a> = std::bitset&lt; 32 &gt;</td></tr>
<tr class="memdesc:gafb2b6757a09f69abeb6795cc0956acbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type to store extended information about a transition from foreground to backgroundSpecification of the fields for <a class="el" href="structpcl_1_1_border_description.html#a48b78318ec7151ebca3d61a47891470c">BorderDescription::traits</a>.  <a href="group__common.html#gafb2b6757a09f69abeb6795cc0956acbf">More...</a><br /></td></tr>
<tr class="separator:gafb2b6757a09f69abeb6795cc0956acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9d37f00989a9de11b48deb263649463c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga9d37f00989a9de11b48deb263649463c">pcl::NormType</a> { <br />
&#160;&#160;<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463cac3661be4b6e0d59a4c7b59a788cfc072">pcl::L1</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca98099ccc2b42084990c7a6caac1d03f1">pcl::L2_SQR</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca784d9a41bb0a8d74c4bbb384b5186c44">pcl::L2</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca731833ab377b1fbe2ea5968c44a1664f">pcl::LINF</a>
, <br />
&#160;&#160;<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463cae072ec2ac425bed6c2f5a0781f0bf24f">pcl::JM</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">pcl::B</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca4da495e4c1d4f4415a13df5a1d55c545">pcl::SUBLINEAR</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463cad3f14cd5f1b7951b16422d8372b40177">pcl::CS</a>
, <br />
&#160;&#160;<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca873d59723678e9e5d0a4c82d95c0e10e">pcl::DIV</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca5bf10e0499f79b70241e2eb83d0bcec3">pcl::PF</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca5c1d5fa96c1a1d9ee8a3d65459576e1f">pcl::K</a>
, <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca8bf338ed604013b750528812f883f95b">pcl::KL</a>
, <br />
&#160;&#160;<a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463ca2ab2951d1cd80c4e5374046b5d670527">pcl::HIK</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9d37f00989a9de11b48deb263649463c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that defines all the types of norms available.  <a href="group__common.html#ga9d37f00989a9de11b48deb263649463c">More...</a><br /></td></tr>
<tr class="separator:ga9d37f00989a9de11b48deb263649463c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b4e0dcfd710e4c96737e6012b318e8b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga7b4e0dcfd710e4c96737e6012b318e8b">pcl::BorderTrait</a> { <br />
&#160;&#160;<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8baba2ab46c88349350939f52bbd63cde63">pcl::BORDER_TRAIT__OBSTACLE_BORDER</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8babbe3c6413874052b1bd961efd024e707">pcl::BORDER_TRAIT__SHADOW_BORDER</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8baed1fff632898caa19ba9c1b15e639c6e">pcl::BORDER_TRAIT__VEIL_POINT</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8bac33023b67fa7bef437316f060a45680a">pcl::BORDER_TRAIT__SHADOW_BORDER_TOP</a>
, <br />
&#160;&#160;<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba02629b93f54ba6f5df84c201841a6885">pcl::BORDER_TRAIT__SHADOW_BORDER_RIGHT</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba930363a872a79a7d81d6e4205855776c">pcl::BORDER_TRAIT__SHADOW_BORDER_BOTTOM</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba68f048247d59b845f64a0c2f98e49200">pcl::BORDER_TRAIT__SHADOW_BORDER_LEFT</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba0126deec3b7ff7353d146e637f5079b0">pcl::BORDER_TRAIT__OBSTACLE_BORDER_TOP</a>
, <br />
&#160;&#160;<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba95274e6ae483a678bfff02bee92a199f">pcl::BORDER_TRAIT__OBSTACLE_BORDER_RIGHT</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba9a16989fdc97f0d09f1602922ff5b915">pcl::BORDER_TRAIT__OBSTACLE_BORDER_BOTTOM</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba639881dfaa920ff16178ccd10032596c">pcl::BORDER_TRAIT__OBSTACLE_BORDER_LEFT</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba15f4b2984e8c57fd9e343d4ef7ecfbf5">pcl::BORDER_TRAIT__VEIL_POINT_TOP</a>
, <br />
&#160;&#160;<a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba0c79af62cb33c6b991a5560dcae502fe">pcl::BORDER_TRAIT__VEIL_POINT_RIGHT</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8ba58422e9652213c3b66933e6488e6934f">pcl::BORDER_TRAIT__VEIL_POINT_BOTTOM</a>
, <a class="el" href="group__common.html#gga7b4e0dcfd710e4c96737e6012b318e8bab835d36d98c678431e97796376690219">pcl::BORDER_TRAIT__VEIL_POINT_LEFT</a>
<br />
 }</td></tr>
<tr class="memdesc:ga7b4e0dcfd710e4c96737e6012b318e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specification of the fields for BorderDescription::traits.  <a href="group__common.html#ga7b4e0dcfd710e4c96737e6012b318e8b">More...</a><br /></td></tr>
<tr class="separator:ga7b4e0dcfd710e4c96737e6012b318e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3177c2c084674693cc38f03e80b6ad77"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga3177c2c084674693cc38f03e80b6ad77">pcl::rad2deg</a> (float alpha)</td></tr>
<tr class="memdesc:ga3177c2c084674693cc38f03e80b6ad77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an angle from radians to degrees.  <a href="group__common.html#ga3177c2c084674693cc38f03e80b6ad77">More...</a><br /></td></tr>
<tr class="separator:ga3177c2c084674693cc38f03e80b6ad77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b0ce695e2a10abb0130bcb5cf90eb6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">pcl::deg2rad</a> (float alpha)</td></tr>
<tr class="memdesc:ga25b0ce695e2a10abb0130bcb5cf90eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an angle from degrees to radians.  <a href="group__common.html#ga25b0ce695e2a10abb0130bcb5cf90eb6">More...</a><br /></td></tr>
<tr class="separator:ga25b0ce695e2a10abb0130bcb5cf90eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997c583b8ac57ffa9ad9e7321b4673e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga997c583b8ac57ffa9ad9e7321b4673e5">pcl::rad2deg</a> (double alpha)</td></tr>
<tr class="memdesc:ga997c583b8ac57ffa9ad9e7321b4673e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an angle from radians to degrees.  <a href="group__common.html#ga997c583b8ac57ffa9ad9e7321b4673e5">More...</a><br /></td></tr>
<tr class="separator:ga997c583b8ac57ffa9ad9e7321b4673e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78fe9974ed54012d6cf057afda5d3350"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga78fe9974ed54012d6cf057afda5d3350">pcl::deg2rad</a> (double alpha)</td></tr>
<tr class="memdesc:ga78fe9974ed54012d6cf057afda5d3350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an angle from degrees to radians.  <a href="group__common.html#ga78fe9974ed54012d6cf057afda5d3350">More...</a><br /></td></tr>
<tr class="separator:ga78fe9974ed54012d6cf057afda5d3350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b37d5c19b2773954bbc5320f011f3ec"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga3b37d5c19b2773954bbc5320f011f3ec">pcl::normAngle</a> (float alpha)</td></tr>
<tr class="memdesc:ga3b37d5c19b2773954bbc5320f011f3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an angle to (-PI, PI].  <a href="group__common.html#ga3b37d5c19b2773954bbc5320f011f3ec">More...</a><br /></td></tr>
<tr class="separator:ga3b37d5c19b2773954bbc5320f011f3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5729fae15603888b49743b118025290"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaf5729fae15603888b49743b118025290"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaf5729fae15603888b49743b118025290">pcl::compute3DCentroid</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gaf5729fae15603888b49743b118025290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D (X-Y-Z) centroid of a set of points and return it as a 3D vector.  <a href="group__common.html#gaf5729fae15603888b49743b118025290">More...</a><br /></td></tr>
<tr class="separator:gaf5729fae15603888b49743b118025290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26f5d53ac5362b04a5c8ed68c4c39038"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga26f5d53ac5362b04a5c8ed68c4c39038"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga26f5d53ac5362b04a5c8ed68c4c39038">pcl::compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga26f5d53ac5362b04a5c8ed68c4c39038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D (X-Y-Z) centroid of a set of points and return it as a 3D vector.  <a href="group__common.html#ga26f5d53ac5362b04a5c8ed68c4c39038">More...</a><br /></td></tr>
<tr class="separator:ga26f5d53ac5362b04a5c8ed68c4c39038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd1abc9deae9bb71dea8e6c1fd24af9"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gadfd1abc9deae9bb71dea8e6c1fd24af9"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gadfd1abc9deae9bb71dea8e6c1fd24af9">pcl::compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gadfd1abc9deae9bb71dea8e6c1fd24af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D (X-Y-Z) centroid of a set of points using their indices and return it as a 3D vector.  <a href="group__common.html#gadfd1abc9deae9bb71dea8e6c1fd24af9">More...</a><br /></td></tr>
<tr class="separator:gadfd1abc9deae9bb71dea8e6c1fd24af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057c72764dfcd1276f7fe19bbfb380a7"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga057c72764dfcd1276f7fe19bbfb380a7"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga057c72764dfcd1276f7fe19bbfb380a7">pcl::compute3DCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga057c72764dfcd1276f7fe19bbfb380a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D (X-Y-Z) centroid of a set of points using their indices and return it as a 3D vector.  <a href="group__common.html#ga057c72764dfcd1276f7fe19bbfb380a7">More...</a><br /></td></tr>
<tr class="separator:ga057c72764dfcd1276f7fe19bbfb380a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac36b146ec26b1ceb7be43a9ecaa010c4">pcl::computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 covariance matrix of a given set of points.  <a href="group__common.html#gac36b146ec26b1ceb7be43a9ecaa010c4">More...</a><br /></td></tr>
<tr class="separator:gac36b146ec26b1ceb7be43a9ecaa010c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ea605f439a80daf6348547379bad8e"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gab5ea605f439a80daf6348547379bad8e"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gab5ea605f439a80daf6348547379bad8e">pcl::computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gab5ea605f439a80daf6348547379bad8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normalized the 3x3 covariance matrix of a given set of points.  <a href="group__common.html#gab5ea605f439a80daf6348547379bad8e">More...</a><br /></td></tr>
<tr class="separator:gab5ea605f439a80daf6348547379bad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2680eec49635c40687ab378bde204fdc"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga2680eec49635c40687ab378bde204fdc"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga2680eec49635c40687ab378bde204fdc">pcl::computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:ga2680eec49635c40687ab378bde204fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 covariance matrix of a given set of points using their indices.  <a href="group__common.html#ga2680eec49635c40687ab378bde204fdc">More...</a><br /></td></tr>
<tr class="separator:ga2680eec49635c40687ab378bde204fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35305b1593d5417be615e940383f4ced"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga35305b1593d5417be615e940383f4ced"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga35305b1593d5417be615e940383f4ced">pcl::computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:ga35305b1593d5417be615e940383f4ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3x3 covariance matrix of a given set of points using their indices.  <a href="group__common.html#ga35305b1593d5417be615e940383f4ced">More...</a><br /></td></tr>
<tr class="separator:ga35305b1593d5417be615e940383f4ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c9e7cc83ff0b2619c466ac7f45e952"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga41c9e7cc83ff0b2619c466ac7f45e952"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga41c9e7cc83ff0b2619c466ac7f45e952">pcl::computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:ga41c9e7cc83ff0b2619c466ac7f45e952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix of a given set of points using their indices.  <a href="group__common.html#ga41c9e7cc83ff0b2619c466ac7f45e952">More...</a><br /></td></tr>
<tr class="separator:ga41c9e7cc83ff0b2619c466ac7f45e952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb4158efe784f3d3a765f0747b13a80"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gadfb4158efe784f3d3a765f0747b13a80"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gadfb4158efe784f3d3a765f0747b13a80">pcl::computeCovarianceMatrixNormalized</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gadfb4158efe784f3d3a765f0747b13a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix of a given set of points using their indices.  <a href="group__common.html#gadfb4158efe784f3d3a765f0747b13a80">More...</a><br /></td></tr>
<tr class="separator:gadfb4158efe784f3d3a765f0747b13a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72dfb6e965df9752c88790e026a8ab5f"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga72dfb6e965df9752c88790e026a8ab5f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga72dfb6e965df9752c88790e026a8ab5f">pcl::computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga72dfb6e965df9752c88790e026a8ab5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop.  <a href="group__common.html#ga72dfb6e965df9752c88790e026a8ab5f">More...</a><br /></td></tr>
<tr class="separator:ga72dfb6e965df9752c88790e026a8ab5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70c66f08214fb34784483627e5fc913"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaf70c66f08214fb34784483627e5fc913"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaf70c66f08214fb34784483627e5fc913">pcl::computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gaf70c66f08214fb34784483627e5fc913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop.  <a href="group__common.html#gaf70c66f08214fb34784483627e5fc913">More...</a><br /></td></tr>
<tr class="separator:gaf70c66f08214fb34784483627e5fc913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d7bf1a81f21fb97505c91957b7f033"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gac4d7bf1a81f21fb97505c91957b7f033"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac4d7bf1a81f21fb97505c91957b7f033">pcl::computeMeanAndCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gac4d7bf1a81f21fb97505c91957b7f033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop.  <a href="group__common.html#gac4d7bf1a81f21fb97505c91957b7f033">More...</a><br /></td></tr>
<tr class="separator:gac4d7bf1a81f21fb97505c91957b7f033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5956698bec9ece7a491ad2fbbfbe6bc1"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga5956698bec9ece7a491ad2fbbfbe6bc1"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga5956698bec9ece7a491ad2fbbfbe6bc1">pcl::computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:ga5956698bec9ece7a491ad2fbbfbe6bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix for a already demeaned point cloud.  <a href="group__common.html#ga5956698bec9ece7a491ad2fbbfbe6bc1">More...</a><br /></td></tr>
<tr class="separator:ga5956698bec9ece7a491ad2fbbfbe6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1be0e0d9c0edfe771edb0eca57b8650"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gae1be0e0d9c0edfe771edb0eca57b8650"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gae1be0e0d9c0edfe771edb0eca57b8650">pcl::computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gae1be0e0d9c0edfe771edb0eca57b8650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix for a already demeaned point cloud.  <a href="group__common.html#gae1be0e0d9c0edfe771edb0eca57b8650">More...</a><br /></td></tr>
<tr class="separator:gae1be0e0d9c0edfe771edb0eca57b8650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3ff94b2145fb22871e41e87ee495b2"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gacf3ff94b2145fb22871e41e87ee495b2"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gacf3ff94b2145fb22871e41e87ee495b2">pcl::computeCovarianceMatrix</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;covariance_matrix)</td></tr>
<tr class="memdesc:gacf3ff94b2145fb22871e41e87ee495b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized 3x3 covariance matrix for a already demeaned point cloud.  <a href="group__common.html#gacf3ff94b2145fb22871e41e87ee495b2">More...</a><br /></td></tr>
<tr class="separator:gacf3ff94b2145fb22871e41e87ee495b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef093d77f87e8a3acb288fe6b8fa397"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga0ef093d77f87e8a3acb288fe6b8fa397"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga0ef093d77f87e8a3acb288fe6b8fa397">pcl::computeCentroidAndOBB</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;obb_center, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;obb_dimensions, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;obb_rotational_matrix)</td></tr>
<tr class="memdesc:ga0ef093d77f87e8a3acb288fe6b8fa397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute centroid, OBB (Oriented Bounding Box), <a class="el" href="classpcl_1_1_p_c_a.html" title="Principal Component analysis (PCA) class.">PCA</a> axes of a given set of points.  <a href="group__common.html#ga0ef093d77f87e8a3acb288fe6b8fa397">More...</a><br /></td></tr>
<tr class="separator:ga0ef093d77f87e8a3acb288fe6b8fa397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0767151bef658b88e1d018e3edf1769e"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga0767151bef658b88e1d018e3edf1769e"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga0767151bef658b88e1d018e3edf1769e">pcl::computeCentroidAndOBB</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;obb_center, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;obb_dimensions, Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;obb_rotational_matrix)</td></tr>
<tr class="memdesc:ga0767151bef658b88e1d018e3edf1769e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute centroid, OBB (Oriented Bounding Box), <a class="el" href="classpcl_1_1_p_c_a.html" title="Principal Component analysis (PCA) class.">PCA</a> axes of a given set of points.  <a href="group__common.html#ga0767151bef658b88e1d018e3edf1769e">More...</a><br /></td></tr>
<tr class="separator:ga0767151bef658b88e1d018e3edf1769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f82fbd4e17063ab86287a2543bdea88"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga7f82fbd4e17063ab86287a2543bdea88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga7f82fbd4e17063ab86287a2543bdea88">pcl::demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, int npts=0)</td></tr>
<tr class="memdesc:ga7f82fbd4e17063ab86287a2543bdea88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation.  <a href="group__common.html#ga7f82fbd4e17063ab86287a2543bdea88">More...</a><br /></td></tr>
<tr class="separator:ga7f82fbd4e17063ab86287a2543bdea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7953d5001218e840a3a10a2c8649461e"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga7953d5001218e840a3a10a2c8649461e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga7953d5001218e840a3a10a2c8649461e">pcl::demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga7953d5001218e840a3a10a2c8649461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation.  <a href="group__common.html#ga7953d5001218e840a3a10a2c8649461e">More...</a><br /></td></tr>
<tr class="separator:ga7953d5001218e840a3a10a2c8649461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776aeabe20fa3eb55e6283fea0476f6a"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga776aeabe20fa3eb55e6283fea0476f6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga776aeabe20fa3eb55e6283fea0476f6a">pcl::demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga776aeabe20fa3eb55e6283fea0476f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation.  <a href="group__common.html#ga776aeabe20fa3eb55e6283fea0476f6a">More...</a><br /></td></tr>
<tr class="separator:ga776aeabe20fa3eb55e6283fea0476f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516ff833c2593ba6e53d369b25989f81"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga516ff833c2593ba6e53d369b25989f81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga516ff833c2593ba6e53d369b25989f81">pcl::demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga516ff833c2593ba6e53d369b25989f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation.  <a href="group__common.html#ga516ff833c2593ba6e53d369b25989f81">More...</a><br /></td></tr>
<tr class="separator:ga516ff833c2593ba6e53d369b25989f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553c2ce698f074fe38d74f01b57a3343"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga553c2ce698f074fe38d74f01b57a3343"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga553c2ce698f074fe38d74f01b57a3343">pcl::demeanPointCloud</a> (<a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_iterator, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;cloud_out, int npts=0)</td></tr>
<tr class="memdesc:ga553c2ce698f074fe38d74f01b57a3343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="group__common.html#ga553c2ce698f074fe38d74f01b57a3343">More...</a><br /></td></tr>
<tr class="separator:ga553c2ce698f074fe38d74f01b57a3343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19c71709093628e61037337056b99fa"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gae19c71709093628e61037337056b99fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gae19c71709093628e61037337056b99fa">pcl::demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gae19c71709093628e61037337056b99fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="group__common.html#gae19c71709093628e61037337056b99fa">More...</a><br /></td></tr>
<tr class="separator:gae19c71709093628e61037337056b99fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743fe66a6743b81611c70acd59c0d680"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga743fe66a6743b81611c70acd59c0d680"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga743fe66a6743b81611c70acd59c0d680">pcl::demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga743fe66a6743b81611c70acd59c0d680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="group__common.html#ga743fe66a6743b81611c70acd59c0d680">More...</a><br /></td></tr>
<tr class="separator:ga743fe66a6743b81611c70acd59c0d680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539a53e4b17ad9ed2f00ae8b2e464221"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga539a53e4b17ad9ed2f00ae8b2e464221"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga539a53e4b17ad9ed2f00ae8b2e464221">pcl::demeanPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;centroid, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga539a53e4b17ad9ed2f00ae8b2e464221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="group__common.html#ga539a53e4b17ad9ed2f00ae8b2e464221">More...</a><br /></td></tr>
<tr class="separator:ga539a53e4b17ad9ed2f00ae8b2e464221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d047d6f7b50a2d81306cc59ac927179"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga4d047d6f7b50a2d81306cc59ac927179"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4d047d6f7b50a2d81306cc59ac927179">pcl::computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga4d047d6f7b50a2d81306cc59ac927179"><td class="mdescLeft">&#160;</td><td class="mdescRight">General, all purpose nD centroid estimation for a set of points using their indices.  <a href="group__common.html#ga4d047d6f7b50a2d81306cc59ac927179">More...</a><br /></td></tr>
<tr class="separator:ga4d047d6f7b50a2d81306cc59ac927179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac394645bca960356e4d1aee5e75b92d"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaac394645bca960356e4d1aee5e75b92d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaac394645bca960356e4d1aee5e75b92d">pcl::computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:gaac394645bca960356e4d1aee5e75b92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">General, all purpose nD centroid estimation for a set of points using their indices.  <a href="group__common.html#gaac394645bca960356e4d1aee5e75b92d">More...</a><br /></td></tr>
<tr class="separator:gaac394645bca960356e4d1aee5e75b92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9654681b5a78f1e3ad5566de05e1d638"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga9654681b5a78f1e3ad5566de05e1d638"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga9654681b5a78f1e3ad5566de05e1d638">pcl::computeNDCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;centroid)</td></tr>
<tr class="memdesc:ga9654681b5a78f1e3ad5566de05e1d638"><td class="mdescLeft">&#160;</td><td class="mdescRight">General, all purpose nD centroid estimation for a set of points using their indices.  <a href="group__common.html#ga9654681b5a78f1e3ad5566de05e1d638">More...</a><br /></td></tr>
<tr class="separator:ga9654681b5a78f1e3ad5566de05e1d638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ba1c9605f3bb1e3063e30fa04857c2"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ga24ba1c9605f3bb1e3063e30fa04857c2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga24ba1c9605f3bb1e3063e30fa04857c2">pcl::computeCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud, PointOutT &amp;centroid)</td></tr>
<tr class="memdesc:ga24ba1c9605f3bb1e3063e30fa04857c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the centroid of a set of points and return it as a point.  <a href="group__common.html#ga24ba1c9605f3bb1e3063e30fa04857c2">More...</a><br /></td></tr>
<tr class="separator:ga24ba1c9605f3bb1e3063e30fa04857c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e10574ff42edc90e7dd583a36e94ce6"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ga9e10574ff42edc90e7dd583a36e94ce6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga9e10574ff42edc90e7dd583a36e94ce6">pcl::computeCentroid</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, PointOutT &amp;centroid)</td></tr>
<tr class="memdesc:ga9e10574ff42edc90e7dd583a36e94ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the centroid of a set of points and return it as a point.  <a href="group__common.html#ga9e10574ff42edc90e7dd583a36e94ce6">More...</a><br /></td></tr>
<tr class="separator:ga9e10574ff42edc90e7dd583a36e94ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54999c02ba9bee56404539747b0fda51"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga54999c02ba9bee56404539747b0fda51">pcl::getAngle3D</a> (const Eigen::Vector4f &amp;v1, const Eigen::Vector4f &amp;v2, const bool in_degree=false)</td></tr>
<tr class="memdesc:ga54999c02ba9bee56404539747b0fda51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the smallest angle between two 3D vectors in radians (default) or degree.  <a href="group__common.html#ga54999c02ba9bee56404539747b0fda51">More...</a><br /></td></tr>
<tr class="separator:ga54999c02ba9bee56404539747b0fda51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c74d7c459961a2650c22eff8126aef8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga8c74d7c459961a2650c22eff8126aef8">pcl::getAngle3D</a> (const Eigen::Vector3f &amp;v1, const Eigen::Vector3f &amp;v2, const bool in_degree=false)</td></tr>
<tr class="memdesc:ga8c74d7c459961a2650c22eff8126aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the smallest angle between two 3D vectors in radians (default) or degree.  <a href="group__common.html#ga8c74d7c459961a2650c22eff8126aef8">More...</a><br /></td></tr>
<tr class="separator:ga8c74d7c459961a2650c22eff8126aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3349ce9c26d4acbb1adae1e9b2d5f7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga3349ce9c26d4acbb1adae1e9b2d5f7e5">pcl::getMeanStd</a> (const std::vector&lt; float &gt; &amp;values, double &amp;mean, double &amp;stddev)</td></tr>
<tr class="memdesc:ga3349ce9c26d4acbb1adae1e9b2d5f7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute both the mean and the standard deviation of an array of values.  <a href="group__common.html#ga3349ce9c26d4acbb1adae1e9b2d5f7e5">More...</a><br /></td></tr>
<tr class="separator:ga3349ce9c26d4acbb1adae1e9b2d5f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa67d411e0077c68c31adbc7d0d995e9c"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaa67d411e0077c68c31adbc7d0d995e9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaa67d411e0077c68c31adbc7d0d995e9c">pcl::getPointsInBox</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt, <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices)</td></tr>
<tr class="memdesc:gaa67d411e0077c68c31adbc7d0d995e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a set of points residing in a box given its bounds.  <a href="group__common.html#gaa67d411e0077c68c31adbc7d0d995e9c">More...</a><br /></td></tr>
<tr class="separator:gaa67d411e0077c68c31adbc7d0d995e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1583a71aef0f54550adef0ebfef89edd"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga1583a71aef0f54550adef0ebfef89edd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga1583a71aef0f54550adef0ebfef89edd">pcl::getMaxDistance</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const Eigen::Vector4f &amp;pivot_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:ga1583a71aef0f54550adef0ebfef89edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the point at maximum distance from a given point and a given pointcloud.  <a href="group__common.html#ga1583a71aef0f54550adef0ebfef89edd">More...</a><br /></td></tr>
<tr class="separator:ga1583a71aef0f54550adef0ebfef89edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43df2b30eedda61e26d132db661cf2ec"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga43df2b30eedda61e26d132db661cf2ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga43df2b30eedda61e26d132db661cf2ec">pcl::getMaxDistance</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, const Eigen::Vector4f &amp;pivot_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:ga43df2b30eedda61e26d132db661cf2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the point at maximum distance from a given point and a given pointcloud.  <a href="group__common.html#ga43df2b30eedda61e26d132db661cf2ec">More...</a><br /></td></tr>
<tr class="separator:ga43df2b30eedda61e26d132db661cf2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3166f09aafd659f69dc75e63f5e10f81"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga3166f09aafd659f69dc75e63f5e10f81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3166f09aafd659f69dc75e63f5e10f81">pcl::getMinMax3D</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;min_pt, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;max_pt)</td></tr>
<tr class="memdesc:ga3166f09aafd659f69dc75e63f5e10f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud.  <a href="group__common.html#ga3166f09aafd659f69dc75e63f5e10f81">More...</a><br /></td></tr>
<tr class="separator:ga3166f09aafd659f69dc75e63f5e10f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9010977f5e52b35b484be7624df3f8"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gafd9010977f5e52b35b484be7624df3f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gafd9010977f5e52b35b484be7624df3f8">pcl::getMinMax3D</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:gafd9010977f5e52b35b484be7624df3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud.  <a href="group__common.html#gafd9010977f5e52b35b484be7624df3f8">More...</a><br /></td></tr>
<tr class="separator:gafd9010977f5e52b35b484be7624df3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e38f91f115922ef4aa80328b6da28f5"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga8e38f91f115922ef4aa80328b6da28f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga8e38f91f115922ef4aa80328b6da28f5">pcl::getMinMax3D</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:ga8e38f91f115922ef4aa80328b6da28f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud.  <a href="group__common.html#ga8e38f91f115922ef4aa80328b6da28f5">More...</a><br /></td></tr>
<tr class="separator:ga8e38f91f115922ef4aa80328b6da28f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41eb246206d51f77a8cb82b5d963e6a2"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga41eb246206d51f77a8cb82b5d963e6a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga41eb246206d51f77a8cb82b5d963e6a2">pcl::getMinMax3D</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, Eigen::Vector4f &amp;min_pt, Eigen::Vector4f &amp;max_pt)</td></tr>
<tr class="memdesc:ga41eb246206d51f77a8cb82b5d963e6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud.  <a href="group__common.html#ga41eb246206d51f77a8cb82b5d963e6a2">More...</a><br /></td></tr>
<tr class="separator:ga41eb246206d51f77a8cb82b5d963e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64d6ba9e834d29feda71a76d3ec841f"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gab64d6ba9e834d29feda71a76d3ec841f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gab64d6ba9e834d29feda71a76d3ec841f">pcl::getCircumcircleRadius</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pa, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pb, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pc)</td></tr>
<tr class="memdesc:gab64d6ba9e834d29feda71a76d3ec841f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the radius of a circumscribed circle for a triangle formed of three points pa, pb, and pc.  <a href="group__common.html#gab64d6ba9e834d29feda71a76d3ec841f">More...</a><br /></td></tr>
<tr class="separator:gab64d6ba9e834d29feda71a76d3ec841f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacff2e632283be60810678d329b166ec"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaacff2e632283be60810678d329b166ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaacff2e632283be60810678d329b166ec">pcl::getMinMax</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;histogram, int len, float &amp;min_p, float &amp;max_p)</td></tr>
<tr class="memdesc:gaacff2e632283be60810678d329b166ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on a point histogram.  <a href="group__common.html#gaacff2e632283be60810678d329b166ec">More...</a><br /></td></tr>
<tr class="separator:gaacff2e632283be60810678d329b166ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9e18520c49be76f2a28834e2da8a56"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga1a9e18520c49be76f2a28834e2da8a56"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga1a9e18520c49be76f2a28834e2da8a56">pcl::calculatePolygonArea</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;polygon)</td></tr>
<tr class="memdesc:ga1a9e18520c49be76f2a28834e2da8a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the area of a polygon given a point cloud that defines the polygon.  <a href="group__common.html#ga1a9e18520c49be76f2a28834e2da8a56">More...</a><br /></td></tr>
<tr class="separator:ga1a9e18520c49be76f2a28834e2da8a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287e6ce2d4be348c059baf31eaf2dd54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga287e6ce2d4be348c059baf31eaf2dd54">pcl::getMinMax</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, int idx, const std::string &amp;field_name, float &amp;min_p, float &amp;max_p)</td></tr>
<tr class="memdesc:ga287e6ce2d4be348c059baf31eaf2dd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum and maximum values on a point histogram.  <a href="group__common.html#ga287e6ce2d4be348c059baf31eaf2dd54">More...</a><br /></td></tr>
<tr class="separator:ga287e6ce2d4be348c059baf31eaf2dd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb684087702126b29c8b99f1e2c2786b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gacb684087702126b29c8b99f1e2c2786b">pcl::getMeanStdDev</a> (const std::vector&lt; float &gt; &amp;values, double &amp;mean, double &amp;stddev)</td></tr>
<tr class="memdesc:gacb684087702126b29c8b99f1e2c2786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute both the mean and the standard deviation of an array of values.  <a href="group__common.html#gacb684087702126b29c8b99f1e2c2786b">More...</a><br /></td></tr>
<tr class="separator:gacb684087702126b29c8b99f1e2c2786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f445da2542cd886856beff40c383c3c"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename Functor &gt; </td></tr>
<tr class="memitem:ga2f445da2542cd886856beff40c383c3c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga2f445da2542cd886856beff40c383c3c">pcl::computeMedian</a> (IteratorT begin, IteratorT end, <a class="el" href="structpcl_1_1_functor.html">Functor</a> f) noexcept -&gt; std::result_of_t&lt; <a class="el" href="structpcl_1_1_functor.html">Functor</a>(decltype(*begin))&gt;</td></tr>
<tr class="memdesc:ga2f445da2542cd886856beff40c383c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median of a list of values (fast).  <a href="group__common.html#ga2f445da2542cd886856beff40c383c3c">More...</a><br /></td></tr>
<tr class="separator:ga2f445da2542cd886856beff40c383c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab978bf1754771246b2f140a5b52a8f8b"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:gab978bf1754771246b2f140a5b52a8f8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gab978bf1754771246b2f140a5b52a8f8b">pcl::copyPoint</a> (const PointInT &amp;point_in, PointOutT &amp;point_out)</td></tr>
<tr class="memdesc:gab978bf1754771246b2f140a5b52a8f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the fields of a source point into a target point.  <a href="group__common.html#gab978bf1754771246b2f140a5b52a8f8b">More...</a><br /></td></tr>
<tr class="separator:gab978bf1754771246b2f140a5b52a8f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee346a92c01c042ffae2907ae5c93c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga4ee346a92c01c042ffae2907ae5c93c5">pcl::lineToLineSegment</a> (const Eigen::VectorXf &amp;line_a, const Eigen::VectorXf &amp;line_b, Eigen::Vector4f &amp;pt1_seg, Eigen::Vector4f &amp;pt2_seg)</td></tr>
<tr class="memdesc:ga4ee346a92c01c042ffae2907ae5c93c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shortest 3D segment between two 3D lines.  <a href="group__common.html#ga4ee346a92c01c042ffae2907ae5c93c5">More...</a><br /></td></tr>
<tr class="separator:ga4ee346a92c01c042ffae2907ae5c93c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9217ecd4cc14221f178af07a16ef75d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gad9217ecd4cc14221f178af07a16ef75d">pcl::sqrPointToLineDistance</a> (const Eigen::Vector4f &amp;pt, const Eigen::Vector4f &amp;line_pt, const Eigen::Vector4f &amp;line_dir)</td></tr>
<tr class="memdesc:gad9217ecd4cc14221f178af07a16ef75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the square distance from a point to a line (represented by a point and a direction)  <a href="group__common.html#gad9217ecd4cc14221f178af07a16ef75d">More...</a><br /></td></tr>
<tr class="separator:gad9217ecd4cc14221f178af07a16ef75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6aa7accd68832e8a4d4707c358e40f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga3d6aa7accd68832e8a4d4707c358e40f">pcl::sqrPointToLineDistance</a> (const Eigen::Vector4f &amp;pt, const Eigen::Vector4f &amp;line_pt, const Eigen::Vector4f &amp;line_dir, const double sqr_length)</td></tr>
<tr class="memdesc:ga3d6aa7accd68832e8a4d4707c358e40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the square distance from a point to a line (represented by a point and a direction)  <a href="group__common.html#ga3d6aa7accd68832e8a4d4707c358e40f">More...</a><br /></td></tr>
<tr class="separator:ga3d6aa7accd68832e8a4d4707c358e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ceb9b4896578ed075a36ad3937ee26"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga30ceb9b4896578ed075a36ad3937ee26"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga30ceb9b4896578ed075a36ad3937ee26">pcl::getMaxSegment</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pmin, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pmax)</td></tr>
<tr class="memdesc:ga30ceb9b4896578ed075a36ad3937ee26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum segment in a given set of points, and return the minimum and maximum points.  <a href="group__common.html#ga30ceb9b4896578ed075a36ad3937ee26">More...</a><br /></td></tr>
<tr class="separator:ga30ceb9b4896578ed075a36ad3937ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e677fb3cb3143a9665d1eb0bf5f1b0"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga29e677fb3cb3143a9665d1eb0bf5f1b0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga29e677fb3cb3143a9665d1eb0bf5f1b0">pcl::getMaxSegment</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pmin, <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;pmax)</td></tr>
<tr class="memdesc:ga29e677fb3cb3143a9665d1eb0bf5f1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum segment in a given set of points, and return the minimum and maximum points.  <a href="group__common.html#ga29e677fb3cb3143a9665d1eb0bf5f1b0">More...</a><br /></td></tr>
<tr class="separator:ga29e677fb3cb3143a9665d1eb0bf5f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72970b7435480c0c1827c8e74bc1d605"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga72970b7435480c0c1827c8e74bc1d605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga72970b7435480c0c1827c8e74bc1d605">pcl::eigen22</a> (const Matrix &amp;mat, typename Matrix::Scalar &amp;eigenvalue, Vector &amp;eigenvector)</td></tr>
<tr class="memdesc:ga72970b7435480c0c1827c8e74bc1d605"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine the smallest eigenvalue and its corresponding eigenvector  <a href="group__common.html#ga72970b7435480c0c1827c8e74bc1d605">More...</a><br /></td></tr>
<tr class="separator:ga72970b7435480c0c1827c8e74bc1d605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fdd69805d49c416393c604f9f209113"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga4fdd69805d49c416393c604f9f209113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4fdd69805d49c416393c604f9f209113">pcl::eigen22</a> (const Matrix &amp;mat, Matrix &amp;eigenvectors, Vector &amp;eigenvalues)</td></tr>
<tr class="memdesc:ga4fdd69805d49c416393c604f9f209113"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine the smallest eigenvalue and its corresponding eigenvector  <a href="group__common.html#ga4fdd69805d49c416393c604f9f209113">More...</a><br /></td></tr>
<tr class="separator:ga4fdd69805d49c416393c604f9f209113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c9b186d04d2e8a868e058473214622"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga11c9b186d04d2e8a868e058473214622"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga11c9b186d04d2e8a868e058473214622">pcl::computeCorrespondingEigenVector</a> (const Matrix &amp;mat, const typename Matrix::Scalar &amp;eigenvalue, Vector &amp;eigenvector)</td></tr>
<tr class="memdesc:ga11c9b186d04d2e8a868e058473214622"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the corresponding eigenvector to the given eigenvalue of the symmetric positive semi definite input matrix  <a href="group__common.html#ga11c9b186d04d2e8a868e058473214622">More...</a><br /></td></tr>
<tr class="separator:ga11c9b186d04d2e8a868e058473214622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca873868052e7d26efcf4b684a17bef2"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:gaca873868052e7d26efcf4b684a17bef2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaca873868052e7d26efcf4b684a17bef2">pcl::eigen33</a> (const Matrix &amp;mat, typename Matrix::Scalar &amp;eigenvalue, Vector &amp;eigenvector)</td></tr>
<tr class="memdesc:gaca873868052e7d26efcf4b684a17bef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the eigenvector and eigenvalue of the smallest eigenvalue of the symmetric positive semi definite input matrix  <a href="group__common.html#gaca873868052e7d26efcf4b684a17bef2">More...</a><br /></td></tr>
<tr class="separator:gaca873868052e7d26efcf4b684a17bef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a1ba2729012164635113224cb211581"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga3a1ba2729012164635113224cb211581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3a1ba2729012164635113224cb211581">pcl::eigen33</a> (const Matrix &amp;mat, Vector &amp;evals)</td></tr>
<tr class="memdesc:ga3a1ba2729012164635113224cb211581"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the eigenvalues of the symmetric positive semi definite input matrix  <a href="group__common.html#ga3a1ba2729012164635113224cb211581">More...</a><br /></td></tr>
<tr class="separator:ga3a1ba2729012164635113224cb211581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d78c3e9c0f3f58a0806499ae6ed97b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ga76d78c3e9c0f3f58a0806499ae6ed97b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga76d78c3e9c0f3f58a0806499ae6ed97b">pcl::eigen33</a> (const Matrix &amp;mat, Matrix &amp;evecs, Vector &amp;evals)</td></tr>
<tr class="memdesc:ga76d78c3e9c0f3f58a0806499ae6ed97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the eigenvalues and corresponding eigenvectors of the symmetric positive semi definite input matrix  <a href="group__common.html#ga76d78c3e9c0f3f58a0806499ae6ed97b">More...</a><br /></td></tr>
<tr class="separator:ga76d78c3e9c0f3f58a0806499ae6ed97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09b0c9a50601f3ae20a7babfd9a8d2d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:gad09b0c9a50601f3ae20a7babfd9a8d2d"><td class="memTemplItemLeft" align="right" valign="top">Matrix::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gad09b0c9a50601f3ae20a7babfd9a8d2d">pcl::invert2x2</a> (const Matrix &amp;matrix, Matrix &amp;inverse)</td></tr>
<tr class="memdesc:gad09b0c9a50601f3ae20a7babfd9a8d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inverse of a 2x2 matrix.  <a href="group__common.html#gad09b0c9a50601f3ae20a7babfd9a8d2d">More...</a><br /></td></tr>
<tr class="separator:gad09b0c9a50601f3ae20a7babfd9a8d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503f55a565c260660c6ac0461f17fa8f"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:ga503f55a565c260660c6ac0461f17fa8f"><td class="memTemplItemLeft" align="right" valign="top">Matrix::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga503f55a565c260660c6ac0461f17fa8f">pcl::invert3x3SymMatrix</a> (const Matrix &amp;matrix, Matrix &amp;inverse)</td></tr>
<tr class="memdesc:ga503f55a565c260660c6ac0461f17fa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inverse of a 3x3 symmetric matrix.  <a href="group__common.html#ga503f55a565c260660c6ac0461f17fa8f">More...</a><br /></td></tr>
<tr class="separator:ga503f55a565c260660c6ac0461f17fa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb12d1f85437aafb0a3ac12af5633400"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:gabb12d1f85437aafb0a3ac12af5633400"><td class="memTemplItemLeft" align="right" valign="top">Matrix::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gabb12d1f85437aafb0a3ac12af5633400">pcl::invert3x3Matrix</a> (const Matrix &amp;matrix, Matrix &amp;inverse)</td></tr>
<tr class="memdesc:gabb12d1f85437aafb0a3ac12af5633400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inverse of a general 3x3 matrix.  <a href="group__common.html#gabb12d1f85437aafb0a3ac12af5633400">More...</a><br /></td></tr>
<tr class="separator:gabb12d1f85437aafb0a3ac12af5633400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d0048ba1efd11359011eb47f6c92fa"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:ga44d0048ba1efd11359011eb47f6c92fa"><td class="memTemplItemLeft" align="right" valign="top">Matrix::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga44d0048ba1efd11359011eb47f6c92fa">pcl::determinant3x3Matrix</a> (const Matrix &amp;matrix)</td></tr>
<tr class="memdesc:ga44d0048ba1efd11359011eb47f6c92fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the determinant of a 3x3 matrix.  <a href="group__common.html#ga44d0048ba1efd11359011eb47f6c92fa">More...</a><br /></td></tr>
<tr class="separator:ga44d0048ba1efd11359011eb47f6c92fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf457d33994792e63129de9709dcdf329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaf457d33994792e63129de9709dcdf329">pcl::getTransFromUnitVectorsZY</a> (const Eigen::Vector3f &amp;z_axis, const Eigen::Vector3f &amp;y_direction, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:gaf457d33994792e63129de9709dcdf329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#gaf457d33994792e63129de9709dcdf329">More...</a><br /></td></tr>
<tr class="separator:gaf457d33994792e63129de9709dcdf329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d47eda3c3f5f91125296fd7d202ebb"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga58d47eda3c3f5f91125296fd7d202ebb">pcl::getTransFromUnitVectorsZY</a> (const Eigen::Vector3f &amp;z_axis, const Eigen::Vector3f &amp;y_direction)</td></tr>
<tr class="memdesc:ga58d47eda3c3f5f91125296fd7d202ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga58d47eda3c3f5f91125296fd7d202ebb">More...</a><br /></td></tr>
<tr class="separator:ga58d47eda3c3f5f91125296fd7d202ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8319aa7921bdc742a9d0f95458e9cfe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga8319aa7921bdc742a9d0f95458e9cfe0">pcl::getTransFromUnitVectorsXY</a> (const Eigen::Vector3f &amp;x_axis, const Eigen::Vector3f &amp;y_direction, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:ga8319aa7921bdc742a9d0f95458e9cfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>x_axis</em> into (1,0,0) and <em>y_direction</em> into a vector with z=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga8319aa7921bdc742a9d0f95458e9cfe0">More...</a><br /></td></tr>
<tr class="separator:ga8319aa7921bdc742a9d0f95458e9cfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8933c653f39db3636bfbdd262278edcb"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga8933c653f39db3636bfbdd262278edcb">pcl::getTransFromUnitVectorsXY</a> (const Eigen::Vector3f &amp;x_axis, const Eigen::Vector3f &amp;y_direction)</td></tr>
<tr class="memdesc:ga8933c653f39db3636bfbdd262278edcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>x_axis</em> into (1,0,0) and <em>y_direction</em> into a vector with z=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga8933c653f39db3636bfbdd262278edcb">More...</a><br /></td></tr>
<tr class="separator:ga8933c653f39db3636bfbdd262278edcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1f523f342ff69277f23ea9f02fc5a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga7d1f523f342ff69277f23ea9f02fc5a6">pcl::getTransformationFromTwoUnitVectors</a> (const Eigen::Vector3f &amp;y_direction, const Eigen::Vector3f &amp;z_axis, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:ga7d1f523f342ff69277f23ea9f02fc5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga7d1f523f342ff69277f23ea9f02fc5a6">More...</a><br /></td></tr>
<tr class="separator:ga7d1f523f342ff69277f23ea9f02fc5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada89edf1699e05ecf7355738e9f56f6b"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gada89edf1699e05ecf7355738e9f56f6b">pcl::getTransformationFromTwoUnitVectors</a> (const Eigen::Vector3f &amp;y_direction, const Eigen::Vector3f &amp;z_axis)</td></tr>
<tr class="memdesc:gada89edf1699e05ecf7355738e9f56f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#gada89edf1699e05ecf7355738e9f56f6b">More...</a><br /></td></tr>
<tr class="separator:gada89edf1699e05ecf7355738e9f56f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4375e99ec2ae368eec9379f506568611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga4375e99ec2ae368eec9379f506568611">pcl::getTransformationFromTwoUnitVectorsAndOrigin</a> (const Eigen::Vector3f &amp;y_direction, const Eigen::Vector3f &amp;z_axis, const Eigen::Vector3f &amp;origin, Eigen::Affine3f &amp;transformation)</td></tr>
<tr class="memdesc:ga4375e99ec2ae368eec9379f506568611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transformation that will translate <em>origin</em> to (0,0,0) and rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>)  <a href="group__common.html#ga4375e99ec2ae368eec9379f506568611">More...</a><br /></td></tr>
<tr class="separator:ga4375e99ec2ae368eec9379f506568611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637da495fec59c1c1d186aa6e3bac15b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga637da495fec59c1c1d186aa6e3bac15b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga637da495fec59c1c1d186aa6e3bac15b">pcl::getEulerAngles</a> (const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;t, Scalar &amp;roll, Scalar &amp;pitch, Scalar &amp;yaw)</td></tr>
<tr class="memdesc:ga637da495fec59c1c1d186aa6e3bac15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the Euler angles (intrinsic rotations, ZYX-convention) from the given transformation.  <a href="group__common.html#ga637da495fec59c1c1d186aa6e3bac15b">More...</a><br /></td></tr>
<tr class="separator:ga637da495fec59c1c1d186aa6e3bac15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e52d439a979e71096f4dd50f1298f32"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga3e52d439a979e71096f4dd50f1298f32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3e52d439a979e71096f4dd50f1298f32">pcl::getTranslationAndEulerAngles</a> (const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;t, Scalar &amp;x, Scalar &amp;y, Scalar &amp;z, Scalar &amp;roll, Scalar &amp;pitch, Scalar &amp;yaw)</td></tr>
<tr class="memdesc:ga3e52d439a979e71096f4dd50f1298f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract x,y,z and the Euler angles (intrinsic rotations, ZYX-convention) from the given transformation.  <a href="group__common.html#ga3e52d439a979e71096f4dd50f1298f32">More...</a><br /></td></tr>
<tr class="separator:ga3e52d439a979e71096f4dd50f1298f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc746d1fd72f99fee462ed1a9e4abea"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga5cc746d1fd72f99fee462ed1a9e4abea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga5cc746d1fd72f99fee462ed1a9e4abea">pcl::getTransformation</a> (Scalar x, Scalar y, Scalar z, Scalar roll, Scalar pitch, Scalar yaw, Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;t)</td></tr>
<tr class="memdesc:ga5cc746d1fd72f99fee462ed1a9e4abea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation from the given translation and Euler angles (intrinsic rotations, ZYX-convention)  <a href="group__common.html#ga5cc746d1fd72f99fee462ed1a9e4abea">More...</a><br /></td></tr>
<tr class="separator:ga5cc746d1fd72f99fee462ed1a9e4abea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49a34180e337479ddeda21222882124"><td class="memItemLeft" align="right" valign="top">Eigen::Affine3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaf49a34180e337479ddeda21222882124">pcl::getTransformation</a> (float x, float y, float z, float roll, float pitch, float yaw)</td></tr>
<tr class="memdesc:gaf49a34180e337479ddeda21222882124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation from the given translation and Euler angles (intrinsic rotations, ZYX-convention)  <a href="group__common.html#gaf49a34180e337479ddeda21222882124">More...</a><br /></td></tr>
<tr class="separator:gaf49a34180e337479ddeda21222882124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc18ebcacd806fd0c9336fe2f8b7208c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:gacc18ebcacd806fd0c9336fe2f8b7208c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gacc18ebcacd806fd0c9336fe2f8b7208c">pcl::saveBinary</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, std::ostream &amp;file)</td></tr>
<tr class="memdesc:gacc18ebcacd806fd0c9336fe2f8b7208c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a matrix to an output stream.  <a href="group__common.html#gacc18ebcacd806fd0c9336fe2f8b7208c">More...</a><br /></td></tr>
<tr class="separator:gacc18ebcacd806fd0c9336fe2f8b7208c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5281205532955d384c8aa22ff4ff5e80"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ga5281205532955d384c8aa22ff4ff5e80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga5281205532955d384c8aa22ff4ff5e80">pcl::loadBinary</a> (Eigen::MatrixBase&lt; Derived &gt; const &amp;matrix, std::istream &amp;file)</td></tr>
<tr class="memdesc:ga5281205532955d384c8aa22ff4ff5e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix from an input stream.  <a href="group__common.html#ga5281205532955d384c8aa22ff4ff5e80">More...</a><br /></td></tr>
<tr class="separator:ga5281205532955d384c8aa22ff4ff5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d365f5e3c7400a13c55d001ed76e35b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga4d365f5e3c7400a13c55d001ed76e35b">pcl::lineWithLineIntersection</a> (const Eigen::VectorXf &amp;line_a, const Eigen::VectorXf &amp;line_b, Eigen::Vector4f &amp;point, double sqr_eps=1e-4)</td></tr>
<tr class="memdesc:ga4d365f5e3c7400a13c55d001ed76e35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection of a two 3D lines in space as a 3D point.  <a href="group__common.html#ga4d365f5e3c7400a13c55d001ed76e35b">More...</a><br /></td></tr>
<tr class="separator:ga4d365f5e3c7400a13c55d001ed76e35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee7c3cfcb96e3884199191a9c24f6f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaeee7c3cfcb96e3884199191a9c24f6f0">pcl::lineWithLineIntersection</a> (const <a class="el" href="structpcl_1_1_model_coefficients.html">pcl::ModelCoefficients</a> &amp;line_a, const <a class="el" href="structpcl_1_1_model_coefficients.html">pcl::ModelCoefficients</a> &amp;line_b, Eigen::Vector4f &amp;point, double sqr_eps=1e-4)</td></tr>
<tr class="memdesc:gaeee7c3cfcb96e3884199191a9c24f6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection of a two 3D lines in space as a 3D point.  <a href="group__common.html#gaeee7c3cfcb96e3884199191a9c24f6f0">More...</a><br /></td></tr>
<tr class="separator:gaeee7c3cfcb96e3884199191a9c24f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc4b9a4e25de1d0b00db4e41f0ad682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga2bc4b9a4e25de1d0b00db4e41f0ad682">pcl::getFieldIndex</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud, const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ga2bc4b9a4e25de1d0b00db4e41f0ad682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specified field (i.e., dimension/channel)  <a href="group__common.html#ga2bc4b9a4e25de1d0b00db4e41f0ad682">More...</a><br /></td></tr>
<tr class="separator:ga2bc4b9a4e25de1d0b00db4e41f0ad682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f637d9f7422a769448983af5fcbdeb"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga21f637d9f7422a769448983af5fcbdeb"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga21f637d9f7422a769448983af5fcbdeb">pcl::getFieldIndex</a> (const std::string &amp;field_name, std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:ga21f637d9f7422a769448983af5fcbdeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specified field (i.e., dimension/channel)  <a href="group__common.html#ga21f637d9f7422a769448983af5fcbdeb">More...</a><br /></td></tr>
<tr class="separator:ga21f637d9f7422a769448983af5fcbdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c5daaf825f6cc4a3fb93a8544d6bdc4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga3c5daaf825f6cc4a3fb93a8544d6bdc4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3c5daaf825f6cc4a3fb93a8544d6bdc4">pcl::getFieldIndex</a> (const std::string &amp;field_name, const std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;fields)</td></tr>
<tr class="memdesc:ga3c5daaf825f6cc4a3fb93a8544d6bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specified field (i.e., dimension/channel)  <a href="group__common.html#ga3c5daaf825f6cc4a3fb93a8544d6bdc4">More...</a><br /></td></tr>
<tr class="separator:ga3c5daaf825f6cc4a3fb93a8544d6bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8788f010a13b19fc04d9dc2305fde22"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gac8788f010a13b19fc04d9dc2305fde22"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac8788f010a13b19fc04d9dc2305fde22">pcl::getFields</a> ()</td></tr>
<tr class="memdesc:gac8788f010a13b19fc04d9dc2305fde22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of available fields (i.e., dimension/channel)  <a href="group__common.html#gac8788f010a13b19fc04d9dc2305fde22">More...</a><br /></td></tr>
<tr class="separator:gac8788f010a13b19fc04d9dc2305fde22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabed3f370d11ba5dc154d79e682d35b4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaabed3f370d11ba5dc154d79e682d35b4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaabed3f370d11ba5dc154d79e682d35b4">pcl::getFieldsList</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud)</td></tr>
<tr class="memdesc:gaabed3f370d11ba5dc154d79e682d35b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all fields available in a given cloud.  <a href="group__common.html#gaabed3f370d11ba5dc154d79e682d35b4">More...</a><br /></td></tr>
<tr class="separator:gaabed3f370d11ba5dc154d79e682d35b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769f320a73865c3fe30cb96c0f932e76"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga769f320a73865c3fe30cb96c0f932e76">pcl::getFieldsList</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud)</td></tr>
<tr class="memdesc:ga769f320a73865c3fe30cb96c0f932e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the available point cloud fields as a space separated string.  <a href="group__common.html#ga769f320a73865c3fe30cb96c0f932e76">More...</a><br /></td></tr>
<tr class="separator:ga769f320a73865c3fe30cb96c0f932e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ff4ee40cd3c49c7500905f59f37536"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga83ff4ee40cd3c49c7500905f59f37536">pcl::getFieldSize</a> (const int datatype)</td></tr>
<tr class="memdesc:ga83ff4ee40cd3c49c7500905f59f37536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the size of a specific field data type in bytes.  <a href="group__common.html#ga83ff4ee40cd3c49c7500905f59f37536">More...</a><br /></td></tr>
<tr class="separator:ga83ff4ee40cd3c49c7500905f59f37536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac282d255323a916e942f85b7f16740e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gac282d255323a916e942f85b7f16740e3">pcl::getFieldType</a> (const int size, char type)</td></tr>
<tr class="memdesc:gac282d255323a916e942f85b7f16740e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the type of the <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> from a specific size and type.  <a href="group__common.html#gac282d255323a916e942f85b7f16740e3">More...</a><br /></td></tr>
<tr class="separator:gac282d255323a916e942f85b7f16740e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a4eaf1f19dd043252a0b93ac975a10"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gac4a4eaf1f19dd043252a0b93ac975a10">pcl::getFieldType</a> (const int type)</td></tr>
<tr class="memdesc:gac4a4eaf1f19dd043252a0b93ac975a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the type of the <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> from a specific <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> as a char.  <a href="group__common.html#gac4a4eaf1f19dd043252a0b93ac975a10">More...</a><br /></td></tr>
<tr class="separator:gac4a4eaf1f19dd043252a0b93ac975a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15bd342ae8b2f7b0722c9290524e65d4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga15bd342ae8b2f7b0722c9290524e65d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga15bd342ae8b2f7b0722c9290524e65d4">pcl::concatenate</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud1, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud2, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga15bd342ae8b2f7b0722c9290524e65d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two pcl::PointCloud&lt;PointT&gt;  <a href="group__common.html#ga15bd342ae8b2f7b0722c9290524e65d4">More...</a><br /></td></tr>
<tr class="separator:ga15bd342ae8b2f7b0722c9290524e65d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7718075a7ad19719ffcc3fefafa9179a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga7718075a7ad19719ffcc3fefafa9179a">pcl::concatenate</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud1, const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud2, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:ga7718075a7ad19719ffcc3fefafa9179a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a>.  <a href="group__common.html#ga7718075a7ad19719ffcc3fefafa9179a">More...</a><br /></td></tr>
<tr class="separator:ga7718075a7ad19719ffcc3fefafa9179a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76125ee3193f65ae4a331130c13d4d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaf76125ee3193f65ae4a331130c13d4d0">pcl::concatenate</a> (const <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;mesh1, const <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;mesh2, <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;mesh_out)</td></tr>
<tr class="memdesc:gaf76125ee3193f65ae4a331130c13d4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a>.  <a href="group__common.html#gaf76125ee3193f65ae4a331130c13d4d0">More...</a><br /></td></tr>
<tr class="separator:gaf76125ee3193f65ae4a331130c13d4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e4d41367cf18852d8aab9cc1e5391a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga11e4d41367cf18852d8aab9cc1e5391a">pcl::copyPointCloud</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:ga11e4d41367cf18852d8aab9cc1e5391a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga11e4d41367cf18852d8aab9cc1e5391a">More...</a><br /></td></tr>
<tr class="separator:ga11e4d41367cf18852d8aab9cc1e5391a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2c400723fec337e2681bc86aefc18a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga6b2c400723fec337e2681bc86aefc18a">pcl::copyPointCloud</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_in, const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; Eigen::aligned_allocator&lt; <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> &gt; &gt; &amp;indices, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:ga6b2c400723fec337e2681bc86aefc18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga6b2c400723fec337e2681bc86aefc18a">More...</a><br /></td></tr>
<tr class="separator:ga6b2c400723fec337e2681bc86aefc18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6c02fe197e0ea6ca249c46dda0e602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga1c6c02fe197e0ea6ca249c46dda0e602">pcl::copyPointCloud</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_in, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:ga1c6c02fe197e0ea6ca249c46dda0e602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy fields and point cloud data from <em>cloud_in</em> to <em>cloud_out</em>.  <a href="group__common.html#ga1c6c02fe197e0ea6ca249c46dda0e602">More...</a><br /></td></tr>
<tr class="separator:ga1c6c02fe197e0ea6ca249c46dda0e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63889e8e562908917ec218b86ef826b4"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename IndicesVectorAllocator &gt; </td></tr>
<tr class="memitem:ga63889e8e562908917ec218b86ef826b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga63889e8e562908917ec218b86ef826b4">pcl::copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; IndicesVectorAllocator &gt; &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga63889e8e562908917ec218b86ef826b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga63889e8e562908917ec218b86ef826b4">More...</a><br /></td></tr>
<tr class="separator:ga63889e8e562908917ec218b86ef826b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ece0c2faffdb26cd75417200454577"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga44ece0c2faffdb26cd75417200454577"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga44ece0c2faffdb26cd75417200454577">pcl::copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga44ece0c2faffdb26cd75417200454577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga44ece0c2faffdb26cd75417200454577">More...</a><br /></td></tr>
<tr class="separator:ga44ece0c2faffdb26cd75417200454577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafe5bf1194ffaad83a2fc04cde6b20e4"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:gaafe5bf1194ffaad83a2fc04cde6b20e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaafe5bf1194ffaad83a2fc04cde6b20e4">pcl::copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gaafe5bf1194ffaad83a2fc04cde6b20e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#gaafe5bf1194ffaad83a2fc04cde6b20e4">More...</a><br /></td></tr>
<tr class="separator:gaafe5bf1194ffaad83a2fc04cde6b20e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff182bca8d0295d727baaa1fd368c6ad"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:gaff182bca8d0295d727baaa1fd368c6ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaff182bca8d0295d727baaa1fd368c6ad">pcl::copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gaff182bca8d0295d727baaa1fd368c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all the fields from a given point cloud into a new point cloud.  <a href="group__common.html#gaff182bca8d0295d727baaa1fd368c6ad">More...</a><br /></td></tr>
<tr class="separator:gaff182bca8d0295d727baaa1fd368c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c154414777ed872edea44560502922e"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT , typename IndicesVectorAllocator &gt; </td></tr>
<tr class="memitem:ga5c154414777ed872edea44560502922e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga5c154414777ed872edea44560502922e">pcl::copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; IndicesVectorAllocator &gt; &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga5c154414777ed872edea44560502922e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga5c154414777ed872edea44560502922e">More...</a><br /></td></tr>
<tr class="separator:ga5c154414777ed872edea44560502922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67ab079e174e900e6e0b235fb88d7160"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:ga67ab079e174e900e6e0b235fb88d7160"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga67ab079e174e900e6e0b235fb88d7160">pcl::copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:ga67ab079e174e900e6e0b235fb88d7160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#ga67ab079e174e900e6e0b235fb88d7160">More...</a><br /></td></tr>
<tr class="separator:ga67ab079e174e900e6e0b235fb88d7160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ab28ac738a42a65f9f2033d6b33252"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointOutT &gt; </td></tr>
<tr class="memitem:gaa5ab28ac738a42a65f9f2033d6b33252"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaa5ab28ac738a42a65f9f2033d6b33252">pcl::copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;cloud_in, const std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gaa5ab28ac738a42a65f9f2033d6b33252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of a given point cloud as a new point cloud.  <a href="group__common.html#gaa5ab28ac738a42a65f9f2033d6b33252">More...</a><br /></td></tr>
<tr class="separator:gaa5ab28ac738a42a65f9f2033d6b33252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d12b955edd61947ed984e46d65b0046"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr>
<tr class="memitem:ga4d12b955edd61947ed984e46d65b0046"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4d12b955edd61947ed984e46d65b0046">pcl::copyPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, int top, int bottom, int left, int right, <a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485">pcl::InterpolationType</a> border_type, const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;value)</td></tr>
<tr class="memdesc:ga4d12b955edd61947ed984e46d65b0046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a point cloud inside a larger one interpolating borders.  <a href="group__common.html#ga4d12b955edd61947ed984e46d65b0046">More...</a><br /></td></tr>
<tr class="separator:ga4d12b955edd61947ed984e46d65b0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6add803f86fd16a998dce541e9ef402"><td class="memTemplParams" colspan="2">template&lt;typename PointIn1T , typename PointIn2T , typename PointOutT &gt; </td></tr>
<tr class="memitem:gac6add803f86fd16a998dce541e9ef402"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac6add803f86fd16a998dce541e9ef402">pcl::concatenateFields</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointIn1T &gt; &amp;cloud1_in, const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointIn2T &gt; &amp;cloud2_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;cloud_out)</td></tr>
<tr class="memdesc:gac6add803f86fd16a998dce541e9ef402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two datasets representing different fields.  <a href="group__common.html#gac6add803f86fd16a998dce541e9ef402">More...</a><br /></td></tr>
<tr class="separator:gac6add803f86fd16a998dce541e9ef402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54f3a282986844fc7a804242504461e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gac54f3a282986844fc7a804242504461e">pcl::concatenateFields</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud1_in, const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud2_in, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;cloud_out)</td></tr>
<tr class="memdesc:gac54f3a282986844fc7a804242504461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two datasets representing different fields.  <a href="group__common.html#gac54f3a282986844fc7a804242504461e">More...</a><br /></td></tr>
<tr class="separator:gac54f3a282986844fc7a804242504461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d121a64a02046c1c38485ea1fad953e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga6d121a64a02046c1c38485ea1fad953e">pcl::getPointCloudAsEigen</a> (const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;in, Eigen::MatrixXf &amp;out)</td></tr>
<tr class="memdesc:ga6d121a64a02046c1c38485ea1fad953e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the XYZ dimensions of a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> into <a class="el" href="namespace_eigen.html">Eigen</a> format.  <a href="group__common.html#ga6d121a64a02046c1c38485ea1fad953e">More...</a><br /></td></tr>
<tr class="separator:ga6d121a64a02046c1c38485ea1fad953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a91d95901fcbac4a753a4212cfbf221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga7a91d95901fcbac4a753a4212cfbf221">pcl::getEigenAsPointCloud</a> (Eigen::MatrixXf &amp;in, <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;out)</td></tr>
<tr class="memdesc:ga7a91d95901fcbac4a753a4212cfbf221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the XYZ dimensions from an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf into a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> message.  <a href="group__common.html#ga7a91d95901fcbac4a753a4212cfbf221">More...</a><br /></td></tr>
<tr class="separator:ga7a91d95901fcbac4a753a4212cfbf221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb19421457db739a96fe4eacf620139"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ga4bb19421457db739a96fe4eacf620139"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4bb19421457db739a96fe4eacf620139">pcl::io::swapByte</a> (char *bytes)</td></tr>
<tr class="memdesc:ga4bb19421457db739a96fe4eacf620139"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap bytes order of a char array of length N  <a href="group__common.html#ga4bb19421457db739a96fe4eacf620139">More...</a><br /></td></tr>
<tr class="separator:ga4bb19421457db739a96fe4eacf620139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047d812778a099ab333c847342c4b6bf"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga047d812778a099ab333c847342c4b6bf"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga047d812778a099ab333c847342c4b6bf">pcl::selectNorm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim, <a class="el" href="group__common.html#ga9d37f00989a9de11b48deb263649463c">NormType</a> norm_type)</td></tr>
<tr class="memdesc:ga047d812778a099ab333c847342c4b6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that calculates any norm type available, based on the norm_type variable.  <a href="group__common.html#ga047d812778a099ab333c847342c4b6bf">More...</a><br /></td></tr>
<tr class="separator:ga047d812778a099ab333c847342c4b6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d1e988b461de40a26b4e4e9e93ce55"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga61d1e988b461de40a26b4e4e9e93ce55"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga61d1e988b461de40a26b4e4e9e93ce55">pcl::L1_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga61d1e988b461de40a26b4e4e9e93ce55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L1 norm of the vector between two points.  <a href="group__common.html#ga61d1e988b461de40a26b4e4e9e93ce55">More...</a><br /></td></tr>
<tr class="separator:ga61d1e988b461de40a26b4e4e9e93ce55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf034c4bca3fc85c1e6d27d893c2936a5"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:gaf034c4bca3fc85c1e6d27d893c2936a5"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaf034c4bca3fc85c1e6d27d893c2936a5">pcl::L2_Norm_SQR</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:gaf034c4bca3fc85c1e6d27d893c2936a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared L2 norm of the vector between two points.  <a href="group__common.html#gaf034c4bca3fc85c1e6d27d893c2936a5">More...</a><br /></td></tr>
<tr class="separator:gaf034c4bca3fc85c1e6d27d893c2936a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70456fbb6c67cf3c1229e19c831b30ac"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga70456fbb6c67cf3c1229e19c831b30ac"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga70456fbb6c67cf3c1229e19c831b30ac">pcl::L2_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga70456fbb6c67cf3c1229e19c831b30ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2 norm of the vector between two points.  <a href="group__common.html#ga70456fbb6c67cf3c1229e19c831b30ac">More...</a><br /></td></tr>
<tr class="separator:ga70456fbb6c67cf3c1229e19c831b30ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63fded8c9593744836d761940cab9350"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga63fded8c9593744836d761940cab9350"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga63fded8c9593744836d761940cab9350">pcl::Linf_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga63fded8c9593744836d761940cab9350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L-infinity norm of the vector between two points.  <a href="group__common.html#ga63fded8c9593744836d761940cab9350">More...</a><br /></td></tr>
<tr class="separator:ga63fded8c9593744836d761940cab9350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45baeaeb21308cd128a7c44ab786552c"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga45baeaeb21308cd128a7c44ab786552c"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga45baeaeb21308cd128a7c44ab786552c">pcl::JM_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga45baeaeb21308cd128a7c44ab786552c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the JM norm of the vector between two points.  <a href="group__common.html#ga45baeaeb21308cd128a7c44ab786552c">More...</a><br /></td></tr>
<tr class="separator:ga45baeaeb21308cd128a7c44ab786552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb2818b6fa817f3ada41296793283a1"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga0eb2818b6fa817f3ada41296793283a1"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga0eb2818b6fa817f3ada41296793283a1">pcl::B_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga0eb2818b6fa817f3ada41296793283a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the B norm of the vector between two points.  <a href="group__common.html#ga0eb2818b6fa817f3ada41296793283a1">More...</a><br /></td></tr>
<tr class="separator:ga0eb2818b6fa817f3ada41296793283a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac986c55a5b8850fec89cd26c46303747"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:gac986c55a5b8850fec89cd26c46303747"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac986c55a5b8850fec89cd26c46303747">pcl::Sublinear_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:gac986c55a5b8850fec89cd26c46303747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sublinear norm of the vector between two points.  <a href="group__common.html#gac986c55a5b8850fec89cd26c46303747">More...</a><br /></td></tr>
<tr class="separator:gac986c55a5b8850fec89cd26c46303747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e43f6ae7f0607bfdedaea512c510ff8"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga7e43f6ae7f0607bfdedaea512c510ff8"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga7e43f6ae7f0607bfdedaea512c510ff8">pcl::CS_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga7e43f6ae7f0607bfdedaea512c510ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the CS norm of the vector between two points.  <a href="group__common.html#ga7e43f6ae7f0607bfdedaea512c510ff8">More...</a><br /></td></tr>
<tr class="separator:ga7e43f6ae7f0607bfdedaea512c510ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b5c722d30c22652327a1481528224e"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:gae8b5c722d30c22652327a1481528224e"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gae8b5c722d30c22652327a1481528224e">pcl::Div_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:gae8b5c722d30c22652327a1481528224e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the div norm of the vector between two points.  <a href="group__common.html#gae8b5c722d30c22652327a1481528224e">More...</a><br /></td></tr>
<tr class="separator:gae8b5c722d30c22652327a1481528224e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf977fbc818d41de61285d1da0521991a"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:gaf977fbc818d41de61285d1da0521991a"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaf977fbc818d41de61285d1da0521991a">pcl::PF_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim, float P1, float P2)</td></tr>
<tr class="memdesc:gaf977fbc818d41de61285d1da0521991a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the PF norm of the vector between two points.  <a href="group__common.html#gaf977fbc818d41de61285d1da0521991a">More...</a><br /></td></tr>
<tr class="separator:gaf977fbc818d41de61285d1da0521991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df86a6dafef9778fb8df865ad54e28f"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga4df86a6dafef9778fb8df865ad54e28f"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga4df86a6dafef9778fb8df865ad54e28f">pcl::K_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim, float P1, float P2)</td></tr>
<tr class="memdesc:ga4df86a6dafef9778fb8df865ad54e28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the K norm of the vector between two points.  <a href="group__common.html#ga4df86a6dafef9778fb8df865ad54e28f">More...</a><br /></td></tr>
<tr class="separator:ga4df86a6dafef9778fb8df865ad54e28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga186a26b9face0cfb0fea3d6eb37f909b"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga186a26b9face0cfb0fea3d6eb37f909b"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga186a26b9face0cfb0fea3d6eb37f909b">pcl::KL_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga186a26b9face0cfb0fea3d6eb37f909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the KL between two discrete probability density functions.  <a href="group__common.html#ga186a26b9face0cfb0fea3d6eb37f909b">More...</a><br /></td></tr>
<tr class="separator:ga186a26b9face0cfb0fea3d6eb37f909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86297c76ef1756ff1db90d8e39c14fa3"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT &gt; </td></tr>
<tr class="memitem:ga86297c76ef1756ff1db90d8e39c14fa3"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga86297c76ef1756ff1db90d8e39c14fa3">pcl::HIK_Norm</a> (FloatVectorT A, FloatVectorT <a class="el" href="group__common.html#gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47">B</a>, int dim)</td></tr>
<tr class="memdesc:ga86297c76ef1756ff1db90d8e39c14fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the HIK norm of the vector between two points.  <a href="group__common.html#ga86297c76ef1756ff1db90d8e39c14fa3">More...</a><br /></td></tr>
<tr class="separator:ga86297c76ef1756ff1db90d8e39c14fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d532f7f2b4d7bba78d13701d3a33d8"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga52d532f7f2b4d7bba78d13701d3a33d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga52d532f7f2b4d7bba78d13701d3a33d8">pcl::transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga52d532f7f2b4d7bba78d13701d3a33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform.  <a href="group__common.html#ga52d532f7f2b4d7bba78d13701d3a33d8">More...</a><br /></td></tr>
<tr class="separator:ga52d532f7f2b4d7bba78d13701d3a33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938b05611e2f2cfa64839852b4d69df8"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga938b05611e2f2cfa64839852b4d69df8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga938b05611e2f2cfa64839852b4d69df8">pcl::transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga938b05611e2f2cfa64839852b4d69df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform.  <a href="group__common.html#ga938b05611e2f2cfa64839852b4d69df8">More...</a><br /></td></tr>
<tr class="separator:ga938b05611e2f2cfa64839852b4d69df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9afb23505913d26d9a1f06242d8eefa"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaa9afb23505913d26d9a1f06242d8eefa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaa9afb23505913d26d9a1f06242d8eefa">pcl::transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:gaa9afb23505913d26d9a1f06242d8eefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform.  <a href="group__common.html#gaa9afb23505913d26d9a1f06242d8eefa">More...</a><br /></td></tr>
<tr class="separator:gaa9afb23505913d26d9a1f06242d8eefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac841d05d13c925f3a3a8090d9d7ff24d"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gac841d05d13c925f3a3a8090d9d7ff24d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gac841d05d13c925f3a3a8090d9d7ff24d">pcl::transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:gac841d05d13c925f3a3a8090d9d7ff24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform defined by a 4x4 matrix.  <a href="group__common.html#gac841d05d13c925f3a3a8090d9d7ff24d">More...</a><br /></td></tr>
<tr class="separator:gac841d05d13c925f3a3a8090d9d7ff24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69421534f84d8c43314da4753e01b825"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga69421534f84d8c43314da4753e01b825"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga69421534f84d8c43314da4753e01b825">pcl::transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga69421534f84d8c43314da4753e01b825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform defined by a 4x4 matrix.  <a href="group__common.html#ga69421534f84d8c43314da4753e01b825">More...</a><br /></td></tr>
<tr class="separator:ga69421534f84d8c43314da4753e01b825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033e051c786ec84f52598ab711a74a4e"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga033e051c786ec84f52598ab711a74a4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga033e051c786ec84f52598ab711a74a4e">pcl::transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga033e051c786ec84f52598ab711a74a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform defined by a 4x4 matrix.  <a href="group__common.html#ga033e051c786ec84f52598ab711a74a4e">More...</a><br /></td></tr>
<tr class="separator:ga033e051c786ec84f52598ab711a74a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga01dcf9e24dec3109a0c8a8b8f2e24bcc">pcl::transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="group__common.html#ga01dcf9e24dec3109a0c8a8b8f2e24bcc">More...</a><br /></td></tr>
<tr class="separator:ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8602e00dcd5398692bc0582db76e1ef3"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga8602e00dcd5398692bc0582db76e1ef3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga8602e00dcd5398692bc0582db76e1ef3">pcl::transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga8602e00dcd5398692bc0582db76e1ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="group__common.html#ga8602e00dcd5398692bc0582db76e1ef3">More...</a><br /></td></tr>
<tr class="separator:ga8602e00dcd5398692bc0582db76e1ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a78021ef33dad9e3d44e6275768760b"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga3a78021ef33dad9e3d44e6275768760b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga3a78021ef33dad9e3d44e6275768760b">pcl::transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;indices, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga3a78021ef33dad9e3d44e6275768760b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="group__common.html#ga3a78021ef33dad9e3d44e6275768760b">More...</a><br /></td></tr>
<tr class="separator:ga3a78021ef33dad9e3d44e6275768760b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff524851ffbcbefdbef2277134382906"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:gaff524851ffbcbefdbef2277134382906"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#gaff524851ffbcbefdbef2277134382906">pcl::transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;offset, const Eigen::Quaternion&lt; Scalar &gt; &amp;rotation, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:gaff524851ffbcbefdbef2277134382906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rigid transform defined by a 3D offset and a quaternion.  <a href="group__common.html#gaff524851ffbcbefdbef2277134382906">More...</a><br /></td></tr>
<tr class="separator:gaff524851ffbcbefdbef2277134382906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d67c0cd4ebb26d770c338d93884974a"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga1d67c0cd4ebb26d770c338d93884974a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga1d67c0cd4ebb26d770c338d93884974a">pcl::transformPointCloudWithNormals</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;cloud_out, const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;offset, const Eigen::Quaternion&lt; Scalar &gt; &amp;rotation, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:ga1d67c0cd4ebb26d770c338d93884974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform.  <a href="group__common.html#ga1d67c0cd4ebb26d770c338d93884974a">More...</a><br /></td></tr>
<tr class="separator:ga1d67c0cd4ebb26d770c338d93884974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70f429594d4d23700cf97875eef3e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#gaf70f429594d4d23700cf97875eef3e73">pcl::transformPointCloud</a> (const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y.html">pcl::PointXY</a> &gt; &amp;cloud_in, <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y.html">pcl::PointXY</a> &gt; &amp;cloud_out, const Eigen::Affine2f &amp;transform, bool copy_all_fields=true)</td></tr>
<tr class="memdesc:gaf70f429594d4d23700cf97875eef3e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform on a pointcloud having points of type <a class="el" href="structpcl_1_1_point_x_y.html" title="A 2D point structure representing Euclidean xy coordinates.">PointXY</a>.  <a href="group__common.html#gaf70f429594d4d23700cf97875eef3e73">More...</a><br /></td></tr>
<tr class="separator:gaf70f429594d4d23700cf97875eef3e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bd2c5ea1258af3a45483dd1341aa429"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga1bd2c5ea1258af3a45483dd1341aa429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga1bd2c5ea1258af3a45483dd1341aa429">pcl::transformPoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform)</td></tr>
<tr class="memdesc:ga1bd2c5ea1258af3a45483dd1341aa429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point with members x,y,z.  <a href="group__common.html#ga1bd2c5ea1258af3a45483dd1341aa429">More...</a><br /></td></tr>
<tr class="separator:ga1bd2c5ea1258af3a45483dd1341aa429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eddef43d5bd5211fcbd774c87962314"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr>
<tr class="memitem:ga6eddef43d5bd5211fcbd774c87962314"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common.html#ga6eddef43d5bd5211fcbd774c87962314">pcl::transformPointWithNormal</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;point, const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;transform)</td></tr>
<tr class="memdesc:ga6eddef43d5bd5211fcbd774c87962314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point with members x,y,z,normal_x,normal_y,normal_z.  <a href="group__common.html#ga6eddef43d5bd5211fcbd774c87962314">More...</a><br /></td></tr>
<tr class="separator:ga6eddef43d5bd5211fcbd774c87962314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9683d853583c45c7bc4da676bc46ec7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common.html#ga9683d853583c45c7bc4da676bc46ec7d">pcl::isBetterCorrespondence</a> (const <a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a> &amp;pc1, const <a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a> &amp;pc2)</td></tr>
<tr class="memdesc:ga9683d853583c45c7bc4da676bc46ec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> to enable us to sort a vector of PointCorrespondences according to their scores using std::sort (begin(), end(), isBetterCorrespondence);.  <a href="group__common.html#ga9683d853583c45c7bc4da676bc46ec7d">More...</a><br /></td></tr>
<tr class="separator:ga9683d853583c45c7bc4da676bc46ec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gafd6ef917f66c9c9b3cb888aea5013b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd6ef917f66c9c9b3cb888aea5013b53">&#9670;&nbsp;</a></span>PCL_FALLTHROUGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCL_FALLTHROUGH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pcl__macros_8h.html">pcl/pcl_macros.h</a>&gt;</code></p>

<p>Macro to add a no-op or a fallthrough attribute based on compiler feature. </p>

<p class="definition">Definition at line <a class="el" href="pcl__macros_8h_source.html#l00437">437</a> of file <a class="el" href="pcl__macros_8h_source.html">pcl_macros.h</a>.</p>

</div>
</div>
<a id="ga35846236568f16ca7fa07d958966e12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35846236568f16ca7fa07d958966e12c">&#9670;&nbsp;</a></span>PCL_MAKE_ALIGNED_OPERATOR_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCL_MAKE_ALIGNED_OPERATOR_NEW</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="memory_8h.html">pcl/memory.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  EIGEN_MAKE_ALIGNED_OPERATOR_NEW \</div>
<div class="line">  using _custom_allocator_type_trait = void;</div>
</div><!-- fragment -->
<p>Macro to signal a class requires a custom allocator. </p>
<p>It's an implementation detail to have <a class="el" href="structpcl_1_1has__custom__allocator.html" title="Tests at compile time if type T has a custom allocator.">pcl::has_custom_allocator</a> work, a thin wrapper over <a class="el" href="namespace_eigen.html">Eigen</a>'s own macro</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structpcl_1_1has__custom__allocator.html" title="Tests at compile time if type T has a custom allocator.">pcl::has_custom_allocator</a>, <a class="el" href="namespacepcl.html#abf0472aa62fb36ea477ef66c191c8626" title="Returns a pcl::shared_ptr compliant with type T&#39;s allocation policy.">pcl::make_shared</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8h_source.html#l00063">63</a> of file <a class="el" href="memory_8h_source.html">memory.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gafb2b6757a09f69abeb6795cc0956acbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2b6757a09f69abeb6795cc0956acbf">&#9670;&nbsp;</a></span>BorderTraits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__common.html#gafb2b6757a09f69abeb6795cc0956acbf">pcl::BorderTraits</a> = typedef std::bitset&lt;32&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2point__types_8h.html">pcl/point_types.h</a>&gt;</code></p>

<p>Data type to store extended information about a transition from foreground to backgroundSpecification of the fields for <a class="el" href="structpcl_1_1_border_description.html#a48b78318ec7151ebca3d61a47891470c">BorderDescription::traits</a>. </p>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2point__types_8h_source.html#l00307">307</a> of file <a class="el" href="common_2include_2pcl_2point__types_8h_source.html">point_types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7b4e0dcfd710e4c96737e6012b318e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b4e0dcfd710e4c96737e6012b318e8b">&#9670;&nbsp;</a></span>BorderTrait</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__common.html#ga7b4e0dcfd710e4c96737e6012b318e8b">pcl::BorderTrait</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2point__types_8h.html">pcl/point_types.h</a>&gt;</code></p>

<p>Specification of the fields for <a class="el" href="structpcl_1_1_border_description.html#a48b78318ec7151ebca3d61a47891470c">BorderDescription::traits</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8baba2ab46c88349350939f52bbd63cde63"></a>BORDER_TRAIT__OBSTACLE_BORDER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8babbe3c6413874052b1bd961efd024e707"></a>BORDER_TRAIT__SHADOW_BORDER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8baed1fff632898caa19ba9c1b15e639c6e"></a>BORDER_TRAIT__VEIL_POINT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8bac33023b67fa7bef437316f060a45680a"></a>BORDER_TRAIT__SHADOW_BORDER_TOP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba02629b93f54ba6f5df84c201841a6885"></a>BORDER_TRAIT__SHADOW_BORDER_RIGHT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba930363a872a79a7d81d6e4205855776c"></a>BORDER_TRAIT__SHADOW_BORDER_BOTTOM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba68f048247d59b845f64a0c2f98e49200"></a>BORDER_TRAIT__SHADOW_BORDER_LEFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba0126deec3b7ff7353d146e637f5079b0"></a>BORDER_TRAIT__OBSTACLE_BORDER_TOP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba95274e6ae483a678bfff02bee92a199f"></a>BORDER_TRAIT__OBSTACLE_BORDER_RIGHT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba9a16989fdc97f0d09f1602922ff5b915"></a>BORDER_TRAIT__OBSTACLE_BORDER_BOTTOM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba639881dfaa920ff16178ccd10032596c"></a>BORDER_TRAIT__OBSTACLE_BORDER_LEFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba15f4b2984e8c57fd9e343d4ef7ecfbf5"></a>BORDER_TRAIT__VEIL_POINT_TOP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba0c79af62cb33c6b991a5560dcae502fe"></a>BORDER_TRAIT__VEIL_POINT_RIGHT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8ba58422e9652213c3b66933e6488e6934f"></a>BORDER_TRAIT__VEIL_POINT_BOTTOM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7b4e0dcfd710e4c96737e6012b318e8bab835d36d98c678431e97796376690219"></a>BORDER_TRAIT__VEIL_POINT_LEFT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2point__types_8h_source.html#l00312">312</a> of file <a class="el" href="common_2include_2pcl_2point__types_8h_source.html">point_types.h</a>.</p>

</div>
</div>
<a id="ga9d37f00989a9de11b48deb263649463c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d37f00989a9de11b48deb263649463c">&#9670;&nbsp;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__common.html#ga9d37f00989a9de11b48deb263649463c">pcl::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="norms_8h.html">pcl/common/norms.h</a>&gt;</code></p>

<p>Enum that defines all the types of norms available. </p>
<dl class="section note"><dt>Note</dt><dd>Any new norm type should have its own enum value and its own case in the selectNorm () method </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463cac3661be4b6e0d59a4c7b59a788cfc072"></a>L1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca98099ccc2b42084990c7a6caac1d03f1"></a>L2_SQR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca784d9a41bb0a8d74c4bbb384b5186c44"></a>L2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca731833ab377b1fbe2ea5968c44a1664f"></a>LINF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463cae072ec2ac425bed6c2f5a0781f0bf24f"></a>JM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463caaf61907b932e6f69308db08e3fa4fe47"></a>B&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca4da495e4c1d4f4415a13df5a1d55c545"></a>SUBLINEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463cad3f14cd5f1b7951b16422d8372b40177"></a>CS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca873d59723678e9e5d0a4c82d95c0e10e"></a>DIV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca5bf10e0499f79b70241e2eb83d0bcec3"></a>PF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca5c1d5fa96c1a1d9ee8a3d65459576e1f"></a>K&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca8bf338ed604013b750528812f883f95b"></a>KL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9d37f00989a9de11b48deb263649463ca2ab2951d1cd80c4e5374046b5d670527"></a>HIK&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="norms_8h_source.html#l00054">54</a> of file <a class="el" href="norms_8h_source.html">norms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0eb2818b6fa817f3ada41296793283a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eb2818b6fa817f3ada41296793283a1">&#9670;&nbsp;</a></span>B_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::B_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the B norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00140">140</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga1a9e18520c49be76f2a28834e2da8a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a9e18520c49be76f2a28834e2da8a56">&#9670;&nbsp;</a></span>calculatePolygonArea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::calculatePolygonArea </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Calculate the area of a polygon given a point cloud that defines the polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>point cloud that contains those vertices that comprises the polygon. <a class="el" href="structpcl_1_1_vertices.html" title="Describes a set of vertices in a polygon mesh, by basically storing an array of indices.">Vertices</a> are stored in counterclockwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the polygon area </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00414">414</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="gadfd1abc9deae9bb71dea8e6c1fd24af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd1abc9deae9bb71dea8e6c1fd24af9">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the 3D (X-Y-Z) centroid of a set of points using their indices and return it as a 3D vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the point cloud indices that need to be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the output centroid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the centroid. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if return value is 0, the centroid is not changed, thus not valid. The last component of the vector is set to 1, this allows to transform the centroid vector with 4x4 matrices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00137">137</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>.</p>

</div>
</div>
<a id="ga057c72764dfcd1276f7fe19bbfb380a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga057c72764dfcd1276f7fe19bbfb380a7">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the 3D (X-Y-Z) centroid of a set of points using their indices and return it as a 3D vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the point cloud indices that need to be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the output centroid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the centroid. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if return value is 0, the centroid is not changed, thus not valid. The last component of the vector is set to 1, this allows to transform the centroid vector with 4x4 matrices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00183">183</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00057">pcl::compute3DCentroid()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="ga26f5d53ac5362b04a5c8ed68c4c39038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26f5d53ac5362b04a5c8ed68c4c39038">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the 3D (X-Y-Z) centroid of a set of points and return it as a 3D vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the output centroid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the centroid. In case of dense point clouds, this is the same as the size of input cloud. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if return value is 0, the centroid is not changed, thus not valid. The last component of the vector is set to 1, this allows to transform the centroid vector with 4x4 matrices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00089">89</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00446">pcl::PointCloud&lt; PointT &gt;::empty()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>.</p>

</div>
</div>
<a id="gaf5729fae15603888b49743b118025290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5729fae15603888b49743b118025290">&#9670;&nbsp;</a></span>compute3DCentroid() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::compute3DCentroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the 3D (X-Y-Z) centroid of a set of points and return it as a 3D vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_iterator</td><td>an iterator over the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the output centroid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the centroid. In case of dense point clouds, this is the same as the size of input cloud. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if return value is 0, the centroid is not changed, thus not valid. The last component of the vector is set to 1, this allows to transform the centroid vector with 4x4 matrices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00057">57</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>, and <a class="el" href="cloud__iterator_8hpp_source.html#l00547">pcl::ConstCloudIterator&lt; PointT &gt;::isValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ia__fpcs_8hpp_source.html#l00584">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, pcl::Normal, float &gt;::bruteForceCorrespondences()</a>, <a class="el" href="label__tree_8h_source.html#l00605">pcl::gpu::people::buildTree()</a>, <a class="el" href="convex__hull_8hpp_source.html#l00057">pcl::ConvexHull&lt; PointInT &gt;::calculateInputDimension()</a>, <a class="el" href="centroid_8hpp_source.html#l00183">pcl::compute3DCentroid()</a>, <a class="el" href="mls_8hpp_source.html#l00692">pcl::MLSResult::computeMLSSurface()</a>, <a class="el" href="moment__invariants_8hpp_source.html#l00049">pcl::MomentInvariantsEstimation&lt; PointInT, PointOutT &gt;::computePointMomentInvariants()</a>, <a class="el" href="transformation__estimation__2_d_8hpp_source.html#l00125">pcl::registration::TransformationEstimation2D&lt; PointSource, PointTarget, Scalar &gt;::estimateRigidTransformation()</a>, <a class="el" href="transformation__estimation__3point_8hpp_source.html#l00135">pcl::registration::TransformationEstimation3Point&lt; PointSource, PointTarget, Scalar &gt;::estimateRigidTransformation()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00796">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::linkMatchWithBase()</a>, <a class="el" href="sac__model__line_8hpp_source.html#l00203">pcl::SampleConsensusModelLine&lt; PointT &gt;::optimizeModelCoefficients()</a>, <a class="el" href="concave__hull_8hpp_source.html#l00119">pcl::ConcaveHull&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="convex__hull_8hpp_source.html#l00076">pcl::ConvexHull&lt; PointInT &gt;::performReconstruction2D()</a>, <a class="el" href="esf_8hpp_source.html#l00481">pcl::ESFEstimation&lt; PointInT, PointOutT &gt;::scale_points_unit_sphere()</a>, and <a class="el" href="label__segment_8h_source.html#l00331">pcl::gpu::people::label_skeleton::sortIndicesToBlob2()</a>.</p>

</div>
</div>
<a id="ga9e10574ff42edc90e7dd583a36e94ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e10574ff42edc90e7dd583a36e94ce6">&#9670;&nbsp;</a></span>computeCentroid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pcl::computeCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOutT &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the centroid of a set of points and return it as a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>point cloud indices that need to be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>This is an overloaded function provided for convenience. See the documentation for <a class="el" href="group__common.html#ga24ba1c9605f3bb1e3063e30fa04857c2" title="Compute the centroid of a set of points and return it as a point.">computeCentroid()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01206">1206</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>.</p>

</div>
</div>
<a id="ga24ba1c9605f3bb1e3063e30fa04857c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24ba1c9605f3bb1e3063e30fa04857c2">&#9670;&nbsp;</a></span>computeCentroid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pcl::computeCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOutT &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the centroid of a set of points and return it as a point. </p>
<p>Implementation leverages <a class="el" href="classpcl_1_1_centroid_point.html">CentroidPoint</a> class and therefore behaves differently from <a class="el" href="group__common.html#gaf5729fae15603888b49743b118025290">compute3DCentroid()</a> and <a class="el" href="group__common.html#ga4d047d6f7b50a2d81306cc59ac927179">computeNDCentroid()</a>. See <a class="el" href="classpcl_1_1_centroid_point.html">CentroidPoint</a> documentation for explanation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>output centroid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the centroid (will be the same as the size of the cloud if it is dense)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If return value is <code>0</code>, then the centroid is not changed, thus is not valid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01187">1187</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>.</p>

</div>
</div>
<a id="ga0767151bef658b88e1d018e3edf1769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0767151bef658b88e1d018e3edf1769e">&#9670;&nbsp;</a></span>computeCentroidAndOBB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCentroidAndOBB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obb_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obb_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obb_rotational_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute centroid, OBB (Oriented Bounding Box), <a class="el" href="classpcl_1_1_p_c_a.html" title="Principal Component analysis (PCA) class.">PCA</a> axes of a given set of points. </p>
<p>OBB is oriented like the three axes (major, middle and minor) with major_axis = obb_rotational_matrix.col(0) middle_axis = obb_rotational_matrix.col(1) minor_axis = obb_rotational_matrix.col(2) one way to visualize OBB when Scalar is float: Eigen::Vector3f position(obb_position(0), obb_position(1), obb_position(2)); Eigen::Quaternionf quat(obb_rotational_matrix); viewer-&gt;addCube(position, quat, obb_dimensions(0), obb_dimensions(1), obb_dimensions(2), .....); </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>subset of points given by their indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the centroid (mean value of the XYZ coordinates) of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obb_center</td><td>position of the center of the OBB (it is the same as centroid if the cloud is centrally symmetric) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obb_dimensions</td><td>(width, height and depth) of the OBB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obb_rotational_matrix</td><td>rotational matrix of the OBB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the output. In case of dense point clouds, this is the same as the size of the input cloud. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00796">796</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00509">pcl::computeMeanAndCovarianceMatrix()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>.</p>

</div>
</div>
<a id="ga0ef093d77f87e8a3acb288fe6b8fa397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ef093d77f87e8a3acb288fe6b8fa397">&#9670;&nbsp;</a></span>computeCentroidAndOBB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCentroidAndOBB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obb_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obb_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obb_rotational_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute centroid, OBB (Oriented Bounding Box), <a class="el" href="classpcl_1_1_p_c_a.html" title="Principal Component analysis (PCA) class.">PCA</a> axes of a given set of points. </p>
<p>OBB is oriented like the three axes (major, middle and minor) with major_axis = obb_rotational_matrix.col(0) middle_axis = obb_rotational_matrix.col(1) minor_axis = obb_rotational_matrix.col(2) one way to visualize OBB when Scalar is float: Eigen::Vector3f position(obb_position(0), obb_position(1), obb_position(2)); Eigen::Quaternionf quat(obb_rotational_matrix); viewer-&gt;addCube(position, quat, obb_dimensions(0), obb_dimensions(1), obb_dimensions(2), .....); </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the centroid (mean value of the XYZ coordinates) of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obb_center</td><td>position of the center of the OBB (it is the same as centroid if the cloud is centrally symmetric) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obb_dimensions</td><td>(width, height and depth) of the OBB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obb_rotational_matrix</td><td>rotational matrix of the OBB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the output. In case of dense point clouds, this is the same as the size of the input cloud. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00663">663</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00509">pcl::computeMeanAndCovarianceMatrix()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="ga11c9b186d04d2e8a868e058473214622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11c9b186d04d2e8a868e058473214622">&#9670;&nbsp;</a></span>computeCorrespondingEigenVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeCorrespondingEigenVector </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Matrix::Scalar &amp;&#160;</td>
          <td class="paramname"><em>eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>eigenvector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>determines the corresponding eigenvector to the given eigenvalue of the symmetric positive semi definite input matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>symmetric positive semi definite input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eigenvalue</td><td>the eigenvalue which corresponding eigenvector is to be computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvector</td><td>the corresponding eigenvector for the input eigenvalue </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00226">226</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="principal__curvatures_8hpp_source.html#l00066">pcl::PrincipalCurvaturesEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePointPrincipalCurvatures()</a>, <a class="el" href="sac__model__line_8hpp_source.html#l00203">pcl::SampleConsensusModelLine&lt; PointT &gt;::optimizeModelCoefficients()</a>, and <a class="el" href="sac__model__stick_8hpp_source.html#l00249">pcl::SampleConsensusModelStick&lt; PointT &gt;::optimizeModelCoefficients()</a>.</p>

</div>
</div>
<a id="gac36b146ec26b1ceb7be43a9ecaa010c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac36b146ec26b1ceb7be43a9ecaa010c4">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the 3x3 covariance matrix of a given set of points. </p>
<p>The result is returned as a Eigen::Matrix3f. Note: the covariance matrix is not normalized with the number of points. For a normalized covariance, please use computeCovarianceMatrixNormalized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input cloud. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if return value is 0, the covariance matrix is not changed, thus not valid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00192">192</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00446">pcl::PointCloud&lt; PointT &gt;::empty()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="covariance__sampling_8hpp_source.html#l00131">pcl::CovarianceSampling&lt; PointT, PointNT &gt;::applyFilter()</a>, <a class="el" href="moment__of__inertia__estimation_8hpp_source.html#l00129">pcl::MomentOfInertiaEstimation&lt; PointT &gt;::compute()</a>, <a class="el" href="covariance__sampling_8hpp_source.html#l00086">pcl::CovarianceSampling&lt; PointT, PointNT &gt;::computeConditionNumber()</a>, <a class="el" href="centroid_8hpp_source.html#l00358">pcl::computeCovarianceMatrix()</a>, <a class="el" href="centroid_8hpp_source.html#l00269">pcl::computeCovarianceMatrixNormalized()</a>, <a class="el" href="mls_8hpp_source.html#l00692">pcl::MLSResult::computeMLSSurface()</a>, and <a class="el" href="sac__model__line_8hpp_source.html#l00203">pcl::SampleConsensusModelLine&lt; PointT &gt;::optimizeModelCoefficients()</a>.</p>

</div>
</div>
<a id="ga2680eec49635c40687ab378bde204fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2680eec49635c40687ab378bde204fdc">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the 3x3 covariance matrix of a given set of points using their indices. </p>
<p>The result is returned as a Eigen::Matrix3f. Note: the covariance matrix is not normalized with the number of points. For a normalized covariance, please use computeCovarianceMatrixNormalized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the point cloud indices that need to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00281">281</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>.</p>

</div>
</div>
<a id="gae1be0e0d9c0edfe771edb0eca57b8650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1be0e0d9c0edfe771edb0eca57b8650">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the normalized 3x3 covariance matrix for a already demeaned point cloud. </p>
<p>Normalized means that every entry has been divided by the number of entries in indices. For small number of points, or if you want explicitly the sample-variance, scale the covariance matrix with n / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by this function. </p><dl class="section note"><dt>Note</dt><dd>This method is theoretically exact. However using float for internal calculations reduces the accuracy but increases the efficiency. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>subset of points given by their indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00446">446</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>.</p>

</div>
</div>
<a id="ga35305b1593d5417be615e940383f4ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35305b1593d5417be615e940383f4ced">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the 3x3 covariance matrix of a given set of points using their indices. </p>
<p>The result is returned as a Eigen::Matrix3f. Note: the covariance matrix is not normalized with the number of points. For a normalized covariance, please use computeCovarianceMatrixNormalized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the point cloud indices that need to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00358">358</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00192">pcl::computeCovarianceMatrix()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="gacf3ff94b2145fb22871e41e87ee495b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf3ff94b2145fb22871e41e87ee495b2">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the normalized 3x3 covariance matrix for a already demeaned point cloud. </p>
<p>Normalized means that every entry has been divided by the number of entries in indices. For small number of points, or if you want explicitly the sample-variance, scale the covariance matrix with n / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by this function. </p><dl class="section note"><dt>Note</dt><dd>This method is theoretically exact. However using float for internal calculations reduces the accuracy but increases the efficiency. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>subset of points given by their indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00500">500</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00192">pcl::computeCovarianceMatrix()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="ga5956698bec9ece7a491ad2fbbfbe6bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5956698bec9ece7a491ad2fbbfbe6bc1">&#9670;&nbsp;</a></span>computeCovarianceMatrix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the normalized 3x3 covariance matrix for a already demeaned point cloud. </p>
<p>Normalized means that every entry has been divided by the number of entries in the input point cloud. For small number of points, or if you want explicitly the sample-variance, scale the covariance matrix with n / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by this function. </p><dl class="section note"><dt>Note</dt><dd>This method is theoretically exact. However using float for internal calculations reduces the accuracy but increases the efficiency. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input cloud. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00392">392</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="gab5ea605f439a80daf6348547379bad8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ea605f439a80daf6348547379bad8e">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute normalized the 3x3 covariance matrix of a given set of points. </p>
<p>The result is returned as a Eigen::Matrix3f. Normalized means that every entry has been divided by the number of points in the point cloud. For small number of points, or if you want explicitly the sample-variance, use computeCovarianceMatrix and scale the covariance matrix with 1 / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by the computeCovarianceMatrix function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input cloud. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00269">269</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00192">pcl::computeCovarianceMatrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="label__tree_8h_source.html#l00605">pcl::gpu::people::buildTree()</a>, <a class="el" href="convex__hull_8hpp_source.html#l00057">pcl::ConvexHull&lt; PointInT &gt;::calculateInputDimension()</a>, <a class="el" href="centroid_8hpp_source.html#l00382">pcl::computeCovarianceMatrixNormalized()</a>, <a class="el" href="concave__hull_8hpp_source.html#l00119">pcl::ConcaveHull&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="convex__hull_8hpp_source.html#l00076">pcl::ConvexHull&lt; PointInT &gt;::performReconstruction2D()</a>, and <a class="el" href="label__segment_8h_source.html#l00331">pcl::gpu::people::label_skeleton::sortIndicesToBlob2()</a>.</p>

</div>
</div>
<a id="ga41c9e7cc83ff0b2619c466ac7f45e952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c9e7cc83ff0b2619c466ac7f45e952">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the normalized 3x3 covariance matrix of a given set of points using their indices. </p>
<p>The result is returned as a Eigen::Matrix3f. Normalized means that every entry has been divided by the number of entries in indices. For small number of points, or if you want explicitly the sample-variance, use computeCovarianceMatrix and scale the covariance matrix with 1 / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by the computeCovarianceMatrix function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the point cloud indices that need to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00368">368</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00192">pcl::computeCovarianceMatrix()</a>.</p>

</div>
</div>
<a id="gadfb4158efe784f3d3a765f0747b13a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb4158efe784f3d3a765f0747b13a80">&#9670;&nbsp;</a></span>computeCovarianceMatrixNormalized() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeCovarianceMatrixNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the normalized 3x3 covariance matrix of a given set of points using their indices. </p>
<p>The result is returned as a Eigen::Matrix3f. Normalized means that every entry has been divided by the number of entries in indices. For small number of points, or if you want explicitly the sample-variance, use computeCovarianceMatrix and scale the covariance matrix with 1 / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by the computeCovarianceMatrix function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the point cloud indices that need to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00382">382</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00269">pcl::computeCovarianceMatrixNormalized()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="gaf70c66f08214fb34784483627e5fc913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf70c66f08214fb34784483627e5fc913">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop. </p>
<p>Normalized means that every entry has been divided by the number of entries in indices. For small number of points, or if you want explicitly the sample-variance, scale the covariance matrix with n / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by this function. </p><dl class="section note"><dt>Note</dt><dd>This method is theoretically exact. However using float for internal calculations reduces the accuracy but increases the efficiency. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>subset of points given by their indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00581">581</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::K</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="gac4d7bf1a81f21fb97505c91957b7f033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4d7bf1a81f21fb97505c91957b7f033">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop. </p>
<p>Normalized means that every entry has been divided by the number of entries in indices. For small number of points, or if you want explicitly the sample-variance, scale the covariance matrix with n / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by this function. </p><dl class="section note"><dt>Note</dt><dd>This method is theoretically exact. However using float for internal calculations reduces the accuracy but increases the efficiency. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>subset of points given by their indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00654">654</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00509">pcl::computeMeanAndCovarianceMatrix()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="ga72dfb6e965df9752c88790e026a8ab5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72dfb6e965df9752c88790e026a8ab5f">&#9670;&nbsp;</a></span>computeMeanAndCovarianceMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pcl::computeMeanAndCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Compute the normalized 3x3 covariance matrix and the centroid of a given set of points in a single loop. </p>
<p>Normalized means that every entry has been divided by the number of valid entries in the point cloud. For small number of points, or if you want explicitly the sample-variance, scale the covariance matrix with n / (n-1), where n is the number of points used to calculate the covariance matrix and is returned by this function. </p><dl class="section note"><dt>Note</dt><dd>This method is theoretically exact. However using float for internal calculations reduces the accuracy but increases the efficiency. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covariance_matrix</td><td>the resultant 3x3 covariance matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the centroid of the set of points in the cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of valid points used to determine the covariance matrix. In case of dense point clouds, this is the same as the size of input cloud. </dd></dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00509">509</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="point__tests_8h_source.html#l00055">pcl::isFinite()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::K</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="centroid_8hpp_source.html#l00663">pcl::computeCentroidAndOBB()</a>, <a class="el" href="centroid_8hpp_source.html#l00654">pcl::computeMeanAndCovarianceMatrix()</a>, <a class="el" href="features_2include_2pcl_2features_2normal__3d_8h_source.html#l00280">pcl::NormalEstimation&lt; PointInT, PointOutT &gt;::computePointNormal()</a>, <a class="el" href="features_2include_2pcl_2features_2normal__3d_8h_source.html#l00061">pcl::computePointNormal()</a>, <a class="el" href="sac__model__registration_8h_source.html#l00233">pcl::SampleConsensusModelRegistration&lt; PointT &gt;::computeSampleDistanceThreshold()</a>, <a class="el" href="transforms_8hpp_source.html#l00495">pcl::getPrincipalTransformation()</a>, <a class="el" href="grid__projection_8hpp_source.html#l00312">pcl::GridProjection&lt; PointNT &gt;::getProjectionWithPlaneFit()</a>, <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00048">pcl::isPointIn2DPolygon()</a>, <a class="el" href="sac__model__plane_8hpp_source.html#l00312">pcl::SampleConsensusModelPlane&lt; PointT &gt;::optimizeModelCoefficients()</a>, <a class="el" href="sac__model__stick_8hpp_source.html#l00249">pcl::SampleConsensusModelStick&lt; PointT &gt;::optimizeModelCoefficients()</a>, <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00149">pcl::ExtractPolygonalPrismData&lt; PointT &gt;::segment()</a>, and <a class="el" href="organized__multi__plane__segmentation_8hpp_source.html#l00083">pcl::OrganizedMultiPlaneSegmentation&lt; PointT, PointNT, PointLT &gt;::segment()</a>.</p>

</div>
</div>
<a id="ga2f445da2542cd886856beff40c383c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f445da2542cd886856beff40c383c3c">&#9670;&nbsp;</a></span>computeMedian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto pcl::computeMedian </td>
          <td>(</td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_functor.html">Functor</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::result_of_t&lt;<a class="el" href="structpcl_1_1_functor.html">Functor</a>(decltype(*begin))&gt;

  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Compute the median of a list of values (fast). </p>
<p>If the number of values is even, take the mean of the two middle values. This function can be used like this: </p><div class="fragment"><div class="line">std::vector&lt;double&gt; vector{1.0, 25.0, 9.0, 4.0, 16.0};</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> median = <a class="code" href="group__common.html#ga2f445da2542cd886856beff40c383c3c">pcl::computeMedian</a> (vector.begin (), vector.end (), <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span>(*)(<span class="keywordtype">double</span>)<span class="keyword">&gt;</span>(std::sqrt)); <span class="comment">// = 3</span></div>
<div class="ttc" id="agroup__common_html_ga2f445da2542cd886856beff40c383c3c"><div class="ttname"><a href="group__common.html#ga2f445da2542cd886856beff40c383c3c">pcl::computeMedian</a></div><div class="ttdeci">auto computeMedian(IteratorT begin, IteratorT end, Functor f) noexcept -&gt; std::result_of_t&lt; Functor(decltype(*begin))&gt;</div><div class="ttdoc">Compute the median of a list of values (fast).</div><div class="ttdef"><b>Definition:</b> <a href="common_2include_2pcl_2common_2common_8h_source.html#l00285">common.h:285</a></div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">begin,end</td><td>Iterators that mark the beginning and end of the value range. These values will be reordered! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A lamda, function pointer, or similar that is implicitly applied to all values before median computation. In reality, it will be applied lazily (i.e. at most twice) and thus may not change the sorting order (e.g. monotonic functions like sqrt are allowed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the median </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2common_8h_source.html#l00285">285</a> of file <a class="el" href="common_2include_2pcl_2common_2common_8h_source.html">common.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlesac_8hpp_source.html#l00261">pcl::MaximumLikelihoodSampleConsensus&lt; PointT &gt;::computeMedian()</a>, <a class="el" href="common_2include_2pcl_2common_2common_8h_source.html#l00309">pcl::computeMedian()</a>, <a class="el" href="mlesac_8hpp_source.html#l00212">pcl::MaximumLikelihoodSampleConsensus&lt; PointT &gt;::computeMedianAbsoluteDeviation()</a>, and <a class="el" href="lmeds_8hpp_source.html#l00049">pcl::LeastMedianSquares&lt; PointT &gt;::computeModel()</a>.</p>

</div>
</div>
<a id="gaac394645bca960356e4d1aee5e75b92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac394645bca960356e4d1aee5e75b92d">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>General, all purpose nD centroid estimation for a set of points using their indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">indices</td><td>the point cloud indices that need to be used </td></tr>
    <tr><td class="paramname">centroid</td><td>the output centroid </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01133">1133</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

</div>
</div>
<a id="ga9654681b5a78f1e3ad5566de05e1d638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9654681b5a78f1e3ad5566de05e1d638">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>General, all purpose nD centroid estimation for a set of points using their indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">indices</td><td>the point cloud indices that need to be used </td></tr>
    <tr><td class="paramname">centroid</td><td>the output centroid </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01156">1156</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l01111">pcl::computeNDCentroid()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="ga4d047d6f7b50a2d81306cc59ac927179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d047d6f7b50a2d81306cc59ac927179">&#9670;&nbsp;</a></span>computeNDCentroid() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::computeNDCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>General, all purpose nD centroid estimation for a set of points using their indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the input point cloud </td></tr>
    <tr><td class="paramname">centroid</td><td>the output centroid </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01111">1111</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00446">pcl::PointCloud&lt; PointT &gt;::empty()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="centroid_8hpp_source.html#l01156">pcl::computeNDCentroid()</a>.</p>

</div>
</div>
<a id="ga7718075a7ad19719ffcc3fefafa9179a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7718075a7ad19719ffcc3fefafa9179a">&#9670;&nbsp;</a></span>concatenate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Concatenate two <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will concatenate IFF the non-skip fields are in the correct order and same in number. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud1</td><td>the first input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud2</td><td>the second input point cloud dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00299">299</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

<p class="reference">References <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html#a7346aad6c08fcbd799f87f9676e5e0a1">pcl::PCLPointCloud2::concatenate()</a>.</p>

</div>
</div>
<a id="ga15bd342ae8b2f7b0722c9290524e65d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15bd342ae8b2f7b0722c9290524e65d4">&#9670;&nbsp;</a></span>concatenate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Concatenate two pcl::PointCloud&lt;PointT&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud1</td><td>the first input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud2</td><td>the second input point cloud dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00281">281</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00231">pcl::PointCloud&lt; PointT &gt;::concatenate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00064">pcl::PCLPointCloud2::concatenate()</a>, <a class="el" href="_polygon_mesh_8h_source.html#l00066">pcl::PolygonMesh::concatenate()</a>, <a class="el" href="octree__disk__container_8hpp_source.html#l00511">pcl::outofcore::OutofcoreOctreeDiskContainer&lt; PointT &gt;::insertRange()</a>, <a class="el" href="_polygon_mesh_8h_source.html#l00079">pcl::PolygonMesh::operator+=()</a>, <a class="el" href="octree__base__node_8hpp_source.html#l01375">pcl::outofcore::OutofcoreOctreeBaseNode&lt; ContainerT, PointT &gt;::queryBBIncludes()</a>, <a class="el" href="octree__base__node_8hpp_source.html#l01564">pcl::outofcore::OutofcoreOctreeBaseNode&lt; ContainerT, PointT &gt;::queryBBIncludes_subsample()</a>, and <a class="el" href="octree__disk__container_8hpp_source.html#l00576">pcl::outofcore::OutofcoreOctreeDiskContainer&lt; PointT &gt;::read()</a>.</p>

</div>
</div>
<a id="gaf76125ee3193f65ae4a331130c13d4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf76125ee3193f65ae4a331130c13d4d0">&#9670;&nbsp;</a></span>concatenate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Concatenate two <a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh1</td><td>the first input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh2</td><td>the second input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mesh_out</td><td>the resultant output mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00314">314</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

<p class="reference">References <a class="el" href="_polygon_mesh_8h_source.html#l00030">pcl::PolygonMesh::concatenate()</a>.</p>

</div>
</div>
<a id="gac54f3a282986844fc7a804242504461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac54f3a282986844fc7a804242504461e">&#9670;&nbsp;</a></span>concatenateFields() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::concatenateFields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Concatenate two datasets representing different fields. </p>
<dl class="section note"><dt>Note</dt><dd>If the input datasets have overlapping fields (i.e., both contain the same fields), then the data in the second cloud (cloud2_in) will overwrite the data in the first (cloud1_in).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud1_in</td><td>the first input dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud2_in</td><td>the second input dataset (overwrites the fields of the first dataset for those that are shared) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the output dataset created by concatenating all the fields in the input datasets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6add803f86fd16a998dce541e9ef402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6add803f86fd16a998dce541e9ef402">&#9670;&nbsp;</a></span>concatenateFields() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointIn1T , typename PointIn2T , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::concatenateFields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointIn1T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud1_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointIn2T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud2_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Concatenate two datasets representing different fields. </p>
<dl class="section note"><dt>Note</dt><dd>If the input datasets have overlapping fields (i.e., both contain the same fields), then the data in the second cloud (cloud2_in) will overwrite the data in the first (cloud1_in).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud1_in</td><td>the first input dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud2_in</td><td>the second input dataset (overwrites the fields of the first dataset for those that are shared) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output dataset created by the concatenation of all the fields in the input datasets </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00303">303</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="gab978bf1754771246b2f140a5b52a8f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab978bf1754771246b2f140a5b52a8f8b">&#9670;&nbsp;</a></span>copyPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPoint </td>
          <td>(</td>
          <td class="paramtype">const PointInT &amp;&#160;</td>
          <td class="paramname"><em>point_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointOutT &amp;&#160;</td>
          <td class="paramname"><em>point_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/copy_point.h&gt;</code></p>

<p>Copy the fields of a source point into a target point. </p>
<p>If the source and the target point types are the same, then a complete copy is made. Otherwise only those fields that the two point types share in common are copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_in</td><td>the source point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point_out</td><td>the target point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="copy__point_8hpp_source.html#l00137">137</a> of file <a class="el" href="copy__point_8hpp_source.html">copy_point.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="conditional__removal_8hpp_source.html#l00625">pcl::ConditionalRemoval&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="filter__indices_8hpp_source.html#l00077">pcl::FilterIndices&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="mls_8hpp_source.html#l00866">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::copyMissingFields()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00188">pcl::copyPointCloud()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00122">pcl::detail::copyPointCloudMemcpy()</a>, <a class="el" href="gpu__extract__clusters_8hpp_source.html#l00058">pcl::gpu::extractEuclideanClusters()</a>, <a class="el" href="search_8h_source.html#l00158">pcl::search::Search&lt; PointT &gt;::nearestKSearchT()</a>, <a class="el" href="kdtree_2include_2pcl_2kdtree_2kdtree_8h_source.html#l00173">pcl::KdTree&lt; PointT &gt;::nearestKSearchT()</a>, <a class="el" href="correspondence__estimation_8hpp_source.html#l00135">pcl::registration::detail::pointCopyOrRef()</a>, <a class="el" href="kdtree_2include_2pcl_2kdtree_2kdtree_8h_source.html#l00263">pcl::KdTree&lt; PointT &gt;::radiusSearchT()</a>, and <a class="el" href="search_8h_source.html#l00286">pcl::search::Search&lt; PointT &gt;::radiusSearchT()</a>.</p>

</div>
</div>
<a id="ga11e4d41367cf18852d8aab9cc1e5391a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e4d41367cf18852d8aab9cc1e5391a">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Extract the indices of a given point cloud as a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of indices representing the points to be copied from <em>cloud_in</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes unique indices. </dd></dl>

</div>
</div>
<a id="ga6b2c400723fec337e2681bc86aefc18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b2c400723fec337e2681bc86aefc18a">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; Eigen::aligned_allocator&lt; <a class="el" href="namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911">index_t</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Extract the indices of a given point cloud as a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of indices representing the points to be copied from <em>cloud_in</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes unique indices. </dd></dl>

</div>
</div>
<a id="ga1c6c02fe197e0ea6ca249c46dda0e602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c6c02fe197e0ea6ca249c46dda0e602">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Copy fields and point cloud data from <em>cloud_in</em> to <em>cloud_out</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c154414777ed872edea44560502922e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c154414777ed872edea44560502922e">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT , typename IndicesVectorAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; IndicesVectorAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Extract the indices of a given point cloud as a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of indices representing the points to be copied from <em>cloud_in</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes unique indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00188">188</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="copy__point_8hpp_source.html#l00137">pcl::copyPoint()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ga67ab079e174e900e6e0b235fb88d7160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67ab079e174e900e6e0b235fb88d7160">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Extract the indices of a given point cloud as a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> structure representing the points to be copied from cloud_in </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes unique indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00217">217</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00142">pcl::copyPointCloud()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="gaa5ab28ac738a42a65f9f2033d6b33252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ab28ac738a42a65f9f2033d6b33252">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Extract the indices of a given point cloud as a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of indices representing the points to be copied from cloud_in </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes unique indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00265">265</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="copy__point_8hpp_source.html#l00137">pcl::copyPoint()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00142">pcl::copyPointCloud()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="gaff182bca8d0295d727baaa1fd368c6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff182bca8d0295d727baaa1fd368c6ad">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointInT , typename PointOutT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointInT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointOutT &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Copy all the fields from a given point cloud into a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00142">142</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00122">pcl::detail::copyPointCloudMemcpy()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00446">pcl::PointCloud&lt; PointT &gt;::empty()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="hypotheses__verification_8h_source.html#l00218">pcl::HypothesisVerification&lt; ModelT, SceneT &gt;::addModels()</a>, <a class="el" href="octree__base__node_8hpp_source.html#l00499">pcl::outofcore::OutofcoreOctreeBaseNode&lt; ContainerT, PointT &gt;::addPointCloud()</a>, <a class="el" href="octree__base__node_8hpp_source.html#l00706">pcl::outofcore::OutofcoreOctreeBaseNode&lt; ContainerT, PointT &gt;::addPointCloud_and_genLOD()</a>, <a class="el" href="line__rgbd_8hpp_source.html#l00314">pcl::LineRGBD&lt; PointXYZT, PointRGBT &gt;::addTemplate()</a>, <a class="el" href="agast__2d_8h_source.html#l00484">pcl::keypoints::internal::AgastApplyNonMaxSuppresion&lt; Out &gt;::AgastApplyNonMaxSuppresion()</a>, <a class="el" href="agast__2d_8h_source.html#l00513">pcl::keypoints::internal::AgastDetector&lt; Out &gt;::AgastDetector()</a>, <a class="el" href="extract__indices_8hpp_source.html#l00079">pcl::ExtractIndices&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="fast__bilateral_8hpp_source.html#l00051">pcl::FastBilateralFilter&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="fast__bilateral__omp_8hpp_source.html#l00062">pcl::FastBilateralFilterOMP&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="filter__indices_8hpp_source.html#l00077">pcl::FilterIndices&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="median__filter_8hpp_source.html#l00046">pcl::MedianFilter&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="iccv2011_2include_2object__recognition_8h_source.html#l00138">ObjectRecognition::applyFiltersAndSegment()</a>, <a class="el" href="morphological__filter_8hpp_source.html#l00057">pcl::applyMorphologicalOperator()</a>, <a class="el" href="geometric__consistency_8hpp_source.html#l00057">pcl::GeometricConsistencyGrouping&lt; PointModelT, PointSceneT &gt;::clusterCorrespondences()</a>, <a class="el" href="hough__3d_8hpp_source.html#l00259">pcl::Hough3DGrouping&lt; PointModelT, PointSceneT, PointModelRfT, PointSceneRfT &gt;::clusterCorrespondences()</a>, <a class="el" href="pyramidal__klt_8hpp_source.html#l00364">pcl::tracking::PyramidalKLTTracker&lt; PointInT, IntensityT &gt;::computePyramids()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00208">pcl::copyPointCloud()</a>, <a class="el" href="line__rgbd_8hpp_source.html#l00221">pcl::LineRGBD&lt; PointXYZT, PointRGBT &gt;::createAndAddTemplate()</a>, <a class="el" href="harris__6d_8hpp_source.html#l00142">pcl::HarrisKeypoint6D&lt; PointInT, PointOutT, NormalT &gt;::detectKeypoints()</a>, <a class="el" href="keypoints_2include_2pcl_2keypoints_2impl_2brisk__2d_8hpp_source.html#l00069">pcl::BriskKeypoint2D&lt; PointInT, PointOutT, IntensityT &gt;::detectKeypoints()</a>, <a class="el" href="filters_2include_2pcl_2filters_2filter_8h_source.html#l00121">pcl::Filter&lt; PointT &gt;::filter()</a>, <a class="el" href="occlusion__reasoning_8hpp_source.html#l00067">pcl::occlusion_reasoning::ZBuffering&lt; ModelT, SceneT &gt;::filter()</a>, <a class="el" href="occlusion__reasoning_8h_source.html#l00072">pcl::occlusion_reasoning::filter()</a>, <a class="el" href="supervoxel__clustering_8hpp_source.html#l00576">pcl::SupervoxelClustering&lt; PointT &gt;::getLabeledCloud()</a>, <a class="el" href="supervoxel__clustering_8hpp_source.html#l00554">pcl::SupervoxelClustering&lt; PointT &gt;::getLabeledVoxelCloud()</a>, <a class="el" href="occlusion__reasoning_8h_source.html#l00163">pcl::occlusion_reasoning::getOccludedCloud()</a>, <a class="el" href="segment__differences_8hpp_source.html#l00050">pcl::getPointCloudDifference()</a>, <a class="el" href="supervoxel__clustering_8hpp_source.html#l00545">pcl::SupervoxelClustering&lt; PointT &gt;::getVoxelCentroidCloud()</a>, <a class="el" href="concave__hull_8hpp_source.html#l00119">pcl::ConcaveHull&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="octree__base__node_8hpp_source.html#l01375">pcl::outofcore::OutofcoreOctreeBaseNode&lt; ContainerT, PointT &gt;::queryBBIncludes()</a>, and <a class="el" href="ply__io_8h_source.html#l00862">pcl::io::savePLYFile()</a>.</p>

</div>
</div>
<a id="ga63889e8e562908917ec218b86ef826b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63889e8e562908917ec218b86ef826b4">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename IndicesVectorAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a61689ac607f746f728bb76bc14fe8ca4">IndicesAllocator</a>&lt; IndicesVectorAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Extract the indices of a given point cloud as a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of indices representing the points to be copied from <em>cloud_in</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes unique indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00160">160</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00885">pcl::PointCloud&lt; PointT &gt;::clear()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00445">pcl::PointCloud&lt; PointT &gt;::reserve()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00675">pcl::PointCloud&lt; PointT &gt;::transient_push_back()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ga44ece0c2faffdb26cd75417200454577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44ece0c2faffdb26cd75417200454577">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Extract the indices of a given point cloud as a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the <a class="el" href="structpcl_1_1_point_indices.html">PointIndices</a> structure representing the points to be copied from cloud_in </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes unique indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00208">208</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00142">pcl::copyPointCloud()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="gaafe5bf1194ffaad83a2fc04cde6b20e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafe5bf1194ffaad83a2fc04cde6b20e4">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Extract the indices of a given point cloud as a new point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of indices representing the points to be copied from <em>cloud_in</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes unique indices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00226">226</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00885">pcl::PointCloud&lt; PointT &gt;::clear()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00445">pcl::PointCloud&lt; PointT &gt;::reserve()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00675">pcl::PointCloud&lt; PointT &gt;::transient_push_back()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ga4d12b955edd61947ed984e46d65b0046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d12b955edd61947ed984e46d65b0046">&#9670;&nbsp;</a></span>copyPointCloud() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::copyPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a223710941333ffcbfd147e4f4c9a1485">pcl::InterpolationType</a>&#160;</td>
          <td class="paramname"><em>border_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Copy a point cloud inside a larger one interpolating borders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud dataset </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">top</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bottom</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">left</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">right</td><td>Position of cloud_in inside cloud_out is given by <em>top</em>, <em>left</em>, <em>bottom</em> <em>right</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">border_type</td><td>the interpolating method (pcl::BORDER_XXX) BORDER_REPLICATE: aaaaaa|abcdefgh|hhhhhhh BORDER_REFLECT: fedcba|abcdefgh|hgfedcb BORDER_REFLECT_101: gfedcb|abcdefgh|gfedcba BORDER_WRAP: cdefgh|abcdefgh|abcdefg BORDER_CONSTANT: iiiiii|abcdefgh|iiiiiii with some specified 'i' BORDER_TRANSPARENT: mnopqr|abcdefgh|tuvwxyz where m-r and t-z are original values of cloud_out </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpcl_1_1_bad_argument_exception.html" title="An exception that is thrown when the arguments number or type is wrong/unhandled.">pcl::BadArgumentException</a></td><td>if any of top, bottom, left or right is negative. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00337">337</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00256">pcl::BORDER_CONSTANT</a>, <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00258">pcl::BORDER_TRANSPARENT</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00447">pcl::PointCloud&lt; PointT &gt;::data()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="namespacepcl.html#a4ffcf78b18f7bf6e262782ff7c8050b4">pcl::interpolatePointIndex()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ga7e43f6ae7f0607bfdedaea512c510ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e43f6ae7f0607bfdedaea512c510ff8">&#9670;&nbsp;</a></span>CS_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::CS_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the CS norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00169">169</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga78fe9974ed54012d6cf057afda5d3350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78fe9974ed54012d6cf057afda5d3350">&#9670;&nbsp;</a></span>deg2rad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::deg2rad </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="angles_8h.html">pcl/common/angles.h</a>&gt;</code></p>

<p>Convert an angle from degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the input angle (in degrees) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="angles_8hpp_source.html#l00079">79</a> of file <a class="el" href="angles_8hpp_source.html">angles.hpp</a>.</p>

</div>
</div>
<a id="ga25b0ce695e2a10abb0130bcb5cf90eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b0ce695e2a10abb0130bcb5cf90eb6">&#9670;&nbsp;</a></span>deg2rad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::deg2rad </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="angles_8h.html">pcl/common/angles.h</a>&gt;</code></p>

<p>Convert an angle from degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the input angle (in degrees) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="angles_8hpp_source.html#l00067">67</a> of file <a class="el" href="angles_8hpp_source.html">angles.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l00109">pcl::RangeImage::createFromPointCloud()</a>, <a class="el" href="range__image_8hpp_source.html#l00159">pcl::RangeImage::createFromPointCloudWithKnownSize()</a>, <a class="el" href="range__image_8hpp_source.html#l00891">pcl::RangeImage::getImpactAngleBasedOnLocalNormal()</a>, <a class="el" href="3dsc_8hpp_source.html#l00053">pcl::ShapeContext3DEstimation&lt; PointInT, PointNT, PointOutT &gt;::initCompute()</a>, and <a class="el" href="usc_8hpp_source.html#l00054">pcl::UniqueShapeContext&lt; PointInT, PointOutT, PointRFT &gt;::initCompute()</a>.</p>

</div>
</div>
<a id="gae19c71709093628e61037337056b99fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae19c71709093628e61037337056b99fa">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output XYZ0 dimensions of <em>cloud_in</em> as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix (4 rows, N pts columns) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01054">1054</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="ga7953d5001218e840a3a10a2c8649461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7953d5001218e840a3a10a2c8649461e">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Subtract a centroid from a point cloud and return the de-meaned representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00966">966</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

</div>
</div>
<a id="ga743fe66a6743b81611c70acd59c0d680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga743fe66a6743b81611c70acd59c0d680">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output XYZ0 dimensions of <em>cloud_in</em> as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix (4 rows, N pts columns) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01077">1077</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

</div>
</div>
<a id="ga776aeabe20fa3eb55e6283fea0476f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga776aeabe20fa3eb55e6283fea0476f6a">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Subtract a centroid from a point cloud and return the de-meaned representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the centroid of the point cloud </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00983">983</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ga539a53e4b17ad9ed2f00ae8b2e464221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga539a53e4b17ad9ed2f00ae8b2e464221">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output XYZ0 dimensions of <em>cloud_in</em> as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix (4 rows, N pts columns) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01101">1101</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00933">pcl::demeanPointCloud()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="ga516ff833c2593ba6e53d369b25989f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga516ff833c2593ba6e53d369b25989f81">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Subtract a centroid from a point cloud and return the de-meaned representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>the centroid of the point cloud </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01013">1013</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00933">pcl::demeanPointCloud()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="ga553c2ce698f074fe38d74f01b57a3343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga553c2ce698f074fe38d74f01b57a3343">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Subtract a centroid from a point cloud and return the de-meaned representation as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_iterator</td><td>an iterator over the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output XYZ0 dimensions of <em>cloud_in</em> as an <a class="el" href="namespace_eigen.html">Eigen</a> matrix (4 rows, N pts columns) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npts</td><td>the number of samples guaranteed to be left in the input cloud, accessible by the iterator. If not given, it will be calculated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l01023">1023</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="cloud__iterator_8hpp_source.html#l00547">pcl::ConstCloudIterator&lt; PointT &gt;::isValid()</a>, and <a class="el" href="cloud__iterator_8hpp_source.html#l00540">pcl::ConstCloudIterator&lt; PointT &gt;::reset()</a>.</p>

</div>
</div>
<a id="ga7f82fbd4e17063ab86287a2543bdea88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f82fbd4e17063ab86287a2543bdea88">&#9670;&nbsp;</a></span>demeanPointCloud() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::demeanPointCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_const_cloud_iterator.html">ConstCloudIterator</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="centroid_8h.html">pcl/common/centroid.h</a>&gt;</code></p>

<p>Subtract a centroid from a point cloud and return the de-meaned representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_iterator</td><td>an iterator over the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centroid</td><td>the centroid of the point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npts</td><td>the number of samples guaranteed to be left in the input cloud, accessible by the iterator. If not given, it will be calculated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="centroid_8hpp_source.html#l00933">933</a> of file <a class="el" href="centroid_8hpp_source.html">centroid.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="cloud__iterator_8hpp_source.html#l00547">pcl::ConstCloudIterator&lt; PointT &gt;::isValid()</a>, <a class="el" href="cloud__iterator_8hpp_source.html#l00540">pcl::ConstCloudIterator&lt; PointT &gt;::reset()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="centroid_8hpp_source.html#l01013">pcl::demeanPointCloud()</a>, <a class="el" href="transformation__estimation__2_d_8hpp_source.html#l00125">pcl::registration::TransformationEstimation2D&lt; PointSource, PointTarget, Scalar &gt;::estimateRigidTransformation()</a>, <a class="el" href="transformation__estimation__3point_8hpp_source.html#l00135">pcl::registration::TransformationEstimation3Point&lt; PointSource, PointTarget, Scalar &gt;::estimateRigidTransformation()</a>, <a class="el" href="concave__hull_8hpp_source.html#l00119">pcl::ConcaveHull&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="esf_8hpp_source.html#l00481">pcl::ESFEstimation&lt; PointInT, PointOutT &gt;::scale_points_unit_sphere()</a>, and <a class="el" href="our__cvfh_8hpp_source.html#l00200">pcl::OURCVFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::sgurf()</a>.</p>

</div>
</div>
<a id="ga44d0048ba1efd11359011eb47f6c92fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d0048ba1efd11359011eb47f6c92fa">&#9670;&nbsp;</a></span>determinant3x3Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Scalar pcl::determinant3x3Matrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Calculate the determinant of a 3x3 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>determinant of the matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00502">502</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

</div>
</div>
<a id="gae8b5c722d30c22652327a1481528224e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8b5c722d30c22652327a1481528224e">&#9670;&nbsp;</a></span>Div_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::Div_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the div norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00183">183</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga4fdd69805d49c416393c604f9f209113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fdd69805d49c416393c604f9f209113">&#9670;&nbsp;</a></span>eigen22() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::eigen22 </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>determine the smallest eigenvalue and its corresponding eigenvector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>input matrix that needs to be symmetric and positive semi definite </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvectors</td><td>the corresponding eigenvector to the smallest eigenvalue of the input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvalues</td><td>the smallest eigenvalue of the input matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00172">172</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

</div>
</div>
<a id="ga72970b7435480c0c1827c8e74bc1d605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72970b7435480c0c1827c8e74bc1d605">&#9670;&nbsp;</a></span>eigen22() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::eigen22 </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Matrix::Scalar &amp;&#160;</td>
          <td class="paramname"><em>eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>eigenvector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>determine the smallest eigenvalue and its corresponding eigenvector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>input matrix that needs to be symmetric and positive semi definite </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvalue</td><td>the smallest eigenvalue of the input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvector</td><td>the corresponding eigenvector to the smallest eigenvalue of the input matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00133">133</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="polygon__operations_8hpp_source.html#l00080">pcl::approximatePolygon2D()</a>.</p>

</div>
</div>
<a id="ga76d78c3e9c0f3f58a0806499ae6ed97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d78c3e9c0f3f58a0806499ae6ed97b">&#9670;&nbsp;</a></span>eigen33() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::eigen33 </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>evecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>evals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>determines the eigenvalues and corresponding eigenvectors of the symmetric positive semi definite input matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>symmetric positive semi definite input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">evecs</td><td>corresponding eigenvectors in correct order according to eigenvalues </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">evals</td><td>resulting eigenvalues in ascending order </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00344">344</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00068">pcl::computeRoots()</a>, and <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>.</p>

</div>
</div>
<a id="gaca873868052e7d26efcf4b684a17bef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca873868052e7d26efcf4b684a17bef2">&#9670;&nbsp;</a></span>eigen33() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::eigen33 </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Matrix::Scalar &amp;&#160;</td>
          <td class="paramname"><em>eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>eigenvector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>determines the eigenvector and eigenvalue of the smallest eigenvalue of the symmetric positive semi definite input matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>symmetric positive semi definite input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvalue</td><td>smallest eigenvalue of the input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvector</td><td>the corresponding eigenvector for the input eigenvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if the smallest eigenvalue is not unique, this function may return any eigenvector that is consistent to the eigenvalue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00295">295</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00068">pcl::computeRoots()</a>.</p>

<p class="reference">Referenced by <a class="el" href="label__tree_8h_source.html#l00605">pcl::gpu::people::buildTree()</a>, <a class="el" href="convex__hull_8hpp_source.html#l00057">pcl::ConvexHull&lt; PointInT &gt;::calculateInputDimension()</a>, <a class="el" href="mls_8hpp_source.html#l00692">pcl::MLSResult::computeMLSSurface()</a>, <a class="el" href="intensity__gradient_8hpp_source.html#l00050">pcl::IntensityGradientEstimation&lt; PointInT, PointNT, PointOutT, IntensitySelectorT &gt;::computePointIntensityGradient()</a>, <a class="el" href="integral__image__normal_8hpp_source.html#l00205">pcl::IntegralImageNormalEstimation&lt; PointInT, PointOutT &gt;::computePointNormal()</a>, <a class="el" href="integral__image__normal_8hpp_source.html#l00460">pcl::IntegralImageNormalEstimation&lt; PointInT, PointOutT &gt;::computePointNormalMirror()</a>, <a class="el" href="principal__curvatures_8hpp_source.html#l00066">pcl::PrincipalCurvaturesEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePointPrincipalCurvatures()</a>, <a class="el" href="sac__model__registration_8h_source.html#l00233">pcl::SampleConsensusModelRegistration&lt; PointT &gt;::computeSampleDistanceThreshold()</a>, <a class="el" href="vector__average_8hpp_source.html#l00147">pcl::VectorAverage&lt; real, dimension &gt;::doPCA()</a>, <a class="el" href="vector__average_8hpp_source.html#l00164">pcl::VectorAverage&lt; real, dimension &gt;::getEigenVector1()</a>, <a class="el" href="transforms_8hpp_source.html#l00495">pcl::getPrincipalTransformation()</a>, <a class="el" href="grid__projection_8hpp_source.html#l00312">pcl::GridProjection&lt; PointNT &gt;::getProjectionWithPlaneFit()</a>, <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00048">pcl::isPointIn2DPolygon()</a>, <a class="el" href="sac__model__line_8hpp_source.html#l00203">pcl::SampleConsensusModelLine&lt; PointT &gt;::optimizeModelCoefficients()</a>, <a class="el" href="sac__model__plane_8hpp_source.html#l00312">pcl::SampleConsensusModelPlane&lt; PointT &gt;::optimizeModelCoefficients()</a>, <a class="el" href="sac__model__stick_8hpp_source.html#l00249">pcl::SampleConsensusModelStick&lt; PointT &gt;::optimizeModelCoefficients()</a>, <a class="el" href="concave__hull_8hpp_source.html#l00119">pcl::ConcaveHull&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="convex__hull_8hpp_source.html#l00076">pcl::ConvexHull&lt; PointInT &gt;::performReconstruction2D()</a>, <a class="el" href="harris__3d_8hpp_source.html#l00457">pcl::HarrisKeypoint3D&lt; PointInT, PointOutT, NormalT &gt;::responseTomasi()</a>, <a class="el" href="extract__polygonal__prism__data_8hpp_source.html#l00149">pcl::ExtractPolygonalPrismData&lt; PointT &gt;::segment()</a>, <a class="el" href="organized__multi__plane__segmentation_8hpp_source.html#l00083">pcl::OrganizedMultiPlaneSegmentation&lt; PointT, PointNT, PointLT &gt;::segment()</a>, <a class="el" href="feature_8hpp_source.html#l00065">pcl::solvePlaneParameters()</a>, and <a class="el" href="label__segment_8h_source.html#l00331">pcl::gpu::people::label_skeleton::sortIndicesToBlob2()</a>.</p>

</div>
</div>
<a id="ga3a1ba2729012164635113224cb211581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a1ba2729012164635113224cb211581">&#9670;&nbsp;</a></span>eigen33() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::eigen33 </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>evals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>determines the eigenvalues of the symmetric positive semi definite input matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>symmetric positive semi definite input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">evals</td><td>resulting eigenvalues in ascending order </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00330">330</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00068">pcl::computeRoots()</a>.</p>

</div>
</div>
<a id="ga8c74d7c459961a2650c22eff8126aef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c74d7c459961a2650c22eff8126aef8">&#9670;&nbsp;</a></span>getAngle3D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::getAngle3D </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>in_degree</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Compute the smallest angle between two 3D vectors in radians (default) or degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>the first 3D vector (represented as a <em>Eigen::Vector3f</em>) </td></tr>
    <tr><td class="paramname">v2</td><td>the second 3D vector (represented as a <em>Eigen::Vector3f</em>) </td></tr>
    <tr><td class="paramname">in_degree</td><td>determine if angle should be in radians or degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle between v1 and v2 in radians or degrees </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00059">59</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>.</p>

</div>
</div>
<a id="ga54999c02ba9bee56404539747b0fda51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54999c02ba9bee56404539747b0fda51">&#9670;&nbsp;</a></span>getAngle3D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::getAngle3D </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>in_degree</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Compute the smallest angle between two 3D vectors in radians (default) or degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>the first 3D vector (represented as a <em>Eigen::Vector4f</em>) </td></tr>
    <tr><td class="paramname">v2</td><td>the second 3D vector (represented as a <em>Eigen::Vector4f</em>) </td></tr>
    <tr><td class="paramname">in_degree</td><td>determine if angle should be in radians or degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle between v1 and v2 in radians or degrees </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles rounding error for parallel and anti-parallel vectors </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00047">47</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>.</p>

<p class="reference">Referenced by <a class="el" href="normal__coherence_8hpp_source.html#l00012">pcl::tracking::NormalCoherence&lt; PointInT &gt;::computeCoherence()</a>, <a class="el" href="particle__filter_8hpp_source.html#l00298">pcl::tracking::ParticleFilterTracker&lt; PointInT, StateT &gt;::computeTransformedPointCloudWithNormal()</a>, <a class="el" href="lccp__segmentation_8hpp_source.html#l00416">pcl::LCCPSegmentation&lt; PointT &gt;::connIsConvex()</a>, <a class="el" href="sac__model__cone_8hpp_source.html#l00274">pcl::SampleConsensusModelCone&lt; PointT, PointNT &gt;::countWithinDistance()</a>, <a class="el" href="sac__model__cylinder_8hpp_source.html#l00240">pcl::SampleConsensusModelCylinder&lt; PointT, PointNT &gt;::countWithinDistance()</a>, <a class="el" href="sac__model__normal__sphere_8hpp_source.html#l00110">pcl::SampleConsensusModelNormalSphere&lt; PointT, PointNT &gt;::countWithinDistance()</a>, <a class="el" href="sac__model__normal__plane_8hpp_source.html#l00129">pcl::SampleConsensusModelNormalPlane&lt; PointT, PointNT &gt;::countWithinDistanceStandard()</a>, <a class="el" href="sac__model__cone_8hpp_source.html#l00150">pcl::SampleConsensusModelCone&lt; PointT, PointNT &gt;::getDistancesToModel()</a>, <a class="el" href="sac__model__cylinder_8hpp_source.html#l00145">pcl::SampleConsensusModelCylinder&lt; PointT, PointNT &gt;::getDistancesToModel()</a>, <a class="el" href="sac__model__normal__plane_8hpp_source.html#l00292">pcl::SampleConsensusModelNormalPlane&lt; PointT, PointNT &gt;::getDistancesToModel()</a>, <a class="el" href="sac__model__normal__sphere_8hpp_source.html#l00161">pcl::SampleConsensusModelNormalSphere&lt; PointT, PointNT &gt;::getDistancesToModel()</a>, <a class="el" href="sac__model__cone_8hpp_source.html#l00525">pcl::SampleConsensusModelCone&lt; PointT, PointNT &gt;::isModelValid()</a>, <a class="el" href="sac__model__cylinder_8hpp_source.html#l00467">pcl::SampleConsensusModelCylinder&lt; PointT, PointNT &gt;::isModelValid()</a>, <a class="el" href="sac__model__parallel__line_8hpp_source.html#l00093">pcl::SampleConsensusModelParallelLine&lt; PointT &gt;::isModelValid()</a>, <a class="el" href="sac__model__perpendicular__plane_8hpp_source.html#l00093">pcl::SampleConsensusModelPerpendicularPlane&lt; PointT &gt;::isModelValid()</a>, <a class="el" href="sac__model__cone_8hpp_source.html#l00206">pcl::SampleConsensusModelCone&lt; PointT, PointNT &gt;::selectWithinDistance()</a>, <a class="el" href="sac__model__cylinder_8hpp_source.html#l00188">pcl::SampleConsensusModelCylinder&lt; PointT, PointNT &gt;::selectWithinDistance()</a>, <a class="el" href="sac__model__normal__plane_8hpp_source.html#l00049">pcl::SampleConsensusModelNormalPlane&lt; PointT, PointNT &gt;::selectWithinDistance()</a>, and <a class="el" href="sac__model__normal__sphere_8hpp_source.html#l00049">pcl::SampleConsensusModelNormalSphere&lt; PointT, PointNT &gt;::selectWithinDistance()</a>.</p>

</div>
</div>
<a id="gab64d6ba9e834d29feda71a76d3ec841f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab64d6ba9e834d29feda71a76d3ec841f">&#9670;&nbsp;</a></span>getCircumcircleRadius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::getCircumcircleRadius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Compute the radius of a circumscribed circle for a triangle formed of three points pa, pb, and pc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pa</td><td>the first point </td></tr>
    <tr><td class="paramname">pb</td><td>the second point </td></tr>
    <tr><td class="paramname">pc</td><td>the third point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the radius of the circumscribed circle </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00383">383</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="concave__hull_8hpp_source.html#l00119">pcl::ConcaveHull&lt; PointInT &gt;::performReconstruction()</a>.</p>

</div>
</div>
<a id="ga7a91d95901fcbac4a753a4212cfbf221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a91d95901fcbac4a753a4212cfbf221">&#9670;&nbsp;</a></span>getEigenAsPointCloud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::getEigenAsPointCloud </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Copy the XYZ dimensions from an <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf into a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf format containing XYZ0 / point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the resultant point cloud message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the method assumes that the <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">PCLPointCloud2</a> message already has the fields set up properly ! </dd></dl>

</div>
</div>
<a id="ga637da495fec59c1c1d186aa6e3bac15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga637da495fec59c1c1d186aa6e3bac15b">&#9670;&nbsp;</a></span>getEulerAngles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getEulerAngles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Extract the Euler angles (intrinsic rotations, ZYX-convention) from the given transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the input transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll</td><td>the resulting roll angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>the resulting pitch angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yaw</td><td>the resulting yaw angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00595">595</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="tracking_8hpp_source.html#l00060">pcl::tracking::ParticleXYZRPY::sample()</a>.</p>

</div>
</div>
<a id="ga2bc4b9a4e25de1d0b00db4e41f0ad682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc4b9a4e25de1d0b00db4e41f0ad682">&#9670;&nbsp;</a></span>getFieldIndex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::getFieldIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Get the index of a specified field (i.e., dimension/channel) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_name</td><td>the string defining the field name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the field or a negative integer if no field with the given name exists </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00061">61</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>, and <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00023">pcl::PCLPointCloud2::fields</a>.</p>

</div>
</div>
<a id="ga3c5daaf825f6cc4a3fb93a8544d6bdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c5daaf825f6cc4a3fb93a8544d6bdc4">&#9670;&nbsp;</a></span>getFieldIndex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int pcl::getFieldIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Get the index of a specified field (i.e., dimension/channel) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointT</td><td>datatype for which fields is being queries </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field_name</td><td>the string defining the field name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td>a vector to the original <em><a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a></em> vector that the raw <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> message contains </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00071">71</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>.</p>

</div>
</div>
<a id="ga21f637d9f7422a769448983af5fcbdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21f637d9f7422a769448983af5fcbdeb">&#9670;&nbsp;</a></span>getFieldIndex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int pcl::getFieldIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Get the index of a specified field (i.e., dimension/channel) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointT</td><td>datatype for which fields is being queries </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field_name</td><td>the string defining the field name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fields</td><td>a vector to the original <em><a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a></em> vector that the raw <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> message contains </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the field or a negative integer if no field with the given name exists </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00061">61</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

</div>
</div>
<a id="gac8788f010a13b19fc04d9dc2305fde22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8788f010a13b19fc04d9dc2305fde22">&#9670;&nbsp;</a></span>getFields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structpcl_1_1_p_c_l_point_field.html">pcl::PCLPointField</a> &gt; pcl::getFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Get the list of available fields (i.e., dimension/channel) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointT</td><td>datatype whose details are requested </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00097">97</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

</div>
</div>
<a id="ga83ff4ee40cd3c49c7500905f59f37536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ff4ee40cd3c49c7500905f59f37536">&#9670;&nbsp;</a></span>getFieldSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::getFieldSize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>datatype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Obtains the size of a specific field data type in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>the field data type (see <a class="el" href="_p_c_l_point_field_8h_source.html">PCLPointField.h</a>) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00127">127</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_field_8h_source.html#l00020">pcl::PCLPointField::BOOL</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00029">pcl::PCLPointField::FLOAT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00030">pcl::PCLPointField::FLOAT64</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00023">pcl::PCLPointField::INT16</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00025">pcl::PCLPointField::INT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00027">pcl::PCLPointField::INT64</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00021">pcl::PCLPointField::INT8</a>, <a class="el" href="pcl__macros_8h_source.html#l00437">PCL_FALLTHROUGH</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00024">pcl::PCLPointField::UINT16</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00026">pcl::PCLPointField::UINT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00028">pcl::PCLPointField::UINT64</a>, and <a class="el" href="_p_c_l_point_field_8h_source.html#l00022">pcl::PCLPointField::UINT8</a>.</p>

<p class="reference">Referenced by <a class="el" href="pcd__io_8hpp_source.html#l00057">pcl::PCDWriter::generateHeader()</a>, <a class="el" href="point__cloud__color__handlers_8hpp_source.html#l00383">pcl::visualization::PointCloudColorHandlerGenericField&lt; PointT &gt;::getColor()</a>, <a class="el" href="pcd__io_8hpp_source.html#l00111">pcl::PCDWriter::writeBinary()</a>, and <a class="el" href="pcd__io_8hpp_source.html#l00241">pcl::PCDWriter::writeBinaryCompressed()</a>.</p>

</div>
</div>
<a id="ga769f320a73865c3fe30cb96c0f932e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga769f320a73865c3fe30cb96c0f932e76">&#9670;&nbsp;</a></span>getFieldsList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcl::getFieldsList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Get the available point cloud fields as a space separated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>a pointer to the <a class="el" href="classpcl_1_1_point_cloud.html" title="PointCloud represents the base class in PCL for storing collections of 3D points.">PointCloud</a> message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00110">110</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_cloud2_8h_source.html#l00023">pcl::PCLPointCloud2::fields</a>.</p>

</div>
</div>
<a id="gaabed3f370d11ba5dc154d79e682d35b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabed3f370d11ba5dc154d79e682d35b4">&#9670;&nbsp;</a></span>getFieldsList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcl::getFieldsList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/io.hpp&gt;</code></p>

<p>Get the list of all fields available in a given cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html#l00107">107</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2io_8hpp_source.html">io.hpp</a>.</p>

</div>
</div>
<a id="gac282d255323a916e942f85b7f16740e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac282d255323a916e942f85b7f16740e3">&#9670;&nbsp;</a></span>getFieldType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::getFieldType </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Obtains the type of the <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> from a specific size and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the size in bytes of the data field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>a char describing the type of the field ('B' = bool, 'F' = float, 'I' = signed, 'U' = unsigned) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00171">171</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_field_8h_source.html#l00020">pcl::PCLPointField::BOOL</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00029">pcl::PCLPointField::FLOAT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00030">pcl::PCLPointField::FLOAT64</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00023">pcl::PCLPointField::INT16</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00025">pcl::PCLPointField::INT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00027">pcl::PCLPointField::INT64</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00021">pcl::PCLPointField::INT8</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00024">pcl::PCLPointField::UINT16</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00026">pcl::PCLPointField::UINT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00028">pcl::PCLPointField::UINT64</a>, and <a class="el" href="_p_c_l_point_field_8h_source.html#l00022">pcl::PCLPointField::UINT8</a>.</p>

<p class="reference">Referenced by <a class="el" href="pcd__io_8hpp_source.html#l00057">pcl::PCDWriter::generateHeader()</a>.</p>

</div>
</div>
<a id="gac4a4eaf1f19dd043252a0b93ac975a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4a4eaf1f19dd043252a0b93ac975a10">&#9670;&nbsp;</a></span>getFieldType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char pcl::getFieldType </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Obtains the type of the <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> from a specific <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> as a char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the <a class="el" href="structpcl_1_1_p_c_l_point_field.html">PCLPointField</a> field type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html#l00226">226</a> of file <a class="el" href="common_2include_2pcl_2common_2io_8h_source.html">io.h</a>.</p>

<p class="reference">References <a class="el" href="_p_c_l_point_field_8h_source.html#l00020">pcl::PCLPointField::BOOL</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00029">pcl::PCLPointField::FLOAT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00030">pcl::PCLPointField::FLOAT64</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00023">pcl::PCLPointField::INT16</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00025">pcl::PCLPointField::INT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00027">pcl::PCLPointField::INT64</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00021">pcl::PCLPointField::INT8</a>, <a class="el" href="pcl__macros_8h_source.html#l00437">PCL_FALLTHROUGH</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00024">pcl::PCLPointField::UINT16</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00026">pcl::PCLPointField::UINT32</a>, <a class="el" href="_p_c_l_point_field_8h_source.html#l00028">pcl::PCLPointField::UINT64</a>, and <a class="el" href="_p_c_l_point_field_8h_source.html#l00022">pcl::PCLPointField::UINT8</a>.</p>

</div>
</div>
<a id="ga1583a71aef0f54550adef0ebfef89edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1583a71aef0f54550adef0ebfef89edd">&#9670;&nbsp;</a></span>getMaxDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMaxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>pivot_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get the point at maximum distance from a given point and a given pointcloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramname">pivot_pt</td><td>the point from where to compute the distance </td></tr>
    <tr><td class="paramname">max_pt</td><td>the point in cloud that is the farthest point away from pivot_pt </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00197">197</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="gasd_8hpp_source.html#l00253">pcl::GASDEstimation&lt; PointInT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="vfh_8hpp_source.html#l00092">pcl::VFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePointSPFHSignature()</a>, <a class="el" href="our__cvfh_8hpp_source.html#l00383">pcl::OURCVFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeRFAndShapeDistribution()</a>, and <a class="el" href="our__cvfh_8hpp_source.html#l00200">pcl::OURCVFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::sgurf()</a>.</p>

</div>
</div>
<a id="ga43df2b30eedda61e26d132db661cf2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43df2b30eedda61e26d132db661cf2ec">&#9670;&nbsp;</a></span>getMaxDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMaxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>pivot_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get the point at maximum distance from a given point and a given pointcloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramname">indices</td><td>the vector of point indices to use from <em>cloud</em> </td></tr>
    <tr><td class="paramname">pivot_pt</td><td>the point from where to compute the distance </td></tr>
    <tr><td class="paramname">max_pt</td><td>the point in cloud that is the farthest point away from pivot_pt </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00244">244</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>.</p>

</div>
</div>
<a id="ga29e677fb3cb3143a9665d1eb0bf5f1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e677fb3cb3143a9665d1eb0bf5f1b0">&#9670;&nbsp;</a></span>getMaxSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::getMaxSegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2distances_8h.html">pcl/common/distances.h</a>&gt;</code></p>

<p>Obtain the maximum segment in a given set of points, and return the minimum and maximum points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud dataset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>a set of point indices to use from <em>cloud</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmin</td><td>the coordinates of the "minimum" point in <em>cloud</em> (one end of the segment) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmax</td><td>the coordinates of the "maximum" point in <em>cloud</em> (the other end of the segment) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of segment length </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00146">146</a> of file <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html">distances.h</a>.</p>

</div>
</div>
<a id="ga30ceb9b4896578ed075a36ad3937ee26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30ceb9b4896578ed075a36ad3937ee26">&#9670;&nbsp;</a></span>getMaxSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::getMaxSegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>pmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2distances_8h.html">pcl/common/distances.h</a>&gt;</code></p>

<p>Obtain the maximum segment in a given set of points, and return the minimum and maximum points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmin</td><td>the coordinates of the "minimum" point in <em>cloud</em> (one end of the segment) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmax</td><td>the coordinates of the "maximum" point in <em>cloud</em> (the other end of the segment) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of segment length </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00106">106</a> of file <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html">distances.h</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

</div>
</div>
<a id="ga3349ce9c26d4acbb1adae1e9b2d5f7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3349ce9c26d4acbb1adae1e9b2d5f7e5">&#9670;&nbsp;</a></span>getMeanStd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMeanStd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>stddev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Compute both the mean and the standard deviation of an array of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>the array of values </td></tr>
    <tr><td class="paramname">mean</td><td>the resultant mean of the distribution </td></tr>
    <tr><td class="paramname">stddev</td><td>the resultant standard deviation of the distribution </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00124">124</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a id="gacb684087702126b29c8b99f1e2c2786b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb684087702126b29c8b99f1e2c2786b">&#9670;&nbsp;</a></span>getMeanStdDev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::getMeanStdDev </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>stddev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Compute both the mean and the standard deviation of an array of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>the array of values </td></tr>
    <tr><td class="paramname">mean</td><td>the resultant mean of the distribution </td></tr>
    <tr><td class="paramname">stddev</td><td>the resultant standard deviation of the distribution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga287e6ce2d4be348c059baf31eaf2dd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga287e6ce2d4be348c059baf31eaf2dd54">&#9670;&nbsp;</a></span>getMinMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::getMinMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>min_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>max_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get the minimum and maximum values on a point histogram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the cloud containing multi-dimensional histograms </td></tr>
    <tr><td class="paramname">idx</td><td>point index representing the histogram that we need to compute min/max for </td></tr>
    <tr><td class="paramname">field_name</td><td>the field name containing the multi-dimensional histogram </td></tr>
    <tr><td class="paramname">min_p</td><td>the resultant minimum </td></tr>
    <tr><td class="paramname">max_p</td><td>the resultant maximum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacff2e632283be60810678d329b166ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacff2e632283be60810678d329b166ec">&#9670;&nbsp;</a></span>getMinMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMinMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>histogram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>min_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>max_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get the minimum and maximum values on a point histogram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">histogram</td><td>the point representing a multi-dimensional histogram </td></tr>
    <tr><td class="paramname">len</td><td>the length of the histogram </td></tr>
    <tr><td class="paramname">min_p</td><td>the resultant minimum </td></tr>
    <tr><td class="paramname">max_p</td><td>the resultant maximum </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00400">400</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlesac_8hpp_source.html#l00050">pcl::MaximumLikelihoodSampleConsensus&lt; PointT &gt;::computeModel()</a>.</p>

</div>
</div>
<a id="ga8e38f91f115922ef4aa80328b6da28f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e38f91f115922ef4aa80328b6da28f5">&#9670;&nbsp;</a></span>getMinMax3D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMinMax3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of point indices to use from <em>cloud</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_pt</td><td>the resultant minimum bounds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_pt</td><td>the resultant maximum bounds </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00348">348</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>.</p>

</div>
</div>
<a id="ga41eb246206d51f77a8cb82b5d963e6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41eb246206d51f77a8cb82b5d963e6a2">&#9670;&nbsp;</a></span>getMinMax3D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMinMax3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the vector of point indices to use from <em>cloud</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_pt</td><td>the resultant minimum bounds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_pt</td><td>the resultant maximum bounds </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00340">340</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00295">pcl::getMinMax3D()</a>, and <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="gafd9010977f5e52b35b484be7624df3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9010977f5e52b35b484be7624df3f8">&#9670;&nbsp;</a></span>getMinMax3D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMinMax3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_pt</td><td>the resultant minimum bounds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_pt</td><td>the resultant maximum bounds </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00305">305</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00395">pcl::PointCloud&lt; PointT &gt;::points</a>.</p>

</div>
</div>
<a id="ga3166f09aafd659f69dc75e63f5e10f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3166f09aafd659f69dc75e63f5e10f81">&#9670;&nbsp;</a></span>getMinMax3D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getMinMax3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_pt</td><td>the resultant minimum bounds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_pt</td><td>the resultant maximum bounds </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00295">295</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="label__tree_8h_source.html#l00605">pcl::gpu::people::buildTree()</a>, <a class="el" href="particle__filter_8hpp_source.html#l00187">pcl::tracking::ParticleFilterTracker&lt; PointInT, StateT &gt;::calcBoundingBox()</a>, <a class="el" href="gasd_8hpp_source.html#l00253">pcl::GASDEstimation&lt; PointInT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="data__source_8hpp_source.html#l00082">pcl::gpu::DataSource::DataSource()</a>, <a class="el" href="grid__projection_8hpp_source.html#l00087">pcl::GridProjection&lt; PointNT &gt;::getBoundingBox()</a>, <a class="el" href="marching__cubes_8hpp_source.html#l00050">pcl::MarchingCubes&lt; PointNT &gt;::getBoundingBox()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00340">pcl::getMinMax3D()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00225">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::initCompute()</a>, <a class="el" href="mls_8hpp_source.html#l00808">pcl::MovingLeastSquares&lt; PointInT, PointOutT &gt;::MLSVoxelGrid::MLSVoxelGrid()</a>, and <a class="el" href="label__segment_8h_source.html#l00331">pcl::gpu::people::label_skeleton::sortIndicesToBlob2()</a>.</p>

</div>
</div>
<a id="ga6d121a64a02046c1c38485ea1fad953e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d121a64a02046c1c38485ea1fad953e">&#9670;&nbsp;</a></span>getPointCloudAsEigen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::getPointCloudAsEigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXf &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>Copy the XYZ dimensions of a <a class="el" href="structpcl_1_1_p_c_l_point_cloud2.html">pcl::PCLPointCloud2</a> into <a class="el" href="namespace_eigen.html">Eigen</a> format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>the point cloud message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the resultant <a class="el" href="namespace_eigen.html">Eigen</a> MatrixXf format containing XYZ0 / point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa67d411e0077c68c31adbc7d0d995e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa67d411e0077c68c31adbc7d0d995e9c">&#9670;&nbsp;</a></span>getPointsInBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getPointsInBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>min_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>max_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2common_8h.html">pcl/common/common.h</a>&gt;</code></p>

<p>Get a set of points residing in a box given its bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>the point cloud data message </td></tr>
    <tr><td class="paramname">min_pt</td><td>the minimum bounds </td></tr>
    <tr><td class="paramname">max_pt</td><td>the maximum bounds </td></tr>
    <tr><td class="paramname">indices</td><td>the resultant set of point indices residing in the box </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00154">154</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html">common.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree__base__node_8hpp_source.html#l01375">pcl::outofcore::OutofcoreOctreeBaseNode&lt; ContainerT, PointT &gt;::queryBBIncludes()</a>.</p>

</div>
</div>
<a id="gaf49a34180e337479ddeda21222882124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf49a34180e337479ddeda21222882124">&#9670;&nbsp;</a></span>getTransformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::getTransformation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Create a transformation from the given translation and Euler angles (intrinsic rotations, ZYX-convention) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the input x translation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>the input y translation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>the input z translation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll</td><td>the input roll angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>the input pitch angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yaw</td><td>the input yaw angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting transformation matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html#l00316">316</a> of file <a class="el" href="common_2include_2pcl_2common_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ga5cc746d1fd72f99fee462ed1a9e4abea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc746d1fd72f99fee462ed1a9e4abea">&#9670;&nbsp;</a></span>getTransformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTransformation </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>yaw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Create a transformation from the given translation and Euler angles (intrinsic rotations, ZYX-convention) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the input x translation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>the input y translation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>the input z translation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll</td><td>the input roll angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>the input pitch angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yaw</td><td>the input yaw angle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>the resulting transformation matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00618">618</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="norms_8h_source.html#l00054">pcl::B</a>.</p>

<p class="reference">Referenced by <a class="el" href="crop__box_8hpp_source.html#l00051">pcl::CropBox&lt; PointT &gt;::applyFilter()</a>, <a class="el" href="lum_8hpp_source.html#l00308">pcl::registration::LUM&lt; PointT &gt;::computeEdge()</a>, <a class="el" href="lum_8hpp_source.html#l00294">pcl::registration::LUM&lt; PointT &gt;::getConcatenatedCloud()</a>, <a class="el" href="lum_8hpp_source.html#l00171">pcl::registration::LUM&lt; PointT &gt;::getTransformation()</a>, <a class="el" href="lum_8hpp_source.html#l00285">pcl::registration::LUM&lt; PointT &gt;::getTransformedCloud()</a>, <a class="el" href="tracking_8hpp_source.html#l00060">pcl::tracking::ParticleXYZRPY::sample()</a>, <a class="el" href="tracking_8hpp_source.html#l00118">pcl::tracking::ParticleXYZRPY::toEigenMatrix()</a>, <a class="el" href="tracking_8hpp_source.html#l00308">pcl::tracking::ParticleXYZR::toEigenMatrix()</a>, <a class="el" href="tracking_8hpp_source.html#l00492">pcl::tracking::ParticleXYRPY::toEigenMatrix()</a>, <a class="el" href="tracking_8hpp_source.html#l00682">pcl::tracking::ParticleXYRP::toEigenMatrix()</a>, and <a class="el" href="tracking_8hpp_source.html#l00869">pcl::tracking::ParticleXYR::toEigenMatrix()</a>.</p>

</div>
</div>
<a id="gada89edf1699e05ecf7355738e9f56f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada89edf1699e05ecf7355738e9f56f6b">&#9670;&nbsp;</a></span>getTransformationFromTwoUnitVectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::getTransformationFromTwoUnitVectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>z_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y_direction</td><td>the y direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_axis</td><td>the z-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation the resultant 3D rotation </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00573">573</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00564">pcl::getTransformationFromTwoUnitVectors()</a>.</p>

</div>
</div>
<a id="ga7d1f523f342ff69277f23ea9f02fc5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d1f523f342ff69277f23ea9f02fc5a6">&#9670;&nbsp;</a></span>getTransformationFromTwoUnitVectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTransformationFromTwoUnitVectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>z_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y_direction</td><td>the y direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_axis</td><td>the z-axis </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transformation</td><td>the resultant 3D rotation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00564">564</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00512">pcl::getTransFromUnitVectorsZY()</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l01187">pcl::RangeImage::getRotationToViewerCoordinateFrame()</a>, <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00573">pcl::getTransformationFromTwoUnitVectors()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00583">pcl::getTransformationFromTwoUnitVectorsAndOrigin()</a>.</p>

</div>
</div>
<a id="ga4375e99ec2ae368eec9379f506568611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4375e99ec2ae368eec9379f506568611">&#9670;&nbsp;</a></span>getTransformationFromTwoUnitVectorsAndOrigin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTransformationFromTwoUnitVectorsAndOrigin </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>z_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Get the transformation that will translate <em>origin</em> to (0,0,0) and rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y_direction</td><td>the y direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_axis</td><td>the z-axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>the origin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transformation</td><td>the resultant transformation matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00583">583</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00564">pcl::getTransformationFromTwoUnitVectors()</a>.</p>

<p class="reference">Referenced by <a class="el" href="range__image_8hpp_source.html#l01179">pcl::RangeImage::getTransformationToViewerCoordinateFrame()</a>.</p>

</div>
</div>
<a id="ga8933c653f39db3636bfbdd262278edcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8933c653f39db3636bfbdd262278edcb">&#9670;&nbsp;</a></span>getTransFromUnitVectorsXY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::getTransFromUnitVectorsXY </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>x_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Get the unique 3D rotation that will rotate <em>x_axis</em> into (1,0,0) and <em>y_direction</em> into a vector with z=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_axis</td><td>the x-axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_direction</td><td>the y direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting 3D rotation </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00554">554</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00538">pcl::getTransFromUnitVectorsXY()</a>.</p>

</div>
</div>
<a id="ga8319aa7921bdc742a9d0f95458e9cfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8319aa7921bdc742a9d0f95458e9cfe0">&#9670;&nbsp;</a></span>getTransFromUnitVectorsXY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTransFromUnitVectorsXY </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>x_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Get the unique 3D rotation that will rotate <em>x_axis</em> into (1,0,0) and <em>y_direction</em> into a vector with z=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_axis</td><td>the x-axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_direction</td><td>the y direction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transformation</td><td>the resultant 3D rotation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00538">538</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00554">pcl::getTransFromUnitVectorsXY()</a>.</p>

</div>
</div>
<a id="ga58d47eda3c3f5f91125296fd7d202ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58d47eda3c3f5f91125296fd7d202ebb">&#9670;&nbsp;</a></span>getTransFromUnitVectorsZY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Affine3f pcl::getTransFromUnitVectorsZY </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>z_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z_axis</td><td>the z-axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_direction</td><td>the y direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resultant 3D rotation </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00528">528</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00512">pcl::getTransFromUnitVectorsZY()</a>.</p>

</div>
</div>
<a id="gaf457d33994792e63129de9709dcdf329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf457d33994792e63129de9709dcdf329">&#9670;&nbsp;</a></span>getTransFromUnitVectorsZY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTransFromUnitVectorsZY </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>z_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>y_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3f &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Get the unique 3D rotation that will rotate <em>z_axis</em> into (0,0,1) and <em>y_direction</em> into a vector with x=0 (or into (0,1,0) should <em>y_direction</em> be orthogonal to <em>z_axis</em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z_axis</td><td>the z-axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_direction</td><td>the y direction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transformation</td><td>the resultant 3D rotation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00512">512</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00564">pcl::getTransformationFromTwoUnitVectors()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00528">pcl::getTransFromUnitVectorsZY()</a>.</p>

</div>
</div>
<a id="ga3e52d439a979e71096f4dd50f1298f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e52d439a979e71096f4dd50f1298f32">&#9670;&nbsp;</a></span>getTranslationAndEulerAngles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::getTranslationAndEulerAngles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Extract x,y,z and the Euler angles (intrinsic rotations, ZYX-convention) from the given transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the input transformation matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>the resulting x translation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>the resulting y translation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>the resulting z translation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">roll</td><td>the resulting roll angle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pitch</td><td>the resulting pitch angle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yaw</td><td>the resulting yaw angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00604">604</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="narf_8hpp_source.html#l00054">pcl::Narf::copyToNarf36()</a>, <a class="el" href="tracking_8hpp_source.html#l00124">pcl::tracking::ParticleXYZRPY::toState()</a>, <a class="el" href="tracking_8hpp_source.html#l00314">pcl::tracking::ParticleXYZR::toState()</a>, <a class="el" href="tracking_8hpp_source.html#l00498">pcl::tracking::ParticleXYRPY::toState()</a>, <a class="el" href="tracking_8hpp_source.html#l00688">pcl::tracking::ParticleXYRP::toState()</a>, and <a class="el" href="tracking_8hpp_source.html#l00875">pcl::tracking::ParticleXYR::toState()</a>.</p>

</div>
</div>
<a id="ga86297c76ef1756ff1db90d8e39c14fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86297c76ef1756ff1db90d8e39c14fa3">&#9670;&nbsp;</a></span>HIK_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::HIK_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the HIK norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00233">233</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="gad09b0c9a50601f3ae20a7babfd9a8d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad09b0c9a50601f3ae20a7babfd9a8d2d">&#9670;&nbsp;</a></span>invert2x2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Scalar pcl::invert2x2 </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Calculate the inverse of a 2x2 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>matrix to be inverted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inverse</td><td>the resultant inverted matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>only the upper triangular part is taken into account =&gt; non symmetric matrices will give wrong results </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>determinant of the original matrix =&gt; if 0 no inverse exists =&gt; result is invalid </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00415">415</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

</div>
</div>
<a id="gabb12d1f85437aafb0a3ac12af5633400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb12d1f85437aafb0a3ac12af5633400">&#9670;&nbsp;</a></span>invert3x3Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Scalar pcl::invert3x3Matrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Calculate the inverse of a general 3x3 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>matrix to be inverted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inverse</td><td>the resultant inverted matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>determinant of the original matrix =&gt; if 0 no inverse exists =&gt; result is invalid </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00469">469</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

</div>
</div>
<a id="ga503f55a565c260660c6ac0461f17fa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga503f55a565c260660c6ac0461f17fa8f">&#9670;&nbsp;</a></span>invert3x3SymMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Scalar pcl::invert3x3SymMatrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Calculate the inverse of a 3x3 symmetric matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>matrix to be inverted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inverse</td><td>the resultant inverted matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>only the upper triangular part is taken into account =&gt; non symmetric matrices will give wrong results </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>determinant of the original matrix =&gt; if 0 no inverse exists =&gt; result is invalid </dd></dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00434">434</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

</div>
</div>
<a id="ga9683d853583c45c7bc4da676bc46ec7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9683d853583c45c7bc4da676bc46ec7d">&#9670;&nbsp;</a></span>isBetterCorrespondence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::isBetterCorrespondence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a> &amp;&#160;</td>
          <td class="paramname"><em>pc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_correspondence.html">Correspondence</a> &amp;&#160;</td>
          <td class="paramname"><em>pc2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/correspondence.h&gt;</code></p>

<p><a class="el" href="classpcl_1_1_comparator.html" title="Comparator is the base class for comparators that compare two points given some function.">Comparator</a> to enable us to sort a vector of PointCorrespondences according to their scores using std::sort (begin(), end(), isBetterCorrespondence);. </p>

<p class="definition">Definition at line <a class="el" href="correspondence_8h_source.html#l00146">146</a> of file <a class="el" href="correspondence_8h_source.html">correspondence.h</a>.</p>

<p class="reference">References <a class="el" href="correspondence_8h_source.html#l00069">pcl::Correspondence::distance</a>.</p>

</div>
</div>
<a id="ga45baeaeb21308cd128a7c44ab786552c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45baeaeb21308cd128a7c44ab786552c">&#9670;&nbsp;</a></span>JM_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::JM_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the JM norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00128">128</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga4df86a6dafef9778fb8df865ad54e28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df86a6dafef9778fb8df865ad54e28f">&#9670;&nbsp;</a></span>K_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::K_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>P2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the K norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
    <tr><td class="paramname">P1</td><td>the first parameter </td></tr>
    <tr><td class="paramname">P2</td><td>the second parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00208">208</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

</div>
</div>
<a id="ga186a26b9face0cfb0fea3d6eb37f909b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga186a26b9face0cfb0fea3d6eb37f909b">&#9670;&nbsp;</a></span>KL_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::KL_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the KL between two discrete probability density functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first discrete PDF </td></tr>
    <tr><td class="paramname">B</td><td>the second discrete PDF </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00219">219</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga61d1e988b461de40a26b4e4e9e93ce55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61d1e988b461de40a26b4e4e9e93ce55">&#9670;&nbsp;</a></span>L1_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::L1_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the L1 norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00088">88</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="narf_8hpp_source.html#l00046">pcl::Narf::getDescriptorDistance()</a>, and <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga70456fbb6c67cf3c1229e19c831b30ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70456fbb6c67cf3c1229e19c831b30ac">&#9670;&nbsp;</a></span>L2_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::L2_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the L2 norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00111">111</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">References <a class="el" href="norms_8hpp_source.html#l00098">pcl::L2_Norm_SQR()</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="gaf034c4bca3fc85c1e6d27d893c2936a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf034c4bca3fc85c1e6d27d893c2936a5">&#9670;&nbsp;</a></span>L2_Norm_SQR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::L2_Norm_SQR </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the squared L2 norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00098">98</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00111">pcl::L2_Norm()</a>, and <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga4ee346a92c01c042ffae2907ae5c93c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee346a92c01c042ffae2907ae5c93c5">&#9670;&nbsp;</a></span>lineToLineSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> void pcl::lineToLineSegment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>line_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>line_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>pt1_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>pt2_seg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2distances_8h.html">pcl/common/distances.h</a>&gt;</code></p>

<p>Get the shortest 3D segment between two 3D lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_a</td><td>the coefficients of the first line (point, direction) </td></tr>
    <tr><td class="paramname">line_b</td><td>the coefficients of the second line (point, direction) </td></tr>
    <tr><td class="paramname">pt1_seg</td><td>the first point on the line segment </td></tr>
    <tr><td class="paramname">pt2_seg</td><td>the second point on the line segment </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="intersections_8hpp_source.html#l00049">pcl::lineWithLineIntersection()</a>.</p>

</div>
</div>
<a id="ga4d365f5e3c7400a13c55d001ed76e35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d365f5e3c7400a13c55d001ed76e35b">&#9670;&nbsp;</a></span>lineWithLineIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::lineWithLineIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>line_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>line_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sqr_eps</em> = <code>1e-4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/intersections.hpp&gt;</code></p>

<p>Get the intersection of a two 3D lines in space as a 3D point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">line_a</td><td>the coefficients of the first line (point, direction) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_b</td><td>the coefficients of the second line (point, direction) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point</td><td>holder for the computed 3D point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sqr_eps</td><td>maximum allowable squared distance to the true solution </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="intersections_8hpp_source.html#l00049">49</a> of file <a class="el" href="intersections_8hpp_source.html">intersections.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__common.html#ga4ee346a92c01c042ffae2907ae5c93c5">pcl::lineToLineSegment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="intersections_8hpp_source.html#l00069">pcl::lineWithLineIntersection()</a>.</p>

</div>
</div>
<a id="gaeee7c3cfcb96e3884199191a9c24f6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeee7c3cfcb96e3884199191a9c24f6f0">&#9670;&nbsp;</a></span>lineWithLineIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::lineWithLineIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_model_coefficients.html">pcl::ModelCoefficients</a> &amp;&#160;</td>
          <td class="paramname"><em>line_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_model_coefficients.html">pcl::ModelCoefficients</a> &amp;&#160;</td>
          <td class="paramname"><em>line_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sqr_eps</em> = <code>1e-4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/intersections.hpp&gt;</code></p>

<p>Get the intersection of a two 3D lines in space as a 3D point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">line_a</td><td>the coefficients of the first line (point, direction) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_b</td><td>the coefficients of the second line (point, direction) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point</td><td>holder for the computed 3D point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sqr_eps</td><td>maximum allowable squared distance to the true solution </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="intersections_8hpp_source.html#l00069">69</a> of file <a class="el" href="intersections_8hpp_source.html">intersections.hpp</a>.</p>

<p class="reference">References <a class="el" href="intersections_8hpp_source.html#l00049">pcl::lineWithLineIntersection()</a>, and <a class="el" href="_model_coefficients_8h_source.html#l00017">pcl::ModelCoefficients::values</a>.</p>

</div>
</div>
<a id="ga63fded8c9593744836d761940cab9350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63fded8c9593744836d761940cab9350">&#9670;&nbsp;</a></span>Linf_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::Linf_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the L-infinity norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00118">118</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga5281205532955d384c8aa22ff4ff5e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5281205532955d384c8aa22ff4ff5e80">&#9670;&nbsp;</a></span>loadBinary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::loadBinary </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Read a matrix from an input stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>the resulting matrix, read from the input stream </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>the input stream </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00648">648</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

</div>
</div>
<a id="ga3b37d5c19b2773954bbc5320f011f3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b37d5c19b2773954bbc5320f011f3ec">&#9670;&nbsp;</a></span>normAngle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::normAngle </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="angles_8h.html">pcl/common/angles.h</a>&gt;</code></p>

<p>Normalize an angle to (-PI, PI]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the input angle (in radians) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="angles_8hpp_source.html#l00048">48</a> of file <a class="el" href="angles_8hpp_source.html">angles.hpp</a>.</p>

<p class="reference">References <a class="el" href="pcl__macros_8h_source.html#l00201">M_PI</a>.</p>

</div>
</div>
<a id="gaf977fbc818d41de61285d1da0521991a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf977fbc818d41de61285d1da0521991a">&#9670;&nbsp;</a></span>PF_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::PF_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>P2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the PF norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
    <tr><td class="paramname">P1</td><td>the first parameter </td></tr>
    <tr><td class="paramname">P2</td><td>the second parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00197">197</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

</div>
</div>
<a id="ga997c583b8ac57ffa9ad9e7321b4673e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga997c583b8ac57ffa9ad9e7321b4673e5">&#9670;&nbsp;</a></span>rad2deg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::rad2deg </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="angles_8h.html">pcl/common/angles.h</a>&gt;</code></p>

<p>Convert an angle from radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the input angle (in radians) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="angles_8hpp_source.html#l00073">73</a> of file <a class="el" href="angles_8hpp_source.html">angles.hpp</a>.</p>

</div>
</div>
<a id="ga3177c2c084674693cc38f03e80b6ad77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3177c2c084674693cc38f03e80b6ad77">&#9670;&nbsp;</a></span>rad2deg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::rad2deg </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="angles_8h.html">pcl/common/angles.h</a>&gt;</code></p>

<p>Convert an angle from radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the input angle (in radians) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="angles_8hpp_source.html#l00061">61</a> of file <a class="el" href="angles_8hpp_source.html">angles.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="3dsc_8hpp_source.html#l00133">pcl::ShapeContext3DEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePoint()</a>, <a class="el" href="usc_8hpp_source.html#l00146">pcl::UniqueShapeContext&lt; PointInT, PointOutT, PointRFT &gt;::computePointDescriptor()</a>, and <a class="el" href="edge_8hpp_source.html#l00448">pcl::Edge&lt; ImageType, ImageType &gt;::detectEdgeLoG()</a>.</p>

</div>
</div>
<a id="gacc18ebcacd806fd0c9336fe2f8b7208c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc18ebcacd806fd0c9336fe2f8b7208c">&#9670;&nbsp;</a></span>saveBinary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::saveBinary </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/eigen.h&gt;</code></p>

<p>Write a matrix to an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>the matrix to output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">file</td><td>the output stream </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00633">633</a> of file <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html">eigen.hpp</a>.</p>

</div>
</div>
<a id="ga047d812778a099ab333c847342c4b6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga047d812778a099ab333c847342c4b6bf">&#9670;&nbsp;</a></span>selectNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::selectNorm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d37f00989a9de11b48deb263649463c">NormType</a>&#160;</td>
          <td class="paramname"><em>norm_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Method that calculates any norm type available, based on the norm_type variable. </p>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00050">50</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">References <a class="el" href="norms_8h_source.html#l00054">pcl::B</a>, <a class="el" href="norms_8hpp_source.html#l00140">pcl::B_Norm()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::CS</a>, <a class="el" href="norms_8hpp_source.html#l00169">pcl::CS_Norm()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::DIV</a>, <a class="el" href="norms_8hpp_source.html#l00183">pcl::Div_Norm()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::HIK</a>, <a class="el" href="norms_8hpp_source.html#l00233">pcl::HIK_Norm()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::JM</a>, <a class="el" href="norms_8hpp_source.html#l00128">pcl::JM_Norm()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::K</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::KL</a>, <a class="el" href="norms_8hpp_source.html#l00219">pcl::KL_Norm()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::L1</a>, <a class="el" href="norms_8hpp_source.html#l00088">pcl::L1_Norm()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::L2</a>, <a class="el" href="norms_8hpp_source.html#l00111">pcl::L2_Norm()</a>, <a class="el" href="norms_8hpp_source.html#l00098">pcl::L2_Norm_SQR()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::L2_SQR</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::LINF</a>, <a class="el" href="norms_8hpp_source.html#l00118">pcl::Linf_Norm()</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::PF</a>, <a class="el" href="norms_8h_source.html#l00054">pcl::SUBLINEAR</a>, and <a class="el" href="norms_8hpp_source.html#l00157">pcl::Sublinear_Norm()</a>.</p>

</div>
</div>
<a id="gad9217ecd4cc14221f178af07a16ef75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9217ecd4cc14221f178af07a16ef75d">&#9670;&nbsp;</a></span>sqrPointToLineDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::sqrPointToLineDistance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>line_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>line_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2distances_8h.html">pcl/common/distances.h</a>&gt;</code></p>

<p>Get the square distance from a point to a line (represented by a point and a direction) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>a point </td></tr>
    <tr><td class="paramname">line_pt</td><td>a point on the line (make sure that line_pt[3] = 0 as there are no internal checks!) </td></tr>
    <tr><td class="paramname">line_dir</td><td>the line direction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00075">75</a> of file <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html">distances.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sac__model__cylinder_8hpp_source.html#l00075">pcl::SampleConsensusModelCylinder&lt; PointT, PointNT &gt;::computeModelCoefficients()</a>, <a class="el" href="sac__model__cone_8hpp_source.html#l00515">pcl::SampleConsensusModelCone&lt; PointT, PointNT &gt;::pointToAxisDistance()</a>, and <a class="el" href="sac__model__cylinder_8hpp_source.html#l00439">pcl::SampleConsensusModelCylinder&lt; PointT, PointNT &gt;::pointToLineDistance()</a>.</p>

</div>
</div>
<a id="ga3d6aa7accd68832e8a4d4707c358e40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d6aa7accd68832e8a4d4707c358e40f">&#9670;&nbsp;</a></span>sqrPointToLineDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pcl::sqrPointToLineDistance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>line_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>line_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sqr_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="common_2include_2pcl_2common_2distances_8h.html">pcl/common/distances.h</a>&gt;</code></p>

<p>Get the square distance from a point to a line (represented by a point and a direction) </p>
<dl class="section note"><dt>Note</dt><dd>This one is useful if one has to compute many distances to a fixed line, so the vector length can be pre-computed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>a point </td></tr>
    <tr><td class="paramname">line_pt</td><td>a point on the line (make sure that line_pt[3] = 0 as there are no internal checks!) </td></tr>
    <tr><td class="paramname">line_dir</td><td>the line direction </td></tr>
    <tr><td class="paramname">sqr_length</td><td>the squared norm of the line direction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html#l00091">91</a> of file <a class="el" href="common_2include_2pcl_2common_2distances_8h_source.html">distances.h</a>.</p>

</div>
</div>
<a id="gac986c55a5b8850fec89cd26c46303747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac986c55a5b8850fec89cd26c46303747">&#9670;&nbsp;</a></span>Sublinear_Norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pcl::Sublinear_Norm </td>
          <td>(</td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatVectorT&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/norms.hpp&gt;</code></p>

<p>Compute the sublinear norm of the vector between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first point </td></tr>
    <tr><td class="paramname">B</td><td>the second point </td></tr>
    <tr><td class="paramname">dim</td><td>the number of dimensions in <em>A</em> and <em>B</em> (dimensions must match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FloatVectorT is any type of vector with its values accessible via [ ] </dd></dl>

<p class="definition">Definition at line <a class="el" href="norms_8hpp_source.html#l00157">157</a> of file <a class="el" href="norms_8hpp_source.html">norms.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="norms_8hpp_source.html#l00050">pcl::selectNorm()</a>.</p>

</div>
</div>
<a id="ga4bb19421457db739a96fe4eacf620139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb19421457db739a96fe4eacf620139">&#9670;&nbsp;</a></span>swapByte()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::io::swapByte </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/io.h&gt;</code></p>

<p>swap bytes order of a char array of length N </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>char array to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1bd2c5ea1258af3a45483dd1341aa429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bd2c5ea1258af3a45483dd1341aa429">&#9670;&nbsp;</a></span>transformPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> pcl::transformPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Transform a point with members x,y,z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the point to transform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transform</td><td>the transformation to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transformed point </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00474">474</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="transforms_8hpp_source.html#l00091">pcl::detail::Transformer&lt; Scalar &gt;::se3()</a>.</p>

</div>
</div>
<a id="gaf70f429594d4d23700cf97875eef3e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf70f429594d4d23700cf97875eef3e73">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y.html">pcl::PointXY</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y.html">pcl::PointXY</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Affine2f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Apply an affine transform on a pointcloud having points of type <a class="el" href="structpcl_1_1_point_x_y.html" title="A 2D point structure representing Euclidean xy coordinates.">PointXY</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00310">310</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00548">pcl::PointCloud&lt; PointT &gt;::assign()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00429">pcl::PointCloud&lt; PointT &gt;::begin()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00430">pcl::PointCloud&lt; PointT &gt;::end()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00445">pcl::PointCloud&lt; PointT &gt;::reserve()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ga69421534f84d8c43314da4753e01b825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69421534f84d8c43314da4753e01b825">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Apply a rigid transform defined by a 4x4 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>a rigid transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00263">263</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="transforms_8hpp_source.html#l00091">pcl::detail::Transformer&lt; Scalar &gt;::se3()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ga938b05611e2f2cfa64839852b4d69df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938b05611e2f2cfa64839852b4d69df8">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/transforms.h&gt;</code></p>

<p>Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transforms_8h_source.html#l00086">86</a> of file <a class="el" href="transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="ga033e051c786ec84f52598ab711a74a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga033e051c786ec84f52598ab711a74a4e">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/transforms.h&gt;</code></p>

<p>Apply a rigid transform defined by a 4x4 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>a rigid transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transforms_8h_source.html#l00280">280</a> of file <a class="el" href="transforms_8h_source.html">transforms.h</a>.</p>

<p class="reference">References <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="gaa9afb23505913d26d9a1f06242d8eefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9afb23505913d26d9a1f06242d8eefa">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/transforms.h&gt;</code></p>

<p>Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transforms_8h_source.html#l00115">115</a> of file <a class="el" href="transforms_8h_source.html">transforms.h</a>.</p>

<p class="reference">References <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="gaff524851ffbcbefdbef2277134382906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff524851ffbcbefdbef2277134382906">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Apply a rigid transform defined by a 3D offset and a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>the translation component of the rigid transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>the rotation component of the rigid transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00446">446</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="transforms_8hpp_source.html#l00221">pcl::transformPointCloud()</a>.</p>

</div>
</div>
<a id="gac841d05d13c925f3a3a8090d9d7ff24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac841d05d13c925f3a3a8090d9d7ff24d">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Apply a rigid transform defined by a 4x4 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>a rigid transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used with cloud_in equal to cloud_out </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00221">221</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00548">pcl::PointCloud&lt; PointT &gt;::assign()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00429">pcl::PointCloud&lt; PointT &gt;::begin()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00447">pcl::PointCloud&lt; PointT &gt;::data()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00430">pcl::PointCloud&lt; PointT &gt;::end()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00445">pcl::PointCloud&lt; PointT &gt;::reserve()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="transforms_8hpp_source.html#l00091">pcl::detail::Transformer&lt; Scalar &gt;::se3()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="iccv2011_2include_2object__recognition_8h_source.html#l00175">ObjectRecognition::alignModelPoints()</a>, <a class="el" href="ground__based__people__detection__app_8hpp_source.html#l00260">pcl::people::GroundBasedPeopleDetectionApp&lt; PointT &gt;::applyTransformationPointCloud()</a>, <a class="el" href="elch_8hpp_source.html#l00216">pcl::registration::ELCH&lt; PointT &gt;::compute()</a>, <a class="el" href="gasd_8hpp_source.html#l00253">pcl::GASDEstimation&lt; PointInT, PointOutT &gt;::computeFeature()</a>, <a class="el" href="our__cvfh_8hpp_source.html#l00383">pcl::OURCVFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeRFAndShapeDistribution()</a>, <a class="el" href="ndt_8hpp_source.html#l00650">pcl::NormalDistributionsTransform&lt; PointSource, PointTarget, Scalar &gt;::computeStepLengthMT()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00142">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::computeTransformation()</a>, <a class="el" href="ia__ransac_8hpp_source.html#l00189">pcl::SampleConsensusInitialAlignment&lt; PointSource, PointTarget, FeatureT &gt;::computeTransformation()</a>, <a class="el" href="ndt__2d_8hpp_source.html#l00392">pcl::NormalDistributionsTransform2D&lt; PointSource, PointTarget &gt;::computeTransformation()</a>, <a class="el" href="sample__consensus__prerejective_8hpp_source.html#l00154">pcl::SampleConsensusPrerejective&lt; PointSource, PointTarget, FeatureT &gt;::computeTransformation()</a>, <a class="el" href="gicp_8hpp_source.html#l00770">pcl::GeneralizedIterativeClosestPoint&lt; PointSource, PointTarget, Scalar &gt;::computeTransformation()</a>, <a class="el" href="ndt_8hpp_source.html#l00068">pcl::NormalDistributionsTransform&lt; PointSource, PointTarget, Scalar &gt;::computeTransformation()</a>, <a class="el" href="lum_8hpp_source.html#l00294">pcl::registration::LUM&lt; PointT &gt;::getConcatenatedCloud()</a>, <a class="el" href="world__model_8hpp_source.html#l00063">pcl::kinfuLS::WorldModel&lt; pcl::PointXYZI &gt;::getExistingData()</a>, <a class="el" href="sample__consensus__prerejective_8hpp_source.html#l00307">pcl::SampleConsensusPrerejective&lt; PointSource, PointTarget, FeatureT &gt;::getFitness()</a>, <a class="el" href="registration_8hpp_source.html#l00134">pcl::Registration&lt; PointSource, PointTarget, Scalar &gt;::getFitnessScore()</a>, <a class="el" href="standalone__marching__cubes_8hpp_source.html#l00094">pcl::gpu::kinfuLS::StandaloneMarchingCubes&lt; PointT &gt;::getMeshesFromTSDFVector()</a>, <a class="el" href="lum_8hpp_source.html#l00285">pcl::registration::LUM&lt; PointT &gt;::getTransformedCloud()</a>, <a class="el" href="texture__mapping_8hpp_source.html#l00281">pcl::TextureMapping&lt; PointInT &gt;::mapMultipleTexturesToMeshUV()</a>, <a class="el" href="concave__hull_8hpp_source.html#l00119">pcl::ConcaveHull&lt; PointInT &gt;::performReconstruction()</a>, <a class="el" href="meta__registration_8hpp_source.html#l00052">pcl::registration::MetaRegistration&lt; PointT, Scalar &gt;::registerCloud()</a>, <a class="el" href="esf_8hpp_source.html#l00481">pcl::ESFEstimation&lt; PointInT, PointOutT &gt;::scale_points_unit_sphere()</a>, <a class="el" href="our__cvfh_8hpp_source.html#l00200">pcl::OURCVFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::sgurf()</a>, <a class="el" href="texture__mapping_8hpp_source.html#l00530">pcl::TextureMapping&lt; PointInT &gt;::sortFacesByCamera()</a>, <a class="el" href="texture__mapping_8hpp_source.html#l00702">pcl::TextureMapping&lt; PointInT &gt;::textureMeshwithMultipleCameras()</a>, <a class="el" href="transforms_8hpp_source.html#l00446">pcl::transformPointCloud()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00849">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::validateMatch()</a>, <a class="el" href="ia__fpcs_8hpp_source.html#l00881">pcl::registration::FPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::validateTransformation()</a>, and <a class="el" href="ia__kfpcs_8hpp_source.html#l00165">pcl::registration::KFPCSInitialAlignment&lt; PointSource, PointTarget, NormalT, Scalar &gt;::validateTransformation()</a>.</p>

</div>
</div>
<a id="ga52d532f7f2b4d7bba78d13701d3a33d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52d532f7f2b4d7bba78d13701d3a33d8">&#9670;&nbsp;</a></span>transformPointCloud() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/transforms.h&gt;</code></p>

<p>Apply an affine transform defined by an <a class="el" href="namespace_eigen.html">Eigen</a> Transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used with cloud_in equal to cloud_out </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8h_source.html#l00059">59</a> of file <a class="el" href="transforms_8h_source.html">transforms.h</a>.</p>

</div>
</div>
<a id="ga8602e00dcd5398692bc0582db76e1ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8602e00dcd5398692bc0582db76e1ef3">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z, normal_x, normal_y, normal_z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used with cloud_in equal to cloud_out </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00395">395</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="transforms_8hpp_source.html#l00091">pcl::detail::Transformer&lt; Scalar &gt;::se3()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, <a class="el" href="transforms_8hpp_source.html#l00079">pcl::detail::Transformer&lt; Scalar &gt;::so3()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="ga3a78021ef33dad9e3d44e6275768760b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a78021ef33dad9e3d44e6275768760b">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_indices.html">pcl::PointIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/transforms.h&gt;</code></p>

<p>Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>the set of point indices to use from the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z, normal_x, normal_y, normal_z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used with cloud_in equal to cloud_out </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8h_source.html#l00366">366</a> of file <a class="el" href="transforms_8h_source.html">transforms.h</a>.</p>

<p class="reference">References <a class="el" href="_point_indices_8h_source.html#l00020">pcl::PointIndices::indices</a>.</p>

</div>
</div>
<a id="ga1d67c0cd4ebb26d770c338d93884974a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d67c0cd4ebb26d770c338d93884974a">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>the translation component of the rigid transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>the rotation component of the rigid transformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z, normal_x, normal_y, normal_z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00460">460</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="transforms_8hpp_source.html#l00349">pcl::transformPointCloudWithNormals()</a>.</p>

</div>
</div>
<a id="ga01dcf9e24dec3109a0c8a8b8f2e24bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01dcf9e24dec3109a0c8a8b8f2e24bcc">&#9670;&nbsp;</a></span>transformPointCloudWithNormals() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::transformPointCloudWithNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloud_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_all_fields</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Transform a point cloud and rotate its normals using an <a class="el" href="namespace_eigen.html">Eigen</a> transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud_in</td><td>the input point cloud </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloud_out</td><td>the resultant output point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>an affine transformation (typically a rigid transformation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_all_fields</td><td>flag that controls whether the contents of the fields (other than x, y, z, normal_x, normal_y, normal_z) should be copied into the new transformed cloud </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be used with cloud_in equal to cloud_out </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00349">349</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00548">pcl::PointCloud&lt; PointT &gt;::assign()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00429">pcl::PointCloud&lt; PointT &gt;::begin()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00430">pcl::PointCloud&lt; PointT &gt;::end()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00392">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00400">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00403">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00445">pcl::PointCloud&lt; PointT &gt;::reserve()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00462">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="transforms_8hpp_source.html#l00091">pcl::detail::Transformer&lt; Scalar &gt;::se3()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::sensor_orientation_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00406">pcl::PointCloud&lt; PointT &gt;::sensor_origin_</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, <a class="el" href="transforms_8hpp_source.html#l00079">pcl::detail::Transformer&lt; Scalar &gt;::so3()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00398">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="icp_8hpp_source.html#l00314">pcl::IterativeClosestPointWithNormals&lt; PointSource, PointTarget, Scalar &gt;::transformCloud()</a>, and <a class="el" href="transforms_8hpp_source.html#l00460">pcl::transformPointCloudWithNormals()</a>.</p>

</div>
</div>
<a id="ga6eddef43d5bd5211fcbd774c87962314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eddef43d5bd5211fcbd774c87962314">&#9670;&nbsp;</a></span>transformPointWithNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> pcl::transformPointWithNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b.html">PointT</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, 3, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;pcl/common/impl/transforms.hpp&gt;</code></p>

<p>Transform a point with members x,y,z,normal_x,normal_y,normal_z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the point to transform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transform</td><td>the transformation to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transformed point </dd></dl>

<p class="definition">Definition at line <a class="el" href="transforms_8hpp_source.html#l00484">484</a> of file <a class="el" href="transforms_8hpp_source.html">transforms.hpp</a>.</p>

<p class="reference">References <a class="el" href="transforms_8hpp_source.html#l00091">pcl::detail::Transformer&lt; Scalar &gt;::se3()</a>, and <a class="el" href="transforms_8hpp_source.html#l00079">pcl::detail::Transformer&lt; Scalar &gt;::so3()</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Wed Oct 23 2024 10:17:06</p>
</div> <!-- #footer -->
</body>
</html>
