<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Writing a new PCL class &mdash; Point Cloud Library 1.14.1-dev documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Point Cloud Library
          </a>
              <div class="version">
                1.14.1-dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Writing a new PCL class</a></li>
<li><a class="reference internal" href="#advantages-why-contribute">Advantages: Why contribute?</a></li>
<li><a class="reference internal" href="#example-a-bilateral-filter">Example: a bilateral filter</a></li>
<li><a class="reference internal" href="#setting-up-the-structure">Setting up the structure</a><ul>
<li><a class="reference internal" href="#bilateral-h">bilateral.h</a></li>
<li><a class="reference internal" href="#bilateral-hpp">bilateral.hpp</a></li>
<li><a class="reference internal" href="#bilateral-cpp">bilateral.cpp</a></li>
<li><a class="reference internal" href="#cmakelists-txt">CMakeLists.txt</a></li>
</ul>
</li>
<li><a class="reference internal" href="#filling-in-the-class-structure">Filling in the class structure</a><ul>
<li><a class="reference internal" href="#id3">bilateral.cpp</a></li>
<li><a class="reference internal" href="#id4">bilateral.h</a></li>
<li><a class="reference internal" href="#id5">bilateral.hpp</a></li>
</ul>
</li>
<li><a class="reference internal" href="#taking-advantage-of-other-pcl-concepts">Taking advantage of other PCL concepts</a><ul>
<li><a class="reference internal" href="#point-indices">Point indices</a></li>
<li><a class="reference internal" href="#licenses">Licenses</a></li>
<li><a class="reference internal" href="#proper-naming">Proper naming</a></li>
<li><a class="reference internal" href="#code-comments">Code comments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-the-new-class">Testing the new class</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Point Cloud Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Writing a new PCL class</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="writing-a-new-pcl-class">
<span id="writing-new-classes"></span><h1><a class="toc-backref" href="#id6">Writing a new PCL class</a></h1>
<p>Converting code to a PCL-like mentality/syntax for someone that comes in
contact for the first time with our infrastructure might appear difficult, or
raise certain questions.</p>
<p>This short guide is to serve as both a HowTo and a FAQ for writing new PCL
classes, either from scratch, or by adapting old code.</p>
<p>Besides converting your code, this guide also explains some of the advantages
of contributing your code to an already existing open source project. Here, we
advocate for PCL, but you can certainly apply the same ideology to other
similar projects.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#writing-a-new-pcl-class" id="id6">Writing a new PCL class</a></p></li>
<li><p><a class="reference internal" href="#advantages-why-contribute" id="id7">Advantages: Why contribute?</a></p></li>
<li><p><a class="reference internal" href="#example-a-bilateral-filter" id="id8">Example: a bilateral filter</a></p></li>
<li><p><a class="reference internal" href="#setting-up-the-structure" id="id9">Setting up the structure</a></p>
<ul>
<li><p><a class="reference internal" href="#bilateral-h" id="id10">bilateral.h</a></p></li>
<li><p><a class="reference internal" href="#bilateral-hpp" id="id11">bilateral.hpp</a></p></li>
<li><p><a class="reference internal" href="#bilateral-cpp" id="id12">bilateral.cpp</a></p></li>
<li><p><a class="reference internal" href="#cmakelists-txt" id="id13">CMakeLists.txt</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#filling-in-the-class-structure" id="id14">Filling in the class structure</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id15">bilateral.cpp</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id16">bilateral.h</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id17">bilateral.hpp</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#taking-advantage-of-other-pcl-concepts" id="id18">Taking advantage of other PCL concepts</a></p>
<ul>
<li><p><a class="reference internal" href="#point-indices" id="id19">Point indices</a></p></li>
<li><p><a class="reference internal" href="#licenses" id="id20">Licenses</a></p></li>
<li><p><a class="reference internal" href="#proper-naming" id="id21">Proper naming</a></p></li>
<li><p><a class="reference internal" href="#code-comments" id="id22">Code comments</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#testing-the-new-class" id="id23">Testing the new class</a></p></li>
</ul>
</div>
</section>
<section id="advantages-why-contribute">
<h1><a class="toc-backref" href="#id7">Advantages: Why contribute?</a></h1>
<p>The first question that someone might ask and we would like to answer is:</p>
<p><em>Why contribute to PCL, as in what are its advantages?</em></p>
<p>This question assumes you’ve already identified that the set of tools and
libraries that PCL has to offer are useful for your project, so you have already
become an <em>user</em>.</p>
<p>Because open source projects are mostly voluntary efforts, usually with
developers geographically distributed around the world, it’s very common that
the development process has a certain <em>incremental</em>, and <em>iterative</em> flavor.
This means that:</p>
<blockquote>
<div><ul class="simple">
<li><p>it’s impossible for developers to think ahead of all the possible uses a new
piece of code they write might have, but also…</p></li>
<li><p>figuring out solutions for corner cases and applications where bugs might
occur is hard, and might not be desirable to tackle at the beginning, due to
limited resources (mostly a cost function of free time).</p></li>
</ul>
</div></blockquote>
<p>In both cases, everyone has definitely encountered situations where either an
algorithm/method that they need is missing, or an existing one is buggy.
Therefore the next natural step is obvious:</p>
<p><em>change the existing code to fit your application/problem</em>.</p>
<p>While we’re going to discuss how to do that in the next sections, we would
still like to provide an answer for the first question that we raised, namely
“why contribute?”.</p>
<p>In our opinion, there are many advantages. To quote Eric Raymond’s <em>Linus’s
Law</em>: <strong>“given enough eyeballs, all bugs are shallow”</strong>. What this means is
that by opening your code to the world, and allowing others to see it, the
chances of it getting fixed and optimized are higher, especially in the
presence of a dynamic community such as the one that PCL has.</p>
<p>In addition to the above, your contribution might enable, amongst many things:</p>
<blockquote>
<div><ul class="simple">
<li><p>others to create new work based on your code;</p></li>
<li><p>you to learn about new uses (e.g., thinks that you haven’t thought it could be used when you designed it);</p></li>
<li><p>worry-free maintainership (e.g., you can go away for some time, and then return and see your code still working. Others will take care of adapting it to the newest platforms, newest compilers, etc);</p></li>
<li><p>your reputation in the community to grow - everyone likes free stuff (!).</p></li>
</ul>
</div></blockquote>
<p>For most of us, all of the above apply. For others, only some (your mileage
might vary).</p>
</section>
<section id="example-a-bilateral-filter">
<span id="bilateral-filter-example"></span><h1><a class="toc-backref" href="#id8">Example: a bilateral filter</a></h1>
<p>To illustrate the code conversion process, we selected the following example:
apply a bilateral filter over intensity data from a given input point cloud,
and save the results to disk.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/point_types.h&gt;</span><span class="cp"></span>
<span class="linenos"> 2</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/io/pcd_io.h&gt;</span><span class="cp"></span>
<span class="linenos"> 3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree_flann.h&gt;</span><span class="cp"></span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="w"> </span><span class="k">typedef</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZI</span><span class="w"> </span><span class="n">PointT</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w"> </span><span class="kt">float</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w"> </span><span class="nf">G</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">sigma</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">10</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">));</span><span class="w"></span>
<span class="linenos">11</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="linenos">14</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="linenos">15</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">16</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">incloudfile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="linenos">17</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">outcloudfile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="linenos">18</span><span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">sigma_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atof</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">sigma_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atof</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="w">   </span><span class="c1">// Load cloud</span>
<span class="linenos">22</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">cloud</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">23</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">loadPCDFile</span><span class="w"> </span><span class="p">(</span><span class="n">incloudfile</span><span class="p">.</span><span class="n">c_str</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">cloud</span><span class="p">);</span><span class="w"></span>
<span class="linenos">24</span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">pnumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cloud</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="linenos">25</span>
<span class="linenos">26</span><span class="w">   </span><span class="c1">// Output Cloud = Input Cloud</span>
<span class="linenos">27</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outcloud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">cloud</span><span class="p">;</span><span class="w"></span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="w">   </span><span class="c1">// Set up KDTree</span>
<span class="linenos">30</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">31</span><span class="w">   </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span><span class="w"></span>
<span class="linenos">32</span>
<span class="linenos">33</span><span class="w">   </span><span class="c1">// Neighbors containers</span>
<span class="linenos">34</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_indices</span><span class="p">;</span><span class="w"></span>
<span class="linenos">35</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_distances</span><span class="p">;</span><span class="w"></span>
<span class="linenos">36</span>
<span class="linenos">37</span><span class="w">   </span><span class="c1">// Main Loop</span>
<span class="linenos">38</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">point_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">point_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pnumber</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">point_id</span><span class="p">)</span><span class="w"></span>
<span class="linenos">39</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">40</span><span class="w">     </span><span class="kt">float</span><span class="w"> </span><span class="n">BF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">41</span><span class="w">     </span><span class="kt">float</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">42</span>
<span class="linenos">43</span><span class="w">     </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">radiusSearch</span><span class="w"> </span><span class="p">(</span><span class="n">point_id</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sigma_s</span><span class="p">,</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="w">     </span><span class="c1">// For each neighbor</span>
<span class="linenos">46</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k_indices</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">n_id</span><span class="p">)</span><span class="w"></span>
<span class="linenos">47</span><span class="w">     </span><span class="p">{</span><span class="w"></span>
<span class="linenos">48</span><span class="w">       </span><span class="kt">float</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_indices</span><span class="p">.</span><span class="n">at</span><span class="w"> </span><span class="p">(</span><span class="n">n_id</span><span class="p">);</span><span class="w"></span>
<span class="linenos">49</span><span class="w">       </span><span class="kt">float</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="w"> </span><span class="p">(</span><span class="n">k_distances</span><span class="p">.</span><span class="n">at</span><span class="w"> </span><span class="p">(</span><span class="n">n_id</span><span class="p">));</span><span class="w"></span>
<span class="linenos">50</span><span class="w">       </span><span class="kt">float</span><span class="w"> </span><span class="n">intensity_dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">cloud</span><span class="p">)[</span><span class="n">point_id</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">cloud</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">);</span><span class="w"></span>
<span class="linenos">51</span>
<span class="linenos">52</span><span class="w">       </span><span class="kt">float</span><span class="w"> </span><span class="n">w_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_s</span><span class="p">);</span><span class="w"></span>
<span class="linenos">53</span><span class="w">       </span><span class="kt">float</span><span class="w"> </span><span class="n">w_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="p">(</span><span class="n">intensity_dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_r</span><span class="p">);</span><span class="w"></span>
<span class="linenos">54</span><span class="w">       </span><span class="kt">float</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w_a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w_b</span><span class="p">;</span><span class="w"></span>
<span class="linenos">55</span>
<span class="linenos">56</span><span class="w">       </span><span class="n">BF</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">cloud</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">;</span><span class="w"></span>
<span class="linenos">57</span><span class="w">       </span><span class="n">W</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span><span class="w"></span>
<span class="linenos">58</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">59</span>
<span class="linenos">60</span><span class="w">     </span><span class="n">outcloud</span><span class="p">[</span><span class="n">point_id</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BF</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">W</span><span class="p">;</span><span class="w"></span>
<span class="linenos">61</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">62</span>
<span class="linenos">63</span><span class="w">   </span><span class="c1">// Save filtered output</span>
<span class="linenos">64</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">savePCDFile</span><span class="w"> </span><span class="p">(</span><span class="n">outcloudfile</span><span class="p">.</span><span class="n">c_str</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="n">outcloud</span><span class="p">);</span><span class="w"></span>
<span class="linenos">65</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">66</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<dl class="simple">
<dt>The presented code snippet contains:</dt><dd><ul class="simple">
<li><p>an I/O component: lines 21-27 (reading data from disk), and 64 (writing data to disk)</p></li>
<li><p>an initialization component: lines 29-35 (setting up a search method for nearest neighbors using a KdTree)</p></li>
<li><p>the actual algorithmic component: lines 7-11 and 37-61</p></li>
</ul>
</dd>
</dl>
<p>Our goal here is to convert the algorithm given into an useful PCL class so that it can be reused elsewhere.</p>
</section>
<section id="setting-up-the-structure">
<h1><a class="toc-backref" href="#id9">Setting up the structure</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you’re not familiar with the PCL file structure already, please go ahead
and read the <a class="reference external" href="https://pcl.readthedocs.io/projects/advanced/en/latest/pcl_style_guide.html">PCL C++ Programming Style Guide</a> to
familiarize yourself with the concepts.</p>
</div>
<p>There’re two different ways we could set up the structure: i) set up the code
separately, as a standalone PCL class, but outside of the PCL code tree; or ii)
set up the files directly in the PCL code tree. Since our assumption is that
the end result will be contributed back to PCL, it’s best to concentrate on the
latter, also because it is a bit more complex (i.e., it involves a few
additional steps). You can obviously repeat these steps with the former case as
well, with the exception that you don’t need the files copied in the PCL tree,
nor you need the fancier <em>cmake</em> logic.</p>
<p>Assuming that we want the new algorithm to be part of the PCL Filtering library, we will begin by creating 3 different files under filters:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>include/pcl/filters/bilateral.h</em> - will contain all definitions;</p></li>
<li><p><em>include/pcl/filters/impl/bilateral.hpp</em> - will contain the templated implementations;</p></li>
<li><p><em>src/bilateral.cpp</em> - will contain the explicit template instantiations <a class="footnote-reference brackets" href="#id2" id="id1">*</a>.</p></li>
</ul>
</div></blockquote>
<p>We also need a name for our new class. Let’s call it <cite>BilateralFilter</cite>.</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">*</a></span></dt>
<dd><p>Some PCL filter algorithms provide two implementations: one for PointCloud&lt;T&gt; types and another one operating on legacy PCLPointCloud2 types. This is no longer required.</p>
</dd>
</dl>
<section id="bilateral-h">
<h2><a class="toc-backref" href="#id10">bilateral.h</a></h2>
<p>As previously mentioned, the <em>bilateral.h</em> header file will contain all the
definitions pertinent to the <cite>BilateralFilter</cite> class. Here’s a minimal
skeleton:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#pragma once</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/filter.h&gt;</span><span class="cp"></span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">pcl</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">   </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">BilateralFilter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">10</span><span class="w">   </span><span class="p">};</span><span class="w"></span>
<span class="linenos">11</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bilateral-hpp">
<h2><a class="toc-backref" href="#id11">bilateral.hpp</a></h2>
<p>While we’re at it, let’s set up two skeleton <em>bilateral.hpp</em> and
<em>bilateral.cpp</em> files as well. First, <em>bilateral.hpp</em>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="cp">#pragma once</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>This should be straightforward. We haven’t declared any methods for
<cite>BilateralFilter</cite> yet, therefore there is no implementation.</p>
</section>
<section id="bilateral-cpp">
<h2><a class="toc-backref" href="#id12">bilateral.cpp</a></h2>
<p>Let’s write <em>bilateral.cpp</em> too:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos">2</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/impl/bilateral.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Because we are writing templated code in PCL (1.x) where the template parameter
is a point type (see <a class="reference internal" href="adding_custom_ptype.html#adding-custom-ptype"><span class="std std-ref">Adding your own custom PointT type</span></a>), we want to explicitly
instantiate the most common use cases in <em>bilateral.cpp</em>, so that users don’t
have to spend extra cycles when compiling code that uses our
<cite>BilateralFilter</cite>. To do this, we need to access both the header
(<em>bilateral.h</em>) and the implementations (<em>bilateral.hpp</em>).</p>
</section>
<section id="cmakelists-txt">
<h2><a class="toc-backref" href="#id13">CMakeLists.txt</a></h2>
<p>Let’s add all the files to the PCL Filtering <em>CMakeLists.txt</em> file, so we can
enable the build.</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="c"># Find &quot;set (srcs&quot;, and add a new entry there, e.g.,</span>
<span class="linenos"> 2</span><span class="w"> </span><span class="nb">set</span> <span class="p">(</span><span class="s">srcs</span>
<span class="linenos"> 3</span><span class="w">      </span><span class="s">src/conditional_removal.cpp</span>
<span class="linenos"> 4</span><span class="w">      </span><span class="c"># ...</span>
<span class="linenos"> 5</span><span class="w">      </span><span class="s">src/bilateral.cpp</span>
<span class="linenos"> 6</span><span class="w">      </span><span class="p">)</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="w"> </span><span class="c"># Find &quot;set (incs&quot;, and add a new entry there, e.g.,</span>
<span class="linenos"> 9</span><span class="w"> </span><span class="nb">set</span> <span class="p">(</span><span class="s">incs</span>
<span class="linenos">10</span><span class="w">      </span><span class="s">include</span><span class="w"> </span><span class="s">pcl/</span><span class="o">${</span><span class="nv">SUBSYS_NAME</span><span class="o">}</span><span class="s">/conditional_removal.h</span>
<span class="linenos">11</span><span class="w">      </span><span class="c"># ...</span>
<span class="linenos">12</span><span class="w">      </span><span class="s">include</span><span class="w"> </span><span class="s">pcl/</span><span class="o">${</span><span class="nv">SUBSYS_NAME</span><span class="o">}</span><span class="s">/bilateral.h</span>
<span class="linenos">13</span><span class="w">      </span><span class="p">)</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="w"> </span><span class="c"># Find &quot;set (impl_incs&quot;, and add a new entry there, e.g.,</span>
<span class="linenos">16</span><span class="w"> </span><span class="nb">set</span> <span class="p">(</span><span class="s">impl_incs</span>
<span class="linenos">17</span><span class="w">      </span><span class="s">include/pcl/</span><span class="o">${</span><span class="nv">SUBSYS_NAME</span><span class="o">}</span><span class="s">/impl/conditional_removal.hpp</span>
<span class="linenos">18</span><span class="w">      </span><span class="c"># ...</span>
<span class="linenos">19</span><span class="w">      </span><span class="s">include/pcl/</span><span class="o">${</span><span class="nv">SUBSYS_NAME</span><span class="o">}</span><span class="s">/impl/bilateral.hpp</span>
<span class="linenos">20</span><span class="w">      </span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="filling-in-the-class-structure">
<span id="filling"></span><h1><a class="toc-backref" href="#id14">Filling in the class structure</a></h1>
<p>If you correctly edited all the files above, recompiling PCL using the new
filter classes in place should work without problems. In this section, we’ll
begin filling in the actual code in each file. Let’s start with the
<em>bilateral.cpp</em> file, as its content is the shortest.</p>
<section id="id3">
<h2><a class="toc-backref" href="#id15">bilateral.cpp</a></h2>
<p>As previously mentioned, we’re going to explicitly instantiate and
<em>precompile</em> a number of templated specializations for the <cite>BilateralFilter</cite>
class. While this might lead to an increased compilation time for the PCL
Filtering library, it will save users the pain of processing and compiling the
templates on their end, when they use the class in code they write. The
simplest possible way to do this would be to declare each instance that we want
to precompile by hand in the <em>bilateral.cpp</em> file as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/point_types.h&gt;</span><span class="cp"></span>
<span class="linenos">2</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos">3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/impl/bilateral.hpp&gt;</span><span class="cp"></span>
<span class="linenos">4</span>
<span class="linenos">5</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PCL_EXPORTS</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">6</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PCL_EXPORTS</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZI</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">7</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PCL_EXPORTS</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">8</span><span class="w"> </span><span class="c1">// ...</span>
</pre></div>
</div>
<p>However, this becomes cumbersome really fast, as the number of point types PCL
supports grows. Maintaining this list up to date in multiple files in PCL is
also painful. Therefore, we are going to use a special macro called
<cite>PCL_INSTANTIATE</cite> and change the above code as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/point_types.h&gt;</span><span class="cp"></span>
<span class="linenos">2</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/impl/instantiate.hpp&gt;</span><span class="cp"></span>
<span class="linenos">3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos">4</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/impl/bilateral.hpp&gt;</span><span class="cp"></span>
<span class="linenos">5</span>
<span class="linenos">6</span><span class="w"> </span><span class="n">PCL_INSTANTIATE</span><span class="p">(</span><span class="n">BilateralFilter</span><span class="p">,</span><span class="w"> </span><span class="n">PCL_XYZ_POINT_TYPES</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This example, will instantiate a <cite>BilateralFilter</cite> for all XYZ point types
defined in the <em>point_types.h</em> file (see
<span>PCL_XYZ_POINT_TYPES</span> for more information).</p>
<p>By looking closer at the code presented in <a class="reference internal" href="#bilateral-filter-example"><span class="std std-ref">Example: a bilateral filter</span></a>, we
notice constructs such as <cite>(*cloud)[point_id].intensity</cite>. This indicates
that our filter expects the presence of an <strong>intensity</strong> field in the point
type. Because of this, using <strong>PCL_XYZ_POINT_TYPES</strong> won’t work, as not all the
types defined there have intensity data present. In fact, it’s easy to notice
that only two of the types contain intensity, namely:
<a class="reference external" href="https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_i.html">PointXYZI</a> and
<a class="reference external" href="https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_i_normal.html">PointXYZINormal</a>. We therefore replace
<strong>PCL_XYZ_POINT_TYPES</strong> and the final <em>bilateral.cpp</em> file becomes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/point_types.h&gt;</span><span class="cp"></span>
<span class="linenos">2</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/impl/instantiate.hpp&gt;</span><span class="cp"></span>
<span class="linenos">3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos">4</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/impl/bilateral.hpp&gt;</span><span class="cp"></span>
<span class="linenos">5</span>
<span class="linenos">6</span><span class="w"> </span><span class="n">PCL_INSTANTIATE</span><span class="p">(</span><span class="n">BilateralFilter</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZI</span><span class="p">)(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZINormal</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>Note that at this point we haven’t declared the PCL_INSTANTIATE template for
<cite>BilateralFilter</cite>, nor did we actually implement the pure virtual functions in
the abstract class <a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_filter.html">pcl::Filter</a> so attempting to compile the
code will result in errors like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>filters/src/bilateral.cpp:6:32: error: expected constructor, destructor, or type conversion before ‘(’ token
</pre></div>
</div>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id16">bilateral.h</a></h2>
<p>We begin filling the <cite>BilateralFilter</cite> class by first declaring the
constructor, and its member variables. Because the bilateral filtering
algorithm has two parameters, we will store these as class members, and
implement setters and getters for them, to be compatible with the PCL 1.x API
paradigms.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">pcl</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">   </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">BilateralFilter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">     </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">       </span><span class="n">BilateralFilter</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">                            </span><span class="n">sigma_r_</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos">10</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">11</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">14</span><span class="w">       </span><span class="n">setSigmaS</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_s</span><span class="p">)</span><span class="w"></span>
<span class="linenos">15</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">16</span><span class="w">         </span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigma_s</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">20</span><span class="w">       </span><span class="n">getSigmaS</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="linenos">21</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">22</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">23</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">24</span>
<span class="linenos">25</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">26</span><span class="w">       </span><span class="n">setSigmaR</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_r</span><span class="p">)</span><span class="w"></span>
<span class="linenos">27</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">28</span><span class="w">         </span><span class="n">sigma_r_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigma_r</span><span class="p">;</span><span class="w"></span>
<span class="linenos">29</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">32</span><span class="w">       </span><span class="n">getSigmaR</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="linenos">33</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">34</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_r_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">35</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">36</span>
<span class="linenos">37</span><span class="w">     </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="linenos">38</span><span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_s_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">39</span><span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_r_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">40</span><span class="w">   </span><span class="p">};</span><span class="w"></span>
<span class="linenos">41</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">42</span>
<span class="linenos">43</span><span class="w"> </span><span class="cp">#endif </span><span class="c1">// PCL_FILTERS_BILATERAL_H_</span>
</pre></div>
</div>
<p>Nothing out of the ordinary so far, except maybe lines 8-9, where we gave some
default values to the two parameters. Because our class inherits from
<a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_filter.html">pcl::Filter</a>, and that inherits from
<a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_p_c_l_base.html">pcl::PCLBase</a>, we can make use of the
<a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">setInputCloud</a> method to pass the input data
to our algorithm (stored as <a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">input_</a>). We therefore
add an <cite>using</cite> declaration as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos">2</span><span class="w">   </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos">3</span><span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">BilateralFilter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos">4</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">5</span><span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">6</span><span class="w">     </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos">7</span><span class="w">       </span><span class="n">BilateralFilter</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">8</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>This will make sure that our class has access to the member variable <cite>input_</cite>
without typing the entire construct. Next, we observe that each class that
inherits from <a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_filter.html">pcl::Filter</a> must inherit a
<a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_filter.html#a1f703f36f50546e950f03af2453da623">applyFilter</a> method. We therefore define:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">     </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">PointCloud</span><span class="w"> </span><span class="n">PointCloud</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="w">     </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">       </span><span class="n">BilateralFilter</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">                            </span><span class="n">sigma_r_</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">12</span><span class="w">       </span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The implementation of <cite>applyFilter</cite> will be given in the <em>bilateral.hpp</em> file
later. Line 3 constructs a typedef so that we can use the type <cite>PointCloud</cite>
without typing the entire construct.</p>
<p>Looking at the original code from section <a class="reference internal" href="#bilateral-filter-example"><span class="std std-ref">Example: a bilateral filter</span></a>, we
notice that the algorithm consists of applying the same operation to every
point in the cloud. To keep the <cite>applyFilter</cite> call clean, we therefore define
method called <cite>computePointWeight</cite> whose implementation will contain the corpus
defined in between lines 45-58:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos">2</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">3</span><span class="w">       </span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">);</span><span class="w"></span>
<span class="linenos">4</span>
<span class="linenos">5</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">6</span><span class="w">       </span><span class="nf">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">7</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>In addition, we notice that lines 29-31 and 43 from section
<a class="reference internal" href="#bilateral-filter-example"><span class="std std-ref">Example: a bilateral filter</span></a> construct a <a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_kd_tree.html">KdTree</a>
structure for obtaining the nearest neighbors for a given point. We therefore
add:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree.h&gt;</span><span class="cp"></span>
<span class="linenos"> 2</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">     </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">PointCloud</span><span class="w"> </span><span class="n">PointCloud</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">     </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">pcl</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">KdTreePtr</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w">   </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">     </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">11</span><span class="w">     </span><span class="n">setSearchMethod</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">KdTreePtr</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tree</span><span class="p">)</span><span class="w"></span>
<span class="linenos">12</span><span class="w">     </span><span class="p">{</span><span class="w"></span>
<span class="linenos">13</span><span class="w">       </span><span class="n">tree_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span><span class="w"></span>
<span class="linenos">14</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">   </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="linenos">17</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos">18</span><span class="w">     </span><span class="n">KdTreePtr</span><span class="w"> </span><span class="n">tree_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">19</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>Finally, we would like to add the kernel method (<cite>G (float x, float sigma)</cite>)
inline so that we speed up the computation of the filter. Because the method is
only useful within the context of the algorithm, we will make it private. The
header file becomes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#pragma once</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/filter.h&gt;</span><span class="cp"></span>
<span class="linenos"> 4</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree.h&gt;</span><span class="cp"></span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">pcl</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">   </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">BilateralFilter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos">10</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">11</span><span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="w">     </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">PointCloud</span><span class="w"> </span><span class="n">PointCloud</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span><span class="w">     </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">pcl</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">KdTreePtr</span><span class="p">;</span><span class="w"></span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="w">     </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos">16</span><span class="w">       </span><span class="n">BilateralFilter</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">17</span><span class="w">                            </span><span class="n">sigma_r_</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos">18</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">19</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">23</span><span class="w">       </span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">);</span><span class="w"></span>
<span class="linenos">24</span>
<span class="linenos">25</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">26</span><span class="w">       </span><span class="nf">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">27</span>
<span class="linenos">28</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">29</span><span class="w">       </span><span class="nf">setSigmaS</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_s</span><span class="p">)</span><span class="w"></span>
<span class="linenos">30</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">31</span><span class="w">         </span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigma_s</span><span class="p">;</span><span class="w"></span>
<span class="linenos">32</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">33</span>
<span class="linenos">34</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">35</span><span class="w">       </span><span class="nf">getSigmaS</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="linenos">36</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">37</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">38</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">41</span><span class="w">       </span><span class="nf">setSigmaR</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_r</span><span class="p">)</span><span class="w"></span>
<span class="linenos">42</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">43</span><span class="w">         </span><span class="n">sigma_r_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigma_r</span><span class="p">;</span><span class="w"></span>
<span class="linenos">44</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">47</span><span class="w">       </span><span class="nf">getSigmaR</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="linenos">48</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">49</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_r_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">50</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">51</span>
<span class="linenos">52</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">53</span><span class="w">       </span><span class="nf">setSearchMethod</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">KdTreePtr</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tree</span><span class="p">)</span><span class="w"></span>
<span class="linenos">54</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">55</span><span class="w">         </span><span class="n">tree_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span><span class="w"></span>
<span class="linenos">56</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">57</span>
<span class="linenos">58</span>
<span class="linenos">59</span><span class="w">     </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="linenos">60</span>
<span class="linenos">61</span><span class="w">       </span><span class="kr">inline</span><span class="w"> </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">62</span><span class="w">       </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma</span><span class="p">)</span><span class="w"></span>
<span class="linenos">63</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">64</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">)));</span><span class="w"></span>
<span class="linenos">65</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">66</span>
<span class="linenos">67</span><span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_s_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">68</span><span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_r_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">69</span><span class="w">       </span><span class="n">KdTreePtr</span><span class="w"> </span><span class="n">tree_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">70</span><span class="w">   </span><span class="p">};</span><span class="w"></span>
<span class="linenos">71</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id17">bilateral.hpp</a></h2>
<p>There’re two methods that we need to implement here, namely <cite>applyFilter</cite> and
<cite>computePointWeight</cite>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">double</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">distances</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">BF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="w">   </span><span class="c1">// For each neighbor</span>
<span class="linenos"> 9</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">n_id</span><span class="p">)</span><span class="w"></span>
<span class="linenos">10</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">11</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="n">n_id</span><span class="p">];</span><span class="w"></span>
<span class="linenos">12</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="w"> </span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">n_id</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">13</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">intensity_dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">pid</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_s_</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="n">intensity_dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_r_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="w">     </span><span class="n">BF</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">;</span><span class="w"></span>
<span class="linenos">18</span><span class="w">     </span><span class="n">W</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span><span class="w"></span>
<span class="linenos">19</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">20</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">BF</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">W</span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">24</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="linenos">25</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">26</span><span class="w">   </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">27</span>
<span class="linenos">28</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_indices</span><span class="p">;</span><span class="w"></span>
<span class="linenos">29</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_distances</span><span class="p">;</span><span class="w"></span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="w">   </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">32</span>
<span class="linenos">33</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">point_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">point_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">point_id</span><span class="p">)</span><span class="w"></span>
<span class="linenos">34</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">35</span><span class="w">     </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">radiusSearch</span><span class="w"> </span><span class="p">(</span><span class="n">point_id</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">36</span>
<span class="linenos">37</span><span class="w">     </span><span class="n">output</span><span class="p">[</span><span class="n">point_id</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="n">point_id</span><span class="p">,</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">38</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <cite>computePointWeight</cite> method should be straightforward as it’s <em>almost
identical</em> to lines 45-58 from section <a class="reference internal" href="#bilateral-filter-example"><span class="std std-ref">Example: a bilateral filter</span></a>. We
basically pass in a point index that we want to compute the intensity weight
for, and a set of neighboring points with distances.</p>
<p>In <cite>applyFilter</cite>, we first set the input data in the tree, copy all the input
data into the output, and then proceed at computing the new weighted point
intensities.</p>
<p>Looking back at <a class="reference internal" href="#filling"><span class="std std-ref">Filling in the class structure</span></a>, it’s now time to declare the <cite>PCL_INSTANTIATE</cite>
entry for the class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="cp">#pragma once</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos">4</span>
<span class="linenos">5</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos">6</span>
<span class="linenos">7</span><span class="w"> </span><span class="cp">#define PCL_INSTANTIATE_BilateralFilter(T) template class PCL_EXPORTS pcl::BilateralFilter&lt;T&gt;;</span>
</pre></div>
</div>
<p>One additional thing that we can do is error checking on:</p>
<blockquote>
<div><ul class="simple">
<li><p>whether the two <cite>sigma_s_</cite> and <cite>sigma_r_</cite> parameters have been given;</p></li>
<li><p>whether the search method object (i.e., <cite>tree_</cite>) has been set.</p></li>
</ul>
</div></blockquote>
<p>For the former, we’re going to check the value of <cite>sigma_s_</cite>, which was set to
a default of 0, and has a critical importance for the behavior of the algorithm
(it basically defines the size of the support region). Therefore, if at the
execution of the code, its value is still 0, we will print an error using the
<span>PCL_ERROR</span> macro, and return.</p>
<p>In the case of the search method, we can either do the same, or be clever and
provide a default option for the user. The best default options are:</p>
<blockquote>
<div><ul class="simple">
<li><p>use an organized search method via <a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1search_1_1_organized_neighbor.html">pcl::search::OrganizedNeighbor</a> if the point cloud is organized;</p></li>
<li><p>use a general purpose kdtree via <a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_kd_tree_f_l_a_n_n.html">pcl::KdTreeFLANN</a> if the point cloud is unorganized.</p></li>
</ul>
</div></blockquote>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree_flann.h&gt;</span><span class="cp"></span>
<span class="linenos"> 2</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/organized_data.h&gt;</span><span class="cp"></span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">10</span><span class="w">     </span><span class="n">PCL_ERROR</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;[pcl::BilateralFilter::applyFilter] Need a sigma_s value given before continuing.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="w">     </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">13</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tree_</span><span class="p">)</span><span class="w"></span>
<span class="linenos">14</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">15</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">isOrganized</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos">16</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">OrganizedNeighbor</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">());</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="k">else</span><span class="w"></span>
<span class="linenos">18</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
<span class="linenos">19</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">20</span><span class="w">   </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The implementation file header thus becomes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#pragma once</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos"> 4</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree_flann.h&gt;</span><span class="cp"></span>
<span class="linenos"> 5</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/organized_data.h&gt;</span><span class="cp"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">double</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span><span class="w"></span>
<span class="linenos">10</span><span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">distances</span><span class="p">)</span><span class="w"></span>
<span class="linenos">11</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">BF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">   </span><span class="c1">// For each neighbor</span>
<span class="linenos">15</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">n_id</span><span class="p">)</span><span class="w"></span>
<span class="linenos">16</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="n">n_id</span><span class="p">];</span><span class="w"></span>
<span class="linenos">18</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="w"> </span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">n_id</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">intensity_dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">pid</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">);</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_s_</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="n">intensity_dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_r_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="w">     </span><span class="n">BF</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">;</span><span class="w"></span>
<span class="linenos">24</span><span class="w">     </span><span class="n">W</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">26</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">BF</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">W</span><span class="p">);</span><span class="w"></span>
<span class="linenos">27</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">30</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="linenos">31</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">32</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="linenos">33</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">34</span><span class="w">     </span><span class="n">PCL_ERROR</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;[pcl::BilateralFilter::applyFilter] Need a sigma_s value given before continuing.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">35</span><span class="w">     </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="linenos">36</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">37</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tree_</span><span class="p">)</span><span class="w"></span>
<span class="linenos">38</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">39</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">isOrganized</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos">40</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">OrganizedNeighbor</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">());</span><span class="w"></span>
<span class="linenos">41</span><span class="w">     </span><span class="k">else</span><span class="w"></span>
<span class="linenos">42</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
<span class="linenos">43</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">44</span><span class="w">   </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_indices</span><span class="p">;</span><span class="w"></span>
<span class="linenos">47</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_distances</span><span class="p">;</span><span class="w"></span>
<span class="linenos">48</span>
<span class="linenos">49</span><span class="w">   </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">50</span>
<span class="linenos">51</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">point_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">point_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">point_id</span><span class="p">)</span><span class="w"></span>
<span class="linenos">52</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">53</span><span class="w">     </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">radiusSearch</span><span class="w"> </span><span class="p">(</span><span class="n">point_id</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">54</span>
<span class="linenos">55</span><span class="w">     </span><span class="n">output</span><span class="p">[</span><span class="n">point_id</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="n">point_id</span><span class="p">,</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">56</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">57</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">58</span>
<span class="linenos">59</span><span class="w"> </span><span class="cp">#define PCL_INSTANTIATE_BilateralFilter(T) template class PCL_EXPORTS pcl::BilateralFilter&lt;T&gt;;</span>
</pre></div>
</div>
</section>
</section>
<section id="taking-advantage-of-other-pcl-concepts">
<h1><a class="toc-backref" href="#id18">Taking advantage of other PCL concepts</a></h1>
<section id="point-indices">
<h2><a class="toc-backref" href="#id19">Point indices</a></h2>
<p>The standard way of passing point cloud data into PCL algorithms is via
<a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">setInputCloud</a> calls. In addition, PCL also
defines a way to define a region of interest / <em>list of point indices</em> that the
algorithm should operate on, rather than the entire cloud, via
<a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">setIndices</a>.</p>
<p>All classes inheriting from <a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_p_c_l_base.html">PCLBase</a> exhibit the following
behavior: in case no set of indices is given by the user, a fake one is created
once and used for the duration of the algorithm. This means that we could
easily change the implementation code above to operate on a <em>&lt;cloud, indices&gt;</em>
tuple, which has the added advantage that if the user does pass a set of
indices, only those will be used, and if not, the entire cloud will be used.</p>
<p>The new <em>bilateral.hpp</em> class thus becomes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree_flann.h&gt;</span><span class="cp"></span>
<span class="linenos"> 2</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/organized_data.h&gt;</span><span class="cp"></span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">10</span><span class="w">     </span><span class="n">PCL_ERROR</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;[pcl::BilateralFilter::applyFilter] Need a sigma_s value given before continuing.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="w">     </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">13</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tree_</span><span class="p">)</span><span class="w"></span>
<span class="linenos">14</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">15</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">isOrganized</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos">16</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">OrganizedNeighbor</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">());</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="k">else</span><span class="w"></span>
<span class="linenos">18</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
<span class="linenos">19</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">20</span><span class="w">   </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The implementation file header thus becomes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#pragma once</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos"> 4</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree_flann.h&gt;</span><span class="cp"></span>
<span class="linenos"> 5</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/organized_data.h&gt;</span><span class="cp"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">double</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span><span class="w"></span>
<span class="linenos">10</span><span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">distances</span><span class="p">)</span><span class="w"></span>
<span class="linenos">11</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">BF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">   </span><span class="c1">// For each neighbor</span>
<span class="linenos">15</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">n_id</span><span class="p">)</span><span class="w"></span>
<span class="linenos">16</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="n">n_id</span><span class="p">];</span><span class="w"></span>
<span class="linenos">18</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="w"> </span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">n_id</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">intensity_dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">pid</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">);</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_s_</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="n">intensity_dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_r_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="w">     </span><span class="n">BF</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">;</span><span class="w"></span>
<span class="linenos">24</span><span class="w">     </span><span class="n">W</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">26</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">BF</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">W</span><span class="p">);</span><span class="w"></span>
<span class="linenos">27</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">30</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="linenos">31</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">32</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="linenos">33</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">34</span><span class="w">     </span><span class="n">PCL_ERROR</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;[pcl::BilateralFilter::applyFilter] Need a sigma_s value given before continuing.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">35</span><span class="w">     </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="linenos">36</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">37</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tree_</span><span class="p">)</span><span class="w"></span>
<span class="linenos">38</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">39</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">isOrganized</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos">40</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">OrganizedNeighbor</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">());</span><span class="w"></span>
<span class="linenos">41</span><span class="w">     </span><span class="k">else</span><span class="w"></span>
<span class="linenos">42</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
<span class="linenos">43</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">44</span><span class="w">   </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_indices</span><span class="p">;</span><span class="w"></span>
<span class="linenos">47</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_distances</span><span class="p">;</span><span class="w"></span>
<span class="linenos">48</span>
<span class="linenos">49</span><span class="w">   </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">50</span>
<span class="linenos">51</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">indices_</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="linenos">52</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">53</span><span class="w">     </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">radiusSearch</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">indices_</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">54</span>
<span class="linenos">55</span><span class="w">     </span><span class="n">output</span><span class="p">[(</span><span class="o">*</span><span class="n">indices_</span><span class="p">)[</span><span class="n">i</span><span class="p">]].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computePointWeight</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">indices_</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">56</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">57</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">58</span>
<span class="linenos">59</span><span class="w"> </span><span class="cp">#define PCL_INSTANTIATE_BilateralFilter(T) template class PCL_EXPORTS pcl::BilateralFilter&lt;T&gt;;</span>
</pre></div>
</div>
<p>To make <a class="reference external" href="https://pointclouds.org/documentation/classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">indices_</a> work without typing the full
construct, we need to add a new line to <em>bilateral.h</em> that specifies the class
where <cite>indices_</cite> is declared:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="linenos">2</span><span class="w">   </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos">3</span><span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">BilateralFilter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos">4</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">5</span><span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">6</span><span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">indices_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">7</span><span class="w">     </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos">8</span><span class="w">       </span><span class="n">BilateralFilter</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">9</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="licenses">
<h2><a class="toc-backref" href="#id20">Licenses</a></h2>
<p>It is advised that each file contains a license that describes the author of
the code. This is very useful for our users that need to understand what sort
of restrictions are they bound to when using the code. PCL is 100% <strong>BSD
licensed</strong>, and we insert the corpus of the license as a C++ comment in the
file, as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="cm">/*</span>
<span class="linenos">2</span><span class="cm">* SPDX-License-Identifier: BSD-3-Clause</span>
<span class="linenos">3</span><span class="cm">*</span>
<span class="linenos">4</span><span class="cm">*  Point Cloud Library (PCL) - www.pointclouds.org</span>
<span class="linenos">5</span><span class="cm">*  Copyright (c) 2014-, Open Perception Inc.</span>
<span class="linenos">6</span><span class="cm">*</span>
<span class="linenos">7</span><span class="cm">*  All rights reserved</span>
<span class="linenos">8</span><span class="cm">*/</span><span class="w"></span>
</pre></div>
</div>
<p>An additional line can be inserted if additional copyright is needed (or the
original copyright can be changed):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Copyright</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">XXX</span><span class="p">,</span><span class="w"> </span><span class="n">respective</span><span class="w"> </span><span class="n">authors</span><span class="p">.</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="proper-naming">
<h2><a class="toc-backref" href="#id21">Proper naming</a></h2>
<p>We wrote the tutorial so far by using <em>silly named</em> setters and getters in our
example, like <cite>setSigmaS</cite> or <cite>setSigmaR</cite>. In reality, we would like to use a
better naming scheme, that actually represents what the parameter is doing. In
a final version of the code we could therefore rename the setters and getters
to <cite>set/getHalfSize</cite> and <cite>set/getStdDev</cite> or something similar.</p>
</section>
<section id="code-comments">
<h2><a class="toc-backref" href="#id22">Code comments</a></h2>
<p>PCL is trying to maintain a <em>high standard</em> with respect to user and API
documentation. This sort of Doxygen documentation has been stripped from the
examples shown above. In reality, we would have had the <em>bilateral.h</em> header
class look like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="cm">/*</span>
<span class="linenos">  2</span><span class="cm">* SPDX-License-Identifier: BSD-3-Clause</span>
<span class="linenos">  3</span><span class="cm">*</span>
<span class="linenos">  4</span><span class="cm">*  Point Cloud Library (PCL) - www.pointclouds.org</span>
<span class="linenos">  5</span><span class="cm">*  Copyright (c) 2014-, Open Perception Inc.</span>
<span class="linenos">  6</span><span class="cm">*</span>
<span class="linenos">  7</span><span class="cm">*  All rights reserved</span>
<span class="linenos">  8</span><span class="cm">*/</span><span class="w"></span>
<span class="linenos">  9</span>
<span class="linenos"> 10</span><span class="w"> </span><span class="cp">#pragma once</span>
<span class="linenos"> 11</span>
<span class="linenos"> 12</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/filter.h&gt;</span><span class="cp"></span>
<span class="linenos"> 13</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree.h&gt;</span><span class="cp"></span>
<span class="linenos"> 14</span>
<span class="linenos"> 15</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">pcl</span><span class="w"></span>
<span class="linenos"> 16</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 17</span><span class="w">   </span><span class="cm">/** \brief A bilateral filter implementation for point cloud data. Uses the intensity data channel.</span>
<span class="linenos"> 18</span><span class="cm">     * \note For more information please see</span>
<span class="linenos"> 19</span><span class="cm">     * &lt;b&gt;C. Tomasi and R. Manduchi. Bilateral Filtering for Gray and Color Images.</span>
<span class="linenos"> 20</span><span class="cm">     * In Proceedings of the IEEE International Conference on Computer Vision,</span>
<span class="linenos"> 21</span><span class="cm">     * 1998.&lt;/b&gt;</span>
<span class="linenos"> 22</span><span class="cm">     * \author Luca Penasa</span>
<span class="linenos"> 23</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos"> 24</span><span class="w">   </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos"> 25</span><span class="w">   </span><span class="k">class</span><span class="w"> </span><span class="nc">BilateralFilter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="linenos"> 26</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 27</span><span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 28</span><span class="w">     </span><span class="k">using</span><span class="w"> </span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">indices_</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 29</span><span class="w">     </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">PointCloud</span><span class="w"> </span><span class="n">PointCloud</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 30</span><span class="w">     </span><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">pcl</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">KdTreePtr</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 31</span>
<span class="linenos"> 32</span><span class="w">     </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos"> 33</span><span class="w">       </span><span class="cm">/** \brief Constructor.</span>
<span class="linenos"> 34</span><span class="cm">         * Sets \ref sigma_s_ to 0 and \ref sigma_r_ to MAXDBL</span>
<span class="linenos"> 35</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos"> 36</span><span class="w">       </span><span class="n">BilateralFilter</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos"> 37</span><span class="w">                            </span><span class="n">sigma_r_</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos"> 38</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 39</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 40</span>
<span class="linenos"> 41</span>
<span class="linenos"> 42</span><span class="w">       </span><span class="cm">/** \brief Filter the input data and store the results into output</span>
<span class="linenos"> 43</span><span class="cm">         * \param[out] output the resultant point cloud message</span>
<span class="linenos"> 44</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos"> 45</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos"> 46</span><span class="w">       </span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 47</span>
<span class="linenos"> 48</span><span class="w">       </span><span class="cm">/** \brief Compute the intensity average for a single point</span>
<span class="linenos"> 49</span><span class="cm">         * \param[in] pid the point index to compute the weight for</span>
<span class="linenos"> 50</span><span class="cm">         * \param[in] indices the set of nearest neighbor indices</span>
<span class="linenos"> 51</span><span class="cm">         * \param[in] distances the set of nearest neighbor distances</span>
<span class="linenos"> 52</span><span class="cm">         * \return the intensity average at a given point index</span>
<span class="linenos"> 53</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos"> 54</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos"> 55</span><span class="w">       </span><span class="nf">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 56</span>
<span class="linenos"> 57</span><span class="w">       </span><span class="cm">/** \brief Set the half size of the Gaussian bilateral filter window.</span>
<span class="linenos"> 58</span><span class="cm">         * \param[in] sigma_s the half size of the Gaussian bilateral filter window to use</span>
<span class="linenos"> 59</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos"> 60</span><span class="w">       </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="linenos"> 61</span><span class="w">       </span><span class="nf">setHalfSize</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_s</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 62</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 63</span><span class="w">         </span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigma_s</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 64</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 65</span>
<span class="linenos"> 66</span><span class="w">       </span><span class="cm">/** \brief Get the half size of the Gaussian bilateral filter window as set by the user. */</span><span class="w"></span>
<span class="linenos"> 67</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos"> 68</span><span class="w">       </span><span class="nf">getHalfSize</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="linenos"> 69</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 70</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s_</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 71</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 72</span>
<span class="linenos"> 73</span><span class="w">       </span><span class="cm">/** \brief Set the standard deviation parameter</span>
<span class="linenos"> 74</span><span class="cm">         * \param[in] sigma_r the new standard deviation parameter</span>
<span class="linenos"> 75</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos"> 76</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos"> 77</span><span class="w">       </span><span class="nf">setStdDev</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_r</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 78</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 79</span><span class="w">         </span><span class="n">sigma_r_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigma_r</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 80</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 81</span>
<span class="linenos"> 82</span><span class="w">       </span><span class="cm">/** \brief Get the value of the current standard deviation parameter of the bilateral filter. */</span><span class="w"></span>
<span class="linenos"> 83</span><span class="w">       </span><span class="kt">double</span><span class="w"></span>
<span class="linenos"> 84</span><span class="w">       </span><span class="nf">getStdDev</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="linenos"> 85</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 86</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_r_</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 87</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 88</span>
<span class="linenos"> 89</span><span class="w">       </span><span class="cm">/** \brief Provide a pointer to the search object.</span>
<span class="linenos"> 90</span><span class="cm">         * \param[in] tree a pointer to the spatial search object.</span>
<span class="linenos"> 91</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos"> 92</span><span class="w">       </span><span class="kt">void</span><span class="w"></span>
<span class="linenos"> 93</span><span class="w">       </span><span class="nf">setSearchMethod</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">KdTreePtr</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tree</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 94</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 95</span><span class="w">         </span><span class="n">tree_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 96</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 97</span>
<span class="linenos"> 98</span><span class="w">     </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="linenos"> 99</span>
<span class="linenos">100</span><span class="w">       </span><span class="cm">/** \brief The bilateral filter Gaussian distance kernel.</span>
<span class="linenos">101</span><span class="cm">         * \param[in] x the spatial distance (distance or intensity)</span>
<span class="linenos">102</span><span class="cm">         * \param[in] sigma standard deviation</span>
<span class="linenos">103</span><span class="cm">         */</span><span class="w"></span>
<span class="linenos">104</span><span class="w">       </span><span class="kr">inline</span><span class="w"> </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">105</span><span class="w">       </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma</span><span class="p">)</span><span class="w"></span>
<span class="linenos">106</span><span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="linenos">107</span><span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="p">)));</span><span class="w"></span>
<span class="linenos">108</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="linenos">109</span>
<span class="linenos">110</span><span class="w">       </span><span class="cm">/** \brief The half size of the Gaussian bilateral filter window (e.g., spatial extents in Euclidean). */</span><span class="w"></span>
<span class="linenos">111</span><span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_s_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">112</span><span class="w">       </span><span class="cm">/** \brief The standard deviation of the bilateral filter (e.g., standard deviation in intensity). */</span><span class="w"></span>
<span class="linenos">113</span><span class="w">       </span><span class="kt">double</span><span class="w"> </span><span class="n">sigma_r_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">114</span>
<span class="linenos">115</span><span class="w">       </span><span class="cm">/** \brief A pointer to the spatial search object. */</span><span class="w"></span>
<span class="linenos">116</span><span class="w">       </span><span class="n">KdTreePtr</span><span class="w"> </span><span class="n">tree_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">117</span><span class="w">   </span><span class="p">};</span><span class="w"></span>
<span class="linenos">118</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>And the <em>bilateral.hpp</em> likes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cm">/*</span>
<span class="linenos"> 2</span><span class="cm">* SPDX-License-Identifier: BSD-3-Clause</span>
<span class="linenos"> 3</span><span class="cm">*</span>
<span class="linenos"> 4</span><span class="cm">*  Point Cloud Library (PCL) - www.pointclouds.org</span>
<span class="linenos"> 5</span><span class="cm">*  Copyright (c) 2014-, Open Perception Inc.</span>
<span class="linenos"> 6</span><span class="cm">*</span>
<span class="linenos"> 7</span><span class="cm">*  All rights reserved</span>
<span class="linenos"> 8</span><span class="cm">*/</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w"> </span><span class="cp">#pragma once</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos">13</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree_flann.h&gt;</span><span class="cp"></span>
<span class="linenos">14</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/organized_data.h&gt;</span><span class="cp"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w"> </span><span class="c1">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="linenos">17</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">double</span><span class="w"></span>
<span class="linenos">18</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">computePointWeight</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"></span>
<span class="linenos">19</span><span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span><span class="w"></span>
<span class="linenos">20</span><span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">distances</span><span class="p">)</span><span class="w"></span>
<span class="linenos">21</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">22</span><span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">BF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="w">   </span><span class="c1">// For each neighbor</span>
<span class="linenos">25</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">n_id</span><span class="p">)</span><span class="w"></span>
<span class="linenos">26</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">27</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="n">n_id</span><span class="p">];</span><span class="w"></span>
<span class="linenos">28</span><span class="w">     </span><span class="c1">// Compute the difference in intensity</span>
<span class="linenos">29</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">intensity_dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">pid</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">);</span><span class="w"></span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="w">     </span><span class="c1">// Compute the Gaussian intensity weights both in Euclidean and in intensity space</span>
<span class="linenos">32</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="w"> </span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">n_id</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">33</span><span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_s_</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="p">(</span><span class="n">intensity_dist</span><span class="p">,</span><span class="w"> </span><span class="n">sigma_r_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">34</span>
<span class="linenos">35</span><span class="w">     </span><span class="c1">// Calculate the bilateral filter response</span>
<span class="linenos">36</span><span class="w">     </span><span class="n">BF</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">)[</span><span class="n">id</span><span class="p">].</span><span class="n">intensity</span><span class="p">;</span><span class="w"></span>
<span class="linenos">37</span><span class="w">     </span><span class="n">W</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span><span class="w"></span>
<span class="linenos">38</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">39</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">BF</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">W</span><span class="p">);</span><span class="w"></span>
<span class="linenos">40</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="w"> </span><span class="c1">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="linenos">43</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="linenos">44</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">applyFilter</span><span class="w"> </span><span class="p">(</span><span class="n">PointCloud</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="linenos">45</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">46</span><span class="w">   </span><span class="c1">// Check if sigma_s has been given by the user</span>
<span class="linenos">47</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="linenos">48</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">49</span><span class="w">     </span><span class="n">PCL_ERROR</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;[pcl::BilateralFilter::applyFilter] Need a sigma_s value given before continuing.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">50</span><span class="w">     </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="linenos">51</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">52</span><span class="w">   </span><span class="c1">// In case a search method has not been given, initialize it using some defaults</span>
<span class="linenos">53</span><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tree_</span><span class="p">)</span><span class="w"></span>
<span class="linenos">54</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">55</span><span class="w">     </span><span class="c1">// For organized datasets, use an OrganizedNeighbor</span>
<span class="linenos">56</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">isOrganized</span><span class="w"> </span><span class="p">())</span><span class="w"></span>
<span class="linenos">57</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">OrganizedNeighbor</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">());</span><span class="w"></span>
<span class="linenos">58</span><span class="w">     </span><span class="c1">// For unorganized data, use a FLANN kdtree</span>
<span class="linenos">59</span><span class="w">     </span><span class="k">else</span><span class="w"></span>
<span class="linenos">60</span><span class="w">       </span><span class="n">tree_</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
<span class="linenos">61</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">62</span><span class="w">   </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">input_</span><span class="p">);</span><span class="w"></span>
<span class="linenos">63</span>
<span class="linenos">64</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_indices</span><span class="p">;</span><span class="w"></span>
<span class="linenos">65</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_distances</span><span class="p">;</span><span class="w"></span>
<span class="linenos">66</span>
<span class="linenos">67</span><span class="w">   </span><span class="c1">// Copy the input data into the output</span>
<span class="linenos">68</span><span class="w">   </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">input_</span><span class="p">;</span><span class="w"></span>
<span class="linenos">69</span>
<span class="linenos">70</span><span class="w">   </span><span class="c1">// For all the indices given (equal to the entire cloud if none given)</span>
<span class="linenos">71</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">indices_</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="linenos">72</span><span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="linenos">73</span><span class="w">     </span><span class="c1">// Perform a radius search to find the nearest neighbors</span>
<span class="linenos">74</span><span class="w">     </span><span class="n">tree_</span><span class="o">-&gt;</span><span class="n">radiusSearch</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">indices_</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">sigma_s_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">75</span>
<span class="linenos">76</span><span class="w">     </span><span class="c1">// Overwrite the intensity value with the computed average</span>
<span class="linenos">77</span><span class="w">     </span><span class="n">output</span><span class="p">[(</span><span class="o">*</span><span class="n">indices_</span><span class="p">)[</span><span class="n">i</span><span class="p">]].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computePointWeight</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">indices_</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="n">k_distances</span><span class="p">);</span><span class="w"></span>
<span class="linenos">78</span><span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="linenos">79</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos">80</span>
<span class="linenos">81</span><span class="w"> </span><span class="cp">#define PCL_INSTANTIATE_BilateralFilter(T) template class PCL_EXPORTS pcl::BilateralFilter&lt;T&gt;;</span>
</pre></div>
</div>
</section>
</section>
<section id="testing-the-new-class">
<h1><a class="toc-backref" href="#id23">Testing the new class</a></h1>
<p>Testing the new class is easy. We’ll take the first code snippet example as
shown above, strip the algorithm, and make it use the <cite>pcl::BilateralFilter</cite>
class instead:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/point_types.h&gt;</span><span class="cp"></span>
<span class="linenos"> 2</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/io/pcd_io.h&gt;</span><span class="cp"></span>
<span class="linenos"> 3</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/kdtree/kdtree_flann.h&gt;</span><span class="cp"></span>
<span class="linenos"> 4</span><span class="w"> </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/bilateral.h&gt;</span><span class="cp"></span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w"> </span><span class="k">typedef</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZI</span><span class="w"> </span><span class="n">PointT</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="linenos">10</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">11</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">incloudfile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="linenos">12</span><span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">outcloudfile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="linenos">13</span><span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">sigma_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atof</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">14</span><span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">sigma_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atof</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">   </span><span class="c1">// Load cloud</span>
<span class="linenos">17</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">cloud</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">loadPCDFile</span><span class="w"> </span><span class="p">(</span><span class="n">incloudfile</span><span class="p">.</span><span class="n">c_str</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">cloud</span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outcloud</span><span class="p">;</span><span class="w"></span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="w">   </span><span class="c1">// Set up KDTree</span>
<span class="linenos">23</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">24</span>
<span class="linenos">25</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">BilateralFilter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bf</span><span class="p">;</span><span class="w"></span>
<span class="linenos">26</span><span class="w">   </span><span class="n">bf</span><span class="p">.</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span><span class="w"></span>
<span class="linenos">27</span><span class="w">   </span><span class="n">bf</span><span class="p">.</span><span class="n">setSearchMethod</span><span class="w"> </span><span class="p">(</span><span class="n">tree</span><span class="p">);</span><span class="w"></span>
<span class="linenos">28</span><span class="w">   </span><span class="n">bf</span><span class="p">.</span><span class="n">setHalfSize</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_s</span><span class="p">);</span><span class="w"></span>
<span class="linenos">29</span><span class="w">   </span><span class="n">bf</span><span class="p">.</span><span class="n">setStdDev</span><span class="w"> </span><span class="p">(</span><span class="n">sigma_r</span><span class="p">);</span><span class="w"></span>
<span class="linenos">30</span><span class="w">   </span><span class="n">bf</span><span class="p">.</span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="n">outcloud</span><span class="p">);</span><span class="w"></span>
<span class="linenos">31</span>
<span class="linenos">32</span><span class="w">   </span><span class="c1">// Save filtered output</span>
<span class="linenos">33</span><span class="w">   </span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">savePCDFile</span><span class="w"> </span><span class="p">(</span><span class="n">outcloudfile</span><span class="p">.</span><span class="n">c_str</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="n">outcloud</span><span class="p">);</span><span class="w"></span>
<span class="linenos">34</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">35</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>