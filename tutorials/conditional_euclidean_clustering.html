<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Conditional Euclidean Clustering &mdash; Point Cloud Library 1.14.1-dev documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Point Cloud Library
          </a>
              <div class="version">
                1.14.1-dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Conditional Euclidean Clustering</a></li>
<li><a class="reference internal" href="#theoretical-primer">Theoretical Primer</a></li>
<li><a class="reference internal" href="#the-code">The Code</a></li>
<li><a class="reference internal" href="#the-explanation">The Explanation</a></li>
<li><a class="reference internal" href="#compiling-and-running-the-program">Compiling and running the program</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Point Cloud Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Conditional Euclidean Clustering</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="conditional-euclidean-clustering">
<span id="id1"></span><h1>Conditional Euclidean Clustering</h1>
<p>This tutorial describes how to use the <code class="docutils literal notranslate"><span class="pre">pcl::ConditionalEuclideanClustering</span></code> class:
A segmentation algorithm that clusters points based on Euclidean distance and a user-customizable condition that needs to hold.</p>
<p>This class uses the same greedy-like / region-growing / flood-filling approach that is used in <a class="reference internal" href="cluster_extraction.html#cluster-extraction"><span class="std std-ref">Euclidean Cluster Extraction</span></a>, <a class="reference internal" href="region_growing_segmentation.html#region-growing-segmentation"><span class="std std-ref">Region growing segmentation</span></a> and <a class="reference internal" href="region_growing_rgb_segmentation.html#region-growing-rgb-segmentation"><span class="std std-ref">Color-based region growing segmentation</span></a>.
The advantage of using this class over the other classes is that the constraints for clustering (pure Euclidean, smoothness, RGB) are now customizable by the user.
Some disadvantages include: no initial seeding system, no over- and under-segmentation control, and the fact that calling a conditional function from inside the main computational loop is less time efficient.</p>
</section>
<section id="theoretical-primer">
<h1>Theoretical Primer</h1>
<p>The <a class="reference internal" href="cluster_extraction.html#cluster-extraction"><span class="std std-ref">Euclidean Cluster Extraction</span></a> and <a class="reference internal" href="region_growing_segmentation.html#region-growing-segmentation"><span class="std std-ref">Region growing segmentation</span></a> tutorials already explain the region growing algorithm very accurately.
The only addition to those explanations is that the condition that needs to hold for a neighbor to be merged into the current cluster, can now be fully customized.</p>
<p>As a cluster grows, it will evaluate the user-defined condition between points already inside the cluster and nearby candidate points.
The candidate points (nearest neighbor points) are found using a Euclidean radius search around each point in the cluster.
For each point within a resulting cluster, the condition needed to hold with at least one of its neighbors and NOT with all of its neighbors.</p>
<p>The Conditional Euclidean Clustering class can also automatically filter clusters based on a size constraint.
The clusters classified as too small or too large can still be retrieved afterwards.</p>
</section>
<section id="the-code">
<h1>The Code</h1>
<p>First, download the dataset <a class="reference external" href="https://sourceforge.net/projects/pointclouds/files/PCDdatasets/Trimble/Outdoor1/Statues_4.pcd.zip">Statues_4.pcd</a> and extract the PCD file from the archive.
This is a very large data set of an outdoor environment where we aim to cluster the separate objects and also want to separate the building from the ground plane even though it is attached in a Euclidean sense.</p>
<p>Now create a file, letâ€™s say, <code class="docutils literal notranslate"><span class="pre">conditional_euclidean_clustering.cpp</span></code> in your favorite editor, and place the following inside it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/point_types.h&gt;</span><span class="cp"></span>
<span class="linenos">  2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/io/pcd_io.h&gt;</span><span class="cp"></span>
<span class="linenos">  3</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/console/time.h&gt;</span><span class="cp"></span>
<span class="linenos">  4</span>
<span class="linenos">  5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/filters/voxel_grid.h&gt;</span><span class="cp"></span>
<span class="linenos">  6</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/features/normal_3d.h&gt;</span><span class="cp"></span>
<span class="linenos">  7</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pcl/segmentation/conditional_euclidean_clustering.h&gt;</span><span class="cp"></span>
<span class="linenos">  8</span>
<span class="linenos">  9</span><span class="k">typedef</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZI</span><span class="w"> </span><span class="n">PointTypeIO</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 10</span><span class="k">typedef</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZINormal</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 11</span>
<span class="linenos"> 12</span><span class="kt">bool</span><span class="w"></span>
<span class="linenos"> 13</span><span class="nf">enforceIntensitySimilarity</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_b</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="cm">/*squared_distance*/</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 14</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 15</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a</span><span class="p">.</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">intensity</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 16</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 17</span><span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="linenos"> 18</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 19</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 20</span>
<span class="linenos"> 21</span><span class="kt">bool</span><span class="w"></span>
<span class="linenos"> 22</span><span class="nf">enforceNormalOrIntensitySimilarity</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_b</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="cm">/*squared_distance*/</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 23</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 24</span><span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">&gt;</span><span class="w"> </span><span class="n">point_a_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_a</span><span class="p">.</span><span class="n">getNormalVector3fMap</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="n">point_b_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">getNormalVector3fMap</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="linenos"> 25</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a</span><span class="p">.</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">intensity</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 26</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 27</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a_normal</span><span class="p">.</span><span class="n">dot</span><span class="w"> </span><span class="p">(</span><span class="n">point_b_normal</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="w"> </span><span class="p">(</span><span class="mf">30.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">180.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">M_PI</span><span class="p">)))</span><span class="w"></span>
<span class="linenos"> 28</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 29</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 30</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 31</span>
<span class="linenos"> 32</span><span class="kt">bool</span><span class="w"></span>
<span class="linenos"> 33</span><span class="nf">customRegionGrowing</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_b</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">squared_distance</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 34</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 35</span><span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">&gt;</span><span class="w"> </span><span class="n">point_a_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_a</span><span class="p">.</span><span class="n">getNormalVector3fMap</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="n">point_b_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">getNormalVector3fMap</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="linenos"> 36</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">squared_distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 37</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 38</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a</span><span class="p">.</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">intensity</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">8.0f</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 39</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 40</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a_normal</span><span class="p">.</span><span class="n">dot</span><span class="w"> </span><span class="p">(</span><span class="n">point_b_normal</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="w"> </span><span class="p">(</span><span class="mf">30.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">180.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">M_PI</span><span class="p">)))</span><span class="w"></span>
<span class="linenos"> 41</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 42</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 43</span><span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="linenos"> 44</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 45</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a</span><span class="p">.</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">intensity</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 46</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 47</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 48</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 49</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 50</span>
<span class="linenos"> 51</span><span class="kt">int</span><span class="w"></span>
<span class="linenos"> 52</span><span class="nf">main</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="linenos"> 53</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 54</span><span class="w">  </span><span class="c1">// Data containers used</span>
<span class="linenos"> 55</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointTypeIO</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">cloud_in</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointTypeIO</span><span class="o">&gt;</span><span class="p">),</span><span class="w"> </span><span class="n">cloud_out</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointTypeIO</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 56</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointTypeFull</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">cloud_with_normals</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointTypeFull</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 57</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">IndicesClustersPtr</span><span class="w"> </span><span class="n">clusters</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">IndicesClusters</span><span class="p">),</span><span class="w"> </span><span class="n">small_clusters</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">IndicesClusters</span><span class="p">),</span><span class="w"> </span><span class="n">large_clusters</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">IndicesClusters</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 58</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">search</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">PointTypeIO</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">search_tree</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">search</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">PointTypeIO</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 59</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">TicToc</span><span class="w"> </span><span class="n">tt</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 60</span>
<span class="linenos"> 61</span><span class="w">  </span><span class="c1">// Load the input point cloud</span>
<span class="linenos"> 62</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Loading...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">tic</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="linenos"> 63</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">loadPCDFile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Statues_4.pcd&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">cloud_in</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 64</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&gt;&gt; Done: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">toc</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ms, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cloud_in</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; points</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 65</span>
<span class="linenos"> 66</span><span class="w">  </span><span class="c1">// Downsample the cloud using a Voxel Grid class</span>
<span class="linenos"> 67</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Downsampling...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">tic</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="linenos"> 68</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">VoxelGrid</span><span class="o">&lt;</span><span class="n">PointTypeIO</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vg</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 69</span><span class="w">  </span><span class="n">vg</span><span class="p">.</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">cloud_in</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 70</span><span class="w">  </span><span class="n">vg</span><span class="p">.</span><span class="n">setLeafSize</span><span class="w"> </span><span class="p">(</span><span class="mf">80.0</span><span class="p">,</span><span class="w"> </span><span class="mf">80.0</span><span class="p">,</span><span class="w"> </span><span class="mf">80.0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 71</span><span class="w">  </span><span class="n">vg</span><span class="p">.</span><span class="n">setDownsampleAllData</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 72</span><span class="w">  </span><span class="n">vg</span><span class="p">.</span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_out</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 73</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&gt;&gt; Done: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">toc</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ms, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cloud_out</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; points</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 74</span>
<span class="linenos"> 75</span><span class="w">  </span><span class="c1">// Set up a Normal Estimation class and merge data in cloud_with_normals</span>
<span class="linenos"> 76</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Computing normals...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">tic</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="linenos"> 77</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">copyPointCloud</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_out</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">cloud_with_normals</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 78</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">NormalEstimation</span><span class="o">&lt;</span><span class="n">PointTypeIO</span><span class="p">,</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ne</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 79</span><span class="w">  </span><span class="n">ne</span><span class="p">.</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">cloud_out</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 80</span><span class="w">  </span><span class="n">ne</span><span class="p">.</span><span class="n">setSearchMethod</span><span class="w"> </span><span class="p">(</span><span class="n">search_tree</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 81</span><span class="w">  </span><span class="n">ne</span><span class="p">.</span><span class="n">setRadiusSearch</span><span class="w"> </span><span class="p">(</span><span class="mf">300.0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 82</span><span class="w">  </span><span class="n">ne</span><span class="p">.</span><span class="n">compute</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_with_normals</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 83</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&gt;&gt; Done: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">toc</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 84</span>
<span class="linenos"> 85</span><span class="w">  </span><span class="c1">// Set up a Conditional Euclidean Clustering class</span>
<span class="linenos"> 86</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Segmenting to clusters...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">tic</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="linenos"> 87</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">ConditionalEuclideanClustering</span><span class="o">&lt;</span><span class="n">PointTypeFull</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cec</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 88</span><span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">cloud_with_normals</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 89</span><span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setConditionFunction</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">customRegionGrowing</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 90</span><span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setClusterTolerance</span><span class="w"> </span><span class="p">(</span><span class="mf">500.0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 91</span><span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setMinClusterSize</span><span class="w"> </span><span class="p">(</span><span class="n">cloud_with_normals</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 92</span><span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setMaxClusterSize</span><span class="w"> </span><span class="p">(</span><span class="n">cloud_with_normals</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 93</span><span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">segment</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">clusters</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 94</span><span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">getRemovedClusters</span><span class="w"> </span><span class="p">(</span><span class="n">small_clusters</span><span class="p">,</span><span class="w"> </span><span class="n">large_clusters</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 95</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&gt;&gt; Done: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">toc</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 96</span>
<span class="linenos"> 97</span><span class="w">  </span><span class="c1">// Using the intensity channel for lazy visualization of the output</span>
<span class="linenos"> 98</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">small_cluster</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">small_clusters</span><span class="p">))</span><span class="w"></span>
<span class="linenos"> 99</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">small_cluster</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span><span class="w"></span>
<span class="linenos">100</span><span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_out</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-2.0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">101</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">large_cluster</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">large_clusters</span><span class="p">))</span><span class="w"></span>
<span class="linenos">102</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">large_cluster</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span><span class="w"></span>
<span class="linenos">103</span><span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_out</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="mf">10.0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">104</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cluster</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">clusters</span><span class="p">))</span><span class="w"></span>
<span class="linenos">105</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="linenos">106</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="linenos">107</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span><span class="w"></span>
<span class="linenos">108</span><span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_out</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">label</span><span class="p">;</span><span class="w"></span>
<span class="linenos">109</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">110</span>
<span class="linenos">111</span><span class="w">  </span><span class="c1">// Save the output point cloud</span>
<span class="linenos">112</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Saving...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">tic</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="linenos">113</span><span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">savePCDFile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;output.pcd&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">cloud_out</span><span class="p">);</span><span class="w"></span>
<span class="linenos">114</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&gt;&gt; Done: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">toc</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">115</span>
<span class="linenos">116</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">117</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="the-explanation">
<h1>The Explanation</h1>
<p>Since the Conditional Euclidean Clustering class is for more advanced users, I will skip explanation of the more obvious parts of the code:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pcl::io::loadPCDFile</span></code> and <code class="docutils literal notranslate"><span class="pre">pcl::io::savePCDFile</span></code> are used for loading and saving the point cloud data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pcl::console::TicToc</span></code> is used for easy output of timing results.</p></li>
<li><p><a class="reference internal" href="voxel_grid.html#voxelgrid"><span class="std std-ref">Downsampling a PointCloud using a VoxelGrid filter</span></a> is being used (lines 66-73) to downsample the cloud and give a more equalized point density.</p></li>
<li><p><a class="reference internal" href="normal_estimation.html#normal-estimation"><span class="std std-ref">Estimating Surface Normals in a PointCloud</span></a> is being used (lines 75-83)  to estimate normals which will be appended to the point information;
The Conditional Euclidean Clustering class will be templated with <code class="docutils literal notranslate"><span class="pre">pcl::PointXYZINormal</span></code>, containing x, y, z, intensity, normal and curvature information to use in the condition function.</p></li>
</ul>
</div></blockquote>
<p>Lines 85-95 set up the Conditional Euclidean Clustering class for use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Set up a Conditional Euclidean Clustering class</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Segmenting to clusters...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">tic</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">ConditionalEuclideanClustering</span><span class="o">&lt;</span><span class="n">PointTypeFull</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cec</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setInputCloud</span><span class="w"> </span><span class="p">(</span><span class="n">cloud_with_normals</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setConditionFunction</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">customRegionGrowing</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setClusterTolerance</span><span class="w"> </span><span class="p">(</span><span class="mf">500.0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setMinClusterSize</span><span class="w"> </span><span class="p">(</span><span class="n">cloud_with_normals</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">setMaxClusterSize</span><span class="w"> </span><span class="p">(</span><span class="n">cloud_with_normals</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">segment</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">clusters</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cec</span><span class="p">.</span><span class="n">getRemovedClusters</span><span class="w"> </span><span class="p">(</span><span class="n">small_clusters</span><span class="p">,</span><span class="w"> </span><span class="n">large_clusters</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&gt;&gt; Done: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tt</span><span class="p">.</span><span class="n">toc</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>A more elaborate description of the different lines of code:</p>
<blockquote>
<div><ul class="simple">
<li><p>The class is initialized with TRUE.
This will allow extraction of clusters that are too small or too large.
It saves some computation time and memory if the class is initialized without this.</p></li>
<li><p>The input data for the class can be specified using methods derived from the <code class="docutils literal notranslate"><span class="pre">PCLBase</span></code> class, i.e.: <code class="docutils literal notranslate"><span class="pre">setInputCloud</span></code> and <code class="docutils literal notranslate"><span class="pre">setIndices</span></code>.</p></li>
<li><p>As a cluster grows, it will evaluate a user-defined condition between points already inside the cluster and nearby candidate points.
More on the condition function can be read further below.</p></li>
<li><p>The cluster tolerance is the radius for the k-NN searching, used to find the candidate points.</p></li>
<li><p>Clusters that make up less than 0.1% of the cloudâ€™s total points are considered too small.</p></li>
<li><p>Clusters that make up more than 20% of the cloudâ€™s total points are considered too large.</p></li>
<li><p>The resulting clusters are stored in the <code class="docutils literal notranslate"><span class="pre">pcl::IndicesClusters</span></code> format, which is an array of indices-arrays, indexing points of the input point cloud.</p></li>
<li><p>Too small clusters or too large clusters are not passed to the main output but can instead be retrieved in separate <code class="docutils literal notranslate"><span class="pre">pcl::IndicesClusters</span></code> data containers, but only if the class was initialized with TRUE.</p></li>
</ul>
</div></blockquote>
<p>Lines 12-49 show some examples of condition functions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"></span>
<span class="nf">enforceIntensitySimilarity</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_b</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="cm">/*squared_distance*/</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a</span><span class="p">.</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">intensity</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"></span>
<span class="nf">enforceNormalOrIntensitySimilarity</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_b</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="cm">/*squared_distance*/</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">&gt;</span><span class="w"> </span><span class="n">point_a_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_a</span><span class="p">.</span><span class="n">getNormalVector3fMap</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="n">point_b_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">getNormalVector3fMap</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a</span><span class="p">.</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">intensity</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a_normal</span><span class="p">.</span><span class="n">dot</span><span class="w"> </span><span class="p">(</span><span class="n">point_b_normal</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="w"> </span><span class="p">(</span><span class="mf">30.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">180.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">M_PI</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"></span>
<span class="nf">customRegionGrowing</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PointTypeFull</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point_b</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">squared_distance</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">&gt;</span><span class="w"> </span><span class="n">point_a_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_a</span><span class="p">.</span><span class="n">getNormalVector3fMap</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="n">point_b_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">getNormalVector3fMap</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">squared_distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a</span><span class="p">.</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">intensity</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">8.0f</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a_normal</span><span class="p">.</span><span class="n">dot</span><span class="w"> </span><span class="p">(</span><span class="n">point_b_normal</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="w"> </span><span class="p">(</span><span class="mf">30.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">180.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">M_PI</span><span class="p">)))</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="w"> </span><span class="p">(</span><span class="n">point_a</span><span class="p">.</span><span class="n">intensity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point_b</span><span class="p">.</span><span class="n">intensity</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The format of the condition function is fixed:</p>
<blockquote>
<div><ul class="simple">
<li><p>The first two input arguments need to be of the same type as the templated type used in the Conditional Euclidean Clustering class.
These arguments will pass the point information for the current seed point (first argument) and the current candidate point (second argument).</p></li>
<li><p>The third input argument needs to be a float.
This argument will pass the squared distance between the seed and candidate point.
Although this information is also computable using the first two arguments, it is already provided by the underlying nearest neighbor search and can be used to easily make a distance dependent condition function.</p></li>
<li><p>The output argument needs to be a boolean.
Returning TRUE will merge the candidate point into the cluster of the seed point.
Returning FALSE will not merge the candidate point through this particular point-pair, however, it is still possible that the two points will end up in the same cluster through a different point-pair relationship.</p></li>
</ul>
</div></blockquote>
<p>These example condition functions are just to give an indication of how to use them.
For instance, the second condition function will grow clusters as long as they are similar in surface normal direction OR similar in intensity value.
This should hopefully cluster buildings of similar texture as one cluster, but not merge them into the same cluster as adjacent objects.
This is going to work out if the intensity is different enough from nearby objects AND the nearby objects are not sharing a nearby surface with the same normal.
The third condition function is similar to the second but has different constraints depending on the distance between the points.</p>
<p>Lines 97-109 contain a piece of code that is a quick and dirty fix to visualize the result:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Using the intensity channel for lazy visualization of the output</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">small_cluster</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">small_clusters</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">small_cluster</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_out</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">large_cluster</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">large_clusters</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">large_cluster</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_out</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="mf">10.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cluster</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">clusters</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">cloud_out</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">label</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>When the output point cloud is opened with PCLâ€™s standard PCD viewer, pressing â€˜5â€™ will switch to the intensity channel visualization.
The too-small clusters will be colored red, the too-large clusters will be colored blue, and the actual clusters/objects of interest will be colored randomly in between yellow and cyan hues.</p>
</section>
<section id="compiling-and-running-the-program">
<h1>Compiling and running the program</h1>
<p>Add the following lines to your CMakeLists.txt</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.5</span><span class="w"> </span><span class="s">FATAL_ERROR</span><span class="p">)</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="nb">project</span><span class="p">(</span><span class="s">conditional_euclidean_clustering</span><span class="p">)</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="nb">find_package</span><span class="p">(</span><span class="s">PCL</span><span class="w"> </span><span class="s">1.7</span><span class="w"> </span><span class="s">REQUIRED</span><span class="p">)</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PCL_INCLUDE_DIRS</span><span class="o">}</span><span class="p">)</span>
<span class="linenos"> 8</span><span class="nb">link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PCL_LIBRARY_DIRS</span><span class="o">}</span><span class="p">)</span>
<span class="linenos"> 9</span><span class="nb">add_definitions</span><span class="p">(</span><span class="o">${</span><span class="nv">PCL_DEFINITIONS</span><span class="o">}</span><span class="p">)</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="nb">add_executable</span> <span class="p">(</span><span class="s">conditional_euclidean_clustering</span><span class="w"> </span><span class="s">conditional_euclidean_clustering.cpp</span><span class="p">)</span>
<span class="linenos">12</span><span class="nb">target_link_libraries</span> <span class="p">(</span><span class="s">conditional_euclidean_clustering</span><span class="w"> </span><span class="o">${</span><span class="nv">PCL_LIBRARIES</span><span class="o">}</span><span class="p">)</span>
</pre></div>
</div>
<p>After you have made the executable, you can run it. Simply do:</p>
<blockquote>
<div><p>$ ./conditional_euclidean_clustering</p>
</div></blockquote>
<p>The resulting output point cloud can be opened like so:</p>
<blockquote>
<div><p>$ ./pcl_viewer output.pcd</p>
</div></blockquote>
<p>You should see something similar to this:</p>
<img alt="Output Cluster Extraction" class="align-center" src="_images/conditional_euclidean_clustering.jpg" />
<p>This result is sub-optimal but it gives an idea of what can be achieved with this class.
The mathematics and heuristics behind the customizable condition are now the responsibility of the user.</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>