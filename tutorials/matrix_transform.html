

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Using a matrix to transform a point cloud &mdash; Point Cloud Library 1.11.0-dev documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Point Cloud Library
          

          
          </a>

          
            
            
              <div class="version">
                1.11.0-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Using a matrix to transform a point cloud</a></li>
<li><a class="reference internal" href="#the-code">The code</a></li>
<li><a class="reference internal" href="#the-explanation">The explanation</a></li>
<li><a class="reference internal" href="#compiling-and-running-the-program">Compiling and running the program</a></li>
<li><a class="reference internal" href="#more-about-transformations">More about transformations</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Point Cloud Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Using a matrix to transform a point cloud</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="using-a-matrix-to-transform-a-point-cloud">
<span id="matrix-transform"></span><h1>Using a matrix to transform a point cloud</h1>
<p>In this tutorial we will learn how to transform a point cloud using a 4x4 matrix.
We will apply a rotation and a translation to a loaded point cloud and display then
result.</p>
<p>This program is able to load one PCD or PLY file; apply a matrix transformation on it
and display the original and transformed point cloud.</p>
</div>
<div class="section" id="the-code">
<h1>The code</h1>
<p>First, create a file, let’s say, <code class="docutils literal notranslate"><span class="pre">matrix_transform.cpp</span></code> in your favorite
editor, and place the following code inside it:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/io/pcd_io.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/io/ply_io.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/point_cloud.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/console/parse.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/common/transforms.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/visualization/pcl_visualizer.h&gt;</span><span class="cp"></span>

<span class="c1">// This function displays the help</span>
<span class="kt">void</span>
<span class="nf">showHelp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">program_name</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">program_name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; cloud_filename.[pcd|ply]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;-h:  Show this help.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This is the main function</span>
<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>

  <span class="c1">// Show help</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">find_switch</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;-h&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">find_switch</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;--help&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">showHelp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Fetch point cloud filename in arguments | Works with PCD and PLY files</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">filenames</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">file_is_pcd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">filenames</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">parse_file_extension_argument</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;.ply&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">filenames</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>  <span class="p">{</span>
    <span class="n">filenames</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">parse_file_extension_argument</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;.pcd&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">filenames</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">showHelp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">file_is_pcd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Load file | Works with PCD and PLY files</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">source_cloud</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">file_is_pcd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">loadPCDFile</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">*</span><span class="n">source_cloud</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error loading point cloud &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">showHelp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">loadPLYFile</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">*</span><span class="n">source_cloud</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error loading point cloud &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">showHelp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* Reminder: how transformation matrices work :</span>

<span class="cm">           |-------&gt; This column is the translation</span>
<span class="cm">    | 1 0 0 x |  \</span>
<span class="cm">    | 0 1 0 y |   }-&gt; The identity 3x3 matrix (no rotation) on the left</span>
<span class="cm">    | 0 0 1 z |  /</span>
<span class="cm">    | 0 0 0 1 |    -&gt; We do not use this line (and it has to stay 0,0,0,1)</span>

<span class="cm">    METHOD #1: Using a Matrix4f</span>
<span class="cm">    This is the &quot;manual&quot; method, perfect to understand but error prone !</span>
<span class="cm">  */</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span> <span class="n">transform_1</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span>

  <span class="c1">// Define a rotation matrix (see https://en.wikipedia.org/wiki/Rotation_matrix)</span>
  <span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">M_PI</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// The angle of rotation in radians</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cos</span> <span class="p">(</span><span class="n">theta</span><span class="p">);</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">sin</span> <span class="p">(</span><span class="n">theta</span><span class="p">);</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cos</span> <span class="p">(</span><span class="n">theta</span><span class="p">);</span>
  <span class="c1">//    (row, column)</span>

  <span class="c1">// Define a translation of 2.5 meters on the x axis.</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">;</span>

  <span class="c1">// Print the transformation</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Method #1: using a Matrix4f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">transform_1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="cm">/*  METHOD #2: Using a Affine3f</span>
<span class="cm">    This method is easier and less error prone</span>
<span class="cm">  */</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3f</span> <span class="n">transform_2</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3f</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span>

  <span class="c1">// Define a translation of 2.5 meters on the x axis.</span>
  <span class="n">transform_2</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="c1">// The same rotation matrix as before; theta radians around Z axis</span>
  <span class="n">transform_2</span><span class="p">.</span><span class="n">rotate</span> <span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxisf</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">::</span><span class="n">UnitZ</span><span class="p">()));</span>

  <span class="c1">// Print the transformation</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Method #2: using an Affine3f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">transform_2</span><span class="p">.</span><span class="n">matrix</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Executing the transformation</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">transformed_cloud</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="p">());</span>
  <span class="c1">// You can either apply transform_1 or transform_2; they are the same</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">transformPointCloud</span> <span class="p">(</span><span class="o">*</span><span class="n">source_cloud</span><span class="p">,</span> <span class="o">*</span><span class="n">transformed_cloud</span><span class="p">,</span> <span class="n">transform_2</span><span class="p">);</span>

  <span class="c1">// Visualization</span>
  <span class="n">printf</span><span class="p">(</span>  <span class="s">&quot;</span><span class="se">\n</span><span class="s">Point cloud colors :  white  = original point cloud</span><span class="se">\n</span><span class="s">&quot;</span>
      <span class="s">&quot;                        red  = transformed point cloud</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span> <span class="n">viewer</span> <span class="p">(</span><span class="s">&quot;Matrix transformation example&quot;</span><span class="p">);</span>

   <span class="c1">// Define R,G,B colors for the point cloud</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PointCloudColorHandlerCustom</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">source_cloud_color_handler</span> <span class="p">(</span><span class="n">source_cloud</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
  <span class="c1">// We add the point cloud to the viewer and pass the color handler</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">addPointCloud</span> <span class="p">(</span><span class="n">source_cloud</span><span class="p">,</span> <span class="n">source_cloud_color_handler</span><span class="p">,</span> <span class="s">&quot;original_cloud&quot;</span><span class="p">);</span>

  <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PointCloudColorHandlerCustom</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">transformed_cloud_color_handler</span> <span class="p">(</span><span class="n">transformed_cloud</span><span class="p">,</span> <span class="mi">230</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// Red</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">addPointCloud</span> <span class="p">(</span><span class="n">transformed_cloud</span><span class="p">,</span> <span class="n">transformed_cloud_color_handler</span><span class="p">,</span> <span class="s">&quot;transformed_cloud&quot;</span><span class="p">);</span>

  <span class="n">viewer</span><span class="p">.</span><span class="n">addCoordinateSystem</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s">&quot;cloud&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">setBackgroundColor</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Setting background to a dark grey</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">setPointCloudRenderingProperties</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCL_VISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;original_cloud&quot;</span><span class="p">);</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">setPointCloudRenderingProperties</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCL_VISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;transformed_cloud&quot;</span><span class="p">);</span>
  <span class="c1">//viewer.setPosition(800, 400); // Setting visualiser window position</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">viewer</span><span class="p">.</span><span class="n">wasStopped</span> <span class="p">())</span> <span class="p">{</span> <span class="c1">// Display the visualiser until &#39;q&#39; key is pressed</span>
    <span class="n">viewer</span><span class="p">.</span><span class="n">spinOnce</span> <span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="the-explanation">
<h1>The explanation</h1>
<p>Now, let’s break down the code piece by piece.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/io/pcd_io.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/io/ply_io.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/point_cloud.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/console/parse.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/common/transforms.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/visualization/pcl_visualizer.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>We include all the headers we will make use of.
<strong>#include &lt;pcl/common/transforms.h&gt;</strong> allows us to use <strong>pcl::transformPointCloud</strong> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This function displays the help</span>
<span class="kt">void</span>
<span class="nf">showHelp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">program_name</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">program_name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; cloud_filename.[pcd|ply]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;-h:  Show this help.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function display the help in case the user didn’t provide expected arguments.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Show help</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">find_switch</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;-h&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">find_switch</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;--help&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">showHelp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>We parse the arguments on the command line, either using <strong>-h</strong> or <strong>–help</strong> will
display the help. This terminates the program</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Fetch point cloud filename in arguments | Works with PCD and PLY files</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">filenames</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">file_is_pcd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">filenames</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">parse_file_extension_argument</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;.ply&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">filenames</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>  <span class="p">{</span>
    <span class="n">filenames</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">::</span><span class="n">console</span><span class="o">::</span><span class="n">parse_file_extension_argument</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;.pcd&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">filenames</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">showHelp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">file_is_pcd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>We look for .ply or .pcd filenames in the arguments. If not found; terminate the program.
The bool <strong>file_is_pcd</strong> will help us choose between loading PCD or PLY file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Load file | Works with PCD and PLY files</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">source_cloud</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">file_is_pcd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">loadPCDFile</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">*</span><span class="n">source_cloud</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error loading point cloud &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">showHelp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">loadPLYFile</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">*</span><span class="n">source_cloud</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error loading point cloud &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">showHelp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>We now load the PCD/PLY file and check if the file was loaded successfully. Otherwise terminate
the program.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="cm">/* Reminder: how transformation matrices work :</span>

<span class="cm">           |-------&gt; This column is the translation</span>
<span class="cm">    | 1 0 0 x |  \</span>
<span class="cm">    | 0 1 0 y |   }-&gt; The identity 3x3 matrix (no rotation) on the left</span>
<span class="cm">    | 0 0 1 z |  /</span>
<span class="cm">    | 0 0 0 1 |    -&gt; We do not use this line (and it has to stay 0,0,0,1)</span>

<span class="cm">    METHOD #1: Using a Matrix4f</span>
<span class="cm">    This is the &quot;manual&quot; method, perfect to understand but error prone !</span>
<span class="cm">  */</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span> <span class="n">transform_1</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span>
</pre></div>
</div>
<p>This is a first approach to create a transformation. This will help you understand how transformation matrices work.
We initialize a 4x4 matrix to identity;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">|</span>  <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">0</span>  <span class="o">|</span>
<span class="n">i</span> <span class="o">=</span> <span class="o">|</span>  <span class="mi">0</span>  <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>  <span class="o">|</span>
    <span class="o">|</span>  <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">1</span>  <span class="mi">0</span>  <span class="o">|</span>
    <span class="o">|</span>  <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">1</span>  <span class="o">|</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The identity matrix is the equivalent of “1” when multiplying numbers; it changes nothing.
It is a square matrix with ones on the main diagonal and zeros elsewhere.</p>
</div>
<p>This means no transformation (no rotation and no translation). We do not use the
last row of the matrix.</p>
<p>The first 3 rows and columns (top left) components are the rotation
matrix. The first 3 rows of the last column is the translation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Define a rotation matrix (see https://en.wikipedia.org/wiki/Rotation_matrix)</span>
  <span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">M_PI</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// The angle of rotation in radians</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cos</span> <span class="p">(</span><span class="n">theta</span><span class="p">);</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">sin</span> <span class="p">(</span><span class="n">theta</span><span class="p">);</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cos</span> <span class="p">(</span><span class="n">theta</span><span class="p">);</span>
  <span class="c1">//    (row, column)</span>

  <span class="c1">// Define a translation of 2.5 meters on the x axis.</span>
  <span class="n">transform_1</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">;</span>

  <span class="c1">// Print the transformation</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Method #1: using a Matrix4f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">transform_1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Here we defined a 45° (PI/4) rotation around the Z axis and a translation on the X axis.
This is the transformation we just defined</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">|</span>  <span class="n">cos</span><span class="p">(</span><span class="n">θ</span><span class="p">)</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">θ</span><span class="p">)</span>  <span class="mf">0.0</span> <span class="o">|</span>
<span class="n">R</span> <span class="o">=</span> <span class="o">|</span>  <span class="n">sin</span><span class="p">(</span><span class="n">θ</span><span class="p">)</span>  <span class="n">cos</span><span class="p">(</span><span class="n">θ</span><span class="p">)</span>  <span class="mf">0.0</span> <span class="o">|</span>
    <span class="o">|</span>  <span class="mf">0.0</span>     <span class="mf">0.0</span>     <span class="mf">1.0</span> <span class="o">|</span>

<span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">&gt;</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="cm">/*  METHOD #2: Using a Affine3f</span>
<span class="cm">    This method is easier and less error prone</span>
<span class="cm">  */</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3f</span> <span class="n">transform_2</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3f</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span>

  <span class="c1">// Define a translation of 2.5 meters on the x axis.</span>
  <span class="n">transform_2</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="c1">// The same rotation matrix as before; theta radians around Z axis</span>
  <span class="n">transform_2</span><span class="p">.</span><span class="n">rotate</span> <span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxisf</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">::</span><span class="n">UnitZ</span><span class="p">()));</span>

  <span class="c1">// Print the transformation</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Method #2: using an Affine3f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">transform_2</span><span class="p">.</span><span class="n">matrix</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>This second approach is easier to understand and is less error prone.
Be careful if you want to apply several rotations; rotations are not commutative ! This means than in most cases:
rotA * rotB != rotB * rotA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Executing the transformation</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">transformed_cloud</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="p">());</span>
  <span class="c1">// You can either apply transform_1 or transform_2; they are the same</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">transformPointCloud</span> <span class="p">(</span><span class="o">*</span><span class="n">source_cloud</span><span class="p">,</span> <span class="o">*</span><span class="n">transformed_cloud</span><span class="p">,</span> <span class="n">transform_2</span><span class="p">);</span>
</pre></div>
</div>
<p>Now we apply this matrix on the point cloud <strong>source_cloud</strong> and we save the result in the
newly created <strong>transformed_cloud</strong>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Visualization</span>
  <span class="n">printf</span><span class="p">(</span>  <span class="s">&quot;</span><span class="se">\n</span><span class="s">Point cloud colors :  white  = original point cloud</span><span class="se">\n</span><span class="s">&quot;</span>
      <span class="s">&quot;                        red  = transformed point cloud</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span> <span class="n">viewer</span> <span class="p">(</span><span class="s">&quot;Matrix transformation example&quot;</span><span class="p">);</span>

   <span class="c1">// Define R,G,B colors for the point cloud</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PointCloudColorHandlerCustom</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">source_cloud_color_handler</span> <span class="p">(</span><span class="n">source_cloud</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
  <span class="c1">// We add the point cloud to the viewer and pass the color handler</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">addPointCloud</span> <span class="p">(</span><span class="n">source_cloud</span><span class="p">,</span> <span class="n">source_cloud_color_handler</span><span class="p">,</span> <span class="s">&quot;original_cloud&quot;</span><span class="p">);</span>

  <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PointCloudColorHandlerCustom</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">transformed_cloud_color_handler</span> <span class="p">(</span><span class="n">transformed_cloud</span><span class="p">,</span> <span class="mi">230</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// Red</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">addPointCloud</span> <span class="p">(</span><span class="n">transformed_cloud</span><span class="p">,</span> <span class="n">transformed_cloud_color_handler</span><span class="p">,</span> <span class="s">&quot;transformed_cloud&quot;</span><span class="p">);</span>

  <span class="n">viewer</span><span class="p">.</span><span class="n">addCoordinateSystem</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s">&quot;cloud&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">setBackgroundColor</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Setting background to a dark grey</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">setPointCloudRenderingProperties</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCL_VISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;original_cloud&quot;</span><span class="p">);</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">setPointCloudRenderingProperties</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCL_VISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;transformed_cloud&quot;</span><span class="p">);</span>
  <span class="c1">//viewer.setPosition(800, 400); // Setting visualiser window position</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">viewer</span><span class="p">.</span><span class="n">wasStopped</span> <span class="p">())</span> <span class="p">{</span> <span class="c1">// Display the visualiser until &#39;q&#39; key is pressed</span>
    <span class="n">viewer</span><span class="p">.</span><span class="n">spinOnce</span> <span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>We then visualize the result using the <strong>PCLVisualizer</strong>. The original point cloud will be
displayed white and the transformed one in red. The coordoniates axis will be displayed.
We also set the background color of the visualizer and the point display size.</p>
</div>
<div class="section" id="compiling-and-running-the-program">
<h1>Compiling and running the program</h1>
<p>Add the following lines to your CMakeLists.txt file:</p>
<div class="highlight-cmake notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">2.6</span> <span class="s">FATAL_ERROR</span><span class="p">)</span>

<span class="nb">project</span><span class="p">(</span><span class="s">pcl-matrix_transform</span><span class="p">)</span>

<span class="nb">find_package</span><span class="p">(</span><span class="s">PCL</span> <span class="s">1.7</span> <span class="s">REQUIRED</span><span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PCL_INCLUDE_DIRS</span><span class="o">}</span><span class="p">)</span>
<span class="nb">link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PCL_LIBRARY_DIRS</span><span class="o">}</span><span class="p">)</span>
<span class="nb">add_definitions</span><span class="p">(</span><span class="o">${</span><span class="nv">PCL_DEFINITIONS</span><span class="o">}</span><span class="p">)</span>

<span class="nb">add_executable</span> <span class="p">(</span><span class="s">matrix_transform</span> <span class="s">matrix_transform.cpp</span><span class="p">)</span>
<span class="nb">target_link_libraries</span> <span class="p">(</span><span class="s">matrix_transform</span> <span class="o">${</span><span class="nv">PCL_LIBRARIES</span><span class="o">}</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>After you have made the executable, run it passing a path to a PCD or PLY file.
To reproduce the results shown below, you can download the <a class="reference external" href="https://raw.github.com/PointCloudLibrary/pcl/master/test/cube.ply">cube.ply</a> file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./matrix_transform cube.ply
</pre></div>
</div>
<p>You will see something similar to this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">matrix_transform</span> <span class="n">cube</span><span class="o">.</span><span class="n">ply</span>
<span class="p">[</span><span class="n">pcl</span><span class="p">::</span><span class="n">PLYReader</span><span class="p">]</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">victor</span><span class="o">/</span><span class="n">cube</span><span class="o">.</span><span class="n">ply</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span> <span class="nb">property</span> <span class="s1">&#39;list uint8 uint32 vertex_indices&#39;</span> <span class="n">of</span> <span class="n">element</span> <span class="s1">&#39;face&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">handled</span>
<span class="n">Method</span> <span class="c1">#1: using a Matrix4f</span>
 <span class="mf">0.707107</span> <span class="o">-</span><span class="mf">0.707107</span>         <span class="mi">0</span>       <span class="mf">2.5</span>
 <span class="mf">0.707107</span>  <span class="mf">0.707107</span>         <span class="mi">0</span>         <span class="mi">0</span>
        <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">1</span>         <span class="mi">0</span>
        <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">1</span>

<span class="n">Method</span> <span class="c1">#2: using an Affine3f</span>
 <span class="mf">0.707107</span> <span class="o">-</span><span class="mf">0.707107</span>         <span class="mi">0</span>       <span class="mf">2.5</span>
 <span class="mf">0.707107</span>  <span class="mf">0.707107</span>         <span class="mi">0</span>         <span class="mi">0</span>
        <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">1</span>         <span class="mi">0</span>
        <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">1</span>

<span class="n">Point</span> <span class="n">cloud</span> <span class="n">colors</span> <span class="p">:</span>  <span class="n">white</span>   <span class="o">=</span> <span class="n">original</span> <span class="n">point</span> <span class="n">cloud</span>
                       <span class="n">red</span>    <span class="o">=</span> <span class="n">transformed</span> <span class="n">point</span> <span class="n">cloud</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/cube_big.png"><img alt="_images/cube_big.png" src="_images/cube_big.png" style="height: 614px;" /></a>
</div>
<div class="section" id="more-about-transformations">
<h1>More about transformations</h1>
<div class="line-block">
<div class="line">So now you successfully transformed a point cloud using a transformation matrix.</div>
<div class="line">What if you want to transform a single point ? A vector ?</div>
</div>
<div class="line-block">
<div class="line">A point is defined in 3D space with its three coordinates; x,y,z (in a cartesian coordinate system).</div>
<div class="line">How can you multiply a vector (with 3 coordinates) with a 4x4 matrix ? You simply can’t ! If you don’t know why please refer to <a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_multiplication">matrix multiplications on wikipedia</a>.</div>
</div>
<p>We need a vector with 4 components. What do you put in the last component ? It depends on what you want to do:</p>
<ul class="simple">
<li><p>If you want to transform a point: put 1 at the end of the vector so that the translation is taken in account.</p></li>
<li><p>If you want to transform the direction of a vector: put 0 at the end of the vector to ignore the translation.</p></li>
</ul>
<p>Here’s a quick example, we want to transform the following vector:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">Where the first 3 components defines the origin coordinates and the last 3 components the direction.</div>
<div class="line">This vector starts at point 10, 5, 0 and ends at 13, 5, -1.</div>
</div>
<p>This is what you need to do to transform the vector:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="n">x4_transformation_matrix</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="n">x4_transformation_matrix</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>