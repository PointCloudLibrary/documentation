<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Point Cloud Library (PCL): pcl::GridProjection&lt; PointNT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Point Cloud Library (PCL)
   &#160;<span id="projectnumber">1.11.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classpcl_1_1_grid_projection-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">pcl::GridProjection&lt; PointNT &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__surface.html">Module surface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_grid.html">Grid</a> projection surface reconstruction method.  
 <a href="classpcl_1_1_grid_projection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="grid__projection_8h_source.html">pcl/surface/grid_projection.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for pcl::GridProjection&lt; PointNT &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classpcl_1_1_grid_projection.png" usemap="#pcl::GridProjection_3C_20PointNT_20_3E_map" alt=""/>
  <map id="pcl::GridProjection_3C_20PointNT_20_3E_map" name="pcl::GridProjection_3C_20PointNT_20_3E_map">
<area href="classpcl_1_1_surface_reconstruction.html" alt="pcl::SurfaceReconstruction&lt; PointNT &gt;" shape="rect" coords="0,112,232,136"/>
<area href="classpcl_1_1_p_c_l_surface_base.html" alt="pcl::PCLSurfaceBase&lt; PointNT &gt;" shape="rect" coords="0,56,232,80"/>
<area href="classpcl_1_1_p_c_l_base.html" alt="pcl::PCLBase&lt; PointNT &gt;" shape="rect" coords="0,0,232,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data leaf.  <a href="structpcl_1_1_grid_projection_1_1_leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9ca02da009752ca2666b6aff0d487416"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a9ca02da009752ca2666b6aff0d487416">Ptr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a>&lt; PointNT &gt; &gt;</td></tr>
<tr class="separator:a9ca02da009752ca2666b6aff0d487416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ac20953abf72c266594cedff72e5b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a56ac20953abf72c266594cedff72e5b8">ConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a>&lt; PointNT &gt; &gt;</td></tr>
<tr class="separator:a56ac20953abf72c266594cedff72e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab704932b115dc26f6d500f256aa5637f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ab704932b115dc26f6d500f256aa5637f">PointCloudPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a9ca02da009752ca2666b6aff0d487416">Ptr</a></td></tr>
<tr class="separator:ab704932b115dc26f6d500f256aa5637f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62edd95ffded7ffe19275d13685aa1ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a62edd95ffded7ffe19275d13685aa1ed">KdTree</a> = <a class="el" href="classpcl_1_1_kd_tree.html">pcl::KdTree</a>&lt; PointNT &gt;</td></tr>
<tr class="separator:a62edd95ffded7ffe19275d13685aa1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e792702888e8569965561644612d6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ae5e792702888e8569965561644612d6c">KdTreePtr</a> = typename <a class="el" href="classpcl_1_1_kd_tree.html#aeab3727a7da7b1cb80fe97d40c64242b">KdTree::Ptr</a></td></tr>
<tr class="separator:ae5e792702888e8569965561644612d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf31b9e2266a6cd09b0d6b426f46c6d"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map&lt; int, <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a>, std::hash&lt; int &gt;, std::equal_to&lt;&gt;, Eigen::aligned_allocator&lt; std::pair&lt; const int, <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a8bf31b9e2266a6cd09b0d6b426f46c6d">HashMap</a></td></tr>
<tr class="separator:a8bf31b9e2266a6cd09b0d6b426f46c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_surface_reconstruction"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_surface_reconstruction')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_surface_reconstruction.html">pcl::SurfaceReconstruction&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a8d14bf9d51bd6ce98c7d9bb0621b93c6 inherit pub_types_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a8d14bf9d51bd6ce98c7d9bb0621b93c6">Ptr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_surface_reconstruction.html">SurfaceReconstruction</a>&lt; PointNT &gt; &gt;</td></tr>
<tr class="separator:a8d14bf9d51bd6ce98c7d9bb0621b93c6 inherit pub_types_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bd525778a5154310743a520235f14b inherit pub_types_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#ac1bd525778a5154310743a520235f14b">ConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_surface_reconstruction.html">SurfaceReconstruction</a>&lt; PointNT &gt; &gt;</td></tr>
<tr class="separator:ac1bd525778a5154310743a520235f14b inherit pub_types_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_p_c_l_surface_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_p_c_l_surface_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">pcl::PCLSurfaceBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a63b00af163012878bce98e2649972cd7 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a63b00af163012878bce98e2649972cd7">Ptr</a> = shared_ptr&lt; <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">PCLSurfaceBase</a>&lt; PointNT &gt; &gt;</td></tr>
<tr class="separator:a63b00af163012878bce98e2649972cd7 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02612b99d45c656409398892fa432e85 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a02612b99d45c656409398892fa432e85">ConstPtr</a> = shared_ptr&lt; const <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">PCLSurfaceBase</a>&lt; PointNT &gt; &gt;</td></tr>
<tr class="separator:a02612b99d45c656409398892fa432e85 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc605a6227e56c9cb783114ff46795a inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#abbc605a6227e56c9cb783114ff46795a">KdTree</a> = <a class="el" href="classpcl_1_1search_1_1_search.html">pcl::search::Search</a>&lt; PointNT &gt;</td></tr>
<tr class="separator:abbc605a6227e56c9cb783114ff46795a inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1a9c729a618b9ec8bf20b824d2a674 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a1c1a9c729a618b9ec8bf20b824d2a674">KdTreePtr</a> = typename <a class="el" href="classpcl_1_1search_1_1_search.html#ab4688e4899ce5aa6937dba334dc75763">KdTree::Ptr</a></td></tr>
<tr class="separator:a1c1a9c729a618b9ec8bf20b824d2a674 inherit pub_types_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a69de4001826d45c280087187322d779d inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a69de4001826d45c280087187322d779d">PointCloud</a> = <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt;</td></tr>
<tr class="separator:a69de4001826d45c280087187322d779d inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4399c6b93663d4762fc3389c1b594eb8 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a4399c6b93663d4762fc3389c1b594eb8">PointCloudPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#ab805ba3b19e952ad19d084a9caa3dc60">PointCloud::Ptr</a></td></tr>
<tr class="separator:a4399c6b93663d4762fc3389c1b594eb8 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575135fb579dc86f7845ed9dba1ea276 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> = typename <a class="el" href="classpcl_1_1_point_cloud.html#af70fd81ce582ccabf683dd782ed3f032">PointCloud::ConstPtr</a></td></tr>
<tr class="separator:a575135fb579dc86f7845ed9dba1ea276 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe906230f3e673dc2ff10b9d579f4ccb inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afe906230f3e673dc2ff10b9d579f4ccb">PointIndicesPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a3c574b78dfbe67c93d09acdbc8ecc499">PointIndices::Ptr</a></td></tr>
<tr class="separator:afe906230f3e673dc2ff10b9d579f4ccb inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b0d9b8a0867631ef2b9114116f9618 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae4b0d9b8a0867631ef2b9114116f9618">PointIndicesConstPtr</a> = <a class="el" href="structpcl_1_1_point_indices.html#a6880da079270712d46b0bb348cf124bc">PointIndices::ConstPtr</a></td></tr>
<tr class="separator:ae4b0d9b8a0867631ef2b9114116f9618 inherit pub_types_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a79cb25cd43c17040722912dbffa5ca22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a79cb25cd43c17040722912dbffa5ca22">GridProjection</a> ()</td></tr>
<tr class="memdesc:a79cb25cd43c17040722912dbffa5ca22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classpcl_1_1_grid_projection.html#a79cb25cd43c17040722912dbffa5ca22">More...</a><br /></td></tr>
<tr class="separator:a79cb25cd43c17040722912dbffa5ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b9a0bf64fe78bbd8c8b16b95735fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#acb6b9a0bf64fe78bbd8c8b16b95735fa">GridProjection</a> (double in_resolution)</td></tr>
<tr class="memdesc:acb6b9a0bf64fe78bbd8c8b16b95735fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classpcl_1_1_grid_projection.html#acb6b9a0bf64fe78bbd8c8b16b95735fa">More...</a><br /></td></tr>
<tr class="separator:acb6b9a0bf64fe78bbd8c8b16b95735fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f6ad98a1afff0c76ff557c68ae7b29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a64f6ad98a1afff0c76ff557c68ae7b29">~GridProjection</a> ()</td></tr>
<tr class="memdesc:a64f6ad98a1afff0c76ff557c68ae7b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classpcl_1_1_grid_projection.html#a64f6ad98a1afff0c76ff557c68ae7b29">More...</a><br /></td></tr>
<tr class="separator:a64f6ad98a1afff0c76ff557c68ae7b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ccfe1a2c8d66ca9a126d33096d2496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#af8ccfe1a2c8d66ca9a126d33096d2496">setResolution</a> (double resolution)</td></tr>
<tr class="memdesc:af8ccfe1a2c8d66ca9a126d33096d2496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the grid cell.  <a href="classpcl_1_1_grid_projection.html#af8ccfe1a2c8d66ca9a126d33096d2496">More...</a><br /></td></tr>
<tr class="separator:af8ccfe1a2c8d66ca9a126d33096d2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28f4d83ee50a5ad6267d7936f55a09d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ae28f4d83ee50a5ad6267d7936f55a09d">getResolution</a> () const</td></tr>
<tr class="separator:ae28f4d83ee50a5ad6267d7936f55a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7661621ee4c96b46571cc5778b9b48cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a7661621ee4c96b46571cc5778b9b48cf">setPaddingSize</a> (int padding_size)</td></tr>
<tr class="memdesc:a7661621ee4c96b46571cc5778b9b48cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">When averaging the vectors, we find the union of all the input data points within the padding area,and do a weighted average.  <a href="classpcl_1_1_grid_projection.html#a7661621ee4c96b46571cc5778b9b48cf">More...</a><br /></td></tr>
<tr class="separator:a7661621ee4c96b46571cc5778b9b48cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb565f51df04964c3b49dbd257d66d3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#adb565f51df04964c3b49dbd257d66d3d">getPaddingSize</a> () const</td></tr>
<tr class="separator:adb565f51df04964c3b49dbd257d66d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab668b2eefe9c9136c06956ad312e6704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ab668b2eefe9c9136c06956ad312e6704">setNearestNeighborNum</a> (int k)</td></tr>
<tr class="memdesc:ab668b2eefe9c9136c06956ad312e6704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this only when using the k nearest neighbors search instead of finding the point union.  <a href="classpcl_1_1_grid_projection.html#ab668b2eefe9c9136c06956ad312e6704">More...</a><br /></td></tr>
<tr class="separator:ab668b2eefe9c9136c06956ad312e6704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9887d299ea2be516a1216cb7843a1bef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a9887d299ea2be516a1216cb7843a1bef">getNearestNeighborNum</a> () const</td></tr>
<tr class="separator:a9887d299ea2be516a1216cb7843a1bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f788e943e8660d1806688f8a56aec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a86f788e943e8660d1806688f8a56aec3">setMaxBinarySearchLevel</a> (int max_binary_search_level)</td></tr>
<tr class="memdesc:a86f788e943e8660d1806688f8a56aec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search is used in projection.  <a href="classpcl_1_1_grid_projection.html#a86f788e943e8660d1806688f8a56aec3">More...</a><br /></td></tr>
<tr class="separator:a86f788e943e8660d1806688f8a56aec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c221e7f97944896dc9003da3303c4f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a8c221e7f97944896dc9003da3303c4f3">getMaxBinarySearchLevel</a> () const</td></tr>
<tr class="separator:a8c221e7f97944896dc9003da3303c4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244e5fdc0993524900d4512c1eb7c60b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcl_1_1_grid_projection.html#a8bf31b9e2266a6cd09b0d6b426f46c6d">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a244e5fdc0993524900d4512c1eb7c60b">getCellHashMap</a> () const</td></tr>
<tr class="separator:a244e5fdc0993524900d4512c1eb7c60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41777645db865cd6155d3714fc8c7380"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a41777645db865cd6155d3714fc8c7380">getVectorAtDataPoint</a> () const</td></tr>
<tr class="separator:a41777645db865cd6155d3714fc8c7380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89bb70feecd87f4c8440ecec5426ccb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#aa89bb70feecd87f4c8440ecec5426ccb">getSurface</a> () const</td></tr>
<tr class="separator:aa89bb70feecd87f4c8440ecec5426ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_surface_reconstruction"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_surface_reconstruction')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_surface_reconstruction.html">pcl::SurfaceReconstruction&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a62586eb3779c4f30358cbc5610f45704 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a62586eb3779c4f30358cbc5610f45704">SurfaceReconstruction</a> ()</td></tr>
<tr class="memdesc:a62586eb3779c4f30358cbc5610f45704 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classpcl_1_1_surface_reconstruction.html#a62586eb3779c4f30358cbc5610f45704">More...</a><br /></td></tr>
<tr class="separator:a62586eb3779c4f30358cbc5610f45704 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcbacafc70d27e9af9dea98cbfe385c inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a5bcbacafc70d27e9af9dea98cbfe385c">~SurfaceReconstruction</a> ()</td></tr>
<tr class="memdesc:a5bcbacafc70d27e9af9dea98cbfe385c inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classpcl_1_1_surface_reconstruction.html#a5bcbacafc70d27e9af9dea98cbfe385c">More...</a><br /></td></tr>
<tr class="separator:a5bcbacafc70d27e9af9dea98cbfe385c inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e1f2937a4a1b1e456253910ab0090c inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a53e1f2937a4a1b1e456253910ab0090c">reconstruct</a> (<a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;output) override</td></tr>
<tr class="memdesc:a53e1f2937a4a1b1e456253910ab0090c inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base method for surface reconstruction for all points given in &lt;setInputCloud (), setIndices ()&gt;  <a href="classpcl_1_1_surface_reconstruction.html#a53e1f2937a4a1b1e456253910ab0090c">More...</a><br /></td></tr>
<tr class="separator:a53e1f2937a4a1b1e456253910ab0090c inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec1dc0c87b4f8bacaa46ef0899a69f7 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#aaec1dc0c87b4f8bacaa46ef0899a69f7">reconstruct</a> (<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; &amp;points, std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;polygons)</td></tr>
<tr class="memdesc:aaec1dc0c87b4f8bacaa46ef0899a69f7 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base method for surface reconstruction for all points given in &lt;setInputCloud (), setIndices ()&gt;  <a href="classpcl_1_1_surface_reconstruction.html#aaec1dc0c87b4f8bacaa46ef0899a69f7">More...</a><br /></td></tr>
<tr class="separator:aaec1dc0c87b4f8bacaa46ef0899a69f7 inherit pub_methods_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_p_c_l_surface_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_p_c_l_surface_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">pcl::PCLSurfaceBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:aa4fba20611b3e995b9cc07dac528e4c3 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#aa4fba20611b3e995b9cc07dac528e4c3">PCLSurfaceBase</a> ()</td></tr>
<tr class="memdesc:aa4fba20611b3e995b9cc07dac528e4c3 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classpcl_1_1_p_c_l_surface_base.html#aa4fba20611b3e995b9cc07dac528e4c3">More...</a><br /></td></tr>
<tr class="separator:aa4fba20611b3e995b9cc07dac528e4c3 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ad794b5490b5d8adc504d7f9b982d8 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#ac5ad794b5490b5d8adc504d7f9b982d8">~PCLSurfaceBase</a> ()</td></tr>
<tr class="memdesc:ac5ad794b5490b5d8adc504d7f9b982d8 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="classpcl_1_1_p_c_l_surface_base.html#ac5ad794b5490b5d8adc504d7f9b982d8">More...</a><br /></td></tr>
<tr class="separator:ac5ad794b5490b5d8adc504d7f9b982d8 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af599c9767a18649344ff21d3976f1779 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#af599c9767a18649344ff21d3976f1779">setSearchMethod</a> (const <a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a1c1a9c729a618b9ec8bf20b824d2a674">KdTreePtr</a> &amp;tree)</td></tr>
<tr class="memdesc:af599c9767a18649344ff21d3976f1779 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an optional pointer to a search object.  <a href="classpcl_1_1_p_c_l_surface_base.html#af599c9767a18649344ff21d3976f1779">More...</a><br /></td></tr>
<tr class="separator:af599c9767a18649344ff21d3976f1779 inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2249d44038e0869bbf60e486ab3826af inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a1c1a9c729a618b9ec8bf20b824d2a674">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a2249d44038e0869bbf60e486ab3826af">getSearchMethod</a> ()</td></tr>
<tr class="memdesc:a2249d44038e0869bbf60e486ab3826af inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the search method used.  <a href="classpcl_1_1_p_c_l_surface_base.html#a2249d44038e0869bbf60e486ab3826af">More...</a><br /></td></tr>
<tr class="separator:a2249d44038e0869bbf60e486ab3826af inherit pub_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">PCLBase</a> ()</td></tr>
<tr class="memdesc:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classpcl_1_1_p_c_l_base.html#af4fbc5eb005057f8a0fc6d60bde595df">More...</a><br /></td></tr>
<tr class="separator:af4fbc5eb005057f8a0fc6d60bde595df inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">PCLBase</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html">PCLBase</a> &amp;base)</td></tr>
<tr class="memdesc:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpcl_1_1_p_c_l_base.html#a7a6dd7a91275d7737cf1b18005b47244">More...</a><br /></td></tr>
<tr class="separator:a7a6dd7a91275d7737cf1b18005b47244 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ace0baa9034497232920bbe6e5a9f393b">~PCLBase</a> ()=default</td></tr>
<tr class="memdesc:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classpcl_1_1_p_c_l_base.html#ace0baa9034497232920bbe6e5a9f393b">More...</a><br /></td></tr>
<tr class="separator:ace0baa9034497232920bbe6e5a9f393b inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">setInputCloud</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a> &amp;cloud)</td></tr>
<tr class="memdesc:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input dataset.  <a href="classpcl_1_1_p_c_l_base.html#a1952d7101f3942bac3b69ed55c1ca7ea">More...</a><br /></td></tr>
<tr class="separator:a1952d7101f3942bac3b69ed55c1ca7ea inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f23a3529c4d192d323844ff6ecdb0ef inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a1f23a3529c4d192d323844ff6ecdb0ef">getInputCloud</a> () const</td></tr>
<tr class="memdesc:a1f23a3529c4d192d323844ff6ecdb0ef inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the input point cloud dataset.  <a href="classpcl_1_1_p_c_l_base.html#a1f23a3529c4d192d323844ff6ecdb0ef">More...</a><br /></td></tr>
<tr class="separator:a1f23a3529c4d192d323844ff6ecdb0ef inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">setIndices</a> (const <a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#ab219359de6eb34c9d51e2e976dd1a0d1">More...</a><br /></td></tr>
<tr class="separator:ab219359de6eb34c9d51e2e976dd1a0d1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">setIndices</a> (const <a class="el" href="namespacepcl.html#a011f84e43d80cb736d9ec9abd0930024">IndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#a436c68c74b31e4dd00000adfbb11ca7c">More...</a><br /></td></tr>
<tr class="separator:a436c68c74b31e4dd00000adfbb11ca7c inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">setIndices</a> (const <a class="el" href="classpcl_1_1_p_c_l_base.html#ae4b0d9b8a0867631ef2b9114116f9618">PointIndicesConstPtr</a> &amp;indices)</td></tr>
<tr class="memdesc:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the vector of indices that represents the input data.  <a href="classpcl_1_1_p_c_l_base.html#af9cc90d8364ce968566f75800d3773ca">More...</a><br /></td></tr>
<tr class="separator:af9cc90d8364ce968566f75800d3773ca inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a554d92d5605748c0573f6d1c7428f5a7">setIndices</a> (std::size_t row_start, std::size_t col_start, std::size_t nb_rows, std::size_t nb_cols)</td></tr>
<tr class="memdesc:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indices for the points laying within an interest region of the point cloud.  <a href="classpcl_1_1_p_c_l_base.html#a554d92d5605748c0573f6d1c7428f5a7">More...</a><br /></td></tr>
<tr class="separator:a554d92d5605748c0573f6d1c7428f5a7 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#af46c8513100321ca44df399abb494ad1">getIndices</a> ()</td></tr>
<tr class="memdesc:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="classpcl_1_1_p_c_l_base.html#af46c8513100321ca44df399abb494ad1">More...</a><br /></td></tr>
<tr class="separator:af46c8513100321ca44df399abb494ad1 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ade38248f3b9009767b671f20795fa inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepcl.html#a011f84e43d80cb736d9ec9abd0930024">IndicesConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a47ade38248f3b9009767b671f20795fa">getIndices</a> () const</td></tr>
<tr class="memdesc:a47ade38248f3b9009767b671f20795fa inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the vector of indices used.  <a href="classpcl_1_1_p_c_l_base.html#a47ade38248f3b9009767b671f20795fa">More...</a><br /></td></tr>
<tr class="separator:a47ade38248f3b9009767b671f20795fa inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">const PointNT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ae97525f1375a8eec6d3119bf3de16ef0">operator[]</a> (std::size_t pos) const</td></tr>
<tr class="memdesc:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override PointCloud operator[] to shorten code.  <a href="classpcl_1_1_p_c_l_base.html#ae97525f1375a8eec6d3119bf3de16ef0">More...</a><br /></td></tr>
<tr class="separator:ae97525f1375a8eec6d3119bf3de16ef0 inherit pub_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3a200448054e67bd9f6117ebf81a1056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a3a200448054e67bd9f6117ebf81a1056">getBoundingBox</a> ()</td></tr>
<tr class="memdesc:a3a200448054e67bd9f6117ebf81a1056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounding box for the input data points, also calculating the cell size, and the gaussian scale factor.  <a href="classpcl_1_1_grid_projection.html#a3a200448054e67bd9f6117ebf81a1056">More...</a><br /></td></tr>
<tr class="separator:a3a200448054e67bd9f6117ebf81a1056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f79063799f9c6f47e8b8c7a61bae696"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a0f79063799f9c6f47e8b8c7a61bae696">reconstructPolygons</a> (std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;polygons)</td></tr>
<tr class="memdesc:a0f79063799f9c6f47e8b8c7a61bae696"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual surface reconstruction method.  <a href="classpcl_1_1_grid_projection.html#a0f79063799f9c6f47e8b8c7a61bae696">More...</a><br /></td></tr>
<tr class="separator:a0f79063799f9c6f47e8b8c7a61bae696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab2df800940ee42460b823690e8f291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#adab2df800940ee42460b823690e8f291">performReconstruction</a> (<a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;output) override</td></tr>
<tr class="memdesc:adab2df800940ee42460b823690e8f291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the surface.  <a href="classpcl_1_1_grid_projection.html#adab2df800940ee42460b823690e8f291">More...</a><br /></td></tr>
<tr class="separator:adab2df800940ee42460b823690e8f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd30531dbaf7cfa895b5061c5745863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#aabd30531dbaf7cfa895b5061c5745863">performReconstruction</a> (<a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; &amp;points, std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;polygons) override</td></tr>
<tr class="memdesc:aabd30531dbaf7cfa895b5061c5745863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the surface.  <a href="classpcl_1_1_grid_projection.html#aabd30531dbaf7cfa895b5061c5745863">More...</a><br /></td></tr>
<tr class="separator:aabd30531dbaf7cfa895b5061c5745863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5411849e36c65f0f841290f9aa9fb562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a5411849e36c65f0f841290f9aa9fb562">scaleInputDataPoint</a> (double scale_factor)</td></tr>
<tr class="memdesc:a5411849e36c65f0f841290f9aa9fb562"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the input data points don't fill into the 1*1*1 box, scale them so that they can be filled in the unit box.  <a href="classpcl_1_1_grid_projection.html#a5411849e36c65f0f841290f9aa9fb562">More...</a><br /></td></tr>
<tr class="separator:a5411849e36c65f0f841290f9aa9fb562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc6098c925df8dd7d769cdd9a48d388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a3dc6098c925df8dd7d769cdd9a48d388">getCellIndex</a> (const Eigen::Vector4f &amp;p, Eigen::Vector3i &amp;index) const</td></tr>
<tr class="memdesc:a3dc6098c925df8dd7d769cdd9a48d388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 3d index (x,y,z) of the cell based on the location of the cell.  <a href="classpcl_1_1_grid_projection.html#a3dc6098c925df8dd7d769cdd9a48d388">More...</a><br /></td></tr>
<tr class="separator:a3dc6098c925df8dd7d769cdd9a48d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be2fc98e055e9b0bdef93ad4bed5088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a7be2fc98e055e9b0bdef93ad4bed5088">getCellCenterFromIndex</a> (const Eigen::Vector3i &amp;index, Eigen::Vector4f &amp;center) const</td></tr>
<tr class="memdesc:a7be2fc98e055e9b0bdef93ad4bed5088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the 3d index (x, y, z) of the cell, get the coordinates of the cell center.  <a href="classpcl_1_1_grid_projection.html#a7be2fc98e055e9b0bdef93ad4bed5088">More...</a><br /></td></tr>
<tr class="separator:a7be2fc98e055e9b0bdef93ad4bed5088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9737031e2e20bafbd0cbf68d56aab6bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a9737031e2e20bafbd0cbf68d56aab6bf">getVertexFromCellCenter</a> (const Eigen::Vector4f &amp;cell_center, std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;pts) const</td></tr>
<tr class="memdesc:a9737031e2e20bafbd0cbf68d56aab6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given cell center, caluate the coordinates of the eight vertices of the cell.  <a href="classpcl_1_1_grid_projection.html#a9737031e2e20bafbd0cbf68d56aab6bf">More...</a><br /></td></tr>
<tr class="separator:a9737031e2e20bafbd0cbf68d56aab6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1e79d0c17350a5d877a4bb62f49559"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ada1e79d0c17350a5d877a4bb62f49559">getIndexIn1D</a> (const Eigen::Vector3i &amp;index) const</td></tr>
<tr class="memdesc:ada1e79d0c17350a5d877a4bb62f49559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index (x, y, z) in 3d, translate it into the index in 1d.  <a href="classpcl_1_1_grid_projection.html#ada1e79d0c17350a5d877a4bb62f49559">More...</a><br /></td></tr>
<tr class="separator:ada1e79d0c17350a5d877a4bb62f49559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dabfb35173b2618cc09e2399229b3bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a0dabfb35173b2618cc09e2399229b3bc">getIndexIn3D</a> (int index_1d, Eigen::Vector3i &amp;index_3d) const</td></tr>
<tr class="memdesc:a0dabfb35173b2618cc09e2399229b3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an index in 1d, translate it into the index (x, y, z) in 3d.  <a href="classpcl_1_1_grid_projection.html#a0dabfb35173b2618cc09e2399229b3bc">More...</a><br /></td></tr>
<tr class="separator:a0dabfb35173b2618cc09e2399229b3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddfa2765e87d007286da283e1bb785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#addddfa2765e87d007286da283e1bb785">fillPad</a> (const Eigen::Vector3i &amp;index)</td></tr>
<tr class="memdesc:addddfa2765e87d007286da283e1bb785"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given 3d index of a cell, test whether the cells within its padding area exist in the hash table, if no, create an entry for that cell.  <a href="classpcl_1_1_grid_projection.html#addddfa2765e87d007286da283e1bb785">More...</a><br /></td></tr>
<tr class="separator:addddfa2765e87d007286da283e1bb785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8911f8091c13fced97e02517394cc92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a8911f8091c13fced97e02517394cc92b">getDataPtsUnion</a> (const Eigen::Vector3i &amp;index, std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:a8911f8091c13fced97e02517394cc92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the index of a cell and the pad size.  <a href="classpcl_1_1_grid_projection.html#a8911f8091c13fced97e02517394cc92b">More...</a><br /></td></tr>
<tr class="separator:a8911f8091c13fced97e02517394cc92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eb7fadd9ea168c7e7f6b179e9e03f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ac5eb7fadd9ea168c7e7f6b179e9e03f9">createSurfaceForCell</a> (const Eigen::Vector3i &amp;index, std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:ac5eb7fadd9ea168c7e7f6b179e9e03f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the index of a cell, exam it's up, left, front edges, and add the vectices to m_surface list.the up, left, front edges only share 4 points, we first get the vectors at these 4 points and exam whether those three edges are intersected by the surface.  <a href="classpcl_1_1_grid_projection.html#ac5eb7fadd9ea168c7e7f6b179e9e03f9">More...</a><br /></td></tr>
<tr class="separator:ac5eb7fadd9ea168c7e7f6b179e9e03f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80852b9daa1e3969edbcb55de2f9bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ae80852b9daa1e3969edbcb55de2f9bfd">getProjection</a> (const Eigen::Vector4f &amp;p, std::vector&lt; int &gt; &amp;pt_union_indices, Eigen::Vector4f &amp;projection)</td></tr>
<tr class="memdesc:ae80852b9daa1e3969edbcb55de2f9bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the coordinates of one point, project it onto the surface, return the projected point.  <a href="classpcl_1_1_grid_projection.html#ae80852b9daa1e3969edbcb55de2f9bfd">More...</a><br /></td></tr>
<tr class="separator:ae80852b9daa1e3969edbcb55de2f9bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcbd49493eae00ac9b08c3ad9d84470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a8fcbd49493eae00ac9b08c3ad9d84470">getProjectionWithPlaneFit</a> (const Eigen::Vector4f &amp;p, std::vector&lt; int &gt; &amp;pt_union_indices, Eigen::Vector4f &amp;projection)</td></tr>
<tr class="memdesc:a8fcbd49493eae00ac9b08c3ad9d84470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the coordinates of one point, project it onto the surface, return the projected point.  <a href="classpcl_1_1_grid_projection.html#a8fcbd49493eae00ac9b08c3ad9d84470">More...</a><br /></td></tr>
<tr class="separator:a8fcbd49493eae00ac9b08c3ad9d84470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074763eb0e0911eaad45550917bd8d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a074763eb0e0911eaad45550917bd8d83">getVectorAtPoint</a> (const Eigen::Vector4f &amp;p, std::vector&lt; int &gt; &amp;pt_union_indices, Eigen::Vector3f &amp;vo)</td></tr>
<tr class="memdesc:a074763eb0e0911eaad45550917bd8d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the location of a point, get it's vector.  <a href="classpcl_1_1_grid_projection.html#a074763eb0e0911eaad45550917bd8d83">More...</a><br /></td></tr>
<tr class="separator:a074763eb0e0911eaad45550917bd8d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060f7e37755634942614e7db6a51bc2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a060f7e37755634942614e7db6a51bc2f">getVectorAtPointKNN</a> (const Eigen::Vector4f &amp;p, std::vector&lt; int &gt; &amp;k_indices, std::vector&lt; float &gt; &amp;k_squared_distances, Eigen::Vector3f &amp;vo)</td></tr>
<tr class="memdesc:a060f7e37755634942614e7db6a51bc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the location of a point, get it's vector.  <a href="classpcl_1_1_grid_projection.html#a060f7e37755634942614e7db6a51bc2f">More...</a><br /></td></tr>
<tr class="separator:a060f7e37755634942614e7db6a51bc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd2b2c908b476f89d409fdd75eaf651"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a0dd2b2c908b476f89d409fdd75eaf651">getMagAtPoint</a> (const Eigen::Vector4f &amp;p, const std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:a0dd2b2c908b476f89d409fdd75eaf651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the magnitude of the vector by summing up the distance.  <a href="classpcl_1_1_grid_projection.html#a0dd2b2c908b476f89d409fdd75eaf651">More...</a><br /></td></tr>
<tr class="separator:a0dd2b2c908b476f89d409fdd75eaf651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4088a346e9317fccdf6ab2d0f6f21026"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a4088a346e9317fccdf6ab2d0f6f21026">getD1AtPoint</a> (const Eigen::Vector4f &amp;p, const Eigen::Vector3f &amp;vec, const std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:a4088a346e9317fccdf6ab2d0f6f21026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 1st derivative.  <a href="classpcl_1_1_grid_projection.html#a4088a346e9317fccdf6ab2d0f6f21026">More...</a><br /></td></tr>
<tr class="separator:a4088a346e9317fccdf6ab2d0f6f21026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548e9827c1cb590510e55b6285952ca1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a548e9827c1cb590510e55b6285952ca1">getD2AtPoint</a> (const Eigen::Vector4f &amp;p, const Eigen::Vector3f &amp;vec, const std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:a548e9827c1cb590510e55b6285952ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 2nd derivative.  <a href="classpcl_1_1_grid_projection.html#a548e9827c1cb590510e55b6285952ca1">More...</a><br /></td></tr>
<tr class="separator:a548e9827c1cb590510e55b6285952ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad417229bdf16b68c1ce7830bcbfbf758"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#ad417229bdf16b68c1ce7830bcbfbf758">isIntersected</a> (const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;end_pts, std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;vect_at_end_pts, std::vector&lt; int &gt; &amp;pt_union_indices)</td></tr>
<tr class="memdesc:ad417229bdf16b68c1ce7830bcbfbf758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the edge is intersected by the surface by doing the dot product of the vector at two end points.  <a href="classpcl_1_1_grid_projection.html#ad417229bdf16b68c1ce7830bcbfbf758">More...</a><br /></td></tr>
<tr class="separator:ad417229bdf16b68c1ce7830bcbfbf758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624615f1f4b63e4c7b9094bdc14a64f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a624615f1f4b63e4c7b9094bdc14a64f4">findIntersection</a> (int level, const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;end_pts, const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;vect_at_end_pts, const Eigen::Vector4f &amp;start_pt, std::vector&lt; int &gt; &amp;pt_union_indices, Eigen::Vector4f &amp;intersection)</td></tr>
<tr class="memdesc:a624615f1f4b63e4c7b9094bdc14a64f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find point where the edge intersects the surface.  <a href="classpcl_1_1_grid_projection.html#a624615f1f4b63e4c7b9094bdc14a64f4">More...</a><br /></td></tr>
<tr class="separator:a624615f1f4b63e4c7b9094bdc14a64f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac13ae4b11bb74d2efd2253dcca78862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#aac13ae4b11bb74d2efd2253dcca78862">storeVectAndSurfacePoint</a> (int index_1d, const Eigen::Vector3i &amp;index_3d, std::vector&lt; int &gt; &amp;pt_union_indices, const <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &amp;cell_data)</td></tr>
<tr class="memdesc:aac13ae4b11bb74d2efd2253dcca78862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through all the entries in the hash table and update the cellData.  <a href="classpcl_1_1_grid_projection.html#aac13ae4b11bb74d2efd2253dcca78862">More...</a><br /></td></tr>
<tr class="separator:aac13ae4b11bb74d2efd2253dcca78862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18151db726b30e36c9e7cfbb45b4a47f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_grid_projection.html#a18151db726b30e36c9e7cfbb45b4a47f">storeVectAndSurfacePointKNN</a> (int index_1d, const Eigen::Vector3i &amp;index_3d, const <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &amp;cell_data)</td></tr>
<tr class="memdesc:a18151db726b30e36c9e7cfbb45b4a47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through all the entries in the hash table and update the cellData.  <a href="classpcl_1_1_grid_projection.html#a18151db726b30e36c9e7cfbb45b4a47f">More...</a><br /></td></tr>
<tr class="separator:a18151db726b30e36c9e7cfbb45b4a47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_p_c_l_surface_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_p_c_l_surface_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">pcl::PCLSurfaceBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a48ad4ec3aee4a3d8f6092f9d63ddf48c inherit pro_methods_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a48ad4ec3aee4a3d8f6092f9d63ddf48c">getClassName</a> () const</td></tr>
<tr class="memdesc:a48ad4ec3aee4a3d8f6092f9d63ddf48c inherit pro_methods_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class get name method.  <a href="classpcl_1_1_p_c_l_surface_base.html#a48ad4ec3aee4a3d8f6092f9d63ddf48c">More...</a><br /></td></tr>
<tr class="separator:a48ad4ec3aee4a3d8f6092f9d63ddf48c inherit pro_methods_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">initCompute</a> ()</td></tr>
<tr class="memdesc:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called before starting the actual computation.  <a href="classpcl_1_1_p_c_l_base.html#acceb20854934f4cf77e266eb5a44d4f0">More...</a><br /></td></tr>
<tr class="separator:acceb20854934f4cf77e266eb5a44d4f0 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">deinitCompute</a> ()</td></tr>
<tr class="memdesc:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should get called after finishing the actual computation.  <a href="classpcl_1_1_p_c_l_base.html#afc426c4eebb94b7734d4fa556bff1420">More...</a><br /></td></tr>
<tr class="separator:afc426c4eebb94b7734d4fa556bff1420 inherit pro_methods_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_surface_reconstruction"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_surface_reconstruction')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_surface_reconstruction.html">pcl::SurfaceReconstruction&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a28e8c20a22904c2b368e36f5fcc841b1 inherit pro_attribs_classpcl_1_1_surface_reconstruction"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_surface_reconstruction.html#a28e8c20a22904c2b368e36f5fcc841b1">check_tree_</a></td></tr>
<tr class="memdesc:a28e8c20a22904c2b368e36f5fcc841b1 inherit pro_attribs_classpcl_1_1_surface_reconstruction"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag specifying whether or not the derived reconstruction algorithm needs the search object <em>tree</em>.  <a href="classpcl_1_1_surface_reconstruction.html#a28e8c20a22904c2b368e36f5fcc841b1">More...</a><br /></td></tr>
<tr class="separator:a28e8c20a22904c2b368e36f5fcc841b1 inherit pro_attribs_classpcl_1_1_surface_reconstruction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_p_c_l_surface_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_p_c_l_surface_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_p_c_l_surface_base.html">pcl::PCLSurfaceBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a28d2f448602636061ef7d716e0f6e930 inherit pro_attribs_classpcl_1_1_p_c_l_surface_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a1c1a9c729a618b9ec8bf20b824d2a674">KdTreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_surface_base.html#a28d2f448602636061ef7d716e0f6e930">tree_</a></td></tr>
<tr class="memdesc:a28d2f448602636061ef7d716e0f6e930 inherit pro_attribs_classpcl_1_1_p_c_l_surface_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the spatial search object.  <a href="classpcl_1_1_p_c_l_surface_base.html#a28d2f448602636061ef7d716e0f6e930">More...</a><br /></td></tr>
<tr class="separator:a28d2f448602636061ef7d716e0f6e930 inherit pro_attribs_classpcl_1_1_p_c_l_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpcl_1_1_p_c_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpcl_1_1_p_c_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpcl_1_1_p_c_l_base.html">pcl::PCLBase&lt; PointNT &gt;</a></td></tr>
<tr class="memitem:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_p_c_l_base.html#a575135fb579dc86f7845ed9dba1ea276">PointCloudConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">input_</a></td></tr>
<tr class="memdesc:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input point cloud dataset.  <a href="classpcl_1_1_p_c_l_base.html#a09c70d8e06e3fb4f07903fe6f8d67869">More...</a><br /></td></tr>
<tr class="separator:a09c70d8e06e3fb4f07903fe6f8d67869 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcl.html#ab11731b62628e35f6adc312d1cdaf372">IndicesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">indices_</a></td></tr>
<tr class="memdesc:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the vector of point indices to use.  <a href="classpcl_1_1_p_c_l_base.html#aaee847c8a517ebf365bad2cb182a6626">More...</a><br /></td></tr>
<tr class="separator:aaee847c8a517ebf365bad2cb182a6626 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">use_indices_</a></td></tr>
<tr class="memdesc:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if point indices are used.  <a href="classpcl_1_1_p_c_l_base.html#ada1eadb824d34ca9206a86343d9760bb">More...</a><br /></td></tr>
<tr class="separator:ada1eadb824d34ca9206a86343d9760bb inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">fake_indices_</a></td></tr>
<tr class="memdesc:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">If no set of indices are given, we construct a set of fake indices that mimic the input PointCloud.  <a href="classpcl_1_1_p_c_l_base.html#adadb0299f144528020ed558af6879662">More...</a><br /></td></tr>
<tr class="separator:adadb0299f144528020ed558af6879662 inherit pro_attribs_classpcl_1_1_p_c_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointNT&gt;<br />
class pcl::GridProjection&lt; PointNT &gt;</h3>

<p><a class="el" href="class_grid.html">Grid</a> projection surface reconstruction method. </p>
<dl class="section author"><dt>Author</dt><dd>Rosie Li</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you use this code in any academic work, please cite:<ul>
<li>Ruosi Li, Lu Liu, Ly Phan, Sasakthi Abeysinghe, Cindy Grimm, Tao Ju. Polygonizing extremal surfaces with manifold guarantees. In Proceedings of the 14th ACM Symposium on Solid and Physical Modeling, 2010. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00075">75</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a56ac20953abf72c266594cedff72e5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ac20953abf72c266594cedff72e5b8">&#9670;&nbsp;</a></span>ConstPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a56ac20953abf72c266594cedff72e5b8">ConstPtr</a> =  shared_ptr&lt;const <a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a>&lt;PointNT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00079">79</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a8bf31b9e2266a6cd09b0d6b426f46c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf31b9e2266a6cd09b0d6b426f46c6d">&#9670;&nbsp;</a></span>HashMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt;int, <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a>, std::hash&lt;int&gt;, std::equal_to&lt;&gt;, Eigen::aligned_allocator&lt;std::pair&lt;const int, <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a>&gt; &gt; &gt; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a8bf31b9e2266a6cd09b0d6b426f46c6d">HashMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00099">99</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a62edd95ffded7ffe19275d13685aa1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62edd95ffded7ffe19275d13685aa1ed">&#9670;&nbsp;</a></span>KdTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a62edd95ffded7ffe19275d13685aa1ed">KdTree</a> =  <a class="el" href="classpcl_1_1_kd_tree.html">pcl::KdTree</a>&lt;PointNT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00086">86</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="ae5e792702888e8569965561644612d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e792702888e8569965561644612d6c">&#9670;&nbsp;</a></span>KdTreePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#ae5e792702888e8569965561644612d6c">KdTreePtr</a> =  typename <a class="el" href="classpcl_1_1_kd_tree.html#aeab3727a7da7b1cb80fe97d40c64242b">KdTree::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00087">87</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="ab704932b115dc26f6d500f256aa5637f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab704932b115dc26f6d500f256aa5637f">&#9670;&nbsp;</a></span>PointCloudPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#ab704932b115dc26f6d500f256aa5637f">PointCloudPtr</a> =  typename <a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt;PointNT&gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a9ca02da009752ca2666b6aff0d487416">Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00084">84</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a9ca02da009752ca2666b6aff0d487416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca02da009752ca2666b6aff0d487416">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html#a9ca02da009752ca2666b6aff0d487416">Ptr</a> =  shared_ptr&lt;<a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a>&lt;PointNT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00078">78</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a79cb25cd43c17040722912dbffa5ca22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cb25cd43c17040722912dbffa5ca22">&#9670;&nbsp;</a></span>GridProjection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00049">49</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="acb6b9a0bf64fe78bbd8c8b16b95735fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6b9a0bf64fe78bbd8c8b16b95735fa">&#9670;&nbsp;</a></span>GridProjection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::<a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>in_resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_resolution</td><td>set the resolution of the grid </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00056">56</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="a64f6ad98a1afff0c76ff557c68ae7b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f6ad98a1afff0c76ff557c68ae7b29">&#9670;&nbsp;</a></span>~GridProjection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::~<a class="el" href="classpcl_1_1_grid_projection.html">GridProjection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00063">63</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac5eb7fadd9ea168c7e7f6b179e9e03f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5eb7fadd9ea168c7e7f6b179e9e03f9">&#9670;&nbsp;</a></span>createSurfaceForCell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::createSurfaceForCell </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the index of a cell, exam it's up, left, front edges, and add the vectices to m_surface list.the up, left, front edges only share 4 points, we first get the vectors at these 4 points and exam whether those three edges are intersected by the surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the input index </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00175">175</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="grid__projection_8h_source.html#l00060">pcl::I_SHIFT_EDGE</a>, and <a class="el" href="grid__projection_8h_source.html#l00056">pcl::I_SHIFT_PT</a>.</p>

</div>
</div>
<a id="addddfa2765e87d007286da283e1bb785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addddfa2765e87d007286da283e1bb785">&#9670;&nbsp;</a></span>fillPad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::fillPad </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given 3d index of a cell, test whether the cells within its padding area exist in the hash table, if no, create an entry for that cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the cell in (x,y,z) format </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00555">555</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="a624615f1f4b63e4c7b9094bdc14a64f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624615f1f4b63e4c7b9094bdc14a64f4">&#9670;&nbsp;</a></span>findIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::findIntersection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>end_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect_at_end_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>start_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find point where the edge intersects the surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>binary search level </td></tr>
    <tr><td class="paramname">end_pts</td><td>the two end points on the edge </td></tr>
    <tr><td class="paramname">vect_at_end_pts</td><td>the vectors at the two end points </td></tr>
    <tr><td class="paramname">start_pt</td><td>the starting point we use for binary search </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
    <tr><td class="paramname">intersection</td><td>the resultant intersection point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00507">507</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="a3a200448054e67bd9f6117ebf81a1056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a200448054e67bd9f6117ebf81a1056">&#9670;&nbsp;</a></span>getBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getBoundingBox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bounding box for the input data points, also calculating the cell size, and the gaussian scale factor. </p>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00088">88</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2common_2impl_2common_8hpp_source.html#l00242">pcl::getMinMax3D()</a>.</p>

</div>
</div>
<a id="a7be2fc98e055e9b0bdef93ad4bed5088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be2fc98e055e9b0bdef93ad4bed5088">&#9670;&nbsp;</a></span>getCellCenterFromIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getCellCenterFromIndex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the 3d index (x, y, z) of the cell, get the coordinates of the cell center. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the output 3d index </td></tr>
    <tr><td class="paramname">center</td><td>the resultant cell center </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00261">261</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a244e5fdc0993524900d4512c1eb7c60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244e5fdc0993524900d4512c1eb7c60b">&#9670;&nbsp;</a></span>getCellHashMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpcl_1_1_grid_projection.html#a8bf31b9e2266a6cd09b0d6b426f46c6d">HashMap</a>&amp; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getCellHashMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00179">179</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a3dc6098c925df8dd7d769cdd9a48d388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc6098c925df8dd7d769cdd9a48d388">&#9670;&nbsp;</a></span>getCellIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getCellIndex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 3d index (x,y,z) of the cell based on the location of the cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinate of the input point </td></tr>
    <tr><td class="paramname">index</td><td>the output 3d index </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00249">249</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a4088a346e9317fccdf6ab2d0f6f21026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4088a346e9317fccdf6ab2d0f6f21026">&#9670;&nbsp;</a></span>getD1AtPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getD1AtPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 1st derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinate of the input point </td></tr>
    <tr><td class="paramname">vec</td><td>the vector at point p </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00446">446</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="a548e9827c1cb590510e55b6285952ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548e9827c1cb590510e55b6285952ca1">&#9670;&nbsp;</a></span>getD2AtPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getD2AtPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 2nd derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinate of the input point </td></tr>
    <tr><td class="paramname">vec</td><td>the vector at point p </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00459">459</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="a8911f8091c13fced97e02517394cc92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8911f8091c13fced97e02517394cc92b">&#9670;&nbsp;</a></span>getDataPtsUnion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getDataPtsUnion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the index of a cell and the pad size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the input index </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00149">149</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="ada1e79d0c17350a5d877a4bb62f49559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1e79d0c17350a5d877a4bb62f49559">&#9670;&nbsp;</a></span>getIndexIn1D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getIndexIn1D </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an index (x, y, z) in 3d, translate it into the index in 1d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the cell in (x,y,z) 3d format </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00283">283</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a0dabfb35173b2618cc09e2399229b3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dabfb35173b2618cc09e2399229b3bc">&#9670;&nbsp;</a></span>getIndexIn3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getIndexIn3D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index_3d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an index in 1d, translate it into the index (x, y, z) in 3d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_1d</td><td>the input 1d index </td></tr>
    <tr><td class="paramname">index_3d</td><td>the output 3d index </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00296">296</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a0dd2b2c908b476f89d409fdd75eaf651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd2b2c908b476f89d409fdd75eaf651">&#9670;&nbsp;</a></span>getMagAtPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getMagAtPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the magnitude of the vector by summing up the distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinate of the input point </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00429">429</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="pcl__macros_8h_source.html#l00190">M_E</a>.</p>

</div>
</div>
<a id="a8c221e7f97944896dc9003da3303c4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c221e7f97944896dc9003da3303c4f3">&#9670;&nbsp;</a></span>getMaxBinarySearchLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getMaxBinarySearchLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00172">172</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a9887d299ea2be516a1216cb7843a1bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9887d299ea2be516a1216cb7843a1bef">&#9670;&nbsp;</a></span>getNearestNeighborNum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getNearestNeighborNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00157">157</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="adb565f51df04964c3b49dbd257d66d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb565f51df04964c3b49dbd257d66d3d">&#9670;&nbsp;</a></span>getPaddingSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getPaddingSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00142">142</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="ae80852b9daa1e3969edbcb55de2f9bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80852b9daa1e3969edbcb55de2f9bfd">&#9670;&nbsp;</a></span>getProjection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getProjection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the coordinates of one point, project it onto the surface, return the projected point. </p>
<p>Do a binary search between p and p+projection_distance to find the projected point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinates of the input point </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
    <tr><td class="paramname">projection</td><td>the resultant point projected </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00274">274</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="a8fcbd49493eae00ac9b08c3ad9d84470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcbd49493eae00ac9b08c3ad9d84470">&#9670;&nbsp;</a></span>getProjectionWithPlaneFit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getProjectionWithPlaneFit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the coordinates of one point, project it onto the surface, return the projected point. </p>
<p>Find the plane which fits all the points in pt_union_indices, projected p to the plane to get the projected point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinates of the input point </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
    <tr><td class="paramname">projection</td><td>the resultant point projected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>iterative weighted least squares or sac might give better results</dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00313">313</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="centroid_8hpp_source.html#l00485">pcl::computeMeanAndCovarianceMatrix()</a>, <a class="el" href="common_2include_2pcl_2common_2geometry_8h_source.html#l00060">pcl::geometry::distance()</a>, and <a class="el" href="common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00296">pcl::eigen33()</a>.</p>

</div>
</div>
<a id="ae28f4d83ee50a5ad6267d7936f55a09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28f4d83ee50a5ad6267d7936f55a09d">&#9670;&nbsp;</a></span>getResolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00122">122</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="aa89bb70feecd87f4c8440ecec5426ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89bb70feecd87f4c8440ecec5426ccb">&#9670;&nbsp;</a></span>getSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;Eigen::Vector4f, Eigen::aligned_allocator&lt;Eigen::Vector4f&gt; &gt;&amp; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00191">191</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a41777645db865cd6155d3714fc8c7380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41777645db865cd6155d3714fc8c7380">&#9670;&nbsp;</a></span>getVectorAtDataPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;Eigen::Vector3f, Eigen::aligned_allocator&lt;Eigen::Vector3f&gt; &gt;&amp; <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getVectorAtDataPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00185">185</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a074763eb0e0911eaad45550917bd8d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074763eb0e0911eaad45550917bd8d83">&#9670;&nbsp;</a></span>getVectorAtPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getVectorAtPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the location of a point, get it's vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinates of the input point </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
    <tr><td class="paramname">vo</td><td>the resultant vector </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00348">348</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="vector__average_8hpp_source.html#l00061">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, <a class="el" href="vector__average_8h_source.html#l00070">pcl::VectorAverage&lt; real, dimension &gt;::getMean()</a>, and <a class="el" href="pcl__macros_8h_source.html#l00190">M_E</a>.</p>

</div>
</div>
<a id="a060f7e37755634942614e7db6a51bc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060f7e37755634942614e7db6a51bc2f">&#9670;&nbsp;</a></span>getVectorAtPointKNN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getVectorAtPointKNN </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_squared_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>vo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the location of a point, get it's vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the coordinates of the input point </td></tr>
    <tr><td class="paramname">k_indices</td><td>the k nearest neighbors of the query point </td></tr>
    <tr><td class="paramname">k_squared_distances</td><td>the squared distances of the k nearest neighbors to the query point </td></tr>
    <tr><td class="paramname">vo</td><td>the resultant vector </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00395">395</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="vector__average_8hpp_source.html#l00061">pcl::VectorAverage&lt; real, dimension &gt;::add()</a>, <a class="el" href="vector__average_8hpp_source.html#l00119">pcl::VectorAverage&lt; real, dimension &gt;::getEigenVector1()</a>, and <a class="el" href="pcl__macros_8h_source.html#l00190">M_E</a>.</p>

</div>
</div>
<a id="a9737031e2e20bafbd0cbf68d56aab6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9737031e2e20bafbd0cbf68d56aab6bf">&#9670;&nbsp;</a></span>getVertexFromCellCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::getVertexFromCellCenter </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>cell_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given cell center, caluate the coordinates of the eight vertices of the cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_center</td><td>the coordinates of the cell center </td></tr>
    <tr><td class="paramname">pts</td><td>the coordinates of the 8 vertices </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00129">129</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="ad417229bdf16b68c1ce7830bcbfbf758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad417229bdf16b68c1ce7830bcbfbf758">&#9670;&nbsp;</a></span>isIntersected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::isIntersected </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector4f, Eigen::aligned_allocator&lt; Eigen::Vector4f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>end_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector3f, Eigen::aligned_allocator&lt; Eigen::Vector3f &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect_at_end_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the edge is intersected by the surface by doing the dot product of the vector at two end points. </p>
<p>Also test whether the edge is intersected by the maximum surface by examing the 2nd derivative of the intersection point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_pts</td><td>the two points of the edge </td></tr>
    <tr><td class="paramname">vect_at_end_pts</td><td></td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and padding cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00472">472</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="aabd30531dbaf7cfa895b5061c5745863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd30531dbaf7cfa895b5061c5745863">&#9670;&nbsp;</a></span>performReconstruction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::performReconstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_point_cloud.html">pcl::PointCloud</a>&lt; PointNT &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the surface. </p>
<p>The 1st step is filling the padding, so that all the cells in the padding area are in the hash map. The 2nd step is store the vector, and projected point. The 3rd step is finding all the edges intersects the surface, and creating surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>the resultant points lying on the surface </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polygons</td><td>the resultant polygons, as a set of vertices. The <a class="el" href="structpcl_1_1_vertices.html" title="Describes a set of vertices in a polygon mesh, by basically storing an array of indices.">Vertices</a> structure contains an array of point indices. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classpcl_1_1_surface_reconstruction.html#adb79f4f50df09a4b8364a7a9f1920e7a">pcl::SurfaceReconstruction&lt; PointNT &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00749">749</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00408">pcl::PointCloud&lt; PointT &gt;::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00466">pcl::PointCloud&lt; PointT &gt;::resize()</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00459">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="adab2df800940ee42460b823690e8f291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab2df800940ee42460b823690e8f291">&#9670;&nbsp;</a></span>performReconstruction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::performReconstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcl_1_1_polygon_mesh.html">pcl::PolygonMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the surface. </p>
<p>The 1st step is filling the padding, so that all the cells in the padding area are in the hash map. The 2nd step is store the vector, and projected point. The 3rd step is finding all the edges intersects the surface, and creating surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the resultant polygonal mesh </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classpcl_1_1_surface_reconstruction.html#a181cf1cc5feb909f5e8405bb82780cc1">pcl::SurfaceReconstruction&lt; PointNT &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00723">723</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="_polygon_mesh_8h_source.html#l00022">pcl::PolygonMesh::cloud</a>, <a class="el" href="_polygon_mesh_8h_source.html#l00020">pcl::PolygonMesh::header</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00416">pcl::PointCloud&lt; PointT &gt;::height</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00419">pcl::PointCloud&lt; PointT &gt;::is_dense</a>, <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00411">pcl::PointCloud&lt; PointT &gt;::points</a>, <a class="el" href="_polygon_mesh_8h_source.html#l00024">pcl::PolygonMesh::polygons</a>, <a class="el" href="conversions_8h_source.html#l00241">pcl::toPCLPointCloud2()</a>, and <a class="el" href="common_2include_2pcl_2point__cloud_8h_source.html#l00414">pcl::PointCloud&lt; PointT &gt;::width</a>.</p>

</div>
</div>
<a id="a0f79063799f9c6f47e8b8c7a61bae696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f79063799f9c6f47e8b8c7a61bae696">&#9670;&nbsp;</a></span>reconstructPolygons()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::reconstructPolygons </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structpcl_1_1_vertices.html">pcl::Vertices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygons</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual surface reconstruction method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">polygons</td><td>the resultant polygons, as a set of vertices. The <a class="el" href="structpcl_1_1_vertices.html" title="Describes a set of vertices in a polygon mesh, by basically storing an array of indices.">Vertices</a> structure contains an array of point indices. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00619">619</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="grid__projection_8h_source.html#l00094">pcl::GridProjection&lt; PointNT &gt;::Leaf::data_indices</a>, <a class="el" href="grid__projection_8h_source.html#l00095">pcl::GridProjection&lt; PointNT &gt;::Leaf::pt_on_surface</a>, and <a class="el" href="_vertices_8h_source.html#l00020">pcl::Vertices::vertices</a>.</p>

</div>
</div>
<a id="a5411849e36c65f0f841290f9aa9fb562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5411849e36c65f0f841290f9aa9fb562">&#9670;&nbsp;</a></span>scaleInputDataPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::scaleInputDataPoint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale_factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When the input data points don't fill into the 1*1*1 box, scale them so that they can be filled in the unit box. </p>
<p>Otherwise, it will be some drawing problem when doing visulization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale_factor</td><td>scale all the input data point by scale_factor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00074">74</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

</div>
</div>
<a id="a86f788e943e8660d1806688f8a56aec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f788e943e8660d1806688f8a56aec3">&#9670;&nbsp;</a></span>setMaxBinarySearchLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::setMaxBinarySearchLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_binary_search_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary search is used in projection. </p>
<p>given a point x, we find another point which is 3*cell_size_ far away from x. Then we do a binary search between these two points to find where the projected point should be. </p>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00167">167</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="ab668b2eefe9c9136c06956ad312e6704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab668b2eefe9c9136c06956ad312e6704">&#9670;&nbsp;</a></span>setNearestNeighborNum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::setNearestNeighborNum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this only when using the k nearest neighbors search instead of finding the point union. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The number of nearest neighbors we are looking for </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00152">152</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="a7661621ee4c96b46571cc5778b9b48cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7661621ee4c96b46571cc5778b9b48cf">&#9670;&nbsp;</a></span>setPaddingSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::setPaddingSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When averaging the vectors, we find the union of all the input data points within the padding area,and do a weighted average. </p>
<p>Say if the padding size is 1, when we process cell (x,y,z), we will find union of input data points from (x-1) to (x+1), (y-1) to (y+1), (z-1) to (z+1)(in total, 27 cells). In this way, even the cells itself doesn't contain any data points, we will still process it because there are data points in the padding area. This can help us fix holes which is smaller than the padding size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">padding_size</td><td>The num of padding cells we want to create </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00137">137</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="af8ccfe1a2c8d66ca9a126d33096d2496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ccfe1a2c8d66ca9a126d33096d2496">&#9670;&nbsp;</a></span>setResolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::setResolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>the size of the grid cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8h_source.html#l00116">116</a> of file <a class="el" href="grid__projection_8h_source.html">grid_projection.h</a>.</p>

</div>
</div>
<a id="aac13ae4b11bb74d2efd2253dcca78862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac13ae4b11bb74d2efd2253dcca78862">&#9670;&nbsp;</a></span>storeVectAndSurfacePoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::storeVectAndSurfacePoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index_3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt_union_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Go through all the entries in the hash table and update the cellData. </p>
<p>When creating the hash table, the pt_on_surface field store the center point of the cell.After calling this function, the projection operator will project the center point onto the surface, and the pt_on_surface field will be updated using the projected point.Also the vect_at_grid_pt field will be updated using the vector at the upper left front vertex of the cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_1d</td><td>the index of the cell after flatting it's 3d index into a 1d array </td></tr>
    <tr><td class="paramname">index_3d</td><td>the index of the cell in (x,y,z) 3d format </td></tr>
    <tr><td class="paramname">pt_union_indices</td><td>the union of input data points within the cell and pads </td></tr>
    <tr><td class="paramname">cell_data</td><td>information stored in the cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00578">578</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="grid__projection_8h_source.html#l00095">pcl::GridProjection&lt; PointNT &gt;::Leaf::pt_on_surface</a>.</p>

</div>
</div>
<a id="a18151db726b30e36c9e7cfbb45b4a47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18151db726b30e36c9e7cfbb45b4a47f">&#9670;&nbsp;</a></span>storeVectAndSurfacePointKNN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointNT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_grid_projection.html">pcl::GridProjection</a>&lt; PointNT &gt;::storeVectAndSurfacePointKNN </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3i &amp;&#160;</td>
          <td class="paramname"><em>index_3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcl_1_1_grid_projection_1_1_leaf.html">Leaf</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Go through all the entries in the hash table and update the cellData. </p>
<p>When creating the hash table, the pt_on_surface field store the center point of the cell.After calling this function, the projection operator will project the center point onto the surface, and the pt_on_surface field will be updated using the projected point.Also the vect_at_grid_pt field will be updated using the vector at the upper left front vertex of the cell. When projecting the point and calculating the vector, using K nearest neighbors instead of using the union of input data point within the cell and pads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_1d</td><td>the index of the cell after flatting it's 3d index into a 1d array </td></tr>
    <tr><td class="paramname">index_3d</td><td>the index of the cell in (x,y,z) 3d format </td></tr>
    <tr><td class="paramname">cell_data</td><td>information stored in the cell </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__projection_8hpp_source.html#l00596">596</a> of file <a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a>.</p>

<p class="reference">References <a class="el" href="grid__projection_8h_source.html#l00095">pcl::GridProjection&lt; PointNT &gt;::Leaf::pt_on_surface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>pcl/surface/<a class="el" href="grid__projection_8h_source.html">grid_projection.h</a></li>
<li>pcl/surface/impl/<a class="el" href="grid__projection_8hpp_source.html">grid_projection.hpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<div id="footer">
<p>
Except where otherwise noted, the PointClouds.org web pages are licensed under <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>. 
</p>
<p>Pages generated on Tue Jun 2 2020 14:12:03</p>
</div> <!-- #footer -->
</body>
</html>
